/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 282:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

/*
 * SimpleModal @VERSION - jQuery Plugin
 * http://simplemodal.com/
 * Copyright (c) 2013 Eric Martin
 * Licensed under MIT and GPL
 * Date:
 */

/**
 * SimpleModal is a lightweight jQuery plugin that provides a simple
 * interface to create a modal dialog.
 *
 * The goal of SimpleModal is to provide developers with a cross-browser
 * overlay and container that will be populated with data provided to
 * SimpleModal.
 *
 * There are two ways to call SimpleModal:
 * 1) As a chained function on a jQuery object, like $('#myDiv').modal();.
 * This call would place the DOM object, #myDiv, inside a modal dialog.
 * Chaining requires a jQuery object. An optional options object can be
 * passed as a parameter.
 *
 * @example $('<div>my data</div>').modal({options});
 * @example $('#myDiv').modal({options});
 * @example jQueryObject.modal({options});
 *
 * 2) As a stand-alone function, like $.modal(data). The data parameter
 * is required and an optional options object can be passed as a second
 * parameter. This method provides more flexibility in the types of data
 * that are allowed. The data could be a DOM object, a jQuery object, HTML
 * or a string.
 *
 * @example $.modal('<div>my data</div>', {options});
 * @example $.modal('my data', {options});
 * @example $.modal($('#myDiv'), {options});
 * @example $.modal(jQueryObject, {options});
 * @example $.modal(document.getElementById('myDiv'), {options});
 *
 * A SimpleModal call can contain multiple elements, but only one modal
 * dialog can be created at a time. Which means that all of the matched
 * elements will be displayed within the modal container.
 *
 * SimpleModal internally sets the CSS needed to display the modal dialog
 * properly in all browsers, yet provides the developer with the flexibility
 * to easily control the look and feel. The styling for SimpleModal can be
 * done through external stylesheets, or through SimpleModal, using the
 * overlayCss, containerCss, and dataCss options.
 *
 * SimpleModal has been tested in the following browsers:
 * - IE 6+
 * - Firefox 2+
 * - Opera 9+
 * - Safari 3+
 * - Chrome 1+
 *
 * @name SimpleModal
 * @type jQuery
 * @requires jQuery v1.3
 * @cat Plugins/Windows and Overlays
 * @author Eric Martin (http://ericmmartin.com)
 * @version @VERSION
 */

/**
 * Package for ComponentJS
 */
var jQuery = __webpack_require__(91089);
(function ($) {
  var d = [],
    doc = $(document),
    ua = navigator.userAgent.toLowerCase(),
    wndw = $(window),
    w = [];
  var browser = {
    ieQuirks: null,
    msie: /msie/.test(ua) && !/opera/.test(ua),
    opera: /opera/.test(ua)
  };
  browser.ie6 = browser.msie && /msie 6./.test(ua) && typeof window['XMLHttpRequest'] !== 'object';
  browser.ie7 = browser.msie && /msie 7.0/.test(ua);

  /*
   * Create and display a modal dialog.
   *
   * @param {string, object} data A string, jQuery object or DOM object
   * @param {object} [options] An optional object containing options overrides
   */
  $.modal = function (data, options) {
    return $.modal.impl.init(data, options);
  };

  /*
   * Close the modal dialog.
   */
  $.modal.close = function () {
    $.modal.impl.close();
  };

  /*
   * Set focus on first or last visible input in the modal dialog. To focus on the last
   * element, call $.modal.focus('last'). If no input elements are found, focus is placed
   * on the data wrapper element.
   */
  $.modal.focus = function (pos) {
    $.modal.impl.focus(pos);
  };

  /*
   * Determine and set the dimensions of the modal dialog container.
   * setPosition() is called if the autoPosition option is true.
   */
  $.modal.setContainerDimensions = function () {
    $.modal.impl.setContainerDimensions();
  };

  /*
   * Re-position the modal dialog.
   */
  $.modal.setPosition = function () {
    $.modal.impl.setPosition();
  };

  /*
   * Update the modal dialog. If new dimensions are passed, they will be used to determine
   * the dimensions of the container.
   *
   * setContainerDimensions() is called, which in turn calls setPosition(), if enabled.
   * Lastly, focus() is called if the focus option is true.
   */
  $.modal.update = function (height, width) {
    $.modal.impl.update(height, width);
  };

  /*
   * Chained function to create a modal dialog.
   *
   * @param {object} [options] An optional object containing options overrides
   */
  $.fn.modal = function (options) {
    return $.modal.impl.init(this, options);
  };

  /*
   * SimpleModal default options
   *
   * appendTo:		(String:'body') The jQuery selector to append the elements to. For .NET, use 'form'.
   * focus:			(Boolean:true) Focus in the first visible, enabled element?
   * opacity:			(Number:50) The opacity value for the overlay div, from 0 - 100
   * overlayId:		(String:'simplemodal-overlay') The DOM element id for the overlay div
   * overlayCss:		(Object:{}) The CSS styling for the overlay div
   * containerId:		(String:'simplemodal-container') The DOM element id for the container div
   * containerCss:	(Object:{}) The CSS styling for the container div
   * dataId:			(String:'simplemodal-data') The DOM element id for the data div
   * dataCss:			(Object:{}) The CSS styling for the data div
   * minHeight:		(Number:null) The minimum height for the container
   * minWidth:		(Number:null) The minimum width for the container
   * maxHeight:		(Number:null) The maximum height for the container. If not specified, the window height is used.
   * maxWidth:		(Number:null) The maximum width for the container. If not specified, the window width is used.
   * autoResize:		(Boolean:false) Automatically resize the container if it exceeds the browser window dimensions?
   * autoPosition:	(Boolean:true) Automatically position the container upon creation and on window resize?
   * zIndex:			(Number: 1000) Starting z-index value
   * close:			(Boolean:true) If true, closeHTML, escClose and overClose will be used if set.
   							If false, none of them will be used.
   * closeHTML:		(String:'<a class="modalCloseImg" title="Close"></a>') The HTML for the default close link.
  							SimpleModal will automatically add the closeClass to this element.
   * closeClass:		(String:'simplemodal-close') The CSS class used to bind to the close event
   * escClose:		(Boolean:true) Allow Esc keypress to close the dialog?
   * overlayClose:	(Boolean:false) Allow click on overlay to close the dialog?
   * fixed:			(Boolean:true) If true, the container will use a fixed position. If false, it will use a
  							absolute position (the dialog will scroll with the page)
   * position:		(Array:null) Position of container [top, left]. Can be number of pixels or percentage
   * persist:			(Boolean:false) Persist the data across modal calls? Only used for existing
  							DOM elements. If true, the data will be maintained across modal calls, if false,
  							the data will be reverted to its original state.
   * modal:			(Boolean:true) User will be unable to interact with the page below the modal or tab away from the dialog.
  							If false, the overlay, iframe, and certain events will be disabled allowing the user to interact
  							with the page below the dialog.
   * onOpen:			(Function:null) The callback function used in place of SimpleModal's open
   * onShow:			(Function:null) The callback function used after the modal dialog has opened
   * onClose:			(Function:null) The callback function used in place of SimpleModal's close
   */
  $.modal.defaults = {
    appendTo: 'body',
    focus: true,
    opacity: 50,
    overlayId: 'simplemodal-overlay',
    overlayCss: {},
    containerId: 'simplemodal-container',
    containerCss: {},
    dataId: 'simplemodal-data',
    dataCss: {},
    minHeight: null,
    minWidth: null,
    maxHeight: null,
    maxWidth: null,
    autoResize: false,
    autoPosition: true,
    zIndex: 1000,
    close: true,
    closeHTML: '<a class="modalCloseImg" title="Close"></a>',
    closeClass: 'simplemodal-close',
    escClose: true,
    overlayClose: false,
    fixed: true,
    position: null,
    persist: false,
    modal: true,
    onOpen: null,
    onShow: null,
    onClose: null
  };

  /*
   * Main modal object
   * o = options
   */
  $.modal.impl = {
    /*
     * Contains the modal dialog elements and is the object passed
     * back to the callback (onOpen, onShow, onClose) functions
     */
    d: {},
    /*
     * Initialize the modal dialog
     */
    init: function (data, options) {
      var s = this;

      // don't allow multiple calls
      if (s.d.data) {
        return false;
      }

      // $.support.boxModel is undefined if checked earlier
      browser.ieQuirks = browser.msie && !$.support.boxModel;

      // merge defaults and user options
      s.o = $.extend({}, $.modal.defaults, options);

      // keep track of z-index
      s.zIndex = s.o.zIndex;

      // set the onClose callback flag
      s.occb = false;

      // determine how to handle the data based on its type
      if (typeof data === 'object') {
        // convert DOM object to a jQuery object
        data = data instanceof $ ? data : $(data);
        s.d.placeholder = false;

        // if the object came from the DOM, keep track of its parent
        if (data.parent().parent().length > 0) {
          data.before($('<span></span>').attr('id', 'simplemodal-placeholder').css({
            display: 'none'
          }));
          s.d.placeholder = true;
          s.display = data.css('display');

          // persist changes? if not, make a clone of the element
          if (!s.o.persist) {
            s.d.orig = data.clone(true);
          }
        }
      } else if (typeof data === 'string' || typeof data === 'number') {
        // just insert the data as innerHTML
        // -------------------------------
        //  FIX: to avoid XSS, use .text()
        // -------------------------------
        data = $('<div></div>').text(data);
      } else {
        // unsupported data type!
        alert('SimpleModal Error: Unsupported data type: ' + typeof data);
        return s;
      }

      // create the modal overlay, container and, if necessary, iframe
      s.create(data);
      data = null;

      // display the modal dialog
      s.open();

      // useful for adding events/manipulating data in the modal dialog
      if (typeof s.o.onShow === 'function') {
        s.o.onShow.apply(s, [s.d]);
      }

      // don't break the chain =)
      return s;
    },
    /*
     * Create and add the modal overlay and container to the page
     */
    create: function (data) {
      var s = this;

      // get the window properties
      s.getDimensions();

      // add an iframe to prevent select options from bleeding through
      if (s.o.modal && browser.ie6) {
        s.d.iframe = $('<iframe src="javascript:false;"></iframe>').css($.extend(s.o.iframeCss, {
          display: 'none',
          opacity: 0,
          position: 'fixed',
          height: w[0],
          width: w[1],
          zIndex: s.o.zIndex,
          top: 0,
          left: 0
        })).appendTo(s.o.appendTo);
      }

      // create the overlay
      s.d.overlay = $('<div></div>').attr('id', s.o.overlayId).addClass('simplemodal-overlay').css($.extend(s.o.overlayCss, {
        display: 'none',
        opacity: s.o.opacity / 100,
        height: s.o.modal ? d[0] : 0,
        width: s.o.modal ? d[1] : 0,
        position: 'fixed',
        left: 0,
        top: 0,
        zIndex: s.o.zIndex + 1
      })).appendTo(s.o.appendTo);

      // create the container
      s.d.container = $('<div></div>').attr('id', s.o.containerId)
      //Adding role attribute with value 'dialog' for 508 compliance.
      .attr('role', 'dialog').addClass('simplemodal-container').css($.extend({
        position: s.o.fixed ? 'fixed' : 'absolute'
      }, s.o.containerCss, {
        display: 'none',
        zIndex: s.o.zIndex + 2
      })).append(s.o.close && s.o.closeHTML ? $(s.o.closeHTML).addClass(s.o.closeClass) : '').appendTo(s.o.appendTo);
      s.d.wrap = $('<div></div>').attr('tabIndex', -1).addClass('simplemodal-wrap').css({
        height: '100%',
        outline: 0,
        width: '100%'
      }).appendTo(s.d.container);

      // add styling and attributes to the data
      // append to body to get correct dimensions, then move to wrap
      s.d.data = data.attr('id', data.attr('id') || s.o.dataId).addClass('simplemodal-data').css($.extend(s.o.dataCss, {
        display: 'none'
      })).appendTo('body');
      data = null;
      s.setContainerDimensions();
      s.d.data.appendTo(s.d.wrap);

      // fix issues with IE
      if (browser.ie6 || browser.ieQuirks) {
        s.fixIE();
      }
    },
    /*
     * Bind events
     */
    bindEvents: function () {
      var s = this;

      // bind the close event to any element with the closeClass class
      $('.' + s.o.closeClass).bind('click.simplemodal', function (e) {
        e.preventDefault();
        s.close();
      });

      // bind the overlay click to the close function, if enabled
      if (s.o.modal && s.o.close && s.o.overlayClose) {
        s.d.overlay.bind('click.simplemodal', function (e) {
          e.preventDefault();
          s.close();
        });
      }

      // bind keydown events
      doc.bind('keydown.simplemodal', function (e) {
        if (s.o.modal && e.keyCode === 9) {
          // TAB
          s.watchTab(e);
        } else if (s.o.close && s.o.escClose && e.keyCode === 27) {
          // ESC
          e.preventDefault();
          s.close();
        }
      });

      // update window size
      wndw.bind('resize.simplemodal orientationchange.simplemodal', function () {
        // redetermine the window width/height
        s.getDimensions();

        // reposition the dialog
        s.o.autoResize ? s.setContainerDimensions() : s.o.autoPosition && s.setPosition();
        if (browser.ie6 || browser.ieQuirks) {
          s.fixIE();
        } else if (s.o.modal) {
          // update the iframe & overlay
          s.d.iframe && s.d.iframe.css({
            height: w[0],
            width: w[1]
          });
          s.d.overlay.css({
            height: d[0],
            width: d[1]
          });
        }
      });
    },
    /*
     * Unbind events
     */
    unbindEvents: function () {
      $('.' + this.o.closeClass).unbind('click.simplemodal');
      doc.unbind('keydown.simplemodal');
      wndw.unbind('.simplemodal');
      this.d.overlay.unbind('click.simplemodal');
    },
    /*
     * Fix issues in IE6 and IE7 in quirks mode
     */
    fixIE: function () {
      var s = this,
        p = s.o.position;

      // simulate fixed position - adapted from BlockUI
      $.each([s.d.iframe || null, !s.o.modal ? null : s.d.overlay, s.d.container.css('position') === 'fixed' ? s.d.container : null], function (i, el) {
        if (el) {
          var bch = 'document.body.clientHeight',
            bcw = 'document.body.clientWidth',
            bsh = 'document.body.scrollHeight',
            bsl = 'document.body.scrollLeft',
            bst = 'document.body.scrollTop',
            bsw = 'document.body.scrollWidth',
            ch = 'document.documentElement.clientHeight',
            cw = 'document.documentElement.clientWidth',
            sl = 'document.documentElement.scrollLeft',
            st = 'document.documentElement.scrollTop',
            s = el[0].style;
          s.position = 'absolute';
          if (i < 2) {
            s.removeExpression('height');
            s.removeExpression('width');
            s.setExpression('height', '' + bsh + ' > ' + bch + ' ? ' + bsh + ' : ' + bch + ' + "px"');
            s.setExpression('width', '' + bsw + ' > ' + bcw + ' ? ' + bsw + ' : ' + bcw + ' + "px"');
          } else {
            var te, le;
            if (p && p.constructor === Array) {
              var top = p[0] ? typeof p[0] === 'number' ? p[0].toString() : p[0].replace(/px/, '') : el.css('top').replace(/px/, '');
              te = top.indexOf('%') === -1 ? top + ' + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"' : parseInt(top.replace(/%/, '')) + ' * ((' + ch + ' || ' + bch + ') / 100) + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"';
              if (p[1]) {
                var left = typeof p[1] === 'number' ? p[1].toString() : p[1].replace(/px/, '');
                le = left.indexOf('%') === -1 ? left + ' + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"' : parseInt(left.replace(/%/, '')) + ' * ((' + cw + ' || ' + bcw + ') / 100) + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"';
              }
            } else {
              te = '(' + ch + ' || ' + bch + ') / 2 - (this.offsetHeight / 2) + (t = ' + st + ' ? ' + st + ' : ' + bst + ') + "px"';
              le = '(' + cw + ' || ' + bcw + ') / 2 - (this.offsetWidth / 2) + (t = ' + sl + ' ? ' + sl + ' : ' + bsl + ') + "px"';
            }
            s.removeExpression('top');
            s.removeExpression('left');
            s.setExpression('top', te);
            s.setExpression('left', le);
          }
        }
      });
    },
    /*
     * Place focus on the first or last visible input
     */
    focus: function (pos) {
      var s = this,
        p = pos && $.inArray(pos, ['first', 'last']) !== -1 ? pos : 'first';

      // focus on dialog or the first visible/enabled input element
      var input = $(':input:enabled:visible:' + p, s.d.wrap);
      setTimeout(function () {
        input.length > 0 ? input.focus() : s.d.wrap.focus();
      }, 10);
    },
    getDimensions: function () {
      // fix a jQuery bug with determining the window height - use innerHeight if available
      var s = this,
        h = typeof window.innerHeight === 'undefined' ? wndw.height() : window.innerHeight;
      d = [doc.height(), doc.width()];
      w = [h, wndw.width()];
    },
    getVal: function (v, d) {
      return v ? typeof v === 'number' ? v : v === 'auto' ? 0 : v.indexOf('%') > 0 ? parseInt(v.replace(/%/, '')) / 100 * (d === 'h' ? w[0] : w[1]) : parseInt(v.replace(/px/, '')) : null;
    },
    /*
     * Update the container. Set new dimensions, if provided.
     * Focus, if enabled. Re-bind events.
     */
    update: function (height, width) {
      var s = this;

      // prevent update if dialog does not exist
      if (!s.d.data) {
        return false;
      }

      // reset orig values
      s.d.origHeight = s.getVal(height, 'h');
      s.d.origWidth = s.getVal(width, 'w');

      // hide data to prevent screen flicker
      s.d.data.hide();
      height && s.d.container.css('height', height);
      width && s.d.container.css('width', width);
      s.setContainerDimensions();
      s.d.data.show();
      s.o.focus && s.focus();

      // rebind events
      s.unbindEvents();
      s.bindEvents();
    },
    setContainerDimensions: function () {
      var s = this,
        badIE = browser.ie6 || browser.ie7;

      // get the dimensions for the container and data
      var ch = s.d.origHeight ? s.d.origHeight : browser.opera ? s.d.container.height() : s.getVal(badIE ? s.d.container[0].currentStyle['height'] : s.d.container.css('height'), 'h'),
        cw = s.d.origWidth ? s.d.origWidth : browser.opera ? s.d.container.width() : s.getVal(badIE ? s.d.container[0].currentStyle['width'] : s.d.container.css('width'), 'w'),
        dh = s.d.data.outerHeight(true),
        dw = s.d.data.outerWidth(true);
      s.d.origHeight = s.d.origHeight || ch;
      s.d.origWidth = s.d.origWidth || cw;

      // mxoh = max option height, mxow = max option width
      var mxoh = s.o.maxHeight ? s.getVal(s.o.maxHeight, 'h') : null,
        mxow = s.o.maxWidth ? s.getVal(s.o.maxWidth, 'w') : null,
        mh = mxoh && mxoh < w[0] ? mxoh : w[0],
        mw = mxow && mxow < w[1] ? mxow : w[1];

      // moh = min option height
      var moh = s.o.minHeight ? s.getVal(s.o.minHeight, 'h') : 'auto';
      if (!ch) {
        if (!dh) {
          ch = moh;
        } else {
          if (dh > mh) {
            ch = mh;
          } else if (s.o.minHeight && moh !== 'auto' && dh < moh) {
            ch = moh;
          } else {
            ch = dh;
          }
        }
      } else {
        ch = s.o.autoResize && ch > mh ? mh : ch < moh ? moh : ch;
      }

      // mow = min option width
      var mow = s.o.minWidth ? s.getVal(s.o.minWidth, 'w') : 'auto';
      if (!cw) {
        if (!dw) {
          cw = mow;
        } else {
          if (dw > mw) {
            cw = mw;
          } else if (s.o.minWidth && mow !== 'auto' && dw < mow) {
            cw = mow;
          } else {
            cw = dw;
          }
        }
      } else {
        cw = s.o.autoResize && cw > mw ? mw : cw < mow ? mow : cw;
      }
      s.d.container.css({
        height: ch,
        width: cw
      });
      s.d.wrap.css({
        overflow: dh > ch || dw > cw ? 'auto' : 'visible'
      });
      s.o.autoPosition && s.setPosition();
    },
    setPosition: function () {
      var s = this,
        top,
        left,
        hc = w[0] / 2 - s.d.container.outerHeight(true) / 2,
        vc = w[1] / 2 - s.d.container.outerWidth(true) / 2,
        st = s.d.container.css('position') !== 'fixed' ? wndw.scrollTop() : 0;
      if (s.o.position && Object.prototype.toString.call(s.o.position) === '[object Array]') {
        top = parseFloat(st) + parseFloat(s.o.position[0] || hc);
        left = s.o.position[1] || vc;
      } else {
        top = st + hc;
        left = vc;
      }
      s.d.container.css({
        left: left,
        top: top
      });
    },
    watchTab: function (e) {
      var s = this;
      const modalContainer = $(e.target).parents('.simplemodal-container');
      if (modalContainer.length > 0) {
        // save the list of inputs
        if (!modalContainer.hasClass('warning-modal-container')) {
          s.inputs = $(':input:enabled:visible:first, :input:enabled:visible:last', s.d.data[0]);

          // if it's the first or last tabbable element, refocus
          if (!e.shiftKey && e.target === s.inputs[s.inputs.length - 1] || e.shiftKey && e.target === s.inputs[0] || s.inputs.length === 0) {
            e.preventDefault();
            var pos = e.shiftKey ? 'last' : 'first';
            s.focus(pos);
          }
        }
      } else {
        // might be necessary when custom onShow callback is used
        e.preventDefault();
        s.focus();
      }
    },
    /*
     * Open the modal dialog elements
     * - Note: If you use the onOpen callback, you must "show" the
     *         overlay and container elements manually
     *         (the iframe will be handled by SimpleModal)
     */
    open: function () {
      var s = this;
      // display the iframe
      s.d.iframe && s.d.iframe.show();
      if (typeof s.o.onOpen === 'function') {
        // execute the onOpen callback
        s.o.onOpen.apply(s, [s.d]);
      } else {
        // display the remaining elements
        s.d.overlay.show();
        s.d.container.show();
        s.d.data.show();
      }
      s.o.focus && s.focus();

      // bind default events
      s.bindEvents();
    },
    /*
     * Close the modal dialog
     * - Note: If you use an onClose callback, you must remove the
     *         overlay, container and iframe elements manually
     *
     * @param {boolean} external Indicates whether the call to this
     *     function was internal or external. If it was external, the
     *     onClose callback will be ignored
     */
    close: function () {
      var s = this;

      // prevent close when dialog does not exist
      if (!s.d.data) {
        return false;
      }

      // remove the default events
      s.unbindEvents();
      if (typeof s.o.onClose === 'function' && !s.occb) {
        // set the onClose callback flag
        s.occb = true;

        // execute the onClose callback
        s.o.onClose.apply(s, [s.d]);
      } else {
        // if the data came from the DOM, put it back
        if (s.d.placeholder) {
          var ph = $('#simplemodal-placeholder');
          // save changes to the data?
          if (s.o.persist) {
            // insert the (possibly) modified data back into the DOM
            ph.replaceWith(s.d.data.removeClass('simplemodal-data').css('display', s.display));
          } else {
            // remove the current and insert the original,
            // unmodified data back into the DOM
            s.d.data.hide().remove();
            ph.replaceWith(s.d.orig);
          }
        } else {
          // otherwise, remove it
          s.d.data.hide().remove();
        }

        // remove the remaining elements
        s.d.container.hide().remove();
        s.d.overlay.hide();
        s.d.iframe && s.d.iframe.hide().remove();
        s.d.overlay.remove();

        // reset the dialog object
        s.d = {};
      }
    }
  };
})(jQuery);

/***/ }),

/***/ 575:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var Buffer = __webpack_require__(17995)["Buffer"];
var $ = __webpack_require__(55401);
var CksUtil = __webpack_require__(15641);
var clientCommonUtils = __webpack_require__(82672);
var i18n = __webpack_require__(2622);
var emailUtils = __webpack_require__(25119);
const {
  _bindAllMethods
} = __webpack_require__(4424);

/** ~
 * Handles the creation of secure emails
 */
function SecureEmailComposer(options) {
  this._secureService = options.secureService;
  this._renderer = options.renderer;
  this._settings = options.settings;
  _bindAllMethods(this);
}

/**
 * Create a new email composer
 */
SecureEmailComposer.create = function (options) {
  return new SecureEmailComposer(options);
};

/**
 * Preprocess the message before sending to secureService
 */
SecureEmailComposer.prototype._preprocess = function (plainHTML) {
  var container = $('<div></div>');
  plainHTML = $(plainHTML);
  // Copy into the preprocessing container
  container.append(plainHTML.clone());

  // There should only be one unless it's a strange message
  var secureMessageEls = container.find('pre:contains(--- START PROTECTED MESSAGE TDF)');
  var secureMessages = [];
  var parsedMessages = [];

  // Store the previous messages
  var messageId;
  if (secureMessageEls.length > 0) {
    secureMessages = Array.from(secureMessageEls).map(el => $(el).text());
    parsedMessages = secureMessages.map(message => clientCommonUtils.email.parseMessage(message).base64);

    // The first message is the most current message. Replace that email with a
    // placeholder
    var secureMessageElem = $(secureMessageEls[0]);
    var email = emailUtils.getMessageContainer(secureMessageElem);
    var parsed = clientCommonUtils.email.parseMessage(secureMessages[0]);
    messageId = parsed.messageId;
    var placeholderHTML = `<div class="virtru-embedded-secure-message" data-message-id="${messageId}">${i18n.t('SECURE_EMAIL_COMPOSER_PLACEHOLDER_HTML')}</div>`;
    email.replaceWith(placeholderHTML);
  }
  messageId = secureMessages.length;
  return {
    html: container.html(),
    secureMessages,
    // Goes to SWIG for secure email format
    parsedMessages,
    // Goes to secureService.forwardMessages()
    messageId
  };
};

/**
 * Compose the email from the given plaintext html and policy options
 */
SecureEmailComposer.prototype.compose = function (messageInfo, policyOptions, templateHtml, associatedAttachments) {
  var plainHTML = messageInfo.body;
  if (!policyOptions.displayName || policyOptions.displayName.length === 0) {
    policyOptions.displayName = i18n.t('SECURE_EMAIL_COMPOSER_POLICY_OPTIONS_DEFAULT');
  }

  // Preprocess the message
  var preprocessedData = this._preprocess(plainHTML);
  var previousMessages = preprocessedData.parsedMessages;
  var processedHTML = preprocessedData.html;

  // Encrypt the html
  var renderer = this._renderer;
  var self = this;

  // Prepare word array for search token generation
  var searchKey = this._settings.user.setting('searchKey');
  var canIndexEncryptedEmails = this._settings.user.settings('permissions.canIndexEncryptedEmails');
  var operation = previousMessages.length > 0 ? this._secureService.forwardMessages(previousMessages, policyOptions.emailUsers) : Promise.resolve();

  // Apply forward for each UUID
  if (associatedAttachments && associatedAttachments.length > 0) {
    policyOptions.associatedAttachments = associatedAttachments;
    for (const associatedAttachment of associatedAttachments) {
      const policyUuid = associatedAttachment.isTdf3Html ? associatedAttachment.originalFile.policyId : associatedAttachment.policyUuid;
      operation = operation.then(this._secureService.forwardPolicies([policyUuid], policyOptions.emailUsers));
    }
  }
  return operation.then(function success() {
    var userSettings = self._settings.user.settings();
    var processorOptions = {
      orgPublicKey: CksUtil.getOrgPublicKey(userSettings)
    };
    var operations = [self._secureService.makeMessage(processedHTML, policyOptions, processorOptions)];

    // Generate search tokens if encrypted search is enabled
    if (searchKey && canIndexEncryptedEmails) {
      var wordArray = clientCommonUtils.encryptedSearch.createWordArray(processedHTML, {
        jquery: $
      });
      operations.push(self._secureService.generateSearchTokens(wordArray, searchKey));
    }
    return Promise.all(operations);
  }).then(function success(data) {
    var _policyOptions$person;
    var response = data[0];
    var searchTokens = data[1];
    var platform = 'browser_extension';
    var version = '';
    try {
      var cs = self._settings.user._profile.clientString.split(':');
      platform = cs[0];
      version = cs[1];
    } catch (e) {
      /* ignore this error */
    }
    var metadata = {
      version: '1.4.0',
      messageId: response.policyUuid,
      remoteContentLink: response.remoteContentLink,
      'user.platform': platform,
      'user.platform.version': version
    };
    var encodedMetadata = new Buffer(JSON.stringify(metadata)).toString('base64');
    var emailData = {
      secureMessage: response.secureMessage,
      messageId: preprocessedData.messageId,
      previousMessages: preprocessedData.secureMessages,
      messageUUID: response.policyUuid,
      metadata: encodedMetadata,
      microTdfLink: metadata.remoteContentLink,
      senderName: policyOptions.ownerDisplayName ? policyOptions.ownerDisplayName : policyOptions.owner,
      senderAddress: policyOptions.sentFrom,
      mobileLink: `virtru://message?uuid=${response.policyUuid}`,
      emailSubject: policyOptions.displayName,
      welcomeMessage: policyOptions.welcomeMessage,
      customPersonalIntro: (_policyOptions$person = policyOptions.personalIntro) === null || _policyOptions$person === void 0 ? void 0 : _policyOptions$person.isModified,
      year: new Date().getFullYear(),
      searchTokens
    };

    // Only use welcomeMessage if the user set a custom intro
    if (policyOptions.personalIntro && policyOptions.personalIntro.isModified) {
      emailData.welcomeMessage = policyOptions.welcomeMessage;
    }
    var rendered = renderer.render(templateHtml, emailData);
    return {
      html: rendered,
      isDevelopment: response.isDevelopment,
      subjectPostfix: response.subjectPostfix
    };
  });
};
exports.SecureEmailComposer = SecureEmailComposer;

/***/ }),

/***/ 721:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * jquery-trigger-native.js
 *
 * Provides a simple interface to dispatch native events
 *
 * Author: Reuven V. Gonzales
 * Copyright (c) 2013 Reuven V. Gonzales
 * License: MIT
 */
var $ = __webpack_require__(91089);
var defaultEventOptions = {
  canBubble: true,
  cancelable: true,
  view: window,
  detail: 1,
  screenX: 0,
  screenY: 0,
  clientX: 0,
  clientY: 0,
  ctrlKey: false,
  altKey: false,
  shiftKey: false,
  metaKey: false,
  button: 0,
  relatedTarget: null,
  extra: {},
  processor() {}
};
var mouseEvents = ['click', 'contextmenu', 'dblclick', 'DOMMouseScroll', 'drag', 'dragdrop', 'dragend', 'dragenter', 'dragexit', 'draggesture', 'dragleave', 'dragover', 'dragstart', 'drop', 'mousedown', 'mousemove', 'mouseout', 'mouseover', 'mouseup', 'mousewheel'];
var uiEvents = ['abort', 'activate', 'beforeactivate', 'beforedeactivate', 'deactivate', 'DOMActivate', 'DOMFocusIn', 'DOMFocusOut', 'overflow', 'resize', 'scroll', 'select', 'underflow'];
$.fn.triggerNative = function (eventType, options) {
  options = $.extend({}, defaultEventOptions, options);
  var event = null;
  // If it's mouse event
  if (mouseEvents.indexOf(eventType) >= 0) {
    event = document.createEvent('MouseEvent');
    event.initMouseEvent(eventType, options.canBubble, options.cancelable, options.view, options.detail, options.screenX, options.screenY, options.clientX, options.clientY, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, options.button, options.relatedTarget);
  } else if (uiEvents.indexOf(eventType) >= 0) {
    event = document.createEvent('UIEvent');
    event.initUIEvent(eventType, options.canBubble, options.cancelable, options.view, options.detail);
  } else {
    event = document.createEvent('Event');
    event.initEvent(eventType, options.canBubble, options.cancelable);
  }
  var {
    extra
  } = options;
  for (var name in extra) {
    event[name] = extra[name];
  }
  var {
    processor
  } = options;
  processor.apply(null, [event]);
  this.each(function () {
    this.dispatchEvent(event);
  });
  return this;
};
module.exports = $;

/***/ }),

/***/ 1246:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports.AnalyticsProxy = __webpack_require__(3751);
module.exports.AnalyticsBackgroundRouter = __webpack_require__(10086);
module.exports.instance = function (transports) {
  return module.exports.AnalyticsProxy.instance(transports);
};

/***/ }),

/***/ 1459:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
/**
 * @file Provides the main Gmail (page-script) plugin.
 */

const {
  transports
} = __webpack_require__(29182);
const AnalyticsService = (__webpack_require__(1246).instance)(transports);
const secureEmail = __webpack_require__(58922);
const $ = __webpack_require__(55401);
const {
  SecureServiceProxy
} = __webpack_require__(6336);
const {
  GmailSettings
} = __webpack_require__(1702);
const globalsProcessor = __webpack_require__(96478);
const {
  WebmailPlugin
} = __webpack_require__(38282);
const sanitizeAnalyticsError = (__webpack_require__(81442)/* ["default"] */ .A);
const gmailUtil = __webpack_require__(2090);
const {
  initLogger
} = __webpack_require__(94064);
const {
  GmailMonitor
} = __webpack_require__(33921);
const gmailMods = __webpack_require__(11741);
const xhrIntercepts = __webpack_require__(60162);
const DEFAULT_GMAIL_DOM = (__webpack_require__(20577).selectors);
const GOOGLE_CALL_WINDOW_INDICATOR = '.lrU2me';
let secureServiceProxy;

/**
 * This function overrides the window.open function and
 * injects the GMail window.GLOBALS object.
 */
function overrideOpen() {}
exports.main = function () {
  // Filter out the 'help' pages that still share the
  // mail.google.com root but aren't part of GMail.
  try {
    var pathName = window.location.pathname;
    if (pathName.indexOf('/mail/help/') >= 0) {
      return;
    }

    // Detects if this is a Google Call window
    if ($(GOOGLE_CALL_WINDOW_INDICATOR).length > 0) {
      return;
    }

    // Detects if a google chat window is open
    if (document.body.matches(DEFAULT_GMAIL_DOM.POPOUT_WINDOW) && !document.body.matches(DEFAULT_GMAIL_DOM.POPOUT_WINDOW_COMPOSE) && !document.body.matches(DEFAULT_GMAIL_DOM.POPOUT_WINDOW_READ)) {
      return;
    }
  } catch (err) {
    // ignore the error and let processing continue
  }
  overrideOpen();

  // Create the secure service proxy
  secureServiceProxy = SecureServiceProxy.create(transports);

  // Configure the email service with the proxy
  secureEmail.configure({
    secureService: secureServiceProxy
  });
  transports.call('content', 'returnSelectors', {
    gmailVersion: gmailUtil.getGmailVersion()
  }).then(selectors => Promise.all([globalsProcessor.process(gmailUtil.getWindowGlobals(), selectors), transports.call('content', 'getManifestVersion')])).then(([gmailGlobals, version]) => {
    // add a class to the body to override styles for different skins
    var $body = $(document.body);
    $body.addClass('virtru-material-design');
    initLogger({
      source: 'page-script',
      version,
      userId: gmailGlobals.user
    });
    WebmailPlugin.run({
      gmailGlobals,
      secureServiceProxy,
      GmailSettings,
      secureEmail,
      GmailMonitor,
      gmailMods,
      xhrIntercepts
    });
  }).catch(err => {
    console.log('Plugin could not be loaded.');
    var context = 'unknown_view';
    if (document.body.matches(DEFAULT_GMAIL_DOM.POPOUT_WINDOW)) {
      if (document.body.matches(DEFAULT_GMAIL_DOM.POPOUT_WINDOW_READ)) {
        context = 'pop-out read';
      }
      if (document.body.matches(DEFAULT_GMAIL_DOM.POPOUT_WINDOW_COMPOSE)) {
        context = 'pop-out compose';
      }
    }
    AnalyticsService.clientError({
      context,
      name: 'No Globals',
      webmail_provider: 'gmail',
      webmail_version: '',
      error_obj: sanitizeAnalyticsError(err)
    }, true);
  });
};

/***/ }),

/***/ 1702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @file Provides the application settings for Gmail plugin
 */

var {
  transports
} = __webpack_require__(29182);
var Emitter = __webpack_require__(16502);
var {
  BaseSettings
} = __webpack_require__(38282);

/**
 * The gmail-plugin application settings; also implements events
 * @constructor
 * @augments BaseSettings
 * @param {Object} window - the 'window' object
 * @param {String} site - (optional) the mail-site (default= gmail)
 * @param {String} provider - (optional) the mail provider (default=google)
 */
class GmailSettings extends BaseSettings {
  constructor(gmailGlobals, window, site, provider) {
    site = site || 'gmail';
    provider = provider || 'google';
    super(window, site, provider);
    this.gmailGlobals = gmailGlobals || {
      user: 'unknown'
    };
  }

  /**
   * Get the current user
   * @method
   * @returns {String} - the email address of current user
   */
  currentUser() {
    return this.gmailGlobals.user;
  }

  /**
   * Get the current user's display name.  Falls back to the e-mail address if
   * the display name cannot be located
   * @method
   * @returns {String} - the display name of the current user or the e-mail address
   */
  currentUserDisplayName() {
    return this.gmailGlobals.displayName ? this.gmailGlobals.displayName : this.currentUser();
  }

  /**
   * Get the current version
   * @method
   * @returns {String} - the 'string-ified' version ID
   */
  currentVersion() {
    return this.gmailGlobals.version;
  }

  /**
   * Get the current version
   * @method
   * @returns {String} - the 'string-ified' version ID
   */
  isNewCompose() {
    return this.gmailGlobals.isNewCompose;
  }

  /**
   * Get the sdk-transports
   * @method
   * @returns {Object} transports - the sdk/transports
   */
  getTransports() {
    return transports;
  }
}

// Implement events for the settings object
Emitter(GmailSettings.prototype);
exports.GmailSettings = GmailSettings;

/***/ }),

/***/ 1814:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SmartSendSecure = __webpack_require__(51694);
module.exports = SmartSendSecure;

/***/ }),

/***/ 2090:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   elementIsInlineImage: () => (/* binding */ elementIsInlineImage),
/* harmony export */   getGmailVersion: () => (/* binding */ getGmailVersion),
/* harmony export */   getWindowGlobals: () => (/* binding */ getWindowGlobals),
/* harmony export */   isSecureParentMessage: () => (/* binding */ isSecureParentMessage),
/* harmony export */   pwnCompose: () => (/* binding */ pwnCompose),
/* harmony export */   unPwnCompose: () => (/* binding */ unPwnCompose)
/* harmony export */ });
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__);


// Constant for classes to add/remove
var BLUR_CLASSES = 'no-touch virtru-blur';

/**
 * Determine if a given element is most likely an inline image on the compose window.
 *
 * @param elem {DOMElement} The element to consider
 * @return {Boolean} Whether or not the element should be considered an inline image.
 */
function elementIsInlineImage(elem) {
  const elemSrc = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(elem).attr('src') || '';
  // whitelist all the possible attributes that indicate this element is considered an inline image by google
  return elemSrc.indexOf('realattid') >= 0 || elemSrc.indexOf('blob') === 0;
}

/**
 * Determine if a given element is a parent element in a message. If not, we are probably a message
 * inside of an unsecure reply.
 *
 * @param elem {DOMElement} The element to consider
 * @return {Boolean} Whether or not the element is a top-level secure message.
 */
function isSecureParentMessage(element) {
  // Find out if the top-level secure message in this container has any content preceding it.
  // If there is content before a secure message, it is most likely an unsecure reply containing the message.
  var closestMessage = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(element).closest('.virtru-message');
  var ancestorElement = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(element).get(0);
  var isSecureParentMessage = true;
  while (closestMessage.length && ancestorElement !== closestMessage.get(0)) {
    if (_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(ancestorElement).index() > 0) {
      isSecureParentMessage = false;
    }
    ancestorElement = ancestorElement.parentElement;
  }
  return isSecureParentMessage;
}

/**
 * Retrieve gmail's GLOBALS object, looking on the parent window if necessary.
 *
 * @return {Object} The windows.GLOBAL object.
 */
function getWindowGlobals() {
  let windowToWork = window;
  // Look for the globals on the parent window if this window was opened (presumably as a popout)
  while (!windowToWork.GLOBALS && windowToWork.opener && windowToWork.opener !== windowToWork) {
    windowToWork = windowToWork.opener;
  }
  return windowToWork.GLOBALS;
}
function getGmailVersion() {
  const GMAIL_GLOBALS = getWindowGlobals();
  return GMAIL_GLOBALS[2];
}

/**
 * This function will take over the new compose window, blurring the send and subject
 * areas, and replacing the editor with custom content.
 *
 * @param element The new compose window element
 * @param content An object which can be appended to a jQuery object that contains
 * the content to be shown in the Editor area of the compose window, replacing the
 * actual editor element
 * @param selectors The selectors to use
 * @param windowHeight The height of the window before the nested content as been expanded
 */
function pwnCompose(element, content, selectors, windowHeight) {
  var recipient = element.find(selectors.PWN_COMPOSE_RECIPIENT);
  var subject = element.find(selectors.PWN_COMPOSE_SUBJECT);
  var footer = element.find(selectors.PWN_COMPOSE_FOOTER);
  var replyOptions = element.find(selectors.PWN_COMPOSE_REPLY_OPTIONS);

  // Blur and add the no-touch class so that users can't interact with these divs
  recipient.addClass(BLUR_CLASSES);
  subject.addClass(BLUR_CLASSES);
  footer.addClass(BLUR_CLASSES);
  replyOptions.addClass(BLUR_CLASSES);

  // Super annoyingly, I had to add this in a setTimeout since the element might not exist
  // by the time this code runs. It's not worth fixing this 'all the way', since soon we'll implement,
  // brand new designs for the personal intro anyway...

  setTimeout(function () {
    element.find('.virtru-intro-message-toggle-outer').addClass(BLUR_CLASSES);
  }, 1);
  var editor = element.find(selectors.NEW_REPLY_TEXTAREA);
  var editorHeight = editor.height();

  // Do not add second compose container if one already exists
  const composeContainer = element.find('.virtru-compose-container');
  var activateContainer = composeContainer.length ? composeContainer : _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()('<div>', {
    class: 'virtru-compose-container'
  });
  activateContainer.append(content);
  if (windowHeight) {
    // Add the container div and then hide the editor
    editor.after(activateContainer);
    activateContainer.css('height', `${windowHeight}px`);
  } else {
    element.append(activateContainer);
    var originalPosition = activateContainer.css('position');
    activateContainer.css({
      position: 'absolute',
      // Optional if #myDiv is already absolute
      visibility: 'hidden'
    });
    var contentHeight = activateContainer.height();
    activateContainer.css({
      position: originalPosition,
      visibility: 'visible'
    });
    activateContainer.remove();
    editor.after(activateContainer);
    if (editorHeight < contentHeight) {
      activateContainer.css('height', `${contentHeight}px`);
    } else {
      activateContainer.css('height', `${editorHeight}px`);
    }
  }
  editor.hide();
}
function unPwnCompose(element, selectors) {
  var recipient = element.find(selectors.PWN_COMPOSE_RECIPIENT);
  var subject = element.find(selectors.PWN_COMPOSE_SUBJECT);
  var footer = element.find(selectors.PWN_COMPOSE_FOOTER);
  var replyOptions = element.find(selectors.PWN_COMPOSE_REPLY_OPTIONS);
  var editor = element.find(selectors.NEW_REPLY_TEXTAREA);
  var container = element.find('.virtru-compose-container');
  var introToggle = element.find('.virtru-intro-message-toggle-outer');

  // Blur and add the no-touch class so that users can't interact with these divs
  recipient.removeClass(BLUR_CLASSES);
  subject.removeClass(BLUR_CLASSES);
  footer.removeClass(BLUR_CLASSES);
  replyOptions.removeClass(BLUR_CLASSES);

  // Same removing as adding following element to the page.
  setTimeout(() => {
    introToggle.removeClass(BLUR_CLASSES);
  }, 2);
  container.remove();
  editor.show();
}

/***/ }),

/***/ 2622:
/***/ ((module, exports, __webpack_require__) => {

__webpack_require__(50154);
module.exports = exports = __webpack_require__(32841);

/***/ }),

/***/ 2688:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   animationWidget: () => (/* binding */ animationWidget)
/* harmony export */ });
const animationWidget = () => '<div class="virtru-animation-widget"></div>';

/***/ }),

/***/ 2883:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ VirtruOfflineMode)
/* harmony export */ });
/* harmony import */ var _connectivity_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(84712);
/* harmony import */ var _index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55675);


class VirtruOfflineMode extends _connectivity_state__WEBPACK_IMPORTED_MODULE_1__/* ["default"] */ .A {
  constructor(profile) {
    super(window);
    this._profile = profile;
  }
  _hasPermission() {
    return (0,_index__WEBPACK_IMPORTED_MODULE_0__.isFeatureEnabled)(this._profile, 'canUseOffline') || this._profile.auth.status === 'new';
  }

  // Avoid invoking any callbacks if we do not have permission
  _onlineListener(event) {
    if (this._hasPermission()) {
      super._onlineListener(event);
    }
  }
  _offlineListener(event) {
    if (this._hasPermission()) {
      super._offlineListener(event);
    }
  }
  isOffline() {
    return this._hasPermission() && super.isOffline();
  }
  isOnline() {
    return !this.isOffline();
  }
}

/***/ }),

/***/ 2913:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(91089);
$.fn.firstChild = function () {
  var ret = [];
  // use a for loop
  for (var i = 0, len = this.length; i < len; i++) {
    var this_el = this[i],
      el = this_el.firstElementChild; // try firstElementChild first
    if (!el) {
      el = this_el.firstChild;
      while (((_el = el) === null || _el === void 0 ? void 0 : _el.nodeType) !== 1) {
        var _el;
        el = el.nextSibling;
      }
    }
    if (el) {
      ret.push(el);
    }
  }
  // maintain jQuery chaining and end() functionality
  return this.pushStack(ret);
};

/***/ }),

/***/ 3558:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
/**
 * This class handles responding to updates to a policy for
 * a rendered e-mail and updates the policy on the ACM
 */
var Emitter = __webpack_require__(16502);
var {
  PolicyAttributes
} = __webpack_require__(38282);
var moment = __webpack_require__(13985);
const {
  _bindAllMethods
} = __webpack_require__(4424);

/**
 * Creates a new policy updater component.
 * @param secureService SecureLibProxy object
 * @constructor
 */
function PolicyUpdater(secureService, contract, connectionEventRouter) {
  this.secureService = secureService;
  this.contract = contract;
  this.connectionEventRouter = connectionEventRouter;
  _bindAllMethods(this);
}

/**
 * Events:
 *   revocation - When an email is revoked and the server sends a message
 *   revoke-succeeded - When a revoke is initiated by the server and it succeeds
 *   revoke-failed - When a revoke is initiated by the server and it fails
 *   enable-succeeded - When an enable succeeds
 *   enable-failed - When an enable fails
 *   policy-update-succeeded - When a policy update succeeds
 *   policy-update-failed - When a policy update fails
 *
 */
Emitter(PolicyUpdater.prototype);
PolicyUpdater.create = function (secureService, contract, router) {
  var updater = new PolicyUpdater(secureService, contract, router);
  updater.setupEvents();
  return updater;
};
PolicyUpdater.prototype.setupEvents = function () {
  this.connectionEventRouter.on('offline', this.onOffline);
  this.connectionEventRouter.on('offline-lease-started', this.onOfflineLeaseStarted);
  this.connectionEventRouter.on('offline-lease-expired', this.onOfflineLeaseExpired);
  this.connectionEventRouter.on('online', this.onOnline);
};
PolicyUpdater.prototype.onOffline = function () {
  this.emit('offline');
};
PolicyUpdater.prototype.onOfflineLeaseStarted = function (leaseTime) {
  this.emit('offline-lease-started', leaseTime);
};
PolicyUpdater.prototype.onOfflineLeaseExpired = function () {
  this.emit('offline-lease-expired');
};
PolicyUpdater.prototype.onOnline = function () {
  this.emit('online');
};

/**
 * Handles a user initiated revoke
 */
PolicyUpdater.prototype.handleRevoke = function () {
  var self = this;
  this.secureService.revokePolicy([this.contract.policyId]).then(() => {
    console.log('Policy revoked');
    self.emit('revoke-succeeded');
  }, errorLoc => {
    console.log('Error', errorLoc);
    self.emit('revoke-failed');
  });
};

/**
 * Handles a user initiated revoke
 */
PolicyUpdater.prototype.handleEnable = function () {
  var self = this;
  this.secureService.enablePolicy(this.contract.policyId).then(() => {
    console.log('Policy enabled');
    self.emit('enable-succeeded');
  }, errorLoc => {
    console.log('Error', errorLoc);
    self.emit('enable-failed');
  });
};

/**
 * Handles a user updating the policy
 * @param policyModel
 */
PolicyUpdater.prototype.handlePolicyChanged = function (policyModel) {
  var self = this;
  var simplePolicy = {};

  // If the arrays are identical, no need to update it
  var authorizations = PolicyAttributes.getAuthorizations(policyModel);
  var oldAuthorizations = this.contract.authorizations;
  var hasDifference = authorizations.some(auth => !oldAuthorizations.includes(auth));
  if (authorizations.length !== oldAuthorizations.length || hasDifference) {
    simplePolicy.authorizations = authorizations;
  }

  // Check to see if the activeEnd has changed
  var activeEnd = policyModel.expires ? policyModel.expirationDate : null;
  var oldActiveEnd = this.contract.activeEnd ? this.contract.activeEnd : null;

  // This code sux... Do null checks... But if they're both dates then make
  // sure they're not the same
  if (activeEnd !== oldActiveEnd) {
    if (activeEnd !== null && oldActiveEnd !== null) {
      if (!moment(activeEnd).isSame(oldActiveEnd)) {
        simplePolicy.activeEnd = activeEnd;
      }
    } else {
      simplePolicy.activeEnd = activeEnd;
    }
  }
  if (policyModel.sms && !policyModel.sms2faMap) {
    console.log('Error', 'SMS2FA is enabled but phones not added');
    self.emit('policy-update-failed');
    return;
  }
  const sms2faMap = policyModel.sms ? policyModel.sms2faMap : null;

  // Emit an event which secure-read-widget is listening for
  // secure-read-widget will loop through its attachments and update them individually
  // this.emit('is-managed-update', policyModel.isManaged);
  simplePolicy.isManaged = policyModel.isManaged;
  this.secureService.updatePolicy(this.contract.policyId, {
    simplePolicy,
    sms2faMap
  }).then(() => {
    // Store the policy updates locally
    if (simplePolicy.authorizations !== undefined) {
      self.contract.authorizations = simplePolicy.authorizations;
    }
    if (simplePolicy.activeEnd !== undefined) {
      self.contract.activeEnd = simplePolicy.activeEnd;
    }
    self.emit('policy-update-succeeded');
  }, errorLoc => {
    console.log('Error', errorLoc);
    self.emit('policy-update-failed');
  });
};
PolicyUpdater.prototype.teardown = function () {
  this.connectionEventRouter.off('offline', this.onOffline);
  this.connectionEventRouter.off('offline-lease-started', this.onOfflineLeaseStarted);
  this.connectionEventRouter.off('offline-lease-expired', this.onOfflineLeaseExpired);
  this.connectionEventRouter.off('online', this.onOnline);
};
exports.PolicyUpdater = PolicyUpdater;

/***/ }),

/***/ 3751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
var Utils = __webpack_require__(55675);
const {
  _bindAllMethods
} = __webpack_require__(4424);

/**
 * Proxies the commands for the secure service proxy.
 *
 * This is necessary for page scripts in the browser extension
 * @param {*} transports - The transports object for comms
 */
function AnalyticsProxy(transports) {
  this.transports = transports;
  _bindAllMethods(this);
}
var INSTANCE = undefined;
AnalyticsProxy.instance = function (transports) {
  if (!INSTANCE) {
    INSTANCE = AnalyticsProxy.create(transports);
  }
  return INSTANCE;
};
AnalyticsProxy.create = function (transports) {
  var proxy = new AnalyticsProxy(transports);
  proxy.initMethods();
  return proxy;
};
AnalyticsProxy.prototype.initMethods = function () {
  console.debug('initMethods');
  // Check for the existance of `this.transports` b/c in certain use-cases
  // it doesn't exist... i.e. from the Virtru content script.  B/c the
  // Virtru content script is importing `sites`, which was intended for
  // use with only the `page` script, the transports are never set.
  if (this.transports) {
    this.callTransport('analytics-methods', {}).then(this._initMethodsCallback).catch(err => {
      console.error(err);
    });
    this.showIntro();
  }
};
AnalyticsProxy.prototype._initMethodsCallback = function (methods) {
  console.debug('_initMethodsCallback');
  try {
    methods.forEach(method => {
      if (this[method] !== undefined) {
        return;
      }
      this[method] = properties => {
        this.track(method, properties);
      };
    });
  } catch (err) {
    console.error(err);
  }
};
AnalyticsProxy.prototype.identify = function (properties) {
  // Format any error so it can cross message boundaries
  for (var key in properties) {
    properties[key] = Utils.formatForTransport(properties[key]);
  }
  var params = {
    properties
  };
  return this.callTransport('analytics-identify', params);
};
AnalyticsProxy.prototype.track = function (name, properties) {
  // Format any error so it can cross message boundaries
  for (var key in properties) {
    properties[key] = Utils.formatForTransport(properties[key]);
  }
  var params = {
    method: name,
    properties
  };
  return this.callTransport('analytics-track', params);
};
AnalyticsProxy.prototype.showIntro = function () {
  var logoStyle = 'font-size: 8px; font-weight: bold; font-family: courier; color: blue';
  var welcomeMessageStyle = 'font-size: 12px; font-weight: bold; font-family: courier; color: blue';
  var virtruLogo = '%c';
  var welcomeMessage = '%c';
  virtruLogo += `
                             +++                '++.
                             +++                ++++
                                                ++++
            ,:::      +++    +++     :+++++++   +++++++    .+++++++   .++     '++
            ++++     .+++.  '+++    ++++++++++  ++++++++  ++++++++++  ++++    ++++
            ++++     ++++\`  ++++\`   +++++''++   +++++++   +++++++++   ++++    ++++
            ++++   .++++    ++++\`   ++++        ++++      ++++        ++++    ++++
            ++++  .++++     ++++\`   ++++        ++++      ++++        ++++    ++++
            ++++ ++++       ++++\`   ++++        ++++      ++++        ++++    ++++
            ++++++\`         ;+++    ++++        ++++      ++++          ++++++++
            ++++             +++     ++'         ++        ++'           .++++\`
         S   i   m   p   l   e      E   m   a   i   l      P   r   i   v   a   c   y \n\n`;
  welcomeMessage += `
Thanks for using Virtru! We're using a service
called Amplitude to learn more about how you, our users,
interact with Virtru. That means some information about your
usage is sent to a third-party. This information does NOT
include email content, or encryption keys.  This helps
us a great deal in improving Virtru, but it's OPTIONAL.

To opt out, visit this link:

  https://secure.virtru.com/control-center/settings

Virtru relies on some outstanding open source projects
to function. Visit the following link to view which projects
we use and their associated licenses:

  https://www.virtru.com/oss/

Thanks,
the Virtru team
`;
  console.log(virtruLogo, logoStyle);
  console.log(welcomeMessage, welcomeMessageStyle);
};
AnalyticsProxy.prototype.callTransport = function (method, params) {
  // Check for the existance of `this.transports` b/c in certain use-cases
  // it doesn't exist... i.e. from the Virtru content script.  B/c the
  // Virtru content script is importing `sites`, which was intended for
  // use with only the `page` script, the transports are never set.
  if (this.transports) {
    return this.transports.call('content', method, params);
  }
};
module.exports = AnalyticsProxy;

/***/ }),

/***/ 4288:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var mods = __webpack_require__(25939);
var contexts = __webpack_require__(47446);
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var AttachmentService = __webpack_require__(95727);
var AttachmentUtil = __webpack_require__(31027);
const {
  PolicyAttributes
} = __webpack_require__(81722);
const {
  _bindAllMethods
} = __webpack_require__(4424);
const {
  ATTACHMENTS_LIMIT
} = __webpack_require__(76223);
const {
  showAttachmentsLimitModal
} = __webpack_require__(52561);

/**
 * Creates a new AddAttachmentButtonMod around the add attachment button element
 *
 * @param settings Current users settings
 * @param element The add attachment button element
 * @param removeSelector The selector of element(s) to remove from the button (optional)
 * @constructor
 */
class AddAttachmentButtonMod extends mods.Mod {
  constructor(settings, element, removeSelector, transports, composeMod) {
    super(settings, element);
    this._settings = settings;
    this._element = $(element);
    this._removeSelector = removeSelector;
    this._transports = transports;
    this._composeMod = composeMod;
    _bindAllMethods(this);
  }
  setup() {
    var element = this._element;
    var cloned = this._cloned = element.clone();
    this._element.replaceWith(cloned);
    if (this._removeSelector) {
      $(this._removeSelector, cloned).remove();
    }
    cloned.removeAttr('onclick');
    cloned.removeAttr('onmousedown');
    cloned.removeAttr('href');
    cloned.on('click', e => this.openFileDialog(e));
    this._attachmentService = new AttachmentService(this._transports, this._composeMod, this._settings);
  }
  teardown() {
    this._cloned.replaceWith(this._element);
  }
  openFileDialog(event) {
    event.stopPropagation();
    var hiddenFileInput = $('<input type="file" multiple>');
    hiddenFileInput.css('display', 'none');
    $(document.body).before(hiddenFileInput);
    hiddenFileInput.on('change', e => this.onFileAttached(e));
    hiddenFileInput.triggerNative('click');
  }
  async onFileAttached(event) {
    var _this$_composeMod, _this$_composeMod$att;
    const processedFiles = AttachmentUtil.processFilesMimeType(event.target.files);
    const securedAttacments = (_this$_composeMod = this._composeMod) === null || _this$_composeMod === void 0 ? void 0 : (_this$_composeMod$att = _this$_composeMod.attachmentsHelper) === null || _this$_composeMod$att === void 0 ? void 0 : _this$_composeMod$att._tdfAttachmentMods.length;
    const filesAmmount = securedAttacments + processedFiles.length;
    if (filesAmmount > ATTACHMENTS_LIMIT) {
      showAttachmentsLimitModal(filesAmmount);
    }
    const files = await AttachmentUtil.validateFileSize(processedFiles, this._settings.user, this._transports);
    if (files.length === 0) {
      return;
    }
    const policyConfigMenu = this._composeMod._policyConfigMenu;
    const isExpandedProtection = policyConfigMenu.isExpandedProtectionEnabled();
    const authorizations = PolicyAttributes.getAuthorizations(this._composeMod.getPolicyConfig());
    if (isExpandedProtection) {
      const canProceedFileUpload = await AttachmentUtil.canProceedLimitedEncryption(files, authorizations);
      if (!canProceedFileUpload) {
        return;
      }
    }
    var self = this;

    // mark the file for insertion at last known cursor position
    files.forEach(function (file) {
      file.doInsertAtCursorPosition = true;
    });
    self.emit('attachment-attached', files);
    const {
      isManaged
    } = this._composeMod._policyConfigMenu._policyModel;
    self._attachmentService.encryptAndUploadFiles(files, {
      isManaged,
      authorizations
    }, 'button').then(function (attachments) {
      self.emit('attach-secure', attachments.successful);
      self.emit('fail-attach-secure', attachments.failed.length);
    });
  }
}
Object.assign(AddAttachmentButtonMod.prototype, mods.ModWaiterPromises);
Object.assign(AddAttachmentButtonMod.prototype, mods.ModElementShortcut);
Object.assign(AddAttachmentButtonMod.prototype, mods.ModEventListenerShortcut);
Emitter(AddAttachmentButtonMod.prototype);
contexts.addOpen(AddAttachmentButtonMod);
exports.AddAttachmentButtonMod = AddAttachmentButtonMod;

/***/ }),

/***/ 4424:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _bindAllMethods: () => (/* binding */ _bindAllMethods)
/* harmony export */ });
const {
  _bindAllMethods
} = __webpack_require__(37605);


/***/ }),

/***/ 5421:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
const $ = __webpack_require__(55401);
const mods = __webpack_require__(25939);
const i18n = __webpack_require__(2622);
const tdf3Template = __webpack_require__(67563);
const Utils = __webpack_require__(55675);
const Popover = __webpack_require__(55929);
const contexts = __webpack_require__(47446);
const {
  PolicyAttributes
} = __webpack_require__(81722);
const AttachmentService = __webpack_require__(95727);
const AnalyticsService = (__webpack_require__(1246).instance)();
const RemoteContentService = __webpack_require__(20318);
const {
  SecureServiceProxy
} = __webpack_require__(6336);
const attachmentsUtils = (__webpack_require__(62769)/* ["default"] */ .Ay);
const PFPService = (__webpack_require__(82672).persistentProtection);
const {
  TDF3_EMAIL_MANIFEST_SELECTOR,
  TDF3_HTML_MANIFEST_SELECTOR,
  TDF3_HTML_PAYLOAD_SELECTOR,
  TDF3_TRANSFER_URL_SELECTOR
} = __webpack_require__(30893);
const {
  AUTHORIZATION_PERSISTENT_PROTECTION,
  AUTHORIZATION_WATERMARK
} = (__webpack_require__(42769).PolicyModel);

/**
 * Creates a new DownloadVirtruAttachmentMod around the download attachment
 * container element.
 *
 * @param settings Current users settings
 * @param element The download attachment container element
 * @param transports The service for downloading attachment data
 * @constructor
 */
class DownloadVirtruAttachmentMod extends mods.Mod {
  constructor(settings, element, transports) {
    super(settings, element);
    this._settings = settings;
    this._element = $(element);

    // In some cases the original forwarded email might have additional line breaks that need removed.
    $('br', element).remove();
    // The click to view text is local to secure-reader and implemented differently in BP
    // Forwarded secure-reader emails don't need this in BP
    $('div[class*=\'click-to-view-text\']', element).remove();
    var link = $('.virtru-attachment-link', element);
    this._previewLink = link.attr('href');
    this._attachmentId = link.attr('id');
    link.attr('href', '#');
    this._remoteContentLinkService = new RemoteContentService(null, null, null, null, null);
    this._attachmentService = new AttachmentService(transports, undefined, settings);
    this._secureService = SecureServiceProxy.create(transports);
    this._downloadFilename = $('.virtru-attachment-file-name', element).text();
    this._downloadFilename = this._downloadFilename.trim(); // Trim whitespace so we don't replace space at ends with dashes.

    // Special case if this is a file governed by an external policy
    this.isReattachedPfpFile = this._element.find('.virtru-reattached-preview-link').length > 0;
    this._reattachedPreviewLink = this._element.find('.virtru-reattached-preview-link').text();
    this.isReattachedTdf3Html = this._element.find(TDF3_EMAIL_MANIFEST_SELECTOR).length > 0;
    this.reattachedTransferUrl = this._element.find(TDF3_TRANSFER_URL_SELECTOR).val();
  }

  /**
   * Initializes the Mod.  This processes the file name then sets up
   * the shield icon and download original link.
   */
  setup({
    withPreviewIcons = true
  } = {}) {
    const userProfile = this._settings.user._profile;
    var $attachmentChip = this._element;
    if (Utils.isFeatureEnabled(userProfile, 'useAttachmentChipsV2')) {
      $attachmentChip.addClass('virtru-attachment-v2');
      $attachmentChip.attr('tabindex', '0');
      // disabled downloads and view buttons while contract is loaded
      $attachmentChip.addClass('virtru-attachment-disabled');
    } else {
      $attachmentChip.removeClass('virtru-attachment-v2');
    }

    // add download and preview icons
    //  (must happen before assigning $preview_button, $downloadIcon below)
    if (withPreviewIcons) {
      this.reskinElement();
    }
    const openInSR = e => this.openInSR(e);
    const configureClickEvents = ({
      $previewButton,
      contract
    }) => {
      const isExpandedWatermarked = contract.authorizations && contract.authorizations.includes(AUTHORIZATION_WATERMARK);
      const pfpEnabled = this.authorizations && this.authorizations.includes(PolicyAttributes.PERSISTENT_PROTECTION);
      const isPfpTdf3 = this.isReattachedTdf3Html && pfpEnabled;
      const notOwnedPfpFile = !this.isOwner && pfpEnabled && Utils.supportsExpandedWatermarking(this._downloadFilename);
      const shouldDoExpandedWatermark = isExpandedWatermarked && Utils.supportsExpandedWatermarking(this._downloadFilename);
      const shouldDoLegacyWatermark = this.isManaged && Utils.supportsLegacyWatermarking(this._downloadFilename);
      if (this.isReattachedPfpFile || isPfpTdf3 || notOwnedPfpFile) {
        $attachmentChip.on('click', this.isReattachedTdf3Html ? this.downloadTdf3Html.bind(this) : this.downloadPfp.bind(this));
        $previewButton.on('click', openInSR);
        // Differentiate managed pdf attachment vs (unmanaged OR managed non-pdf)
        // The owner of the file can always download
        // If expanded watermarking authorization is enabled is enabled
      } else if (!this.isOwner && (shouldDoExpandedWatermark || shouldDoLegacyWatermark)) {
        if ($attachmentChip.hasClass('virtru-attachment-v2')) {
          $previewButton.on('click', openInSR);
        } else {
          $attachmentChip.on('click', openInSR);
        }

        // extra styling for managed view
        $('.download_icon', $attachmentChip).hide();
        if (!Utils.isFeatureEnabled(userProfile, 'useAttachmentChipsV2')) {
          const title = isExpandedWatermarked ? i18n.t('EXPANDED_WATERMARKING_DL_DISABLED_TOOLTIP_TITLE') : i18n.t('ENHANCEDPDF_DL_DISABLED_TOOLTIP_TITLE');
          const tooltip = i18n.t('ENHANCEDPDF_DL_DISABLED_TOOLTIP');
          this._downloadButtonPopover = this.createPopover($attachmentChip, tooltip, title, 'south', 100);
        }
      } else {
        $attachmentChip.on('click', this.isReattachedTdf3Html ? this.downloadDecryptedTdf3.bind(this) : this.downloadOriginal.bind(this));
        $previewButton.on('click', openInSR);
        addPreviewButtonEvents($attachmentChip, $previewButton, this);
      }
    };
    const contractHandler = contract => {
      Object.assign(this, contract);
      $attachmentChip.removeClass('virtru-attachment-disabled');
      const pfpEnabled = this.authorizations && this.authorizations.includes(PolicyAttributes.PERSISTENT_PROTECTION);
      const isExpandedWatermarked = contract.authorizations && contract.authorizations.includes(AUTHORIZATION_WATERMARK);
      const $previewButton = $('.preview_icon_container', $attachmentChip);
      const isReattachedFile = this.isReattachedPfpFile || this.isReattachedTdf3Html;
      if ($attachmentChip.hasClass('virtru-attachment-v2')) {
        $attachmentChip.addClass(attachmentsUtils.attachmentExtensionClassName(this._downloadFilename, isReattachedFile, pfpEnabled, false, this.isReattachedTdf3Html));
      }
      configureClickEvents({
        $previewButton,
        contract
      });
      if (Utils.isFeatureEnabled(userProfile, 'useAttachmentChipsV2')) {
        const isSender = false;
        attachmentsUtils.createChipTooltip({
          $anchor: $attachmentChip,
          fileName: this._downloadFilename,
          authorizations: contract.authorizations,
          isReattachedPFPFile: this.isReattachedPfpFile,
          attachmentId: this._attachmentId,
          isManaged: contract.isManaged,
          isTdf3Html: this.isReattachedTdf3Html,
          isSender
        });
      }
      addChipHoverEvents($attachmentChip, $previewButton, isExpandedWatermarked, this);
    };
    return this.getContract().then(contractHandler).catch(e => {
      console.error(e.message);
      // Display an error state instead of the attachment chip
      if (Utils.isFeatureEnabled(userProfile, 'useAttachmentChipsV2')) {
        switch (e.name) {
          case 'AccessDisabled':
            $attachmentChip.addClass('revoked');
            $attachmentChip.find('.virtru-attachment-file-size').html('').attr('class', 'revoke-permissions-small-warning');
            attachmentsUtils.createRevokedTooltip($attachmentChip, this._attachmentId);
            break;
          default:
        }
      }
    });
  }
  openInSR(e) {
    e.stopPropagation();
    const fileType = Utils.getFileType(this.displayName);
    AnalyticsService.secureAttachmentPreviewed({
      isManaged: this.isManaged,
      isWatermarked: this.authorizations && this.authorizations.includes(AUTHORIZATION_WATERMARK),
      isPfpFile: this.authorizations && this.authorizations.includes(AUTHORIZATION_PERSISTENT_PROTECTION),
      fileType,
      isReattachedPfpFile: this.isReattachedPfpFile,
      'policy.Id': this.policyId
    });
    window.open(this._reattachedPreviewLink || this._previewLink);
  }
  reskinElement() {
    var element = this._element;
    var downloadIcon = createDownloadIcon(element);
    var previewIcon = createPreviewIcon(element);
    var decryptingContainer = `
    <div class="decrypting_container">
      <div class="decrypting_icon"></div>
      <div class="decrypting_text">${i18n.t('VIRTRU_ATTACHMENT_DECRYPTING')}</div>
    </div>
  `;
    var content = $('.virtru-attachment-content', element);
    content.append(downloadIcon);
    content.append(previewIcon);
    content.append(decryptingContainer);
    // remove elements we don't need on read
    $('.virtru-attachment-progress-bar', element).remove();
    $('.virtru-attachment-delete', element).remove();
    element.addClass('read_virtru-attachment');
  }
  teardown() {}
  getContract() {
    if (this.isReattachedTdf3Html) {
      return this._attachmentService.getTDF3originalFileInfo(this._element);
    }
    return this._attachmentService.getAttachmentContract(this._attachmentId, this.isReattachedPfpFile ? this._remoteContentLinkService.parseLink(this._reattachedPreviewLink) : '');
  }

  /**
   * Set watermark authorization on an attachment
   * @param {Boolean} isExpandedWatermarked True/False to add the authorization or not
   */
  setExpandedWatermarking(isExpandedWatermarked) {
    if (typeof isExpandedWatermarked !== 'boolean') {
      throw new Error('Wrong type for isExpandedWatermarked');
    }

    // Only apply for supported file types
    if (Utils.supportsExpandedWatermarking(this._downloadFilename)) {
      // Toggle the existence of the 'watermark' authorization
      const authorizations = this.authorizations.slice(0);
      if (isExpandedWatermarked && !authorizations.includes(AUTHORIZATION_WATERMARK)) {
        authorizations.push(AUTHORIZATION_WATERMARK);
      } else if (!isExpandedWatermarked && authorizations.includes(AUTHORIZATION_WATERMARK)) {
        authorizations.splice(authorizations.indexOf(AUTHORIZATION_WATERMARK), 1);
      }
      this._attachmentService.updateAttachmentPolicy(this.policyId, {
        simplePolicy: {
          authorizations
        }
      });
    }
  }

  /**
   * Set isManaged flag on an attachment
   * @param {Boolean} value True/False for isManaged
   */
  setIsManaged(isManaged) {
    if (typeof isManaged !== 'boolean') {
      throw new Error('Wrong type for isManaged');
    }

    // Currently we only want this to happen for PDFs
    if (Utils.supportsLegacyWatermarking(this._downloadFilename)) {
      this._attachmentService.updateAttachmentPolicy(this.policyId, {
        simplePolicy: {
          isManaged
        }
      });
    }
  }
  createPopover(anchor, text, title, position, showTimer) {
    var popover = new Popover(text, title);
    popover.classname += ' virtru-popover-dark virtru-popover-policy-config-offset';
    popover.position(position);
    popover.setShowTimer(showTimer);
    popover.attach(anchor);
    return popover;
  }

  // Determine the link used to preview the individual attachment in SR
  async getAttachmentRcaLink() {
    return new Promise((resolve, reject) => {
      const parsedPreviewLink = this._remoteContentLinkService.parseLink(this._previewLink);
      const baseUrl = this._previewLink.split('#')[0].split('?')[0];

      // NOTE: this returns a Q promise. Avoiding chaining it with native promises.
      this._secureService.downloadAndDecryptRemoteManifest(parsedPreviewLink.metadataUrl, parsedPreviewLink.metadataKey, parsedPreviewLink.metadataIv).then(response => {
        // retrieve attachment TDF from the parent email's remote manifest
        const attachmentTdo = response.attachments.filter(a => a.tdo && a.tdo.id === parsedPreviewLink.attachmentTdoId)[0];
        if (!attachmentTdo) {
          reject(new Error('Attachment tdo not found'));
        }
        // Construct a minimal URL with attachment TDF
        const attachmentRcaLink = RemoteContentService.generateAttachmentRcaLink(attachmentTdo.tdo, baseUrl);
        resolve(attachmentRcaLink);
      }).catch(reject);
    });
  }
  async downloadTdf3Html(event) {
    event.stopPropagation();
    event.preventDefault();
    this._element.addClass('decrypting');
    try {
      const {
        fullHtmlString,
        fileName
      } = await this._getTdf3Html();
      triggerDownload({
        href: getEmbededHref(fullHtmlString),
        fileName
      });
    } catch (err) {
      console.error(err);
    } finally {
      this._element.removeClass('decrypting');
    }
  }
  async downloadDecryptedTdf3(event) {
    event.stopPropagation();
    event.preventDefault();
    this._element.addClass('decrypting');
    try {
      const {
        fullHtmlString
      } = await this._getTdf3Html();
      const html = $('<div></div>').append(fullHtmlString);
      const payload = html.find(TDF3_HTML_PAYLOAD_SELECTOR).val();
      const originalFileLink = await this._secureService.readTdf3Payload(payload);
      triggerDownload({
        href: originalFileLink,
        fileName: this._downloadFilename
      });
    } catch (err) {
      console.error(err);
    } finally {
      this._element.removeClass('decrypting');
    }
  }
  async _getTdf3Html() {
    const tdo = await this._attachmentService.readSecureFile(this._attachmentId);
    const response = await fetch(tdo.file);
    const htmlString = await response.text();
    const html = $('<div></div>').append(htmlString);
    const manifest = html.find(TDF3_HTML_MANIFEST_SELECTOR).val();
    const payload = html.find(TDF3_HTML_PAYLOAD_SELECTOR).val();
    const {
      origin
    } = new URL(this.reattachedTransferUrl);
    const fullHtmlString = tdf3Template({
      transferUrl: this.reattachedTransferUrl,
      transferBaseUrl: origin,
      manifest,
      payload
    });
    return {
      fullHtmlString,
      fileName: tdo.contract.displayName
    };
  }

  /**
   * Handles the click event from Download PFP
   *
   * @param event
   */
  async downloadPfp(event) {
    console.debug('Download PFP...');
    // Prevent propagation of this event to the download link
    event.stopPropagation();
    event.preventDefault();
    const fileType = Utils.getFileType(this.displayName);
    AnalyticsService.secureAttachmentPressed({
      isManaged: this.isManaged,
      isWatermarked: this.authorizations && this.authorizations.includes(AUTHORIZATION_WATERMARK),
      isPfpFile: true,
      fileType,
      isReattachedPfpFile: this.isReattachedPfpFile,
      'policy.Id': this.policyId
    });
    try {
      let attachmentRcaLink = this._reattachedPreviewLink;
      if (!this.isReattachedPfpFile) {
        attachmentRcaLink = await this.getAttachmentRcaLink();
      }

      // Stick the SR preview link in the TDF.html template and download it via data URL
      const dataUrl = PFPService.generatePFPTemplateURL(attachmentRcaLink, this._downloadFilename, this.policyId, i18n.getCurrentLanguage());
      triggerDownload({
        href: dataUrl,
        fileName: `${this._downloadFilename}.tdf.html`
      });
      AnalyticsService.secureAttachmentDownloaded({
        isManaged: this.isManaged,
        isWatermarked: this.authorizations && this.authorizations.includes(AUTHORIZATION_WATERMARK),
        isPfpFile: false,
        isReattachedPfpFile: this.isReattachedPfpFile,
        fileType,
        'policy.Id': this.policyId
      });
    } catch (err) {
      console.error(err);
      AnalyticsService.clientError({
        context: 'Download PFP file',
        name: err.name,
        message: err.message
      });
    }
  }

  /**
   * Handles the click event from Download Original
   *
   * @param event
   */
  downloadOriginal(event) {
    console.debug('Download original...');
    // Prevent propagation of this event to the download link
    event.stopPropagation();
    event.preventDefault();
    this._element.addClass('decrypting');
    const fileType = Utils.getFileType(this.displayName);
    AnalyticsService.secureAttachmentPressed({
      isManaged: this.isManaged,
      isWatermarked: this.authorizations && this.authorizations.includes(AUTHORIZATION_WATERMARK),
      isPfpFile: false,
      fileType,
      'policy.Id': this.policyId
    });
    this._attachmentService.readSecureFile(this._attachmentId).then(response => {
      var $a = $('<a>', {
        download: this._downloadFilename,
        href: response.file,
        style: 'display: none;'
      });
      $(document.body).before($a);
      $a.triggerNative('click');
      AnalyticsService.secureAttachmentDownloaded({
        isManaged: this.isManaged,
        isWatermarked: this.authorizations && this.authorizations.includes(AUTHORIZATION_WATERMARK),
        isPfpFile: false,
        fileType,
        'policy.Id': this.policyId
      });
    }).finally(() => {
      this._element.removeClass('decrypting');
    });
  }
}

/**
 * Make href for download from stingified data
 *
 * @param data {String}
 * @return href {String}
 */
const getEmbededHref = data => `data:application/octet-stream;charset=utf-8;base64,${btoa(data)}`;
const triggerDownload = ({
  href,
  fileName
}) => {
  const $a = $('<a>', {
    download: fileName,
    href,
    style: 'display: none;'
  });
  $(document.body).before($a);
  $a.triggerNative('click');
  $a.remove();
};
Object.assign(DownloadVirtruAttachmentMod.prototype, mods.ModWaiterPromises);
Object.assign(DownloadVirtruAttachmentMod.prototype, mods.ModElementShortcut);
Object.assign(DownloadVirtruAttachmentMod.prototype, mods.ModEventListenerShortcut);
contexts.addOpen(DownloadVirtruAttachmentMod);

/**
 * Function for add events for hover preview button for old version
 * @param $attachmentChip
 * @param $previewButton
 * @param context
 */
function addPreviewButtonEvents($attachmentChip, $previewButton, context) {
  if (!$attachmentChip.hasClass('virtru-attachment-v2')) {
    var previewMouseEnter = e => {
      e.stopPropagation();

      // The stop propagation prevents it from hiding which can cause it to
      // stick even when you close that email out.
      context._downloadButtonPopover && context._downloadButtonPopover.hide();
      $previewButton.addClass('preview-hover');
      $attachmentChip.removeClass('download-hover');
    };
    var previewMouseLeave = e => {
      e.stopPropagation();
      $previewButton.removeClass('preview-hover');
      if ($attachmentChip[0].contains(e.toElement)) {
        $attachmentChip.addClass('download-hover');
      } else {
        $attachmentChip.removeClass('download-hover');
      }
    };
    $previewButton.on('focus', previewMouseEnter);
    $previewButton.on('mouseenter', previewMouseEnter);
    $previewButton.on('blur', previewMouseLeave);
    $previewButton.on('mouseleave', previewMouseLeave);
  }
}

/**
 * Function for add event for hover chip for old version
 * @param $attachmentChip
 * @param $previewButton
 * @param isExpandedWatermarked
 * @param context
 */
function addChipHoverEvents($attachmentChip, $previewButton, isExpandedWatermarked, context) {
  if (!$attachmentChip.hasClass('virtru-attachment-v2')) {
    $attachmentChip.on('mouseenter', () => {
      $attachmentChip.addClass('download-hover');
      if (context.isManaged || isExpandedWatermarked) {
        $previewButton.addClass('preview-hover');
      }
    });
    $attachmentChip.on('mouseleave', () => {
      $attachmentChip.removeClass('download-hover');
      if (context.isManaged || isExpandedWatermarked) {
        $previewButton.removeClass('preview-hover');
      }
    });
  }
}

/**
 * Create html of download button with text or without text by version
 * @param $element
 * @returns {string}
 */
function createDownloadIcon($element) {
  return $element.hasClass('virtru-attachment-v2') ? `<div class="download_icon" role="button" tabindex="0">${i18n.t('VIRTRU_ATTACHMENT_DOWNLOAD')}</div>` : '<div class="download_icon"></div>';
}

/**
 * Create html of preview button with text or with icon by version
 * @param $element
 * @returns {string}
 */
function createPreviewIcon($element) {
  return $element.hasClass('virtru-attachment-v2') ? `<div class="preview_icon_container" role="button" tabindex="0">${i18n.t('VIRTRU_ATTACHMENT_VIEW')}</div>` : '<div class="preview_icon_container"><div class="preview_icon"></div></div>';
}
exports.DownloadVirtruAttachmentMod = DownloadVirtruAttachmentMod;

/***/ }),

/***/ 5749:
/***/ ((module, exports, __webpack_require__) => {

const i18n = __webpack_require__(2622);
const {
  invitationEmailReplace
} = __webpack_require__(67650);
const {
  limitedEncryptionPopover
} = __webpack_require__(42825);
const {
  animationWidget
} = __webpack_require__(2688);
const {
  readActivation
} = __webpack_require__(89650);
const {
  attachmentSection
} = __webpack_require__(8854);
const {
  promoFooter
} = __webpack_require__(80952);
const {
  footerPopover
} = __webpack_require__(55258);
const {
  emailTemplateSender
} = __webpack_require__(83956);
const {
  emailTemplateReceiver
} = __webpack_require__(83804);
const {
  messageIntegrityError
} = __webpack_require__(23871);
const {
  warningPopoverModal
} = __webpack_require__(65001);
const {
  virtruNewFeatureTipPopover
} = __webpack_require__(81143);
const {
  sendAnimation
} = __webpack_require__(48864);
const {
  newComposeEditor
} = __webpack_require__(55302);
const {
  newComposeActivation
} = __webpack_require__(73667);
const {
  virtruOnboardingV2
} = __webpack_require__(56062);
const {
  virtruTourRestart
} = __webpack_require__(23832);
const {
  virtruTourV2
} = __webpack_require__(58927);
const compile = (template, options = {}) => {
  i18n.syncCurrentLanguage();
  return template(options);
};
const Templates = {
  invitationEmailReplace: options => compile(invitationEmailReplace, options),
  limitedEncryptionPopover: options => compile(limitedEncryptionPopover, options),
  animationWidget: options => compile(animationWidget, options),
  readActivation: options => compile(readActivation, options),
  attachmentSection: options => compile(attachmentSection, options),
  promoFooter: options => compile(promoFooter, options),
  footerPopover: options => compile(footerPopover, options),
  emailTemplateSender: options => compile(emailTemplateSender, options),
  emailTemplateReceiver: options => compile(emailTemplateReceiver, options),
  messageIntegrityError: options => compile(messageIntegrityError, options),
  warningPopoverModal: options => compile(warningPopoverModal, options),
  virtruNewFeatureTipPopover: options => compile(virtruNewFeatureTipPopover, options),
  sendAnimation: options => compile(sendAnimation, options),
  newComposeEditor: options => compile(newComposeEditor, options),
  newComposeActivation: options => compile(newComposeActivation, options),
  virtruOnboardingV2: options => compile(virtruOnboardingV2, options),
  virtruTourRestart: options => compile(virtruTourRestart, options),
  virtruTourV2: options => compile(virtruTourV2, options)
};
module.exports = exports = Templates;

/***/ }),

/***/ 6336:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Emitter = __webpack_require__(16502);
const {
  Binary
} = __webpack_require__(52938);
const blobUtil = __webpack_require__(25235);

/**
 * Proxies the commands for the secure service proxy.
 *
 * This is necessary for page scripts in the browser extension
 */
function SecureServiceProxy(transports) {
  this._transports = transports;
}
Emitter(SecureServiceProxy.prototype);
SecureServiceProxy.create = function (transports) {
  return new SecureServiceProxy(transports);
};
SecureServiceProxy.prototype.makeMessage = function (message, policyOptions, options) {
  return this.callTransport('makeSecureMessage', {
    message,
    policyOptions,
    options
  });
};
SecureServiceProxy.prototype.makeSecureDraft = function (message, policyOptions, options) {
  return this.callTransport('makeSecureDraft', {
    message,
    policyOptions,
    options
  });
};
SecureServiceProxy.prototype.isFeatureEnabled = function (featureName) {
  return this.callTransport('isFeatureEnabled', {
    featureName
  });
};
SecureServiceProxy.prototype.closeDraft = function (composeId) {
  return this.callTransport('closeDraft', {
    composeId
  });
};
SecureServiceProxy.prototype.readMessage = function (secureMessage, remoteContentLink, options) {
  return this.callTransport('readSecureMessage', {
    secureMessage,
    remoteContentLink,
    options
  }).then(async result => {
    const {
      payload
    } = result.tdf;
    result.tdf.payload = new Binary(payload._data, payload._type);
    result.message = result.tdf.payload.asString();
    return result;
  });
};
SecureServiceProxy.prototype.restoreDraft = function (composeId, secureMessage) {
  return this.callTransport('restoreDraft', {
    composeId,
    secureMessage
  });
};
SecureServiceProxy.prototype.forwardMessages = function (secureMessages, newEmailUsers) {
  return this.callTransport('forwardMessages', {
    newEmailUsers,
    secureMessages
  });
};
SecureServiceProxy.prototype.generateSearchTokens = function (content, key) {
  const options = {
    content,
    key
  };
  return this.callTransport('generateSearchTokens', options);
};
SecureServiceProxy.prototype.buildSearchTokenQuery = function (content, key) {
  const options = {
    content,
    key
  };
  return this.callTransport('buildSearchTokenQuery', options);
};

/**
 * Creates a TDF Zip file using the file passed in.
 *
 * @param {Binary} file The file as a {Binary}.
 * @param filename The file name.
 * @param policyOptions The policy options for the file.
 *
 * @returns {Object} An object containing:
 * {
 *    {Binary} file: The file as a {Binary},
 *    {String} policyUUID: The UUID identifier of the policy for the file
 * }
 */
SecureServiceProxy.prototype.makeFile = function (file, filename, mimeType, policyOptions, options) {
  const params = {
    file,
    filename,
    mimeType,
    policyOptions,
    options
  };
  return this._transportFile('makeSecureFile', params);
};

/**
 *
 */
SecureServiceProxy.prototype.downloadAndDecryptRemoteManifest = function (metadataUrl, metadataKey, metadataIv) {
  const params = {
    metadataUrl,
    metadataKey,
    metadataIv
  };
  return this.callTransport('downloadAndDecryptRemoteManifest', params);
};

/**
 *
 */
SecureServiceProxy.prototype.createTdfDataFromPreviewLink = function (previewLink) {
  const params = {
    previewLink
  };
  return this.callTransport('createTdfDataFromPreviewLink', params);
};

/**
 * Reads a TDF Zip file and returns the unencrypted version
 * if the owner has access.
 *
 * @param {String} attachmentId The attachment ID.
 *
 * @returns {Object} An object containing:
 * {
 *    {Binary} file: The file as a {Binary},
 *    {String} filename: The file name
 * }
 */
SecureServiceProxy.prototype.readFile = function (attachmentId, userId) {
  const params = {
    userId,
    attachmentId
  };
  return this.callTransport('readSecureFile', params);
};

/**
 * Reads a TDF Zip file and returns the unencrypted version
 * if the owner has access.
 *
 * @param {String} fileUrl The URL to the file.
 *
 * @returns {Object} An object containing:
 * {
 *    {Binary} file: The file as a {Binary},
 *    {String} filename: The file name
 * }
 */
SecureServiceProxy.prototype.readStandaloneFile = async function (fileUrl) {
  var options = {
    fileUrl
  };
  const result = await this.callTransport('read-secure-standalone-file', options);
  const binary = await blobUtil.blobUriToBinary(params.file); // eslint-disable-line
  response.file = blobUtil.binaryToBlobUri(binary); // eslint-disable-line

  return result;
};
SecureServiceProxy.prototype.secureRemoteFile = function (file, policyOptions, options) {
  return new Promise((resolve, reject) => {
    const params = {
      file,
      policyOptions,
      options
    };
    this.callTransport('secure-remote-file', params).then(function (response) {
      resolve(response);
    }).catch(reject);
  });
};
SecureServiceProxy.prototype._transportFile = function (method, options) {
  return new Promise((resolve, reject) => {
    this.callTransport(method, options).then(response => {
      resolve(response);
    }).catch(reject);
  });
};

// NOTE: TDO is optional
SecureServiceProxy.prototype.getContract = function (attachmentId, parsedPreviewLink) {
  return this.callTransport('getContract', {
    attachmentId,
    parsedPreviewLink
  });
};
SecureServiceProxy.prototype.getTDF3htmlFileInfo = function ({
  policyId,
  userId
}) {
  return this.callTransport('getTDF3htmlFileInfo', {
    policyId,
    userId
  });
};
SecureServiceProxy.prototype.updatePolicy = function (uuid, policyUpdates) {
  return this.callTransport('updatePolicy', {
    uuid,
    policyUpdates
  });
};

/**
 * Returns decrypted tdf3 payload as binary
 *
 * @param payload {string} base64.
 *
 * @returns {Binary} file: The file as a {Binary}
 */
SecureServiceProxy.prototype.readTdf3Payload = async function (payload) {
  const payloadBinary = blobUtil.b64ToBinary(payload);
  const payloadUrl = blobUtil.binaryToBlobUri(payloadBinary);
  const {
    fileLink
  } = await this.callTransport('read-secure-standalone-tdf3-file', payloadUrl);
  return fileLink;
};
SecureServiceProxy.prototype.revokePolicy = function (uuid) {
  return this.callTransport('revokePolicy', {
    uuid
  });
};
SecureServiceProxy.prototype.enablePolicy = function (uuid) {
  return this.callTransport('enablePolicy', {
    uuid
  });
};
SecureServiceProxy.prototype.forwardPolicies = function (uuids, newEmailUsers, associatedAttachmentIds) {
  return this.callTransport('forwardPolicies', {
    uuids,
    newEmailUsers,
    associatedAttachmentIds
  });
};
SecureServiceProxy.prototype.generateKeyPair = function () {
  return this.callTransport('generateKeyPair');
};

/**
 * Generate and store a public/private key pair
 *
 * @param  {String} userId    - User's ID
 * @return {Promise<Boolean>} - Indication of success
 */
SecureServiceProxy.prototype.generateAndStoreKeyPair = function (userId) {
  return this.callTransport('generateAndStoreKeyPair', userId);
};
SecureServiceProxy.prototype.emitRevocation = function (revocation) {
  this.emit('revocation', revocation);
};
SecureServiceProxy.prototype.callTransport = function (method, params) {
  return this._transports.call('content', method, params);
};
exports.SecureServiceProxy = SecureServiceProxy;

/***/ }),

/***/ 6699:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var Emitter = __webpack_require__(16502);
function ConnectionEventRouter(router) {
  this.router = router;
  this.initEvents();
}

/**
 * Events:
 *   offline - Raised when the content script informs us we've lost the connection
 *   offline-lease-started - When the lease time starts
 *   offline-lease-expired - When the lease timer expires
 *   online - When the connection is restored
 */
Emitter(ConnectionEventRouter.prototype);
ConnectionEventRouter.prototype.initEvents = function () {
  var self = this;
  this.router.register('offline', function (params, res) {
    self.emit('offline');
    res.send(null);
  });
  this.router.register('offline-lease-started', function (params, res) {
    self.emit('offline-lease-started');
    res.send(null);
  });
  this.router.register('offline-lease-expired', function (params, res) {
    self.emit('offline-lease-expired');
    res.send(null);
  });
  this.router.register('online', function (params, res) {
    self.emit('online');
    res.send(null);
  });
};
exports.ConnectionEventRouter = ConnectionEventRouter;

/***/ }),

/***/ 7020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = [__webpack_require__(25281), __webpack_require__(33560)];

/***/ }),

/***/ 7709:
/***/ ((__unused_webpack_module, exports) => {

/**
 * ContextManager mixin
 */
var ContextManager = {
  _contexts() {
    this.__contexts = this.__contexts || [];
    return this.__contexts;
  },
  register(context, type) {
    type = type || 'default';
    var contexts = this._contexts();
    contexts.push([context, type]);
  },
  teardownAll() {
    var customTeardown = this.teardown || function () {};
    customTeardown.call(this);
    var contexts = this._contexts();
    contexts.forEach(function (contextTuple) {
      var context = contextTuple[0];
      context.teardownAll();
    });
  },
  teardownTypes(types) {
    var contexts = this._contexts();
    contexts.forEach(function (contextTuple) {
      var context = contextTuple[0];
      var type = contextTuple[1];
      if (types.indexOf(type) !== -1) {
        context.teardownAll();
      }
    });
  }
};
exports.ContextManager = ContextManager;

/**
 * Context Factory Method Builder
 */
function addOpen(cls) {
  cls.open = function (...args) {
    const context = new cls(...args);
    // Run the entire setup
    context.setupAll();
    return context;
  };
}
exports.addOpen = addOpen;
var defaultContextOptions = {
  setup() {},
  teardown() {}
};
function Context(options) {
  this.options = Object.assign({}, defaultContextOptions, options);
}
Context.prototype.setupAll = function () {
  this.options.setup();
};
Context.prototype.teardownAll = function () {
  this.options.teardown();
};
addOpen(Context);
exports.Context = Context;

/***/ }),

/***/ 8561:
/***/ ((module) => {

/**
 * Emit `event` with the given args and allow
 * the event to be canceled.  In some circumstances
 * a listener of an event may want to signal to the
 * emitter to cancel the event.  This function allows
 * that to happen.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Boolean} Returns false if canceled
 */

module.exports.Q = function (event) {
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1);
  var callbacks = this._callbacks[event];
  if (callbacks && callbacks.length) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      var result = callbacks[i].apply(this, args);
      result = result === undefined ? true : result;
      if (!result) {
        return false;
      }
    }
  }
  return true;
};

/***/ }),

/***/ 8854:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   attachmentSection: () => (/* binding */ attachmentSection)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const attachmentSection = () => `
  <div class="virtru-attachment-section" contentEditable="false">
    <hr class="virtru-attachment-divider" />
    <div class="virtru-attachment-section-header" role="region" tabIndex="0" aria-labelledby="virtru-attachment-section-info-label">
      <span class="virtru-attachment-section-header-text" id="virtru-attachment-section-info-label"></span>
      <a class="virtru-attachment-section-info" role="button" href="javascript: void(0);" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SECURE_ATTACHMENT_INFO')}"></a>
    </div>
  </div>
`;

/***/ }),

/***/ 8904:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const Emitter = __webpack_require__(16502);
const $ = __webpack_require__(91089);
const AnalyticsService = (__webpack_require__(1246).instance)();

/**
 * Apply the average use-case of simply
 * showing a tool-tip on `el` hover.
 *
 * Options:
 *
 *  - `delay` hide delay in milliseconds [0]
 *  - `value` defaulting to the element's title attribute
 *
 * @param {Mixed} el
 * @param {Object|String} options or value
 * @api public
 */

function tip(el, options) {
  if (typeof options === 'string') {
    options = {
      value: options
    };
  }
  options = options || {};
  var {
    delay
  } = options;
  $(el).each(function (i, el) {
    el = $(el);
    var val = options.value || el.attr('title');
    var tip = new Tip(val);
    el.attr('title', '');
    tip.cancelHideOnHover(delay);
    tip.attach(el, delay);
  });
}

/**
 * Initialize a `Tip` with the given `content`.
 *
 * @param {Mixed} content
 * @api public
 */

class Tip extends Emitter {
  constructor(content, options) {
    super();
    if (!(this instanceof Tip)) {
      return tip(content, options);
    }
    this.classname = '';
    this.el = $(__webpack_require__(87224));
    this.inner = this.el.find('.tip-inner');
    Tip.prototype.message.call(this, content);
    this.position('south');
    this.defaultPosition('south');
    if (Tip.effect) {
      this.effect(Tip.effect);
    }
  }

  /**
   * Make with suggested position
   *
   *  - `north`
   *  - `south`
   *  - `east`
   *  - `west`
   *
   * @api private
   */
  static makePositionWithSuggested(position, suggestedPosition) {
    const unsupportedPositions = ['westeast'];
    position = position.concat(suggestedPosition);
    return unsupportedPositions.indexOf(position) < 0 ? position : undefined;
  }

  /**
   * Set tip `content`
   *
   * @param {String|jQuery|Element} content
   * @return {Tip} self
   * @api public
   */
  message(content) {
    if (typeof content === 'string') {
      this.inner.empty().text(content); // escape potentially dangerous strings
    } else {
      this.inner.empty().append(content);
    }
    return this;
  }

  /**
   * Attach to the given `el` with optional hide `delay`.
   *
   * @param {Element} el
   * @param {Number} delay
   * @return {Tip}
   * @api public
   */
  attach(el, delay) {
    var self = this;
    $(el).hover(function () {
      self.show(el);
      self.cancelHide();
    }, function () {
      self.hide(delay);
    });
    return this;
  }

  /**
   * Cancel hide on hover, hide with the given `delay`.
   *
   * @param {Number} delay
   * @return {Tip}
   * @api public
   */
  cancelHideOnHover(delay) {
    this.el.hover(this.cancelHide.bind(this), this.hide.bind(this, delay));
    return this;
  }

  /**
   * Set the effect to `type`.
   *
   * @param {String} type
   * @return {Tip}
   * @api public
   */
  effect(type) {
    this._effect = type;
    this.el.addClass(type);
    return this;
  }

  /**
   * Set position:
   *
   *  - `north`
   *  - `north east`
   *  - `north west`
   *  - `south`
   *  - `south east`
   *  - `south west`
   *  - `east`
   *  - `west`
   *
   * @param {String} pos
   * @param {Object} options
   * @return {Tip}
   * @api public
   */
  position(pos, options) {
    options = options || {};
    this._position = pos;
    this._auto = options.auto !== false;
    this.replaceClass(pos);
    return this;
  }

  /**
   * Set default position:
   *
   *  - `north`
   *  - `north east`
   *  - `north west`
   *  - `south`
   *  - `south east`
   *  - `south west`
   *  - `east`
   *  - `west`
   *
   * @param {String} pos
   * @return {Tip}
   * @api public
   */
  defaultPosition(pos) {
    this._defaultPposition = pos;
    return this;
  }

  /**
   * Show the tip attached to `el`.
   *
   * Emits "show" (el) event.
   *
   * @param {jQuery|Element} el or x
   * @param {Number} [y]
   * @return {Tip}
   * @api public
   */
  show(el) {
    // show it
    this.target = $(el);
    this.el.appendTo('body');
    this.el.addClass(`tip-${this._position}`);
    this.el.removeClass('tip-hide');

    // x,y
    if (typeof el === 'number') {
      var x = arguments[0];
      var y = arguments[1];
      this.emit('show');
      this.el.css({
        top: y,
        left: x
      });
      return this;
    }

    // el
    this.target = $(el);
    this.reposition();
    this.emit('show', this.target);
    this._reposition = this.reposition.bind(this);
    $(window).bind('resize', this._reposition);
    $(window).bind('scroll', this._reposition);
    return this;
  }

  /**
   * Reposition the tip if necessary.
   *
   * @api private
   */
  reposition() {
    var pos = this._position;
    var off = this.offset(pos);
    var suggestedPosition = undefined;
    var position = '';
    // limit repositioning to two iterations
    for (var i = 0; i < 2; i++) {
      suggestedPosition = this.suggested(pos, this.offset(pos));
      // if there is a suggested position add that to the popover position
      if (suggestedPosition !== undefined) {
        position = Tip.makePositionWithSuggested(position, suggestedPosition) || this._defaultPposition;
        pos = suggestedPosition;
        off = this.offset(pos = position);
      }
    }
    this.replaceClass(pos);
    this.el.css(off);
  }

  /**
   * Compute the "suggested" position favouring `pos`.
   * Returns undefined if no suggestion is made.
   *
   * @param {String} pos
   * @param {Object} off
   * @return {String}
   * @api private
   */
  suggested(pos, off) {
    var el = this.el; //eslint-disable-line
    var ew = el.outerWidth();
    var eh = el.outerHeight();
    var win = $(window);
    var top = win.scrollTop();
    var left = win.scrollLeft();
    var w = win.width();
    var h = win.height();

    // too high
    if (off.top < top) {
      return 'north';
    }

    // too low
    if (off.top + eh > top + h) {
      return 'south';
    }

    // too far to the right
    if (off.left + ew > left + w) {
      return 'east';
    }

    // too far to the left
    if (off.left < left) {
      return 'west';
    }
  }

  /**
   * Replace position class `name`.
   *
   * @param {String} name
   * @api private
   */
  replaceClass(name) {
    name = name.split(' ').join('-');
    this.el.attr('class', `${this.classname} tip tip-${name} ${this._effect}`);
  }

  /**
   * Compute the offset for `.target`
   * based on the given `pos`.
   *
   * @param {String} pos
   * @return {Object}
   * @api private
   */
  offset(pos) {
    const tipShift = 26;
    const padding = 15;
    const element = this.el;
    const target = this.target instanceof $ ? this.target[0] : this.target;
    const elementWidth = element.outerWidth();
    const elementHeight = element.outerHeight();

    // calculate the offset, taking iFrames into account
    const targetPosition = {
      top: 0,
      left: 0
    };
    const dimensions = target.getBoundingClientRect();
    targetPosition.top += dimensions.top;
    targetPosition.left += dimensions.left;
    const targetWidth = this.target.outerWidth();
    const targetHeight = this.target.outerHeight();
    let leftOffset;
    const positionsMap = {
      south: () => {
        leftOffset = targetPosition.left + targetWidth / 2 - elementWidth / 2;
        return {
          top: targetPosition.top - elementHeight,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      northwest: () => {
        leftOffset = targetPosition.left + targetWidth / 2 - padding - tipShift;
        return {
          top: targetPosition.top + targetHeight + padding,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      northMiddleWest: () => {
        leftOffset = targetPosition.left - padding * 5;
        return {
          top: targetPosition.top + targetHeight + padding,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      northeast: () => {
        leftOffset = targetPosition.left + targetWidth / 2 + padding - elementWidth + tipShift;
        return {
          top: targetPosition.top + targetHeight + padding,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      north: () => {
        leftOffset = targetPosition.left + targetWidth / 2 - elementWidth / 2;
        return {
          top: targetPosition.top + targetHeight,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      southwest: () => {
        leftOffset = targetPosition.left + targetWidth / 2 - padding - tipShift;
        return {
          top: targetPosition.top - elementHeight,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      southeast: () => {
        leftOffset = targetPosition.left + targetWidth / 2 - elementWidth + padding + tipShift;
        return {
          top: targetPosition.top - elementHeight,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      },
      west: () => ({
        top: targetPosition.top + targetHeight / 2 - elementHeight / 2,
        left: targetPosition.left + targetWidth
      }),
      east: () => ({
        top: targetPosition.top + targetHeight / 2 - elementHeight / 2,
        left: targetPosition.left - elementWidth
      }),
      westAlignTop: () => ({
        top: targetPosition.top,
        left: targetPosition.left + targetWidth + padding
      }),
      southAlignRight: () => {
        leftOffset = targetPosition.left + targetWidth - elementWidth;
        return {
          top: targetPosition.top - elementHeight - padding,
          left: leftOffset >= 0 ? leftOffset : 0
        };
      }
    };
    const targetPositionFunc = positionsMap[pos];
    if (!targetPositionFunc) {
      AnalyticsService.popoverInvalidPosition({
        position: pos
      });
      throw new Error(`invalid position "${pos}"`);
    }
    return positionsMap[pos]();
  }

  /**
   * Cancel the `.hide()` timeout.
   *
   * @api private
   */
  cancelHide() {
    clearTimeout(this._hide);
  }

  /**
   * Hide the tip with optional `ms` delay.
   *
   * Emits "hide" event.
   *
   * @param {Number} ms
   * @return {Tip}
   * @api public
   */
  hide(ms) {
    var self = this;

    // duration
    if (ms) {
      this._hide = setTimeout(this.hide.bind(this), ms);
      return this;
    }

    // hide
    this.el.addClass('tip-hide');
    if (this._effect) {
      setTimeout(this.remove.bind(this), 300);
    } else {
      self.remove();
    }
    return this;
  }

  /**
   * Hide the tip without potential animation.
   *
   * @return {Tip}
   * @api
   */
  remove() {
    $(window).unbind('resize', this._reposition);
    $(window).unbind('scroll', this._reposition);
    this.emit('hide');
    this.el.detach();
    return this;
  }
}

/**
 * Expose `Tip`.
 */

module.exports = Tip;

/***/ }),

/***/ 9135:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   G: () => (/* binding */ CksError)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87568);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64078);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(33632);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lib_constants_errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(22592);
/* harmony import */ var _lib_constants_errors__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lib_constants_errors__WEBPACK_IMPORTED_MODULE_3__);
/**
 * Virtru Email Template for a Customer Key Server Error
 */






/**
 * @deprecated Use the `CksError.render` method to render the component
 * @remarks Exported for testing purposes only
 */
function CksError({
  error
}) {
  const renderHeader = () => {
    const err = error.name || error;
    if (err === (_lib_constants_errors__WEBPACK_IMPORTED_MODULE_3___default().COMPROMISED_KEY_ERROR)) {
      return _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('CANNOT_DECRYPT_MESSAGE_CKS_TROUBLE_READING_EMAIL');
    }
    return _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('CANNOT_DECRYPT_HEADER');
  };
  const renderMessage = () => _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('CANNOT_DECRYPT_MESSAGE_CKS', error && error.details || {});
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "vcks-icon"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "vcks-header"
  }, renderHeader()), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "vcks-message"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    dangerouslySetInnerHTML: {
      __html: renderMessage()
    }
  }))));
}
CksError.propTypes = {
  error: prop_types__WEBPACK_IMPORTED_MODULE_4___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_4___default().string), (prop_types__WEBPACK_IMPORTED_MODULE_4___default().object)]).isRequired
};

/**
 * Render the CksError component
 *
 * @param {HTMLElement} siblingElement HTML DOM element to render the component before
 * @param {{ error: string | Error }} props - props used to render the component
 * @param props.error - Error message string or Error object
 *
 * @todo Remove this method once jQuery and React are no longer used together
 */
CksError.render = function (siblingElement, props) {
  // create component container
  const container = document.createElement('div');
  container.className = 'virtru-cks-error-template';

  // add container to DOM before sibling element
  siblingElement.parentNode.insertBefore(container, siblingElement);

  // render component
  const root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__/* .createRoot */ .H)(container);
  root.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(CksError, props));
};

/***/ }),

/***/ 9463:
/***/ ((module) => {

"use strict";
module.exports = "<div class=\"virtru-toggle no-outline\" tabindex=\"0\" aria-label=\"<%= i18n.t('SCREENREADER_VIRTRU_SECURE_TOGGLE') %>\" role=\"button\">\n  <div class=\"virtru-slider\">\n    <div class=\"virtru-slider-handle\">&nbsp;</div>\n  </div>\n  <div class=\"virtru-overlay\">&nbsp;</div>\n</div>\n";

/***/ }),

/***/ 9531:
/***/ ((__unused_webpack_module, exports) => {

function ModCollection(mods) {
  this._mods = mods || [];
}
ModCollection.prototype.open = function (ModClass, args) {
  var mod = ModClass.open.apply(null, [args]);
  this._mods.push(mod);
};
ModCollection.prototype.add = function (mod) {
  this._mods.push(mod);
};
ModCollection.prototype.each = function (callback) {
  this._mods.forEach(function (mod) {
    callback.apply(null, [mod]);
  });
};
ModCollection.prototype.updateSettings = function (settings) {
  this.each(function (mod) {
    mod.updateSettings(settings);
  });
};
ModCollection.prototype.extend = function (mods) {
  this._mods.push.apply(this._mods, mods);
};
ModCollection.prototype.length = function () {
  return this._mods.length;
};
ModCollection.prototype.clean = function () {
  var index = 0;
  var counter = 0;
  var loops = this.length();
  var mods = this._mods;
  while (counter < loops) {
    var mod = mods[index];
    if (!mod.isAlive()) {
      // Clean Up
      mods.splice(index, 1);
      mod.teardownAll();
    } else {
      // Increment the index
      index += 1;
    }
    // Always increment the counter
    counter += 1;
  }
};
exports.ModCollection = ModCollection;

/***/ }),

/***/ 10086:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
var Guard = __webpack_require__(57128);
var Utils = __webpack_require__(55675);
const {
  _bindAllMethods
} = __webpack_require__(4424);
function AnalyticsBackgroundRouter(router, transports) {
  this.router = router;
  this.transports = transports;
  _bindAllMethods(this);
}
AnalyticsBackgroundRouter.prototype.register = function () {
  var self = this;

  // Handles all routed actions
  this.router.register('analytics-track', function (params) {
    if (self.userProfile) {
      if (!self.userProfile.settings.preferences.sendUsageData) {
        // Do not send metrics if `sendUsageData` is off
        return;
      }
      params.properties.userId = self.userProfile.userId;
    }
    console.debug(`(Amplitude Event) ${params.method}: `, params.properties);

    // Format any error so it can cross message boundaries
    var {
      properties
    } = params;
    Object.keys(properties).forEach(key => {
      properties[key] = Utils.formatForTransport(properties[key]);
    });
    self.callBackground('analytics-track', params);
  });

  // Handles all routed actions
  this.router.register('analytics-identify', function (params) {
    self.callBackground('analytics-identify', params);
  });

  // Handles the query for methods
  this.router.register('analytics-methods', function (params, res) {
    self.callBackground('analytics-methods', params).then(function (methods) {
      res.send(null, methods);
    });
  });
};
AnalyticsBackgroundRouter.prototype.setUser = function (userProfile) {
  Guard.checkIsObject(userProfile, 'userProfile');
  this.userProfile = userProfile;

  // Get sendUsageData from user pref. Else fallback to AnalyticsService default
  var {
    sendUsageData
  } = userProfile.settings.preferences;

  // Craft console message regarding sendUsageData
  var message = '%c';
  message += `Amplitude analytics toggled ${sendUsageData ? 'ON.' : 'OFF.'}`;

  // Style console message regarding sendUsageData
  var args = [message];
  var styles = 'font-size: 12px;';
  styles += 'font-weight: bold;';
  styles += 'font-family: courier;';
  styles += 'color: red;';
  args = args.concat(styles);
  console.log.apply(console, args);
};
AnalyticsBackgroundRouter.prototype.callBackground = function (command, params) {
  return this.transports.call('background', command, params);
};
module.exports = AnalyticsBackgroundRouter;

/***/ }),

/***/ 11741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var {
  MessageMod
} = __webpack_require__(70815);
var {
  NewComposerMod
} = __webpack_require__(16415);
var {
  NewComposeInsertPhotosMod
} = __webpack_require__(56282);
var {
  OnboardingMod
} = __webpack_require__(67688);
var {
  OnboardingTourMod
} = __webpack_require__(44883);
var NewFeatureNotification = __webpack_require__(60578);
var {
  PopoutListenerFeature
} = __webpack_require__(75451);
exports.main = [MessageMod, NewComposerMod, NewComposeInsertPhotosMod, NewFeatureNotification, OnboardingMod, OnboardingTourMod, (__webpack_require__(97411)/* ["default"] */ .A), __webpack_require__(66527), __webpack_require__(57500), __webpack_require__(71652), PopoutListenerFeature];

/***/ }),

/***/ 12221:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57128);
/* harmony import */ var _sites_base_modal_page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86345);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5749);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_templates__WEBPACK_IMPORTED_MODULE_3__);
/**
 * @module /lib/widgets/WarningPopoverModal.js
 * Provides generic warning modal class.
 * large set of options to allow for customizations.
 */




const {
  customEscape
} = __webpack_require__(35648);
class WarningPopoverModal extends _sites_base_modal_page__WEBPACK_IMPORTED_MODULE_2__.BaseModalPage {
  /**
   * Constructor
   *
   * @param {Object} options - Modal options
   * @param {Array} options.issuesList - list of items to display
   * @param {Boolean} options.bulletedList - is the list of items bulleted
   * @param {String} options.headingText - text for the heading of the modal
   * @param {String} options.bodyText - text for body of the modal
   * @param {String} options.bodyAdditionalText - additional text for body of the modal
   * @param {String} options.bodyAdditionalBoldText - additional text for body of the modal bold styled
   * @param {String} options.showWhiteButton - show white button with blue text
   * @param {Function} options.whiteButtonOnClick - function to do when white button is clicked
   * @param {String} whiteButtonText - text for white button
   * @param {String} options.showBlueButton - show blue button with white text
   * @param {Function} options.blueButtonOnClick - function to call when blue button is clicked
   * @param {String} blueButtonText - text for blue button
   * @param {String} options.showCancel - show cancel text, (no border close modal)
   * @param {String} options.cancelText - cancel button text, (no border close modal)
   * @param {Function} options.cancelOnClick - function to call when cancel is clicked
   */
  constructor(options) {
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsObject(options, 'Must provide options.');
    super(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(_templates__WEBPACK_IMPORTED_MODULE_3___default().warningPopoverModal()), options);

    // default all buttons to show.
    options.showWhiteButton = options.showWhiteButton !== undefined ? options.showWhiteButton : true;
    options.showBlueButton = options.showBlueButton !== undefined ? options.showBlueButton : true;
    options.showCancel = options.showCancel !== undefined ? options.showCancel : true;
    options.blueButtonOnClick = options.blueButtonOnClick ? options.blueButtonOnClick : () => {};
    options.whiteButtonOnClick = options.whiteButtonOnClick ? options.whiteButtonOnClick : () => {};
    options.cancelOnClick = options.cancelOnClick ? options.cancelOnClick : () => {};
  }
  closeDialog() {
    this.modal.close();
  }
  updateDialog(options) {
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsObject(options, 'Must provide options.');
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsArray(options.issuesList, 'Must provide files list.');
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsString(options.headingText, 'Must provide header');
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsString(options.bodyText, 'must provide body text');

    // Get elements
    const $backdrop = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()('#virtru-modal-backdrop');
    const listContainer = this.element.find('.popup-files-list');
    const list = this.element.find('.popup-files-list ul');
    const listBorder = this.element.find('.popup-list-border-box');

    // Set up buttons based on options passed in
    this.element.find('.popup-header-text').text(options.headingText);
    this.element.find('.popup-description').html(options.bodyText);
    this.element.find('.popup-additional-description').text(options.bodyAdditionalText);
    this.element.find('.popup-additional-bold-description').text(options.bodyAdditionalBoldText);
    this.setUpBlueButton(options);
    this.setUpWhiteButton(options);
    this.setUpCancelButton(options);
    const icon = this.element.find('.popup-icon');

    // Set up files list
    if (options.bulletedList) {
      list.html(options.issuesList.map(item => `<li>${customEscape(item.name)}</li>`));
    } else {
      list.html(options.issuesList.map(item => {
        // replace so if the rule contains a tag it will actually be displayed
        item.name = customEscape(item.name);
        item.desc = customEscape(item.desc);
        item.ruleDetails = customEscape(item.ruleDetails);
        if (item.desc !== undefined) {
          return `<p><span class='bold'>${item.name}:</span> ${item.desc}</p>${item.ruleDetails}`;
        }
        return `<p><span class='bold'>${item.name}</span></p>`;
      }));
    }

    // Override styles
    $backdrop.attr('class', 'modal-overlay-light');

    // If the list height is too long create a scrollable box, for viewing pleasure
    if (listContainer.height() < list.height()) {
      listContainer.addClass('scrollable-block');
      listBorder.addClass('scrollable-block');
    }
    if (options.showIcon) {
      icon.show();
    } else {
      icon.hide();
    }
  }
  clickOnEnter(button) {
    button.on('keypress', function (e) {
      if (e.which === 13) {
        _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(this).trigger('click');
      }
    });
  }

  // If the blue action button is desired set text and on click action based on options
  setUpBlueButton(options) {
    const blueButton = this.element.find('.popup-button.popup-button-blue');
    if (options.showBlueButton) {
      blueButton.show();
      const blueButtonText = options.blueButtonText ? options.blueButtonText : 'Button Text';
      blueButton.text(blueButtonText).attr('aria-label', blueButtonText);
      blueButton.on('click', () => {
        options.blueButtonOnClick();
        this.closeDialog();
      });
      this.clickOnEnter(blueButton);
    } else {
      blueButton.hide();
    }
  }

  // If the white action button is desired set text and on click action based on options
  setUpWhiteButton(options) {
    const whiteButton = this.element.find('.popup-button.popup-button-white');
    if (options.showWhiteButton) {
      whiteButton.show();
      const whiteButtonText = options.whiteButtonText ? options.whiteButtonText : 'Button Text';
      whiteButton.text(whiteButtonText).attr('aria-label', whiteButtonText);
      whiteButton.on('click', () => {
        options.whiteButtonOnClick();
        this.closeDialog();
      });
      this.clickOnEnter(whiteButton);
    } else {
      whiteButton.hide();
    }
  }

  // the cancel button will always close the popover after the given function in the options.
  // cancel button can be hidden
  setUpCancelButton(options) {
    const cancelButton = this.element.find('.popup-button.popup-button-borderless');
    if (options.showCancel) {
      cancelButton.show();
      if (options.cancelText) {
        cancelButton.text(options.cancelText);
      }
      cancelButton.on('click', () => {
        options.cancelOnClick();
        this.closeDialog();
      });
      this.clickOnEnter(cancelButton);
    } else {
      cancelButton.hide();
    }
  }

  /**
   * Defines the base action for the modal page
   * @param {Object} dialog - the 'simplemodal.js' dialog object
   * @param {Object} modal - the modal-window, as in: 'const modal = element.modal();'
   */
  defineActions(dialog, modal) {
    this.modal = modal;
    this.element.addClass('fade-in');
    this.updateDialog(this.options);
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (WarningPopoverModal);

/***/ }),

/***/ 12367:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A script local routers registry
 */
var {
  Router
} = __webpack_require__(61526);
var {
  Dict
} = __webpack_require__(82603);

/**
 * A registry for routers
 */
function RoutersRegistry() {
  this._routers = new Dict();
}

/**
 * Get or create a named router
 */
RoutersRegistry.prototype.router = function (name) {
  var router = this._routers.get(name);
  if (!router) {
    router = new Router();
    this._routers.set(name, router);
  }
  return router;
};
module.exports = new RoutersRegistry();

/***/ }),

/***/ 14483:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConversionType: () => (/* binding */ ConversionType),
/* harmony export */   b64ToBinary: () => (/* binding */ b64ToBinary),
/* harmony export */   binaryConverter: () => (/* binding */ binaryConverter),
/* harmony export */   binaryToBlobUri: () => (/* binding */ binaryToBlobUri),
/* harmony export */   binaryToString: () => (/* binding */ binaryToString),
/* harmony export */   blobUriToBinary: () => (/* binding */ blobUriToBinary),
/* harmony export */   deserializeBinary: () => (/* binding */ deserializeBinary),
/* harmony export */   serializeBinary: () => (/* binding */ serializeBinary)
/* harmony export */ });
/* harmony import */ var _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(52938);
/* harmony import */ var _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__);
/* provided dependency */ var Buffer = __webpack_require__(17995)["Buffer"];


/**
 * Takes a {Binary} and creates a Base64 string for it.
 *
 * @param binary
 * @returns {String} Base64 string
 */
function binaryToString(binary) {
  return Buffer.from(binary.asArrayBuffer()).toString('base64'); // for sending from background script to content
}

/**
 * Takes a {Binary} and creates a Blob URL for it.
 *
 * @param binary
 * @returns {String} Blob Object URL
 */
function binaryToBlobUri(binary) {
  var blob = new Blob([binary.asArrayBuffer()], {
    type: 'octet/stream'
  });
  return window.URL.createObjectURL(blob);
}
/**
 * Takes a Base64 {string} and convert it to Binary
 *
 * @param base64 {string}
 * @returns {binary}
 */
function b64ToBinary(base64) {
  const tdfDataString = atob(base64);
  const arrayBuffer = new ArrayBuffer(tdfDataString.length);
  const bufView = new Uint8Array(arrayBuffer);
  for (let i = 0, strLen = tdfDataString.length; i < strLen; i++) {
    bufView[i] = tdfDataString.charCodeAt(i);
  }
  return _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__.Binary.fromArrayBuffer(arrayBuffer);
}

/**
 * Retrieves the data located at the Blob URL and then
 * revokes it.  So this is effectively a call once
 * function for Blob URLs.
 *
 * @param blobUrl
 * @returns A promise to resolve a {Binary} containing the
 * data
 */
function blobUriToBinary(url) {
  return new Promise(function (resolve, reject) {
    const xhr = new XMLHttpRequest();
    xhr.onload = function () {
      resolve(_virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__.Binary.fromArrayBuffer(xhr.response));
      URL.revokeObjectURL(url);
    };
    xhr.onerror = function () {
      reject(new TypeError('Local request failed'));
      URL.revokeObjectURL(url);
    };
    xhr.responseType = 'arraybuffer';
    xhr.open('GET', url);
    xhr.send(null);
  });
}
function serializeBinary(arrayBuffer) {
  const isArrayBuffer = arrayBuffer.toString() === '[object ArrayBuffer]';
  const binary = isArrayBuffer ? _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__.Binary.fromArrayBuffer(arrayBuffer) : arrayBuffer;
  const stringBinary = binary.asString();
  return _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__.Binary.fromString(stringBinary);
}
function deserializeBinary(stringBinary) {
  const binaryArray = Buffer.from(stringBinary, 'base64'); // get binary array from the received string
  const {
    buffer
  } = new Uint8Array(binaryArray);
  return _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_0__.Binary.fromArrayBuffer(buffer);
}
const ConversionType = {
  STRING_TO_BINARY: 'string-to-binary',
  BINARY_TO_STRING: 'binary-to-string'
};
async function binaryConverter(data, {
  conversionType
}) {
  switch (conversionType) {
    case ConversionType.STRING_TO_BINARY:
      return deserializeBinary(data);
    case ConversionType.BINARY_TO_STRING:
      return binaryToString(data);
    default:
      return null;
  }
}

/***/ }),

/***/ 15641:
/***/ ((module, exports, __webpack_require__) => {

module.exports = exports = __webpack_require__(54026);

/***/ }),

/***/ 16415:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NewComposerMod: () => (/* binding */ NewComposerMod)
});

// EXTERNAL MODULE: ./lib/store/globalStore.js
var globalStore = __webpack_require__(71139);
var globalStore_default = /*#__PURE__*/__webpack_require__.n(globalStore);
// EXTERNAL MODULE: ./compatibility/jquery-pack/index.js
var jquery_pack = __webpack_require__(55401);
var jquery_pack_default = /*#__PURE__*/__webpack_require__.n(jquery_pack);
// EXTERNAL MODULE: ./lib/i18n/index.js
var i18n = __webpack_require__(2622);
var i18n_default = /*#__PURE__*/__webpack_require__.n(i18n);
;// ./sites/gmail/page/mods/helpers/animation-helper.js


const {
  TimelineLite
} = window.GreenSockGlobals;
const {
  Sine
} = window.GreenSockGlobals;
const {
  TweenMax
} = window.GreenSockGlobals;
const {
  Linear
} = window.GreenSockGlobals;
const DISABLE_DUPLICATE_FOR_SEND_BUTTON = 'disabled-send-secure-button';
const DISABLE_LOGO_FOR_SEND_BUTTON = 'disabled-send-secure-logo';
class AnimationHelper {
  static toggleIconPadding() {
    if (jquery_pack_default()('.virtru-new-compose-icon:visible').length > 0) {
      jquery_pack_default()('.virtru-pcm-options-enabled-icons').css('margin-right', '10px');
    } else {
      jquery_pack_default()('.virtru-pcm-options-enabled-icons').css('margin-right', '0');
    }
  }
  constructor({
    $element,
    dom,
    bannerSelector,
    formElement,
    stateManager
  }) {
    this._element = $element;
    this._dom = dom;
    /* TODO: refactor, move from new-compose */
    this.bannerSelector = bannerSelector;
    this._formElement = formElement;
    this._stateManager = stateManager;
    this.unsubscribeToggleIconPadding = this._stateManager.toggleIconPadding().requestSub(AnimationHelper.toggleIconPadding);
  }
  createPopover(configPopoverObj) {
    return this._stateManager.createPopover().requestOnce(configPopoverObj);
  }
  showIndividualAttachmentAnimation(element, filename) {
    const dom = this._dom;
    const container = jquery_pack_default()('<div class="virtru-individual-animation-container" style="overflow: hidden; white-space: nowrap;"></div>');
    const shield = jquery_pack_default()('<div>', {
      class: 'virtru-attachment-shield',
      style: 'display: inline-block; ' + 'vertical-align: middle; ' + 'background-position: left center; ' + 'background-repeat: no-repeat; ' + 'padding: 2px 5px 3px 0; '
    });
    let skipAnimation = false;
    let parent = jquery_pack_default()('a', element);
    if (parent.length === 0) {
      const oldContainer = jquery_pack_default()('.virtru-individual-animation-container', element);
      if (oldContainer.length > 0) {
        parent = oldContainer;
      } else {
        parent = element;
      }
    } else {
      skipAnimation = true;
    }
    const fileNameElement = jquery_pack_default()(dom.NEW_COMPOSE_ATTACHMENT_FILENAME, parent);
    const fileSizeElement = jquery_pack_default()(dom.NEW_COMPOSE_ATTACHMENT_FILE_SIZE, parent);
    const fileExtensionContainer = jquery_pack_default()('<div style="display: inline-block; overflow: hidden; white-space: nowrap; vertical-align: bottom;"></div>');
    const fileExtensionElement = jquery_pack_default()('<div>.tdf</div>');
    fileNameElement.css('color', '#222222');
    fileSizeElement.css('padding-left', '4px');
    fileSizeElement.css('vertical-align', 'bottom');
    // copy style from the filename text element without copying the class itself
    fileExtensionElement.css('text-size', fileNameElement.css('text-size'));
    fileExtensionElement.css('vertical-align', fileNameElement.css('vertical-align'));
    fileExtensionElement.css('line-height', fileNameElement.css('line-height'));
    fileExtensionElement.css('font-weight', fileNameElement.css('font-weight'));
    fileExtensionElement.css('padding-top', fileNameElement.css('padding-top'));
    fileExtensionElement.css('padding-bottom', fileNameElement.css('padding-bottom'));
    fileExtensionElement.css('color', '#47ccc7');
    fileExtensionElement.css('text-overflow', 'clip');
    container.append(shield);
    container.append(fileNameElement);
    fileExtensionContainer.append(fileExtensionElement);
    container.append(fileExtensionContainer);
    container.append(fileSizeElement);
    parent.append(container);
    const shieldWidth = shield.outerWidth();
    const fileNameWidth = fileNameElement.outerWidth();
    const fileSizeWidth = fileSizeElement.outerWidth();
    const fileExtensionWidth = fileExtensionElement.outerWidth();
    container.css('width', fileNameWidth + fileSizeWidth);
    shield.css('margin-left', -shieldWidth);
    fileExtensionContainer.css('width', 0);
    fileExtensionElement.css('margin-left', -fileExtensionWidth);
    const PHASE_1_TIME = 0.35;
    const PHASE_1_2_PAUSE = 0.15;
    const PHASE_2_TIME = 0.2;
    const timeline = new TimelineLite();
    timeline.addLabel('phase_1');
    timeline.to(fileNameElement, PHASE_1_TIME, {
      color: '#1155cc'
    }, 'phase_1');
    timeline.to(shield, PHASE_1_TIME, {
      marginLeft: 0,
      ease: Sine.easeInOut
    }, 'phase_1');
    timeline.to(container, PHASE_1_TIME, {
      width: shieldWidth + fileNameWidth,
      ease: Sine.easeInOut
    }, 'phase_1');
    timeline.addLabel('phase_2', PHASE_1_TIME + PHASE_1_2_PAUSE);
    timeline.set(fileSizeElement, {
      opacity: 0
    }, 'phase_2');
    timeline.set(container, {
      width: shieldWidth + fileNameWidth + fileExtensionWidth,
      ease: Sine.easeOut
    }, 'phase_2');
    timeline.set(fileExtensionContainer, {
      width: fileExtensionWidth
    }, 'phase_2');
    timeline.to(fileExtensionElement, PHASE_2_TIME, {
      marginLeft: 0
    }, 'phase_2');
    timeline.addLabel('end', PHASE_1_TIME + PHASE_1_2_PAUSE + PHASE_2_TIME);
    if (skipAnimation) {
      timeline.seek('end');
    }
    const popoverContent = i18n_default().t('TOOLTIP_SECURE_ATTACHMENT_CONTENT', {
      filename
    });
    const popoverTitle = i18n_default().t('TOOLTIP_SECURE_ATTACHMENT_TITLE');
    this.createPopover({
      $icon: shield,
      content: popoverContent,
      title: popoverTitle,
      position: 'east',
      delay: null
    });
  }

  /**
   * Account for added height from the Virtru banner. Originally we were using a mutation observer to automatically
   * set the height when a change was detected, but it was conflicting with other extensions. Now it simply adds
   * some padding to the fullscreen element because gmail leaves enough space around the full screen window to bleed into.
   * @private
   */
  resizeFullScreenElement() {
    const banner = jquery_pack_default()(this.bannerSelector, this._formElement.parent());
    const bannerHeight = banner.height();
    const dom = this._dom;

    // Don't apply this if we are in a totally different popout window
    if (!document.body.matches(dom.POPOUT_WINDOW)) {
      // Center the element with added vertical margin
      const $element = jquery_pack_default()(dom.NEW_COMPOSE_FULL_SCREEN_RESIZING_ELEMENT);
      const halfOffset = parseInt(bannerHeight / 2);
      $element.css('margin-top', `${-halfOffset}px`);
      $element.css('margin-bottom', `${halfOffset}px`);
    } else if (document.body.matches(dom.POPOUT_WINDOW_COMPOSE)) {
      // If we are in a new popout window, offset the full screen element by the banner height
      const $element = jquery_pack_default()(dom.NEW_COMPOSE_RESIZABLE_BODY);
      $element.css('margin-bottom', `${-bannerHeight}px`);
    }
  }
  teardown() {
    this.unsubscribeToggleIconPadding();
  }
  animateSendDisableButton(rotateLogo) {
    this._disabledButtonLogoTween = TweenMax.to(rotateLogo, 0.75, {
      rotation: 360,
      ease: Linear.easeNone,
      repeat: -1
    });
  }
  removeAnimationForSendDisableButton() {
    if (this._disabledButtonLogoTween) {
      this._disabledButtonLogoTween.kill();
      this._disabledButtonLogoTween = null;
    }
  }
  disableSendButtonAnimate(sendButton) {
    const $disableButton = jquery_pack_default()(`<div class="${DISABLE_DUPLICATE_FOR_SEND_BUTTON}"><div class="${DISABLE_LOGO_FOR_SEND_BUTTON}"></div></div>`);
    const logo = $disableButton.find(`.${DISABLE_LOGO_FOR_SEND_BUTTON}`);
    const borderWidth = 2;
    $disableButton.css('width', sendButton.outerWidth() - borderWidth);
    $disableButton.css('height', sendButton.outerHeight() - borderWidth);
    $disableButton.css('opacity', 0);
    TweenMax.killTweensOf(sendButton);
    TweenMax.killTweensOf(sendButton);
    sendButton.parent().css('position', 'relative');
    sendButton.after($disableButton);
    this.animateSendDisableButton(logo);
    TweenMax.to($disableButton, 0.5, {
      opacity: 1
    });
    TweenMax.to(sendButton, 0.5, {
      opacity: 0,
      onComplete: () => {
        sendButton.addClass('virtru-disabled-send-secure no-touch');
      }
    });
  }
  enableSendButtonAnimate(sendButton) {
    let $disableButton = sendButton.parent().find(`.${DISABLE_DUPLICATE_FOR_SEND_BUTTON}`);
    sendButton.removeClass('virtru-disabled-send-secure no-touch');
    TweenMax.killTweensOf(sendButton);
    TweenMax.to(sendButton, 0.25, {
      opacity: 1
    });
    if ($disableButton && $disableButton.length > 0) {
      TweenMax.killTweensOf($disableButton);
      TweenMax.to($disableButton, 0.25, {
        opacity: 0,
        onComplete: () => {
          this.removeAnimationForSendDisableButton();
          $disableButton.remove();
          $disableButton = null;
        }
      });
    }
  }
}
// EXTERNAL MODULE: ./sites/gmail/page/mods/helpers/tooltip-helper.js
var tooltip_helper = __webpack_require__(85149);
// EXTERNAL MODULE: ./node_modules/@virtru-private/emitter/index.js
var emitter = __webpack_require__(16502);
var emitter_default = /*#__PURE__*/__webpack_require__.n(emitter);
// EXTERNAL MODULE: ./compatibility/helpers/index.js
var helpers = __webpack_require__(4424);
;// ./sites/gmail/page/mods/helpers/state-management-helper.js


const EmitSubjectKeys = new Set(['GET_POLICY_AUTHORIZATIONS', 'GET_ATTACHMENT_METADATA', 'REMOVE_METADATA_DUPLICATES', 'CHECK_IF_SECURE_MODE', 'TOGGLE_ICON_PADDING', 'CREATE_POPOVER', 'GET_MAIL_SENDING_STATE', 'GET_COMPOSE_MOD_sendSecureMod', 'GET_COMPOSE_MOD_sendButtonsMod', 'GET_COMPOSE_MOD_sendArchiveButtonMod', 'GET_ATTACHMENT_SERVICE']);
const ModsEnum = {
  SEND_SECURE_MOD: '_sendSecureMod',
  SEND_BUTTON_MOD: '_sendButtonsMod',
  SEND_ARCHIVE_BUTTON_MOD: '_sendArchiveButtonMod'
};

/**
 * Helps control data flow between various helpers of new-compose.js
 * It uses emitter pub/sub library
 * Works only synchronously
 */
class StateManagementHelper {
  static checkIfCorrectModName(modName) {
    return modName in ModsEnum;
  }
  static checkIfSubjectKeyExists(subjectKey) {
    if (!EmitSubjectKeys.has(subjectKey)) {
      throw new Error(`Can't find emit key ${subjectKey}`);
    }
  }
  constructor() {
    (0,helpers._bindAllMethods)(this);
  }

  /**
   * Make request for data using pub/sub approach
   *
   * @param subjectKey - unique key by which events are being generated
   */
  requestState(subjectKey) {
    StateManagementHelper.checkIfSubjectKeyExists(subjectKey);
    const requestKey = `${subjectKey}_REQUEST`;
    this.emit(requestKey);
  }

  /**
   * Register callback function for request made with subjectKey
   * @param subjectKey - unique key by which events are being generated
   * @param requestFn - callback fn
   * @param args - arguments for callback function
   * @return {*}
   */
  processRequest(subjectKey, requestFn, getRequestArgs) {
    StateManagementHelper.checkIfSubjectKeyExists(subjectKey);
    const requestKey = `${subjectKey}_REQUEST`;
    const wrapperFn = () => {
      const args = getRequestArgs() || [];
      const data = requestFn(...args);
      const responseKey = `${subjectKey}_RESPONSE`;
      this.emit(responseKey, data);
    };
    const emitter = this.on(requestKey, wrapperFn);
    return emitter.off.bind(this, requestKey, wrapperFn);
  }

  /**
   * Send data directly to subscriber
   * @param subjectKey - unique key by which events are being generated
   * @param data - data which we would like to send
   */
  triggerResponse(subjectKey, data) {
    StateManagementHelper.checkIfSubjectKeyExists(subjectKey);
    const responseKey = `${subjectKey}_RESPONSE`;
    this.emit(responseKey, data);
  }

  /**
   * Subscribe to result from request callback function
   * @param subjectKey - unique key by which events are being generated
   * @param responseFn - response callback function
   * @param invokeOnce - should callback function be invoked only once
   * @return {*}
   */
  subscribeResponse(subjectKey, responseFn, invokeOnce = false) {
    StateManagementHelper.checkIfSubjectKeyExists(subjectKey);
    const responseKey = `${subjectKey}_RESPONSE`;
    const emitter = invokeOnce ? this.once(responseKey, responseFn) : this.on(responseKey, responseFn);
    return emitter.off.bind(this, responseKey, responseFn);
  }

  /**
   * Generate emitting subject which is based on pub/sub design pattern
   * @param subjectKey
   * @return {{request: request, requestSub: requestSub, responseSub: (function(*=, *=): *), triggerResponse: (function(*=): void)}}
   */
  generateEmittingSubject(subjectKey) {
    StateManagementHelper.checkIfSubjectKeyExists(subjectKey);
    let requestArgs;
    const emittingSubject = {
      request: (...args) => {
        requestArgs = args || [];
        this.requestState(subjectKey);
      },
      requestSub: requestFn => this.processRequest(subjectKey, requestFn, getRequestArgs),
      responseSub: (responseFn, invokeOnce) => this.subscribeResponse(subjectKey, responseFn, invokeOnce),
      triggerResponse: data => this.triggerResponse(subjectKey, data)
    };
    return {
      ...emittingSubject,
      /* subject helper to request some data
       * and subscribe to it only once
        * and then unsubscribe */
      requestOnce(...args) {
        let response;
        emittingSubject.responseSub(state => response = state, true);
        emittingSubject.request(...args);
        return response;
      }
    };
    function getRequestArgs() {
      return requestArgs;
    }
  }
  isSecureMode() {
    return this.generateEmittingSubject('CHECK_IF_SECURE_MODE');
  }
  removeMetadataDuplicates() {
    return this.generateEmittingSubject('REMOVE_METADATA_DUPLICATES');
  }
  getPolicyAuthorizations() {
    return this.generateEmittingSubject('GET_POLICY_AUTHORIZATIONS');
  }
  getAttachmentMetadata() {
    return this.generateEmittingSubject('GET_ATTACHMENT_METADATA');
  }
  toggleIconPadding() {
    return this.generateEmittingSubject('TOGGLE_ICON_PADDING');
  }
  createPopover() {
    return this.generateEmittingSubject('CREATE_POPOVER');
  }
  getMailSendingState() {
    return this.generateEmittingSubject('GET_MAIL_SENDING_STATE');
  }
  getComposeMod(modName) {
    StateManagementHelper.checkIfCorrectModName(modName);
    const subjectKey = `GET_COMPOSE_MOD${modName}`;
    return this.generateEmittingSubject(subjectKey);
  }
  getAttachmentService() {
    return this.generateEmittingSubject('GET_ATTACHMENT_SERVICE');
  }
}
emitter_default()(StateManagementHelper.prototype);
// EXTERNAL MODULE: ./lib/email/lib/attachment-utils.js
var attachment_utils = __webpack_require__(62769);
// EXTERNAL MODULE: ./node_modules/@virtru-private/binaryjs/index.js
var binaryjs = __webpack_require__(52938);
// EXTERNAL MODULE: ./lib/templates/index.js
var templates = __webpack_require__(5749);
var templates_default = /*#__PURE__*/__webpack_require__.n(templates);
// EXTERNAL MODULE: ./lib/sites/index.js
var sites = __webpack_require__(38282);
// EXTERNAL MODULE: ./node_modules/suspenders/ElementRegistry/index.js + 1 modules
var ElementRegistry = __webpack_require__(98932);
// EXTERNAL MODULE: ./lib/email/index.js
var email = __webpack_require__(58922);
var email_default = /*#__PURE__*/__webpack_require__.n(email);
// EXTERNAL MODULE: ./lib/sdk/index.js
var sdk = __webpack_require__(29182);
// EXTERNAL MODULE: ./lib/utils/sanitizeAnalyticsError.js
var sanitizeAnalyticsError = __webpack_require__(81442);
;// ./sites/gmail/page/mods/helpers/attachments-helper.js
/* provided dependency */ var console = __webpack_require__(31799);











const Utils = __webpack_require__(55675);
const AnalyticsService = (__webpack_require__(1246).instance)();
const getFilesAsBinaries = files => {
  if (files.length === 0) {
    console.error('No files provided');
  }
  const filePromises = Array.from(files).map(file => {
    return new Promise((resolve, reject) => {
      if (file.binary) {
        resolve(file);
      }
      const reader = new FileReader();
      reader.onload = function () {
        resolve({
          file: {
            type: file.type,
            name: file.name,
            binary: binaryjs.Binary.fromArrayBuffer(reader.result)
          }
        });
      };
      reader.onerror = function (error) {
        reject(`Error reading file ${file.name}: ${error}`);
      };
      reader.readAsArrayBuffer(file);
    });
  });
  return Promise.all(filePromises);
};
class AttachmentsHelper {
  constructor({
    dom,
    gmailUtil,
    $editor,
    $element,
    labels,
    policyConfigMenu,
    /* TODO: SPIKE! Refactor! */
    context
  }) {
    this._dom = dom;
    this._gmailUtil = gmailUtil;
    this._editor = $editor;
    this._element = $element;
    this._labels = labels;
    this._policyConfigMenu = policyConfigMenu;
    this._stateManager = context._stateManager;
    this._context = context;
    this._numUploadingAttachments = 0;
    this._tdfAttachmentMods = [];
    this._fileUrlByIdCache = {};
    this._fileByNameCache = {};
    this._base64ImageCache = {};
    this._authorizations = [];
    this._unsecureAttachments = [];
    this.unsubsribeAuthorizationsUpdate = this._stateManager.getPolicyAuthorizations().responseSub(this.updatePolicyAuthorizations.bind(this));
    this.setupAttachmentContainers(context);
    this.initDropZone(context);
    (0,helpers._bindAllMethods)(this);
  }
  getComposeMod(modName) {
    return this._stateManager.getComposeMod(modName).requestOnce();
  }
  get _sendButtonsMod() {
    return this.getComposeMod(ModsEnum.SEND_BUTTON_MOD);
  }
  get _sendArchiveButtonMod() {
    return this.getComposeMod(ModsEnum.SEND_ARCHIVE_BUTTON_MOD);
  }
  get _sendSecureMod() {
    return this.getComposeMod(ModsEnum.SEND_SECURE_MOD);
  }
  get _attachmentService() {
    return this._stateManager.getAttachmentService().requestOnce();
  }
  updatePolicyAuthorizations(value) {
    this._authorizations = value;
  }
  isSecureMode() {
    return this._context.isSecureMode();
  }
  registerListeners(user, onBeforeSetupSecureMode, updateAttachmentSectionHeader, removeSectionTooltip, doConvertInlineImagesToBase64) {
    const targetElement = document.querySelector(this._dom.NEW_COMPOSE_ATTACHMENT_DROP_ZONE);
    targetElement.addEventListener('drop', async e => {
      const res = await getFilesAsBinaries(e.dataTransfer.files);
      this._unsecureAttachments = [...this._unsecureAttachments, ...res.map(item => item.file)];
      this._sendSecureMod.cacheAttachments();
    });
    const addChangeListenerToFileInput = fileInput => {
      fileInput.addEventListener('change', async event => {
        const res = await getFilesAsBinaries(event.target.files);
        this._unsecureAttachments = [...this._unsecureAttachments, ...res.map(item => item.file)];
        this._sendSecureMod.cacheAttachments();
      });
    };
    const observer = new MutationObserver(mutations => {
      mutations.forEach(mutation => {
        if (mutation.addedNodes.length > 0) {
          mutation.addedNodes.forEach(node => {
            if (node.matches && node.matches(fileInputSelector)) {
              addChangeListenerToFileInput(node);
            }
          });
        }
      });
    });
    observer.observe(document.body, {
      childList: true,
      subtree: true
    });
    const fileInputSelector = 'input[name="Filedata"]';
    const initialFileInput = document.querySelector(fileInputSelector);
    if (initialFileInput) {
      addChangeListenerToFileInput(initialFileInput);
    }

    // If we detect a new image attachment, convert it to base64 and cache the results.
    // When toggling into secure, we can just replace the images with their base64 version.
    // If we are already in secure mode, just convert them in place.
    // NOTE: this approach does not support massive images (~10MB) due to limits in message passing.
    ElementRegistry.addListen(this._editor.get(0), this._dom.NEW_COMPOSE_ATTACHMENT_INLINE, elem => {
      if (this._gmailUtil.elementIsInlineImage(elem)) {
        if (doConvertInlineImagesToBase64(user)) {
          const elemSrc = elem.src;
          if (elemSrc) {
            sdk.transports.call('content', 'getImageDataUrl', {
              src: elemSrc
            }).then(response => {
              this._base64ImageCache[elemSrc] = response.dataUrl;
              if (this.isSecureMode()) {
                elem.src = response.dataUrl;
              }
            }).catch(e => {
              AnalyticsService.clientError({
                context: 'new_compose_attachment_inline',
                name: 'Error retrieving data URL for inline image',
                error_obj: (0,sanitizeAnalyticsError/* sanitizeAnalyticsError */.h)(e)
              });
              console.error('Error retrieving image data', e);
              this.convertUnsecureImagesToSecure();
            });
          }
        } else {
          this.convertUnsecureImagesToSecure();
        }
      }
    });
    ElementRegistry.addListen(this._element.get(0), this._dom.NEW_COMPOSE_ATTACHMENT, elem => {
      if (!jquery_pack_default()(elem).hasClass('virtru-hooked')) {
        jquery_pack_default()(elem).addClass('virtru-hooked');
        // Don't setup anything unless the attachment link is ready
        const attachmentLink = jquery_pack_default()(elem).find('a').attr('href');
        if (attachmentLink) {
          if (this._sendSecureMod) {
            this._sendSecureMod.notifyAboutAttachment(attachmentLink);
          }
          if (this.isSecureMode() && !this._context.isSwitchingToSecureMode()) {
            // We need to convert over any gmail attachments added while in secure mode
            // TODO: be more explicit about what actually needs to be done instead of calling a generic setup function
            onBeforeSetupSecureMode(true);
          } else {
            const queryObj = Object.fromEntries(new URL(attachmentLink).searchParams);
            // Cache the blob url only if we haven't done it already
            if (!this._fileUrlByIdCache[queryObj.realattid]) {
              // The drop zone only knows about the file's name. We need to correlate with the actual DOM element.
              // NOTE: we can't rely completely on the file name being unique, because gmail supports multiple different
              // attachments with the same exact name.
              const fileName = jquery_pack_default()(elem).find(this._dom.NEW_COMPOSE_ATTACHMENT_FILENAME).text();
              const file = this._fileByNameCache[fileName];
              if (file) {
                this._fileUrlByIdCache[queryObj.realattid] = file.blobUrl;
                delete this._fileByNameCache[fileName];
              }
            }
          }
        }
      }
    });

    // Whenever a Virtru attachment is added to the compose box, move it down to the attachment section.
    // Whenever a Virtru attachment is removed from the compose box, remove the attachment section if necessary.
    ElementRegistry.addListen(this._editor.get(0), '.virtru-attachment', elem => {
      if (!elem.getAttribute('cvoxignore')) {
        if (Utils.isFeatureEnabled(user._profile, 'useAttachmentChipsV2')) {
          const isBeforeSectionHeader = jquery_pack_default()(elem).prevAll('.virtru-attachment-section-header').length > 0;
          const isInsideAttachmentSection = jquery_pack_default()(elem).parents('.virtru-attachment-section').length > 0;
          const numberOfAttachmentsInWrapper = jquery_pack_default()(elem).parents('.virtru-attachment-wrapper').find('.virtru-attachment').length;
          // Move the attachment below the attachment section header if not done already
          if (!isBeforeSectionHeader && !isInsideAttachmentSection || isInsideAttachmentSection && numberOfAttachmentsInWrapper > 1) {
            // Add an attachment section if none exists
            if (this._editor.find('.virtru-attachment-section').length <= 0) {
              const attachmentSection = jquery_pack_default()(templates_default().attachmentSection());
              // Added <br/> before and after section for prevent remove attachment by backspace (remove) button on keyboard
              this._editor.append('<br/>').append(attachmentSection).append('<br/>');
              attachment_utils/* default.createSectionTooltip */.Ay.createSectionTooltip(this._editor);
            }
            this._editor.find('.virtru-attachment-section').append(elem);
          }
          updateAttachmentSectionHeader();
        }
      }
    }, () => {
      // Remove the attachment section if no other attachments exist
      if (this._editor.find('.virtru-attachment-section .virtru-attachment').length <= 0) {
        removeSectionTooltip();
        this._editor.find('.virtru-attachment-section').remove();
      }
      updateAttachmentSectionHeader();
    });
    ElementRegistry.addListen(this._editor.get(0), (email_default()).Constants.METADATA_SELECTOR, this._stateManager.removeMetadataDuplicates().request, elem => {
      // Add the email meta data back if it is removed
      if (!this.getMailSendingState() && this._editor.is(':visible') && this._editor.find((email_default()).Constants.METADATA_SELECTOR).length <= 0) {
        this._editor.append(elem);
      }
    });
  }
  convertUnsecureImagesToSecure() {
    if (this.isSecureMode()) {
      const attachments = this.getUnsecureImageAttachments();
      this.convertAttachmentsToSecure(attachments);
    }
  }
  convertAttachmentsToSecure(attachments) {
    this._stateManager.getPolicyAuthorizations().request();

    // Temporarily hide any inline images: they will be replaced by the attachment chips
    this.hideInlineAttachments();
    this.onAttachmentAttached(attachments);
    const {
      isManaged
    } = this._policyConfigMenu._policyModel;

    // Add all the attachments, and resolve the promise when they are all through
    return Promise.all(attachments.map(attachment => new Promise((resolve, reject) => {
      this._attachmentService.downloadAndEncryptRemoteFile(attachment, {
        isManaged,
        authorizations: this._authorizations
      }).then(secureAttachments => {
        var _secured$, _secured$$tdfData, _secured$$tdfData$ori;
        const secured = secureAttachments.filter(sa => typeof sa.error === 'undefined');

        // Delete attachment after successful download to prevent race condition with Google
        const a = jquery_pack_default()(`a[href$="${attachment.url}"]`);
        const $delete = jquery_pack_default()(a).parent().find(this._dom.NEW_COMPOSE_DELETE_ATTACHMENT);
        $delete.triggerNative('mousedown');
        $delete.triggerNative('mouseup');
        $delete.triggerNative('click');
        // remove blob from memory
        URL.revokeObjectURL((_secured$ = secured[0]) === null || _secured$ === void 0 ? void 0 : (_secured$$tdfData = _secured$.tdfData) === null || _secured$$tdfData === void 0 ? void 0 : (_secured$$tdfData$ori = _secured$$tdfData.originalFile) === null || _secured$$tdfData$ori === void 0 ? void 0 : _secured$$tdfData$ori.blob);
        this.attachSecure(secured);
        secured.forEach(attachment => {
          AnalyticsService.attachmentAdded({
            isManaged,
            authorizations: this._authorizations,
            type: 'convert',
            ...attachment.getAnalyticsObject()
          });
        });
        resolve(secureAttachments);
      }).catch(err => {
        console.error('convertAttachments error: ', err);
        reject(err);
      });
    }))).then(resolvedAttachments => new Promise(resolve => {
      const failed = resolvedAttachments.filter(ra => ra && ra[0] && typeof ra[0].error !== 'undefined').map(ra => ra[0]);
      if (failed.length === 0) {
        resolve();
      } else {
        sites.RemoteContentAttachment.showErrorModal(failed, resolve);
      }
    })).then(failedAttachments => {
      if (failedAttachments && Array.isArray(failedAttachments)) {
        this.onAttachmentProcessed(failedAttachments.length);
      }
    });
  }

  /**
   * This function finds the two attachment drop areas and hooks
   * into them so we can track which new compose window they belong
   * to.
   */
  setupAttachmentContainers(context) {
    const dropAreas = jquery_pack_default()(this._dom.NEW_COMPOSE_ATTACHMENT_FILTERED_DROP_ZONES);
    this._dropZone = new sites.AttachmentDropZone(undefined, sdk.transports, context);
    dropAreas.each((_, match) => {
      const $match = jquery_pack_default()(match);
      this._dropZone.addElements($match);
    });
    this._dropZone.on('attach-secure', this.attachSecure.bind(this));
    this._dropZone.on('fail-attach-secure', this.onAttachmentProcessed.bind(this));
    this._dropZone.on('attachment-attached', this.onAttachmentAttached.bind(this));
  }
  attachSecure(attachments) {
    attachments.forEach(attachment => {
      this._tdfAttachmentMods.push(attachment);
      this._stateManager.getAttachmentMetadata().triggerResponse({
        policyUuid: attachment.tdfData.policyUuid
      });
      attachment.on('attachment-deleted', () => {
        this.handleTdfAttachmentDeleted(attachment.tdfData.policyUuid);
      });
    });
    this.onAttachmentProcessed(attachments.length);
  }

  /**
   * Handles newly added attachments
   * @private
   */
  onAttachmentAttached(files) {
    this._sendButtonsMod.disableSendButton();
    if (this._context.getEmailMode() === 'new') {
      this._sendButtonsMod.enableSwitchingToPopoutWarning(this.removeUploadingAttachments.bind(this));
    }
    if (this._sendArchiveButtonMod) {
      this._sendArchiveButtonMod.disable();
    }
    this._numUploadingAttachments += files.length;
    jquery_pack_default()(window).triggerNative('resize');
  }
  removeUploadingAttachments() {
    this._editor.find('.virtru-attachment-is-uploading').remove();
    this._numUploadingAttachments = 0;
  }

  /**
   * Removes the email metadata for a Google Drive attachment
   *
   * @param policyUuid
   */
  handleTdfAttachmentDeleted(policyUuid) {
    for (let i = this._tdfAttachmentMods.length - 1; i >= 0; i--) {
      const attachmentMod = this._tdfAttachmentMods[i];
      if (attachmentMod.tdfData.policyUuid === policyUuid) {
        this._tdfAttachmentMods.splice(i, 1);
      }
    }
  }

  /**
   * Handles attachments that are done being encrypted or rejected:
   * Updates counter of attachments in progress and, if none left, activates Send button
   * @private
   */
  onAttachmentProcessed(numAttachments) {
    this._numUploadingAttachments -= numAttachments !== undefined ? numAttachments : 1;
    if (this._numUploadingAttachments === 0) {
      const activeSendToolTip = this._sendSecureMod && this._sendSecureMod.sendToolTip && this._sendSecureMod.sendToolTip._active;

      // Do not re-enable the send button if it has an active SSS sendTooltip
      if (!activeSendToolTip) {
        this._sendButtonsMod.enableSendButton();
        if (this._context.getEmailMode() === 'new') {
          this._sendButtonsMod.disableSwitchingToPopoutWarning();
        }
        if (this._sendArchiveButtonMod) {
          this._sendArchiveButtonMod.enable();
        }
      }
    }
  }
  initDropZone() {
    this._dropZone.setup();
  }

  /**
   * Convert image attachments in the DOM to a list of file objs
   *
   * @param {boolean} ensureStableUrls -- If set, throw an error if any of the urls might not be updated after draft save
   *
   * @return list of file objs with urls representing the images
   */
  getUnsecureImageAttachments() {
    const arr = [];
    const $imgs = this._editor.find(this._dom.NEW_COMPOSE_ATTACHMENT_INLINE);
    $imgs.each((index, elem) => {
      if (this._gmailUtil.elementIsInlineImage(elem)) {
        const elemSrc = jquery_pack_default()(elem).attr('src');
        // generate a unique uuid for this image so that we can correlate element with file
        if (!jquery_pack_default()(elem).attr('data-virtru-inline-image-uuid')) {
          jquery_pack_default()(elem).attr('data-virtru-inline-image-uuid', window.crypto.randomUUID());
        }
        arr.push({
          url: this._base64ImageCache[elemSrc] || elemSrc,
          // Use the alt tag to name the image, otherwise default to Inline Image X
          name: jquery_pack_default()(elem).attr('alt') || `Inline Image ${index}`,
          inlineImageUuid: jquery_pack_default()(elem).attr('data-virtru-inline-image-uuid')
        });
      }
    });
    return arr;
  }
  getUnsecureAttachments() {
    /*
    *  TODO cover scenario when files was uploaded with toggle of and page was reloaded
    *  in this scenario no input tag with file exist and we do need download file from attachments service
    * */
    const arr = [];
    const $regularAttachments = this._element.find(this._dom.NEW_COMPOSE_ATTACHMENT);
    $regularAttachments.each((index, elem) => {
      const attachmentLink = jquery_pack_default()(elem).find('a').attr('href');

      /**
       * There is a short delay between an attachment being "uploaded" and
       * it being fully accessible with a link/href. This can be observed by
       * watching the attachment filename text changing from black to blue.
       */
      if (!attachmentLink) {
        throw new Error(this._labels.ATTACHMENT_NOT_READY_ERROR);
      }
      const queryObj = Object.fromEntries(new URL(attachmentLink).searchParams);
      const fileName = jquery_pack_default()(elem).find(this._dom.NEW_COMPOSE_ATTACHMENT_FILENAME).text();
      const fileId = queryObj.realattid;
      let fileUrl = attachmentLink;
      if (!fileUrl.startsWith('http')) {
        fileUrl = `${window.location.protocol}//${window.location.hostname}${window.location.pathname}${attachmentLink}`;
      }
      const target = this._unsecureAttachments.find(item => item.name === fileName);
      arr.push({
        url: this._fileUrlByIdCache[fileId] || fileUrl,
        name: fileName,
        binary: (target === null || target === void 0 ? void 0 : target.binary) || null,
        type: (target === null || target === void 0 ? void 0 : target.type) || null
      });
    });
    return arr;
  }
  convertInlineAttachmentsToBase64() {
    const dom = this._dom;
    const imgs = this._editor.find(dom.NEW_COMPOSE_ATTACHMENT_INLINE);
    for (let i = 0, len = imgs.length; i < len; ++i) {
      const elem = imgs[i];
      if (this._gmailUtil.elementIsInlineImage(elem)) {
        const elemSrc = jquery_pack_default()(elem).attr('src');
        if (elemSrc) {
          const base64Data = this._base64ImageCache[elemSrc];
          if (base64Data) {
            jquery_pack_default()(elem).attr('src', base64Data);
            // stop referencing this img, gmail
            jquery_pack_default()(elem).removeAttr('data-surl');
          }
        }
      }
    }
  }
  hideInlineAttachments() {
    const dom = this._dom;
    const imgs = this._editor.find(dom.NEW_COMPOSE_ATTACHMENT_INLINE);
    for (let i = 0, len = imgs.length; i < len; ++i) {
      const elem = imgs[i];
      if (this._gmailUtil.elementIsInlineImage(elem)) {
        jquery_pack_default()(elem).hide();
      }
    }
  }
  getAllUnsecureAttachments() {
    // Get both regular attachments and inline images
    return this.getUnsecureAttachments().concat(this.getUnsecureImageAttachments());
  }
  getMailSendingState() {
    return this._stateManager.getMailSendingState().requestOnce();
  }
  teardown() {
    if (this._dropZone) {
      this._dropZone.teardown();
    }

    // make sure the blobs in memory are destroyed
    for (const id of Object.keys(this._fileUrlByIdCache)) {
      URL.revokeObjectURL(this._fileUrlByIdCache[id]);
    }
    this._fileUrlByIdCache = null;
    this._fileByNameCache = null;
    this._base64ImageCache = null;
    this._context = null;
    this._unsecureAttachments = [];
    this.unsubsribeAuthorizationsUpdate();
  }
}
// EXTERNAL MODULE: ./lib/widgets/index.js
var widgets = __webpack_require__(31795);
var widgets_default = /*#__PURE__*/__webpack_require__.n(widgets);
;// ./sites/gmail/page/mods/helpers/policy-helper.js
/* provided dependency */ var policy_helper_console = __webpack_require__(31799);





class PolicyHelper {
  static checkIfMetadataKeyExists(metadataKey) {
    const keyExists = Object.values(sites.EmailMetadataEnum).includes(metadataKey);
    if (!keyExists) {
      throw new Error(`Incorrect metadata key: ${metadataKey}`);
    }
  }
  constructor({
    editor,
    policyConfigMenu,
    composeId,
    stateManager
  }) {
    this._editor = editor;
    this._policyConfigMenu = policyConfigMenu;
    this._composeId = composeId;
    this._stateManager = stateManager;
    this.unsubscribeAuthorizationsRequest = this._stateManager.getPolicyAuthorizations().requestSub(this.getAuthorizations.bind(this));
    this.unsubscribeAttachmentsMetadata = this._stateManager.getAttachmentMetadata().responseSub(this.setAttachmentMetadataForPolicy.bind(this));
    this.unsubscribeRemovingMetadataDuplicates = this._stateManager.removeMetadataDuplicates().requestSub(this.removeMetadataDuplicates.bind(this));
    (0,helpers._bindAllMethods)(this);
  }
  checkIfEmailMetadataIsLoaded() {
    return !!this.emailMetadata;
  }
  loadEmailMetadata() {
    try {
      this.emailMetadata = sites.EmailMetadata.load(this._editor);

      // If the email policy isn't defined set it's defaults
      const emailPolicy = this.getByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY) || widgets.PolicyModel.DEFAULT_OPTIONS;
      this.setByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, emailPolicy);
      this._policyConfigMenu.setOptions(emailPolicy);
      const attachmentsMetadata = this.getByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS);
      if (!attachmentsMetadata) {
        this.setByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS, {});
      }
      this.setByMetadataKey(sites.EmailMetadataEnum.COMPOSE_ID, this._composeId);
    } catch (e) {
      policy_helper_console.error('loadEmailMetadata error: ', e);
    }
  }
  hasError(emailsCount) {
    return this._policyConfigMenu.hasSms2faError(emailsCount);
  }
  getByMetadataKey(metadataKey, loadMetadataIfNull = false) {
    PolicyHelper.checkIfMetadataKeyExists(metadataKey);
    if (!this.emailMetadata && loadMetadataIfNull) {
      this.loadEmailMetadata();
    }
    if (!this.emailMetadata && !loadMetadataIfNull) {
      return null;
    }
    return this.emailMetadata.get(metadataKey);
  }
  setByMetadataKey(metadataKey, value, loadMetadataIfNull) {
    PolicyHelper.checkIfMetadataKeyExists(metadataKey);
    if (!this.emailMetadata && loadMetadataIfNull) {
      this.loadEmailMetadata();
    }
    if (!this.emailMetadata && !loadMetadataIfNull) {
      return;
    }
    this.emailMetadata.set(metadataKey, value);
  }

  /**
   * Convenience function to get the metadata for a policy
   */
  getAttachmentMetadataForPolicy(policyUuid) {
    const attachmentMetadata = this.getByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS);
    return attachmentMetadata[policyUuid];
  }

  /**
   * Convenience function to remove the metadata for a policy
   */
  removeAttachmentMetadataForPolicy(policyUuid) {
    const attachmentMetadata = this.getByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS);
    delete attachmentMetadata[policyUuid];
    this.setByMetadataKey(sites.EmailMetadata.ATTACHMENTS, attachmentMetadata);
  }

  /**
   * Convenience function to update the metadata for a policy
   */
  setAttachmentMetadataForPolicy(metadata) {
    const attachmentMetadata = this.getByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS, true);
    attachmentMetadata[metadata.policyUuid] = metadata;
    this.setByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS, attachmentMetadata);
  }
  removeMetadataDuplicates() {
    // Remove if we already have metadata
    // make sure we only have 1 metadata element
    const metadataElement = this._editor.find((email_default()).Constants.METADATA_SELECTOR);
    metadataElement.each((index, element) => {
      if (index > 0) {
        jquery_pack_default()(element).remove();
      }
    });
    this.loadEmailMetadata();
  }
  getAuthorizations() {
    const policyConfig = this.getByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, true);
    return sites.PolicyAttributes.getAuthorizations(policyConfig);
  }
  tearDown() {
    this.unsubscribeAuthorizationsRequest();
    this.unsubscribeAttachmentsMetadata();
    this.unsubscribeRemovingMetadataDuplicates();
  }
}
// EXTERNAL MODULE: ./lib/utils/virtru-offline-mode.js
var virtru_offline_mode = __webpack_require__(2883);
// EXTERNAL MODULE: ./lib/email/lib/secure-email-reader.js
var secure_email_reader = __webpack_require__(96638);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(64078);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(87568);
// EXTERNAL MODULE: ./node_modules/@virtru-private/design-system/dist/components/VirtruLoadingAnimation/VirtruLoadingAnimation.js
var VirtruLoadingAnimation = __webpack_require__(70150);
// EXTERNAL MODULE: ./lib/smart-send-secure/attachments-warn-modal.js
var attachments_warn_modal = __webpack_require__(52561);
// EXTERNAL MODULE: ./lib/widgets/WarningPopoverModal.js
var WarningPopoverModal = __webpack_require__(12221);
;// ./lib/smart-send-secure/call-stack-exceeded-modal.js
const call_stack_exceeded_modal_i18n = __webpack_require__(2622);


/**
 * Shows warning popup when call stack error appeared
 * */
function showCallStackExceededModal() {
  const modal = new WarningPopoverModal/* default */.A({
    headingText: call_stack_exceeded_modal_i18n.t('SMART_SEND_SECURE_STACK_ERROR_HEADER'),
    bodyText: call_stack_exceeded_modal_i18n.t('SMART_SEND_SECURE_STACK_ERROR_BODY'),
    blueButtonText: 'OK',
    showBlueButton: true,
    showWhiteButton: false,
    showCancel: false,
    issuesList: []
  });
  const list = modal.element.find('.popup-list-border-box');
  list.css('display', 'none');
  modal.openModal();
  modal.updateDialog(modal.options);
}
// EXTERNAL MODULE: ./lib/widgets/policy-config-menu/index.js + 7 modules
var policy_config_menu = __webpack_require__(73405);
// EXTERNAL MODULE: ./sites/gmail/page/mods/gmail-utility.js
var gmail_utility = __webpack_require__(2090);
// EXTERNAL MODULE: ./lib/sites/download-virtru-attachment.js
var download_virtru_attachment = __webpack_require__(5421);
// EXTERNAL MODULE: ./lib/utils/index.js
var utils = __webpack_require__(55675);
// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(13985);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);
// EXTERNAL MODULE: ./lib/analytics/index.js
var analytics = __webpack_require__(1246);
;// ./sites/gmail/page/mods/new-compose-utils.js
/* provided dependency */ var new_compose_utils_console = __webpack_require__(31799);
/**
 * New compose utils functionality
 */









const new_compose_utils_AnalyticsService = (0,analytics.instance)();
const getTabConfig = dom => [{
  currentElement: dom.NEW_COMPOSE_TRASH,
  nextElement: '.virtru-show-info-btn'
}, {
  currentElement: '.virtru-show-info-btn',
  nextElement: '.virtru-pcm-button',
  alternativeElement: '.virtru-toggle'
}, {
  currentElement: '.virtru-toggle',
  // Select NEW_COMPOSE_TO_VISUALS to expand recipients area, then attempt to select targets in reverse order to land on the closest one visible
  nextSequence: [dom.NEW_COMPOSE_TO_VISUALS, dom.TO_SELECT_CONTACTS, dom.NEW_COMPOSE_BCC_BUTTON, dom.NEW_COMPOSE_CC_BUTTON]
}, {
  currentElement: dom.NEW_COMPOSE_CC_BUTTON,
  nextElement: dom.NEW_COMPOSE_BCC_BUTTON,
  alternativeElement: dom.TO_SELECT_CONTACTS
}, {
  currentElement: dom.NEW_COMPOSE_BCC_BUTTON,
  nextElement: dom.TO_SELECT_CONTACTS
},
// Since we scope selection to the parent container, this keeps us from jumping to a reply open in the background in some cases
{
  currentElement: dom.NEW_COMPOSE_EDITOR,
  nextElement: dom.NEW_COMPOSE_SEND_BUTTON
}];
const getShiftTabConfig = dom => [{
  currentElement: dom.TO_SELECT_CONTACTS,
  nextElement: dom.NEW_COMPOSE_BCC_BUTTON,
  alternativeElement: dom.NEW_COMPOSE_CC_BUTTON
}, {
  currentElement: dom.NEW_COMPOSE_CC_BUTTON,
  nextElement: '.virtru-toggle'
}, {
  currentElement: dom.NEW_COMPOSE_BCC_BUTTON,
  nextElement: dom.NEW_COMPOSE_CC_BUTTON,
  alternativeElement: '.virtru-toggle'
}, {
  currentElement: '.virtru-toggle',
  nextElement: '.virtru-show-info-btn'
}, {
  currentElement: '.virtru-show-info-btn',
  nextElement: dom.NEW_COMPOSE_TRASH
}];
const isActivated = user => user.auth('status') === 'active';

// This function should be called only in context (with bind or call)
const callTearDownAndClear = function (name) {
  if (this && this[name]) {
    this[name].teardownAll();
    this[name] = null;
  }
};
const getDriveAttachments = (dom, editor) => {
  const arr = [];
  const gdrive = editor.find(dom.NEW_COMPOSE_ATTACHMENT_GOOGLEDRIVE);
  gdrive.each((_index, elem) => {
    const link = jquery_pack_default()('a', elem);
    const id = link.attr('href').replace('https://docs.google.com/file/d/', '').replace(/\/edit.*/, ''); // This gets the id
    const url = `https://googledrive.com/host/${id}`;
    arr.push({
      url,
      name: link.find('span').text(),
      chip: elem
    });
  });
  return arr;
};
const removeInlineImageAttachments = (dom, editor) => {
  var imgs = editor.find(dom.NEW_COMPOSE_ATTACHMENT_INLINE);
  for (let i = 0, len = imgs.length; i < len; ++i) {
    const elem = imgs[i];
    if (gmail_utility.elementIsInlineImage(elem)) {
      jquery_pack_default()(elem).remove();
    }
  }
};
const _restoreDownloadVirtruAttachmentMods = async (settings, editor) => {
  const promises = [];
  const attachmentChips = jquery_pack_default()('.virtru-attachment', editor);
  for (let i = 0, len = attachmentChips.length; i < len; i++) {
    const mod = new download_virtru_attachment.DownloadVirtruAttachmentMod(settings, attachmentChips[i], sdk.transports);
    promises.push(mod.setup({
      withPreviewIcons: false
    }));
  }
  return Promise.all(promises);
};

/**
 * If trimmed content has already been shown we should find the
 * replacement html, delete it, and then reinsert it.  This is
 * necessary because GMail strips all styling from the content.
 */
const setupExpandedTrimmedContent = element => {
  const replacement = element.find(sites.InvitationEmailReplacement.selector);
  if (replacement.length === 0) {
    return;
  }
  const parentDiv = replacement.parent();
  jquery_pack_default()(sites.InvitationEmailReplacement.html).insertBefore(parentDiv);
  parentDiv.remove();
};

/**
 This method fires events in a way that is more reliable in gmail
 than the event triggers provided by jQuery.
 @param {Object} node - DOM node to which we are attaching
 @param {String} eventName - The type of event we are triggering
 */
const fireEvent = (node, eventName) => {
  let doc;
  if (node.ownerDocument) {
    doc = node.ownerDocument;
  } else if (node.nodeType === 9) {
    // the node may be the document itself, nodeType 9 = DOCUMENT_NODE
    doc = node;
  } else {
    throw new Error(`Invalid node passed to JSUtil.fireEvent: ${node.id}`);
  }

  // TODO change conditions - create two functions
  if (node.fireEvent) {
    // IE-style
    const event = doc.createEventObject();
    event.synthetic = true; // allow detection of synthetic events
    node.fireEvent(`on${eventName}`, event);
  } else if (node.dispatchEvent) {
    // Gecko-style approach is much more difficult.
    let eventClass = '';

    // Different events have different event classes.
    // If this switch statement can't map an eventName to an eventClass,
    // the event firing is going to fail.
    switch (eventName) {
      case 'click':
        break;
      // Dispatching of 'click' appears to not work correctly in Safari.
      // Use 'mousedown' or 'mouseup' instead.
      case 'mousedown':
      case 'mouseup':
        eventClass = 'MouseEvents';
        break;
      case 'focus':
      case 'change':
      case 'blur':
      case 'select':
        eventClass = 'HTMLEvents';
        break;
      default:
        throw `JSUtil.fireEvent: Couldn't find an event class for event '${eventName}'.`;
    }
    const event = doc.createEvent(eventClass);
    const bubbles = eventName !== 'change';

    // All events created as bubbling and cancelable.
    event.initEvent(eventName, bubbles, true);

    // allow detection of synthetic events
    event.synthetic = true;
    node.dispatchEvent(event);
  }
};
const failureInSetup = function (_composeId, callback, context, err) {
  new_compose_utils_console.error(`Failed to set up compose window... ${_composeId}`, err);
  // Throw a client error if it hasn't been handled
  if (!err.handled) {
    new_compose_utils_AnalyticsService.clientError({
      context: 'new_compose',
      name: 'Compose initialization error',
      error_obj: {
        context,
        error: (0,sanitizeAnalyticsError/* default */.A)(err)
      }
    }, true);
  }
  new_compose_utils_AnalyticsService.composeInfo({
    success: false,
    context: 'normal',
    error_obj: (0,sanitizeAnalyticsError/* default */.A)(err)
  }, false);

  // TODO put code here to flip back to non-secure mode on failure
  callback();
};
const forceInitialResize = function () {
  var delay = 10;
  var resize = function () {
    jquery_pack_default()(window).triggerNative('resize');
    delay *= 2;
    if (delay < 2561) {
      setTimeout(resize, delay);
    }
  };
  setTimeout(resize, delay);
};
const contextHandler = () => {
  const sel = window.getSelection();
  if (sel.anchorNode.nodeType === Element.ELEMENT_NODE || sel.type === 'Caret') {
    setTimeout(() => {
      sel.collapseToStart();
    });
  }
};

// Strips out zero-width whitespace that breaks validating the email address
// and can sometimes make its way in there
const emailSpanToEmail = (element, dataAttribute = 'email') => element.getAttribute(dataAttribute).replace(/\u200B/g, '');
const getSelectedRecipients = (nodes, dataAttribute = 'email') => Array.from(nodes).map(el => emailSpanToEmail(el, dataAttribute));

/**
 * Picks up email candidates from typed input. Supports same delimiter variations as Gmail.
 * e.g. "a@b.c, x@y.z foo@bar.baz;test@virtru.com" => ["a@b.c", "x@y.z", "foo@bar.baz", "test@virtru.com"]
 * @param nodes
 * @returns {*}
 */
const getTypedRecipients = nodes => {
  // there is always one element within typed NodeList
  const typed = Array.from(nodes)[0];
  const rawValue = (typed === null || typed === void 0 ? void 0 : typed.value) || '';
  const re = /[,;]/g;
  return rawValue.replace(re, ' ') // narrow possible delimiters to spaces
  .split(' ').filter(Boolean); // omit empty string results produced by splitting out excessive spaces
};
const isOnboardingActive = function (user) {
  // set up onboarding if the use hasn't seen it yet
  if (user.setting('preferences.showOnboardingTour') !== undefined) {
    return user.setting('preferences.showOnboardingTour');
  } else if (user.setting('onboarding')) {
    return user.setting('onboarding.isActive');
  }
  return true;
};
const getBodyHTML = function (element) {
  return `<div>${element.html()}</div>`;
};
const doConvertInlineImagesToBase64 = function (user) {
  return utils.isFeatureEnabled(user._profile, 'base64InlineImages');
};
const getRemainingTime = function (policyModel) {
  if (policyModel.expires && policyModel.expirationDate) {
    const start = moment_default()();
    const end = moment_default()(policyModel.expirationDate);
    return end.from(start);
  }
  return null;
};
const refreshFormattingButton = function (element, dom) {
  // refresh the formatting button if the format menu is open
  // TODO This fires too quickly. Move this to a callback after the setup
  // operation is complete and buttons are in the correct position
  const formatButton = element.find(dom.NEW_REPLY_FORMATTING);
  if (formatButton.parent().parent().parent().attr('aria-pressed') === 'true') {
    formatButton.triggerNative('mousedown');
    formatButton.triggerNative('mousedown');
    formatButton.triggerNative('mouseout');
  }
  const slideOutBar = element.find(dom.NEW_REPLY_SLIDEOUT_BAR);
  let leftPx = slideOutBar.css('left');
  leftPx = leftPx.replace('/px/', '');
  const leftVal = parseInt(leftPx, 10) + 15;
  slideOutBar.css('left', `${leftVal}px`);
};
const determineDefaultVirtruState = function (previousVirtruState, userDefaultVirtruState, orgDefaultVirtruState, orgDefaultVirtruStateOverride) {
  // Default to off
  let secureModeSetting = false;

  // If org-wide default state is set and user is not allowed to override
  if (orgDefaultVirtruState && !orgDefaultVirtruStateOverride) {
    secureModeSetting = orgDefaultVirtruState;
    // If org-wide default state is set and user is allowed to override and has a default state
  } else if (orgDefaultVirtruStateOverride && userDefaultVirtruState) {
    secureModeSetting = userDefaultVirtruState;
    // If org-wide default state is set and user is allowed to override but does not have default state
  } else if (orgDefaultVirtruState) {
    secureModeSetting = orgDefaultVirtruState;
    // If no org-wide default is set and has user preference set
  } else if (userDefaultVirtruState) {
    secureModeSetting = userDefaultVirtruState;
    // If neither org-wide nor user has a default state set and has previous state set
  } else if (previousVirtruState) {
    secureModeSetting = previousVirtruState;
  }

  // Convert state to boolean
  if (secureModeSetting == 'sticky') {
    return previousVirtruState;
  }
  return secureModeSetting == 'on' || secureModeSetting === true;
};
// EXTERNAL MODULE: ./sites/gmail/page/xhr/PredictiveInterceptor.js
var PredictiveInterceptor = __webpack_require__(86278);
// EXTERNAL MODULE: ./lib/sites/attachments/attachment-util.js
var attachment_util = __webpack_require__(31027);
// EXTERNAL MODULE: ./node_modules/@virtru-private/secure-lib/libs/remote-content-service.js
var remote_content_service = __webpack_require__(20318);
var remote_content_service_default = /*#__PURE__*/__webpack_require__.n(remote_content_service);
;// ./sites/gmail/page/mods/compose-keyboard-shortcuts.js
/* provided dependency */ var compose_keyboard_shortcuts_console = __webpack_require__(31799);

var $ = __webpack_require__(55401);
var contexts = __webpack_require__(47446);
var mods = __webpack_require__(25939);
var Emitter = __webpack_require__(16502);

/**
 * The keyboard shortcuts mod
 */
class ComposeKeyboardShortcuts extends mods.Mod {
  constructor(context) {
    super(context._settings, context._element);
    this._context = context;
    this._settings = context._settings;
    this._element = $(context._element);
    this._composeId = this._element.attr('composeId');
    this._editor = context._editor;
    this._toggle = context._toggle;
    (0,helpers._bindAllMethods)(this);
  }
  setup() {
    try {
      this.interceptKeyboardSend();
    } catch (err) {
      compose_keyboard_shortcuts_console.log('There was an error setting up the keyboard shortcuts mod.');
      compose_keyboard_shortcuts_console.log(err);
    }
  }

  /**
   * This function adds an event listener on the body of the document
   * during the capture phase for all keydown events.  The logic behind
   * the handling of events is described in handleKeyboardSend.
   */
  interceptKeyboardSend() {
    // Listen on the full compose window for keydown events
    this._element[0].addEventListener('keydown', this.handleKeydown, true);
  }

  /**
   * Handle a ctrl/cmd + Enter key press only.  The logic is
   *   1. Is it an 'enter' press
   *   2. Is the 'metaKey' or CMD/Ctrl key pressed
   *   3. Does the composeId of the target match the composeId of the mod
   *   4. Is the target the New Compose Editor or the subject element
   *   5. Is secure mode enabled, if so, emit event
   */
  handleKeydown(event) {
    try {
      // Do the simple, quick checks first
      if (event.keyCode === 13 && (event.metaKey || event.ctrlKey)) {
        this.handleKeyboardSend(event);
      }
    } catch (err) {
      compose_keyboard_shortcuts_console.log('There was an error in handleKeyboardSend.');
      compose_keyboard_shortcuts_console.log(err);
    }
  }
  handleKeyboardSend(event) {
    // In the event of a tab into the editor window the target will be the HTML
    // element.. we need to track the body
    var $target = null;
    if (event.target.localName === 'html') {
      $target = $(event.target).find('body');
    } else {
      $target = $(event.target);
    }
    var {
      dom
    } = this._settings;
    var composeId = this._element.attr('composeId');
    var targetComposeId = $target.attr('composeId');
    if (!targetComposeId) {
      var parent = $target.parents(dom.NEW_COMPOSER_SELECTOR);
      if (parent) {
        targetComposeId = parent.attr('composeId');
      }
    }
    if (composeId === targetComposeId) {
      var editorClassName = dom.NEW_COMPOSE_EDITOR.substring(1);
      var inputClassName = dom.NEW_COMPOSE_SUBJECT_CLASS_NAME;
      var recipientsName = dom.RECIPIENT_INPUT.substring(1).replace('.', ' ');
      var targetClassName = $target.attr('class');

      // Tests if security is on
      // Only trigger send if recipients input, subject or body has focus.
      if (targetClassName.indexOf(editorClassName) >= 0 || targetClassName.indexOf(inputClassName) >= 0 || targetClassName.indexOf(recipientsName) >= 0) {
        // Stop the event from propagating
        event.preventDefault();
        event.stopPropagation();
        event.stopImmediatePropagation();

        // Signal a send secure
        this.emit(Send_Email, this);
      }
    }
  }
  teardown() {
    try {
      this._element[0].removeEventListener('keydown', this.handleKeydown, true);
    } catch (err) {
      compose_keyboard_shortcuts_console.log('Error in ComposeKeyboardShortcuts mod.');
      compose_keyboard_shortcuts_console.log(err);
    }
  }
}

/**
 * Event for when the send button is clicked triggered.
 *
 * @type {string}
 */
const Send_Email = ComposeKeyboardShortcuts.Send_Email = 'send-email';
Emitter(ComposeKeyboardShortcuts.prototype);
contexts.addOpen(ComposeKeyboardShortcuts);
;// ./sites/gmail/page/mods/new-compose-send-buttons.js

var new_compose_send_buttons_$ = __webpack_require__(55401);
var new_compose_send_buttons_contexts = __webpack_require__(47446);
var new_compose_send_buttons_mods = __webpack_require__(25939);
var new_compose_send_buttons_Emitter = __webpack_require__(16502);
var new_compose_send_buttons_i18n = __webpack_require__(2622);
var Popover = __webpack_require__(55929);
const VirtruOfflineMode = (__webpack_require__(2883)/* ["default"] */ .A);
const TooltipHelper = (__webpack_require__(85149)/* ["default"] */ .A);
const disabledButtonClass = 'virtru-disabled-button';
const secureSendOptionsClass = 'virtru-send-secure-option';
const secureSendOptionsPopupClass = 'virtru-send-secure-option-popup';
const secureSendOptionsPopupContainer = 'virtru-send-secure-button-popup-container';
/**
 * The send button mod
 */
class NewComposeSendButtonsMod extends new_compose_send_buttons_mods.Mod {
  constructor(settings, element, context) {
    super(settings, element);
    this._settings = settings;
    this._element = new_compose_send_buttons_$(element);
    this._virtruOfflineMode = new VirtruOfflineMode(this._settings.user._profile);
    this._isPopoutWarningAttached = false;
    this._isPopoutWarningEnabled = false;
    (0,helpers._bindAllMethods)(this);

    // Import specific methods from context
    Object.assign(this, {
      getToggleState: context.getToggleState,
      _sendSecureMod: context._sendSecureMod,
      _hasBeenSent: context._hasBeenSent,
      setupSendEmailError: context.setupSendEmailError,
      animationHelper: context.animationHelper
    });
  }
  setup() {
    var sendButtons = this._element;
    var self = this;
    sendButtons.hide();
    sendButtons.addClass('virtru-modded');
    sendButtons.each(function (_, sendButton) {
      sendButton = new_compose_send_buttons_$(sendButton);
      const sendSecureButtons = sendButton.clone();
      // Remove class to avoid mixmax plugin intercept send event
      sendSecureButtons.removeClass(self._settings.dom.NEW_COMPOSE_SEND_BUTTON_CLASS);
      self.resetTabActions(sendSecureButtons);
      self.attachElement({
        element: sendSecureButtons
      });
      sendButton.before(sendSecureButtons);

      // keep track of the send button so we can disable/enable it later
      self._sendButton = sendSecureButtons;
      self.reinitializeButtons(sendSecureButtons);
      sendSecureButtons.on('click', self.sendButtonClicked);
      self._sendSecureButtons = sendSecureButtons;
    });
    this._settings.on('load:user', this.userProfileUpdated);
    this._virtruOfflineMode.onChange(this.updateSendButtonTooltip);
    this.checkMailMerge();
  }
  resetTabActions(sendButton) {
    const SPACE_KEY = 32;
    const ENTER_KEY = 13;
    sendButton.keydown(e => {
      if (e.which === SPACE_KEY || e.which === ENTER_KEY) {
        sendButton.click();
      }
    });
  }
  reinitializeButtons(sendSecureButtons) {
    var eject = !sendSecureButtons;
    sendSecureButtons = sendSecureButtons || this._sendSecureButtons;
    if (this.isMailMergeActive()) {
      sendSecureButtons.show();
      return;
    }
    this._sendButtonTooltip = TooltipHelper.createPopover({
      $icon: sendSecureButtons,
      content: new_compose_send_buttons_i18n.t('COMMON_SEND_SECURE_TOOLTIP_OFFLINE'),
      position: 'southwest',
      delay: null
    });
    this.updateSendButtonTooltip();
    if (this.getToggleState() === 'on') {
      sendSecureButtons.text(new_compose_send_buttons_i18n.t('COMMON_SEND_SECURE'));
      this.disableSendOptionsButton();
    } else {
      this.enableSendOptionsButton();
    }

    // If reinitializing an existing button set, we can stop here.
    if (eject) {
      return;
    }
    sendSecureButtons.removeAttr('id');
    sendSecureButtons.show();
  }
  createPopover(anchor, text, title, position, showTimer) {
    var popover = new Popover(text, title);
    popover.classname += ' virtru-popover-dark virtru-popover-policy-config-offset';
    popover.position(position);
    popover.setShowTimer(showTimer);
    popover.attach(anchor);
    return popover;
  }
  teardown() {
    var sendButtons = this._element;
    sendButtons.removeClass('virtru-modded');

    // Replace send button text
    if (!this.isMailMergeActive()) {
      this._sendSecureButtons.text(new_compose_send_buttons_i18n.t('COMMON_SEND'));
      this.enableSendOptionsButton();
      this.updateSendButtonTooltip();
    }
  }

  /**
   * Triggers the a click on the original send button
   */
  triggerGmailSend() {
    // FIXME total hack
    var sendButton = new_compose_send_buttons_$(this._element[0]);
    sendButton.triggerNative('mouseover');
    sendButton.triggerNative('mousedown');
    sendButton.triggerNative('mouseup');
    sendButton.triggerNative('mouseout');
    sendButton.triggerNative('click');
  }

  /**
   * Emits an event for the send secure click
   */
  sendButtonClicked() {
    if (this._virtruOfflineMode.isOnline() || this.getToggleState() === 'off') {
      this.emit(new_compose_send_buttons_Send_Email);
    }
  }

  /**
   * Allow send button to be disabled (used during attachment uploading)
   */
  disableSendButton() {
    this.animationHelper.disableSendButtonAnimate(this._sendButton);
  }

  /**
   * Allow send button to be enabled (used during attachment uploading)
   */
  enableSendButton() {
    if (this._settings.user.permissions.canCreatePolicies) {
      this._sendButton.addClass('virtru-send-secure');
      this._sendButton.siblings(this._settings.dom.NEW_COMPOSE_SEND_BUTTON_OPTION).addClass('gmail-more-send-options');
      this._sendButton.parent(this._settings.dom.SEND_BUTTON_CONTAINER).addClass('gmail-send-button-container');
      this.animationHelper.enableSendButtonAnimate(this._sendButton);
    }
  }

  /**
   * React to updated user profile
   */
  userProfileUpdated() {
    this.reinitializeButtons(this._sendSecureButtons);
  }

  /**
   * Disabling send options button
   */
  disableSendOptionsButton() {
    if (!this._sendButton) {
      return;
    }
    if (this.sendOptionsButton) {
      this.sendOptionsButton.show();
      this.sendDefaultOptionsButton.hide();
    } else {
      this.sendDefaultOptionsButton = this._sendButton.siblings(this._settings.dom.NEW_COMPOSE_SEND_BUTTON_OPTION);
      this.sendOptionsButton = this.sendDefaultOptionsButton.clone();
      this.sendOptionsButton.css('pointer-events', 'auto');
      this.sendDefaultOptionsButton.after(this.sendOptionsButton);
      this.sendDefaultOptionsButton.hide();
      this.sendOptionsLabelDefaults = {
        ariaLabel: this.sendOptionsButton.attr('aria-label'),
        dataTooltip: this.sendOptionsButton.attr('data-tooltip')
      };
      this.sendOptionsButton.addClass(secureSendOptionsClass).addClass(disabledButtonClass).attr('aria-label', null).attr('data-tooltip', null).attr('tabindex', '-1');
      this.setStylesSendOptionsPopup();
    }
    if (this.popover) {
      this.popover.enable();
    } else {
      this.popover = this.createPopover(this.sendOptionsButton, new_compose_send_buttons_i18n.t('SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE_TOOLTIP'), undefined, 'south', 800);
    }
  }

  /**
   * Enabling send options button with styles
   * And update popup of send button options
   */
  enableSendOptionsButton() {
    if (!this._sendButton) {
      return;
    }
    if (this.popover) {
      this.popover.disable();
    }
    if (this.sendDefaultOptionsButton) {
      this.sendOptionsButton.hide();
      this.sendDefaultOptionsButton.show();
    }
    this.setStylesSendOptionsPopup();
  }

  /**
   * Getting parent main container of secure button
   *
   * @return {jQueryElement} main parent compose window of secure button
   */
  getComposeContainer() {
    const fullComposeContainer = this._settings.dom.NEW_COMPOSE_FULL_SCREEN_BACKGROUND;
    return this._sendButton.closest(fullComposeContainer);
  }

  /**
   * Set styles for send button options popup.
   * It added class, which changed placement of the small popup
   * And localed it to same place where send secure/send archive buttons located.
   */
  setStylesSendOptionsPopup() {
    const optionsSelector = this._settings.dom.NEW_COMPOSE_SEND_BUTTON_OPTION_POPUP;

    // Get full compose window and find there options popup
    const newOptions = this.getComposeContainer().parent().children(optionsSelector);
    if (!newOptions || !newOptions.length) {
      return;
    }

    // Add class to change position of element
    newOptions.addClass(secureSendOptionsPopupClass);

    // Create container for popup
    const newDiv = new_compose_send_buttons_$('<div></div>');
    newDiv.addClass(secureSendOptionsPopupContainer);

    // And insert it before send button to place element using styles only
    newDiv.insertBefore(this._sendButton);

    // Move into container with its created container
    newOptions.detach().appendTo(newDiv);
  }
  updateSendButtonTooltip() {
    if (this._virtruOfflineMode.isOffline() && this.getToggleState() === 'on') {
      this._sendButtonTooltip.enable();
    } else {
      this._sendButtonTooltip.disable().hide();
    }
  }
  disableSwitchingToPopoutWarning() {
    this._isPopoutWarningEnabled = false;
  }
  enableSwitchingToPopoutWarning(onSwitch) {
    this._isPopoutWarningEnabled = true;
    if (!this._isPopoutWarningAttached) {
      this._isPopoutWarningAttached = true;
      this._initSwitchingToPopoutWarning(onSwitch);
    }
  }
  _initSwitchingToPopoutWarning(onSwitch) {
    const {
      dom
    } = this._settings;
    const isPopout = document.body.matches(dom.POPOUT_WINDOW);
    const popoutButtonSelector = isPopout ? dom.POP_IN_BUTTON : dom.POP_OUT_BUTTON;
    const gmailContainer = this._sendButton.closest(dom.GMAIL);
    const buttonsContainer = isPopout ? gmailContainer : gmailContainer.prev(dom.NEW_COMPOSE_TITLEBAR);
    const popButton = buttonsContainer.find(popoutButtonSelector).get(0);

    // We attach listener to parent node to successfully stop propagation
    popButton.parentNode.addEventListener(isPopout ? 'click' : 'mouseup', event => {
      // If no attachments in progress
      if (!this._isPopoutWarningEnabled) {
        return;
      }

      // Ignore other children events
      const isAnotherNode = event.target !== popButton;
      if (isAnotherNode) {
        return;
      }

      // When in popout mode it will always pop in if user clicks the button
      // but in regular mode it only pops out when shift key is pressed
      const isSwitchingEvent = isPopout ? true : event.shiftKey;
      if (!isSwitchingEvent) {
        return;
      }
      const confirmSwitchingText = new_compose_send_buttons_i18n.t('REATTACH_FILE_WARNING_MESSAGE', {
        context: isPopout ? 'POP_IN' : 'POP_OUT'
      });
      const isSwitchingConfirmed = confirm(confirmSwitchingText);
      if (isSwitchingConfirmed) {
        onSwitch();
      } else {
        event.stopPropagation();
      }
    }, true);
  }
  isMailMergeActive() {
    return this._element.parents(this._settings.dom.MAIL_MERGE_COMPOSE_BODY).length > 0;
  }

  /**
   * Check if the mail merge mode is active and hide the default send button
   */
  checkMailMerge() {
    function applyUIChanges() {
      if (this.isMailMergeActive()) {
        const buttonLabel = this._sendButton.next(this._settings.dom.NEW_COMPOSE_SEND_BUTTON).attr('aria-label');
        this._sendButton.text(buttonLabel); // "Continue"
        this._sendButton.addClass('round mail-merge-send-button');
      } else {
        // remove mail merge classes from the send button
        // and add 'virtru-send-secure' in case it wasn't added before
        // for example, when opening a draft with mail merge mode on
        this._sendButton.removeClass('round mail-merge-send-button');
        this._sendButton.text(new_compose_send_buttons_i18n.t('COMMON_SEND'));
      }
    }
    new_compose_send_buttons_$(document).on('click', this._settings.dom.MAIL_MERGE_MENU, applyUIChanges.bind(this)); // apply changes on toggle mail merge mode
    applyUIChanges.call(this); // apply changes on load
  }
  addVirtruStyles() {
    this._sendButton.addClass('virtru-send-secure');
    this._sendButton.siblings(this._settings.dom.NEW_COMPOSE_SEND_BUTTON_OPTION).addClass('gmail-more-send-options');
  }
  revertToGmailStyles() {
    this._sendButton.removeClass('virtru-send-secure');
    this._sendButton.siblings(this._settings.dom.NEW_COMPOSE_SEND_BUTTON_OPTION).removeClass('gmail-more-send-options');
  }
}

/**
 * Event for when the send button is clicked.
 *
 * @type {string}
 */
const new_compose_send_buttons_Send_Email = NewComposeSendButtonsMod.Send_Email = 'send-email';
new_compose_send_buttons_Emitter(NewComposeSendButtonsMod.prototype);
Object.assign(NewComposeSendButtonsMod.prototype, new_compose_send_buttons_mods.ModElementShortcut);
new_compose_send_buttons_contexts.addOpen(NewComposeSendButtonsMod);
// EXTERNAL MODULE: ./sites/gmail/page/mods/new-compose-send-archive-button.js
var new_compose_send_archive_button = __webpack_require__(59195);
var new_compose_send_archive_button_default = /*#__PURE__*/__webpack_require__.n(new_compose_send_archive_button);
;// ./sites/gmail/page/mods/new-compose-recipients.js
const new_compose_recipients_$ = __webpack_require__(55401);
const new_compose_recipients_contexts = __webpack_require__(47446);
const new_compose_recipients_mods = __webpack_require__(25939);
const new_compose_recipients_Emitter = __webpack_require__(16502);

/**
 * The send button mod
 */
class NewComposeRecipientsMod extends new_compose_recipients_mods.Mod {
  constructor(context) {
    super(context._settings, context._element);
    // Import specific keys from context
    Object.assign(this, {
      _element: context._element,
      _settings: context._settings,
      fireEvent: context.fireEvent,
      onceFinds: context.onceFinds
    });

    // "Cc" and "Bcc" buttons in the compose window
    this.expandos = {
      cc: true,
      bcc: true
    };

    // Fix autofocus of the recipient input
    this.focusTo();
  }
  focusTo() {
    const {
      dom
    } = this._settings;
    const toSelected = this._element.find(dom.TO_SELECTED);
    const input = toSelected.find(dom.RECIPIENT_INPUT);
    if (input.length) {
      input.focus();
      return;
    }
    const alternateInput = toSelected.find(dom.RECIPIENT_INPUT_ALTERNATE);
    alternateInput.focus();
  }
  add(type, actionObj) {
    if (!actionObj.value || !actionObj.value.addresses || !actionObj.value.addresses.length > 0) {
      return;
    }
    actionObj.value.addresses.forEach(address => {
      this.addOne(address, type);
    });
  }
  addOne(address, type) {
    // The "Cc" and "Bcc" compose buttons must be clicked in order for
    // Gmail to recognize programtically added recipients
    if (this.expandos[type]) {
      this.addCCBCC(address, type);
      return;
    }
    this.addTo(address);
  }
  addTo(address) {
    const {
      dom
    } = this._settings;
    if (new_compose_recipients_$(dom.RECIPIENT_BUBBLES_SELECTOR_TO).map(function () {
      return new_compose_recipients_$(this).attr(dom.NEW_COMPOSE_DATA_ATTRIBUTE);
    }).toArray().indexOf(address) >= 0) {
      return;
    }
    const input = this._element.find(dom.TO_SELECTED).find(dom.RECIPIENT_INPUT);
    input.val(address);
  }
  addCCBCC(address, type) {
    var {
      dom
    } = this._settings;
    const selectors = {
      cc: {
        EXPAND_SELECTOR: dom.EXPAND_SELECTOR_CC,
        BUBBLES: dom.RECIPIENT_BUBBLES_SELECTOR_CC,
        INPUT: dom.RECIPIENT_INPUT_CC
      },
      bcc: {
        EXPAND_SELECTOR: dom.EXPAND_SELECTOR_BCC,
        BUBBLES: dom.RECIPIENT_BUBBLES_SELECTOR_BCC,
        INPUT: dom.RECIPIENT_INPUT_BCC
      }
    };
    const recipientsBlock = document.querySelector(dom.BCC_AND_CC_BLOCK);
    if (recipientsBlock) {
      const previousHeight = recipientsBlock.style.height;
      const {
        marginBottom
      } = recipientsBlock.style;
      const {
        paddingTop
      } = recipientsBlock.style;
      recipientsBlock.style.visibility = 'hidden';
      recipientsBlock.style.height = '0px';
      recipientsBlock.style.marginBottom = '-1px';
      recipientsBlock.style.paddingTop = '1px';
      recipientsBlock.style.display = 'block';

      // Check existence of email
      if (Array.from(document.querySelectorAll(selectors[type].BUBBLES)).map(itm => {
        var _itm$dataset;
        return itm === null || itm === void 0 ? void 0 : (_itm$dataset = itm.dataset) === null || _itm$dataset === void 0 ? void 0 : _itm$dataset.hovercardId;
      }).indexOf(address) === -1) {
        var _document$querySelect;
        (_document$querySelect = document.querySelector(selectors[type].EXPAND_SELECTOR)) === null || _document$querySelect === void 0 ? void 0 : _document$querySelect.click();
        const input = document.querySelector(selectors[type].INPUT);
        if (input) {
          input.value = address;
        }
      }
      recipientsBlock.style.visibility = 'visible';
      recipientsBlock.style.height = previousHeight;
      recipientsBlock.style.marginBottom = marginBottom;
      recipientsBlock.style.paddingTop = paddingTop;
      recipientsBlock.style.display = 'none';
    }
  }
  teardown() {
    // do nothing.
  }
}
new_compose_recipients_contexts.addOpen(NewComposeRecipientsMod);
new_compose_recipients_Emitter(NewComposeRecipientsMod.prototype);
Object.assign(NewComposeRecipientsMod.prototype, new_compose_recipients_mods.ModElementShortcut);
;// ./sites/gmail/page/mods/new-compose-attachment.js
var new_compose_attachment_mods = __webpack_require__(25939);
var new_compose_attachment_contexts = __webpack_require__(47446);
var new_compose_attachment_$ = __webpack_require__(55401);
var new_compose_attachment_Emitter = __webpack_require__(16502);

/**
 * Creates a new NewComposeAttachmentMod around the attachment
 * container element.
 *
 * @param settings Current users settings
 * @param element The attachment container element
 * @param filename The filename for the attachment
 * @constructor
 */
class NewComposeAttachmentMod extends new_compose_attachment_mods.Mod {
  constructor(settings, element, filename) {
    super(settings, element);
    this._settings = settings;
    this._element = new_compose_attachment_$(element);
    this._filename = filename;
    this.hookDeleteButton = this.hookDeleteButton.bind(this);
    this.deleteAttachmentClick = this.deleteAttachmentClick.bind(this);
  }

  /**
   * Selects all attachment divs given the context
   *
   * @param dom
   * @param context
   * @returns {*|jQuery|HTMLElement}
   */
  static select(dom, context) {
    return new_compose_attachment_$(dom.NEW_COMPOSE_ATTACHMENT, context);
  }

  /**
   * Initializes the Mod.
   */
  setup() {
    var self = this;

    // Process the file name
    var splitFilename = this._filename.toLowerCase().split('.');
    var extension = splitFilename.slice(-1)[0];

    // Skip if not tdf
    if (extension !== 'tdf') {
      return;
    }
    self.hookDeleteButton();
  }
  getClonedDeleteButton() {
    return this._clonedDeleteButton;
  }
  hookDeleteButton() {
    var element = this._element;
    var {
      dom
    } = this._settings;
    var $deleteButton = new_compose_attachment_$(dom.NEW_COMPOSE_DELETE_ATTACHMENT, element);
    var $clone = $deleteButton.clone();
    this._clonedDeleteButton = $clone;
    $clone.removeAttr('id');
    $clone.insertBefore($deleteButton);
    $clone.on('click', this.deleteAttachmentClick);
    $clone.data('original', $deleteButton);
    $deleteButton.hide();
  }
  deleteAttachmentClick(event) {
    var $clone = new_compose_attachment_$(event.target);
    var $delete = $clone.data('original');

    // Update email metadata
    this.emit('attachment-deleted', new_compose_attachment_$(this._element).attr('policyuuid'));

    // Not sure which of these actually triggers delete but can't hurt
    // to have them all.
    $delete.triggerNative('mouseover');
    $delete.triggerNative('mousedown');
    $delete.triggerNative('mouseup');
    $delete.triggerNative('mouseout');
  }
}
Object.assign(NewComposeAttachmentMod.prototype, new_compose_attachment_mods.ModWaiterPromises);
Object.assign(NewComposeAttachmentMod.prototype, new_compose_attachment_mods.ModElementShortcut);
Object.assign(NewComposeAttachmentMod.prototype, new_compose_attachment_mods.ModEventListenerShortcut);
new_compose_attachment_contexts.addOpen(NewComposeAttachmentMod);
new_compose_attachment_Emitter(NewComposeAttachmentMod.prototype);
;// ./sites/gmail/page/mods/new-compose-border.js
var new_compose_border_mods = __webpack_require__(25939);
var new_compose_border_contexts = __webpack_require__(47446);
var new_compose_border_$ = __webpack_require__(55401);

/**
 * New compose border mod.
 *
 * Adds bordering sexiness per designs for new compose window
 */
class NewComposeBorderMod extends new_compose_border_mods.Mod {
  constructor(settings, isNewCompose, element) {
    super(settings, element);
    this._settings = settings;
    this._element = new_compose_border_$(element);
    this._isNewCompose = isNewCompose;
  }
  setup() {
    this.addClassesToElement(this._element, {
      classes: [this._isNewCompose ? 'virtru-new-compose-borders' : 'virtru-reply-borders']
    });
    var bottomBarElements = this._element.find(this._settings.dom.NEW_COMPOSE_BOTTOM_BAR).children();
    for (var i = 0, len = bottomBarElements.length; i < len; i++) {
      this.addClassesToElement(bottomBarElements[i], {
        classes: ['bottom-bar-elements']
      });
    }
    this.setupAdditionalStyles();
  }
  setupBottomBarMenu() {
    const bottomBar = this._element.find(this._settings.dom.NEW_COMPOSE_BOTTOM_BAR_CONTAINER);
    this.addClassesToElement(bottomBar, {
      classes: ['NEW_COMPOSE_BOTTOM_BAR_CONTAINER']
    });
  }
  setupDriveIconBottomBar() {
    const googleDocs = this._element.find(this._settings.dom.GOOGLE_DOCS_BUTTON);
    this.addClassesToElement(googleDocs, {
      classes: ['GOOGLE_DOCS_BUTTON']
    });
  }
  setupAdditionalStyles() {
    this.setupBottomBarMenu();
    this.setupDriveIconBottomBar();
  }
}
Object.assign(NewComposeBorderMod.prototype, new_compose_border_mods.ModCSSClassShortcut);
new_compose_border_contexts.addOpen(NewComposeBorderMod);
;// ./sites/gmail/page/mods/new-compose-insert-from-drive.js

var new_compose_insert_from_drive_$ = __webpack_require__(55401);
var new_compose_insert_from_drive_contexts = __webpack_require__(47446);
var new_compose_insert_from_drive_mods = __webpack_require__(25939);
var {
  DismissPopover
} = __webpack_require__(31795);
var new_compose_insert_from_drive_i18n = __webpack_require__(2622);

/**
 * The attach button mod
 */
class NewComposeInsertFromDriveMod extends new_compose_insert_from_drive_mods.Mod {
  constructor(settings, element, composeId) {
    super(settings, element);
    this._settings = settings;
    this._element = new_compose_insert_from_drive_$(element);
    this._composeId = composeId;
    (0,helpers._bindAllMethods)(this);
  }
  setup() {
    this.setupInsertFromDriveButton();
    this.setupInsertPhotosButton();
  }
  setupInsertFromDriveButton() {
    var insertFromDriveButton = new_compose_insert_from_drive_$('.wG.J-Z-I[command="op.docs"]', this._element);
    var imageDiv = new_compose_insert_from_drive_$('.aA7.aaA.aMZ', insertFromDriveButton);
    insertFromDriveButton.addClass('virtru-modded');
    this._insertFromDriveButton = insertFromDriveButton;
    imageDiv.addClass('virtru-modded');
    insertFromDriveButton.removeAttr('command');
    insertFromDriveButton.on('click', this.insertFromDriveClick);
    imageDiv.removeClass('aMZ');
    imageDiv.removeClass('aA7');
    imageDiv.addClass('virtru-disabled-google-drive-button');
  }
  setupInsertPhotosButton() {
    var insertPhotosButton = new_compose_insert_from_drive_$('.wG.J-Z-I[command="image"]', this._element);
    insertPhotosButton.addClass('virtru-modded');
    var clone = insertPhotosButton.clone();
    insertPhotosButton.hide();
    clone.removeAttr('command');
    clone.on('click', this.insertPhotoClick);
    clone.insertBefore(insertPhotosButton);
    this._insertPhotosButton = insertPhotosButton;
    this._clonedInsertPhotosButton = clone;
  }
  insertPhotoClick() {
    this._settings.user.setting('insert:photos:composeid', this._composeId);
    this._insertPhotosButton.triggerNative('click');
    this._insertPhotosButton.triggerNative('mousedown');
    this._insertPhotosButton.triggerNative('mouseup');
  }
  insertFromDriveClick() {
    var message = new_compose_insert_from_drive_i18n.t('COMPOSE_INSERT_DRIVE_INSERT_FILE');
    var popover = DismissPopover.create(message);
    popover.position('south').effect('fade').show(new_compose_insert_from_drive_$('.virtru-disabled-google-drive-button'));
  }
  teardown() {
    var insertFromDriveButton = this._insertFromDriveButton;
    var imageDiv = new_compose_insert_from_drive_$('.virtru-disabled-google-drive-button', insertFromDriveButton);
    insertFromDriveButton.attr('command', 'op.docs');
    insertFromDriveButton.off('click', this.insertFromDriveClick);
    imageDiv.addClass('aMZ');
    imageDiv.addClass('aA7');
    imageDiv.removeClass('virtru-disabled-google-drive-button');
    this._insertPhotosButton.show();
    this._clonedInsertPhotosButton.hide();
    this._clonedInsertPhotosButton.remove();
    this._settings.user.setting('insert:photos:composeid', '');
  }
}
Object.assign(NewComposeInsertFromDriveMod.prototype, new_compose_insert_from_drive_mods.ModElementShortcut);
new_compose_insert_from_drive_contexts.addOpen(NewComposeInsertFromDriveMod);
;// ./sites/gmail/page/mods/new-compose-trimmed-content.js
/* provided dependency */ var new_compose_trimmed_content_console = __webpack_require__(31799);

var new_compose_trimmed_content_mods = __webpack_require__(25939);
var new_compose_trimmed_content_contexts = __webpack_require__(47446);
var new_compose_trimmed_content_$ = __webpack_require__(55401);
var INVITATION_EMAIL_REPLACEMENT = (__webpack_require__(38282).InvitationEmailReplacement).html;
var emailUtils = __webpack_require__(25119);
var new_compose_trimmed_content_i18n = __webpack_require__(2622);

/**
 * Creates a new NewComposeTrimmedContentMod around the attachment
 * container element.
 *
 * @param settings Current users settings
 * @param element The attachment container element
 * @constructor
 */
class NewComposeTrimmedContentMod extends new_compose_trimmed_content_mods.Mod {
  constructor(settings, element, messageContainer) {
    super(settings, element);
    this._settings = settings;
    this._selectors = settings.dom;
    this._element = new_compose_trimmed_content_$(element);
    this._messageContainer = messageContainer;
    this._invitationContainer = false;
    this._originalContent = false;
    (0,helpers._bindAllMethods)(this);
  }

  /**
   * Initializes the Mod.
   */
  setup() {
    this._clone = new_compose_trimmed_content_$(this._element).clone();
    this._clone.on('click', this.handleClick);
    this._clone.insertBefore(this._element);
    this._element.hide();
    var self = this;
    this.onceFinds(this._selectors.TDF_SELECTOR, {
      listenOn: this._messageContainer,
      timeout: 250
    }).then(function (matches) {
      // Only replace on the first element, becuase that's the only
      // one that has the invitation e-mail
      self.hideAndReplace(matches[0]);
    }).catch(err => new_compose_trimmed_content_console.error(err));
  }

  /**
   * Handle a click on the trimmed content button
   */
  handleClick() {
    this._element.triggerNative('click');
    var self = this;
    this.onceFinds(this._selectors.TDF_SELECTOR, {
      listenOn: this._messageContainer
    }).then(function (matches) {
      // Only replace on the first element, becuase that's the only
      // one that has the invitation e-mail
      self.hideAndReplace(matches[0]);
    });
  }
  hideAndReplace(element) {
    element = new_compose_trimmed_content_$(element);
    var container = emailUtils.getMessageContainer(element);
    this.replaceInvitationTemplate(container);

    // Sometimes the micro-tdf doesn't get hidden (emails from MS Outlook). Hide it.
    // this.hideMicroTdf();
    // This forces the compose area to resize to the new dimensions.
    new_compose_trimmed_content_$(window).triggerNative('resize');
  }

  // hideMicroTdf() {
  //  for(var i = 0, len = TDF_SELECTOR.length; i < len; ++i) {
  //    this._messageContainer.find(TDF_SELECTOR[i]).css('font-size', '0em');
  //  }
  // };

  teardown() {
    this.restoreContent();
    this._clone.remove();
    this._element.show();
    new_compose_trimmed_content_$(window).triggerNative('resize');
  }
  replaceInvitationTemplate(parent) {
    this._invitationContainer = new_compose_trimmed_content_$(parent.children()[0]);
    this._originalContent = this._invitationContainer.html();
    this._invitationContainer.empty();
    this._invitationContainer.html(INVITATION_EMAIL_REPLACEMENT);
    const correctText = new_compose_trimmed_content_i18n.t('INVITATION_EMAIL_REPLACE_TEXT_DEFAULT');
    this._invitationContainer.find('.virtru-nested-secure-message-text-default').text(correctText);
  }
  restoreContent() {
    if (this._invitationContainer) {
      this._invitationContainer.empty();
      this._invitationContainer.html(this._originalContent);
    }
  }
}
Object.assign(NewComposeTrimmedContentMod.prototype, new_compose_trimmed_content_mods.ModWaiterPromises);
Object.assign(NewComposeTrimmedContentMod.prototype, new_compose_trimmed_content_mods.ModElementShortcut);
Object.assign(NewComposeTrimmedContentMod.prototype, new_compose_trimmed_content_mods.ModEventListenerShortcut);
new_compose_trimmed_content_contexts.addOpen(NewComposeTrimmedContentMod);
// EXTERNAL MODULE: ./node_modules/redux/es/redux.js
var redux = __webpack_require__(42804);
// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 21 modules
var es = __webpack_require__(13255);
;// ./sites/gmail/page/mods/new-compose-intro-message.js






var new_compose_intro_message_$ = __webpack_require__(55401);
var new_compose_intro_message_contexts = __webpack_require__(47446);
var new_compose_intro_message_mods = __webpack_require__(25939);
var new_compose_intro_message_Emitter = __webpack_require__(16502);
var new_compose_intro_message_i18n = __webpack_require__(2622);
var new_compose_intro_message_Popover = __webpack_require__(55929);
var new_compose_intro_message_AnalyticsService = (__webpack_require__(1246).instance)();
function stripHTML(input) {
  const doc = new DOMParser().parseFromString(input, 'text/html');
  const text = doc.body.textContent || '';
  return text.trim();
}
function createNewComposeIntroMessageStore({
  status,
  introMessage,
  emailMode,
  policyHelper
}) {
  const updateEmailMetadata = (key, value) => {
    if (policyHelper.checkIfEmailMetadataIsLoaded()) {
      policyHelper.setByMetadataKey(key, value);
    }
  };

  // cleanup existing draft intros saved with HTML by previous contenteditable div implementation
  introMessage = stripHTML(introMessage);
  const initialState = {
    status,
    introMessage,
    emailMode
  };
  const newComposeIntroMessageReducer = (state = initialState, action) => {
    switch (action.type) {
      case 'TOGGLE':
        {
          const newStatus = state.status === 'active' ? 'inactive' : 'active';

          // save status to email metadata
          updateEmailMetadata(sites.EmailMetadataEnum.PERSONAL_INTRO_STATUS, newStatus);
          return {
            ...state,
            status: newStatus
          };
        }
      case 'UPDATE_INTRO_MESSAGE':
        {
          // save intro message to email metadata
          updateEmailMetadata(sites.EmailMetadataEnum.PERSONAL_INTRO, action.introMessage);
          return {
            ...state,
            introMessage: action.introMessage
          };
        }
      default:
        {
          return state;
        }
    }
  };
  return (0,redux.createStore)(newComposeIntroMessageReducer);
}
const toggleButtonPopover = new new_compose_intro_message_Popover(new_compose_intro_message_i18n.t('PERSONAL_INTRO_ONBOARD'));
toggleButtonPopover.classname += ' virtru-popover-dark';
toggleButtonPopover.position('north');
toggleButtonPopover.setShowTimer(500);
function NewComposeIntroMessageToggle() {
  const toggleButtonRef = (0,react.useRef)();
  const status = (0,es/* useSelector */.d4)(state => state.status);
  const emailMode = (0,es/* useSelector */.d4)(state => state.emailMode);
  const dispatch = (0,es/* useDispatch */.wA)();
  const handleToggle = () => {
    dispatch({
      type: 'TOGGLE'
    });
  };
  (0,react.useEffect)(() => {
    if (status === 'active') {
      // personal intro toggle is hidden and editor is open

      // disable and hide the toggle button popover
      toggleButtonPopover.hide();
      toggleButtonPopover.disable();

      // send analytics event
      new_compose_intro_message_AnalyticsService.personalIntroOpen({
        type: emailMode
      });
    } else {
      // personal intro toggle is visible and editor is now closed
      // enable popover so it shows on hover
      toggleButtonPopover.enable();
    }
  }, [status]);
  (0,react.useEffect)(() => {
    toggleButtonPopover.attach(toggleButtonRef.current);
  }, []);
  return /*#__PURE__*/react.createElement("div", {
    className: `virtru-intro-message-toggle-outer ${status}`
  }, /*#__PURE__*/react.createElement("button", {
    tabIndex: "1",
    className: "virtru-intro-message-toggle-button",
    "aria-label": new_compose_intro_message_i18n.t('ARIA_PERSONAL_INTRO'),
    ref: toggleButtonRef,
    onClick: handleToggle,
    disabled: status === 'active'
  }, new_compose_intro_message_i18n.t('PERSONAL_INTRO_ADD'), " ", /*#__PURE__*/react.createElement("div", {
    className: "virtru-intro-message-toggle-arrow"
  })));
}
function NewComposeIntroMessageEditor() {
  const outerEditorRef = (0,react.useRef)();
  const editorRef = (0,react.useRef)();
  const status = (0,es/* useSelector */.d4)(state => state.status);
  const introMessage = (0,es/* useSelector */.d4)(state => state.introMessage);
  const dispatch = (0,es/* useDispatch */.wA)();
  const handleCancel = () => {
    dispatch({
      type: 'TOGGLE'
    });
  };

  // handler used on the outer div wrapping the editor because Gmail hijacks
  // the focus event of the textarea and immediately moves it to the message body
  const handleFocus = e => {
    editorRef.current.focus();
    e.stopPropagation();
  };
  const handleInput = e => {
    dispatch({
      type: 'UPDATE_INTRO_MESSAGE',
      introMessage: e.target.value
    });
  };
  (0,react.useEffect)(() => {
    // used together with CSS to animate the editor slide down/up
    if (status === 'active') {
      outerEditorRef.current.style.marginTop = '0px';
    } else {
      outerEditorRef.current.style.marginTop = `-${outerEditorRef.current.offsetHeight}px`;
    }
  }, [status]);
  return /*#__PURE__*/react.createElement("div", {
    ref: outerEditorRef,
    className: `virtru-intro-editable-outer ${status}`
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-intro-editable-body-outer",
    onClick: handleFocus
  }, /*#__PURE__*/react.createElement("textarea", {
    className: "virtru-intro-editable-body",
    "aria-label": new_compose_intro_message_i18n.t('PERSONAL_INTRO_PLACEHOLDER_TEXT'),
    tabIndex: "1",
    placeholder: new_compose_intro_message_i18n.t('PERSONAL_INTRO_PLACEHOLDER_TEXT'),
    ref: editorRef,
    value: introMessage,
    onChange: handleInput
  })), /*#__PURE__*/react.createElement("div", {
    className: "virtru-intro-editable-footer"
  }, /*#__PURE__*/react.createElement("span", {
    className: "virtru-intro-editable-footer-text"
  }, new_compose_intro_message_i18n.t('INTRO_MESSAGE_FOOTER_TEXT'), /*#__PURE__*/react.createElement("button", {
    tabIndex: "1",
    className: "virtru-intro-link virtru-intro-remove-intro",
    onClick: handleCancel
  }, new_compose_intro_message_i18n.t('COMMON_CANCEL'))), /*#__PURE__*/react.createElement("div", {
    className: "virtru-intro-editable-footer-border"
  })));
}
class NewComposeIntroMessageMod extends new_compose_intro_message_mods.Mod {
  constructor(element, settings, emailMode, status, introMessage, policyHelper) {
    super(settings, element);
    this._element = new_compose_intro_message_$(element);
    this._settings = settings;
    this._newComposeIntroMessageStore = createNewComposeIntroMessageStore({
      status,
      introMessage,
      emailMode,
      policyHelper
    });
    (0,helpers._bindAllMethods)(this);
  }
  setup() {
    // Setup the toggle button
    const toggleComponentContainer = document.createElement('div');
    this._toggleComponentRoot = (0,client/* createRoot */.H)(toggleComponentContainer);
    this._toggleComponentRoot.render(/*#__PURE__*/react.createElement(es/* Provider */.Kq, {
      store: this._newComposeIntroMessageStore
    }, /*#__PURE__*/react.createElement(NewComposeIntroMessageToggle, null)));
    this._element.find(this._settings.dom.NEW_COMPOSE_TOGGLE_INSERTION_POINT).before(toggleComponentContainer);

    // Setup the actual editor
    const editorComponentContainer = document.createElement('div');
    this._editorComponentRoot = (0,client/* createRoot */.H)(editorComponentContainer);
    this._editorComponentRoot.render(/*#__PURE__*/react.createElement(es/* Provider */.Kq, {
      store: this._newComposeIntroMessageStore
    }, /*#__PURE__*/react.createElement(NewComposeIntroMessageEditor, null)));
    this._element.find(this._settings.dom.NEW_COMPOSE_EDITOR_INSERTION_POINT).prepend(editorComponentContainer);
  }
  teardown() {
    if (this._toggleComponentRoot) {
      this._toggleComponentRoot.unmount();
    }
    if (this._editorComponentRoot) {
      this._editorComponentRoot.unmount();
    }
  }
  getIntroText() {
    const {
      status,
      introMessage
    } = this._newComposeIntroMessageStore.getState();
    if (status === 'inactive') {
      return '';
    }
    return introMessage;
  }
}
new_compose_intro_message_contexts.addOpen(NewComposeIntroMessageMod);
new_compose_intro_message_Emitter(NewComposeIntroMessageMod.prototype);
// EXTERNAL MODULE: ./lib/data-storage/reducers/messages-reducer.js
var messages_reducer = __webpack_require__(22885);
// EXTERNAL MODULE: ./sites/gmail/page/mods/onboarding-tour.js
var onboarding_tour = __webpack_require__(44883);
// EXTERNAL MODULE: ./sites/gmail/page/mods/onboarding.js
var onboarding = __webpack_require__(67688);
// EXTERNAL MODULE: ./sites/gmail/page/mods/new-feature-notification.js
var new_feature_notification = __webpack_require__(60578);
// EXTERNAL MODULE: ./sites/gmail/page/mods/compose-manager.js
var compose_manager = __webpack_require__(68207);
var compose_manager_default = /*#__PURE__*/__webpack_require__.n(compose_manager);
// EXTERNAL MODULE: ./lib/smart-send-secure/index.js
var smart_send_secure = __webpack_require__(1814);
var smart_send_secure_default = /*#__PURE__*/__webpack_require__.n(smart_send_secure);
// EXTERNAL MODULE: ./node_modules/@virtru-private/client-common-utils/dist/index.js
var dist = __webpack_require__(82672);
// EXTERNAL MODULE: ./lib/secure-lib-proxy/index.js
var secure_lib_proxy = __webpack_require__(6336);
// EXTERNAL MODULE: ./lib/email/lib/constants.js
var constants = __webpack_require__(76223);
;// ./sites/gmail/page/mods/new-compose-const.js
/**
 * Consts for New compose
 */

const ATTACHMENT_NOT_READY_ERROR = i18n_default().t('ATTACHMENT_NOT_READY_ERROR');
const WATERMARK = 'watermark';
const PERSISTENT_PROTECTION = 'persistent-protection';
const EMAIL_MODE = {
  Reply: 'reply',
  ReplyAll: 'reply-all',
  Forward: 'forward',
  New: 'new'
};

// eslint-disable-next-line
const MESSAGE_REGEX = /^---\s*START\s*PROTECTED\s*MESSAGE\s*TDF\s*([a-zA-Z0-9\-]*)\s*---\s*([a-zA-Z0-9+=\/\s\/\n]+)\s*---\s*END\s*PROTECTED\s*MESSAGE\s*---/;

// A test REGEX for clipped draft content, used for analytics below
// eslint-disable-next-line
const MESSAGE_REGEX_CLIPPED = /^---\s*START\s*PROTECTED\s*MESSAGE\s*TDF\s*([a-zA-Z0-9\-]*)\s*---\s*([a-zA-Z0-9+=\/\s\/\n\.]+)$/;
;// ./sites/gmail/page/mods/new-compose-ui-utils.js
/**
 * New compose UI methods
 */



const dispatchToStore = (globalStore_default()).dispatch;
const correctAttachementHeight = function (element, settings, banner) {
  const footerTooltip = element.find(settings.dom.COMPOSE_FOOTER_TOOLTIP);
  if (footerTooltip.css('display') !== 'none') {
    const attachmentContainer = element.find(settings.dom.NEW_COMPOSE_OUTER_ATTACHMENTS_CONTAINER);
    const attachmentContainerChild = attachmentContainer.children();
    const height = attachmentContainerChild.height();
    const newHeight = height + banner.height();
    if (newHeight && newHeight >= height) {
      attachmentContainerChild.height(height + banner.height());
    }
  }
};
const correctComposeWindowHeight = function (element, settings) {
  const resizeObserver = new ResizeObserver(() => {
    const isFullscreen = element.closest(settings.dom.NEW_COMPOSE_FULL_SCREEN_RESIZING_ELEMENT).length > 0;
    const bottomSide = element.find(settings.dom.COMPOSE_BOTTOM_SIDE);
    bottomSide.css('margin-bottom', '0px'); // for clearing on both fullscreen and non-fullscreen

    if (isFullscreen) {
      // fix bottom side in fullscreen mode
      element.find(settings.dom.COMPOSE_BOTTOM_SIDE_EXPANDED).css('margin-bottom', '-20px');
    }
  });
  resizeObserver.observe(element[0]);
};
const updateAttachmentSectionHeader = function (editor) {
  const attachmentChips = editor.find('.virtru-attachment');
  editor.find('.virtru-attachment-section-header-text').text(i18n_default().t('SECURED_ATTACHMENTS_HEADER', {
    count: attachmentChips.length
  }));
};

/**
 * Finds the `sender` of the email in the case of email aliases, or `undefined`
 * if it's the owner.
 * @returns {String} - The `sender` of the email.
 */
const getSender = function (element) {
  return element.find('form input[name="from"]').val();
};
const virtruMetadataElement = function () {
  return jquery_pack('[name="virtru-metadata"]');
};
const removeAttachmentWrapperTooltip = function (editor) {
  editor.find('.virtru-attachment-wrapper').each(function () {
    const attachmentId = jquery_pack(this).find('.virtru-attachment').attr('id');
    dispatchToStore({
      type: 'REMOVE_ATTACHMENT_DATA',
      id: attachmentId
    });
    jquery_pack(this).after(jquery_pack(this).find('.virtru-attachment'));
  });
  editor.find('.virtru-attachment-wrapper').remove();
};
// EXTERNAL MODULE: ./lib/mods/mod.js
var mod = __webpack_require__(81147);
// EXTERNAL MODULE: ./lib/mods/index.js
var lib_mods = __webpack_require__(25939);
// EXTERNAL MODULE: ./lib/contexts/base.js
var base = __webpack_require__(7709);
// EXTERNAL MODULE: ./node_modules/suspenders/Settings/Compose.js
var Compose = __webpack_require__(95663);
;// ./sites/gmail/page/mods/new-compose-analytic-getters.js

const getUnsupportedFileFormatParams = (newComposeObject, driveAttachments) => [{
  attachmentsCount: newComposeObject.attachmentsHelper.getAllUnsecureAttachments().length + driveAttachments.length,
  unsupportedCount: driveAttachments.length,
  authorizations: newComposeObject.policyHelper.getAuthorizations()
}];
const getSecureModeStatusParams = (newComposeObject, {
  secureMode,
  secureDefault,
  composeWindowData,
  forwardWithAttachments
}) => [{
  context: 'Secure mode status',
  secureMode,
  secureDefault,
  composeWindowDataSecure: composeWindowData && composeWindowData.secure,
  forwardWithAttachments,
  canCreatePolicies: newComposeObject._settings.user.setting('permissions.canCreatePolicies'),
  isSecureDraft: newComposeObject._isSecureDraft,
  isNew: newComposeObject.isNew,
  isForward: newComposeObject.isForward,
  isExistingUnsecureDraft: newComposeObject._isExistingUnsecureDraft,
  checkReplySecure: newComposeObject.checkReplySecure()
}, false];
const getSendInitiatedAllAttachmentsParams = (newComposeObject, {
  isSecureMode,
  attachments
}) => {
  var _newComposeObject$_se, _newComposeObject$_se2, _newComposeObject$pol, _newComposeObject$pol2, _newComposeObject$pol3;
  return [{
    isSecureMode,
    authorizations: newComposeObject.policyHelper.getAuthorizations(),
    averageFileSize: newComposeObject.calculateAverageFileSize(attachments),
    totalFileSize: newComposeObject.calculateTotalFileSize(attachments),
    filesAttached: newComposeObject.getAnalyticsObjectFromAttachments(attachments),
    expandedProtectionCoverage: newComposeObject.calculateExpandedProtectionCoverage(attachments),
    enforceFips: (_newComposeObject$_se = newComposeObject._settings.user) === null || _newComposeObject$_se === void 0 ? void 0 : (_newComposeObject$_se2 = _newComposeObject$_se.permissions) === null || _newComposeObject$_se2 === void 0 ? void 0 : _newComposeObject$_se2.enforceFips,
    sms2fa: !!((_newComposeObject$pol = newComposeObject.policyHelper) !== null && _newComposeObject$pol !== void 0 && (_newComposeObject$pol2 = _newComposeObject$pol._policyConfigMenu) !== null && _newComposeObject$pol2 !== void 0 && (_newComposeObject$pol3 = _newComposeObject$pol2._policyModel) !== null && _newComposeObject$pol3 !== void 0 && _newComposeObject$pol3.sms)
  }];
};
const getSendInitiatedSupportedAttachmentsParams = (newComposeObject, {
  supportedAttachments
}) => [{
  authorizations: newComposeObject.policyHelper.getAuthorizations(),
  averageFileSize: newComposeObject.calculateAverageFileSize(supportedAttachments),
  totalFileSize: newComposeObject.calculateTotalFileSize(supportedAttachments),
  numOfSupportedFiles: supportedAttachments.length
}];
const getSecurityOptionToggledParams = (newComposeObject, {
  optionName,
  value,
  attachments
}) => [{
  option: optionName,
  state: value ? 'on' : 'off',
  filesAttached: newComposeObject.getAnalyticsObjectFromAttachments(attachments),
  expandedProtectionCoverage: newComposeObject.calculateExpandedProtectionCoverage(attachments)
}];
const getErrorDraftParams = error_obj => [{
  context: 'new_compose',
  name: 'clipped draft',
  error_obj
}, true];
const getErrorMissingElemParams = error_obj => [{
  context: 'new_compose',
  name: 'missing elements',
  error_obj
}, true];
const getErrorSendParams = error => [{
  context: 'email_send',
  name: typeof error.name !== 'undefined' ? error.name : 'unknown',
  error_obj: (0,sanitizeAnalyticsError/* default */.A)(error)
}];
const getErrorSetupSendParams = () => [{
  context: 'email_send',
  name: 'SETUP_SEND_EMAIL',
  error_obj: 'none provided'
}];
const getErrorSmartSendParams = ({
  contextString,
  sanitizedError,
  sms2fa
}) => [{
  context: contextString,
  name: 'smart-send-secure',
  error_obj: sanitizedError,
  sms2fa
}, true];
const getErrorUnable2RestoreParams = ({
  userId,
  error
}) => [{
  userId,
  context: 'new_compose',
  name: 'Unable to restore unsent message',
  error_obj: (0,sanitizeAnalyticsError/* default */.A)(error)
}, true];
// EXTERNAL MODULE: ./sites/gmail/page/xhr/utils.js
var xhr_utils = __webpack_require__(60355);
// EXTERNAL MODULE: ./lib/constants/errors.js
var errors = __webpack_require__(22592);
// EXTERNAL MODULE: ./components/modals/renderModal.js + 15 modules
var renderModal = __webpack_require__(58665);
;// ./sites/gmail/page/mods/new-compose.js
/* provided dependency */ var new_compose_console = __webpack_require__(31799);
/**
 * New compose functionality
 */



















const new_compose_dispatchToStore = (globalStore_default()).dispatch;







const {
  Toggle,
  PromoFooter
} = (widgets_default());



















const new_compose_AnalyticsService = (0,analytics.instance)();




const {
  TimelineLite: new_compose_TimelineLite,
  Sine: new_compose_Sine
} = window.GreenSockGlobals;













// Module variable only used for fetching the welcome template.  This object
// caches the template so that it's not pulled every single secure send; that's
// why it's being left at the module level as a singleton
const templateService = new dist.templates();
const MIL_TEMPLATE_URI = 'https://virtru-com-us-east-2-templates-production.s3.us-east-2.amazonaws.com/virtru/base-mil-template.html';

/**
 * New composer mod
 */
class NewComposerMod extends mod.Mod {
  // NewComposerMod.mainDomKey = 'NEW_COMPOSER_SELECTOR';
  static mainDomKey = 'NEW_COMPOSER_SELECTOR';
  bannerSelector = '.virtru-new-compose-editor-banner';
  constructor(settings, element) {
    super(settings, element);
    this._settings = settings;
    this._element = jquery_pack_default()(element);
    this._attachmentMods = {};
    this._isNewComposeWindow = false;
    this._isExistingUnsecureDraft = false;
    this._isSecureDraft = false;
    this._isAlive = true;
    this._initialMetadata = undefined;
    this._initialBodyText = undefined;
    this._hasBeenSent = false;
    this._isSendRetryEnabled = true;
    this._isSwitchingToSecureMode = false;
    this._hasInitialAttachments = false;
    this._stateManager = new StateManagementHelper();
    this.tooltipHelper = new tooltip_helper/* default */.A({
      $element: this._element,
      settings: this._settings,
      stateManager: this._stateManager
    });
    this.unsubscribeIsSecureMode = this._stateManager.isSecureMode().requestSub(this.isSecureMode.bind(this));
    this.unsubscribeGetMailSendingState = this._stateManager.getMailSendingState().requestSub(() => this._hasBeenSent);
    this.unsubscribeAttachmentService = this._stateManager.getAttachmentService().requestSub(() => this._attachmentService);
    this.usubscribeGetComposeMod = this.composeModsSubscription();
    this._formElement = this._element.find('form');
    this.readNewComposeInformation(this._formElement);
    this.animationHelper = new AnimationHelper({
      $element: this._element,
      dom: this._settings.dom,
      bannerSelector: this.bannerSelector,
      formElement: this._formElement,
      stateManager: this._stateManager
    });
    new_compose_console.debug(`Creating NewComposerMod : ${this._composeId}`);
    // This really doesn't belong here... need a refactor of all
    // the attachment stuff.
    this._secureService = secure_lib_proxy.SecureServiceProxy.create(sdk.transports);

    // Hacky but this will kick off pre-fetching the welcome template if necessary
    // so that the user doesn't block waiting for it prior to send.  We do not
    // `await` this since it can happen in the background.
    templateService.fetch(this._settings.user.setting('templateUri'));
    this._predictiveInterceptor = new PredictiveInterceptor.PredictiveInterceptor(this._settings.user);
    this._virtruOfflineMode = new virtru_offline_mode/* default */.A(this._settings.user._profile);

    // enable only if user has permission
    (0,helpers._bindAllMethods)(this);
  }
  composeModsSubscription() {
    const unsubList = [this._stateManager.getComposeMod(ModsEnum.SEND_SECURE_MOD).requestSub(() => this._sendSecureMod), this._stateManager.getComposeMod(ModsEnum.SEND_ARCHIVE_BUTTON_MOD).requestSub(() => this._sendArchiveButtonMod), this._stateManager.getComposeMod(ModsEnum.SEND_BUTTON_MOD).requestSub(() => this._sendButtonsMod)];
    return () => unsubList.forEach(unsubscribe => unsubscribe());
  }
  alert(message) {
    if (this._alertThrown) {
      return;
    }
    alert(message);
    this._alertThrown = true;
    setTimeout(function () {
      this._alertThrown = false;
    }.bind(this), 0);
  }
  getToggleState() {
    return this._toggle.getState();
  }
  isSecureMode() {
    return this.getToggleState() === 'on';
  }
  composeId() {
    return this._composeId;
  }
  isSwitchingToSecureMode() {
    return this._isSwitchingToSecureMode;
  }
  executeTabCommand(tabConfig, e) {
    const element = this._element;
    const isVisible = elem => elem && jquery_pack_default()(elem).length > 0 && jquery_pack_default()(elem).is(':visible');
    tabConfig.forEach(({
      currentElement,
      nextSequence,
      nextElement,
      alternativeElement
    }) => {
      if (jquery_pack_default()(e.target).is(element.find(currentElement))) {
        // sequences have priority
        if (nextSequence && nextSequence.length > 0) {
          nextSequence.forEach(ne => {
            const nextElement = jquery_pack_default()(ne, element);
            if (isVisible(nextElement)) {
              // if any of the targets are visible, prevent the default action
              e.preventDefault();
              nextElement.trigger('focus');
            }
          });
        } else if (isVisible(nextElement)) {
          e.preventDefault();
          jquery_pack_default()(nextElement, element).trigger('focus');
        } else if (isVisible(alternativeElement)) {
          e.preventDefault();
          jquery_pack_default()(alternativeElement, element).trigger('focus');
        } else {
          // let default tab take over
        }
      }
    });
  }
  bindingTabButton() {
    const TAB_KEY = 9;
    const {
      dom
    } = this._settings;
    this._element.on('keydown', e => {
      if (e.which === TAB_KEY && !e.shiftKey) {
        this.executeTabCommand(getTabConfig(dom), e);
      }
      if (e.which === TAB_KEY && e.shiftKey) {
        this.executeTabCommand(getShiftTabConfig(dom), e);
      }
    });
  }
  setup() {
    const self = this;

    // This block must come first to add the processedClass so the waiter ignores this
    const {
      processedClass
    } = this._settings;
    const element = this._element;
    this.bindingTabButton();
    element.addClass(`${processedClass} virtru_new_compose`);

    // Function executes in case of a failure during initialization
    const failure = failureInSetup.bind(null, self._composeId, () => self.teardown());

    // Get the email mode, one of : ['reply', 'reply-all', 'forward', 'new']
    this._emailMode = this.getEmailMode();
    Object.keys(EMAIL_MODE).forEach(mode => {
      this[`is${mode}`] = EMAIL_MODE[mode] === this._emailMode;
    });
    moment_default().updateLocale(moment_default().locale(), {
      calendar: i18n.t('MOMENT_CALENDAR_SENDER_EXPIRING_SOON')
    });

    // Setup the editor banner up
    this.setupEditorBanner(this._element, self._formElement, this._emailMode);
    try {
      new_compose_console.debug(`Setting up mod... ${this._composeId}`);
      const {
        dom
      } = this._settings;
      const selector = `${dom.NEW_COMPOSE_EDITOR}, ${dom.RICH_TEXT_EDITOR}`;
      // We'll attempt to locate the editor body here,
      // then start the handling chain
      (0,ElementRegistry.waitUntilElementHasDescendant)(this._element.get(0), selector, 8).then(self._setupEditor, () => {
        failure('MutationObserver', `Unable to locate ${selector} in ${this._element.get(0).className}`);
      }).then(self.checkInitialAttachments).then(() => self.restoreComposeMessage({
        callpoint: 'setup',
        selector,
        emailMode: this._emailMode
      })).then(self._loadMessage).then(self.configureSecureModeBasedOnContext).catch(err => {
        failure('promise', err);
      }).finally(() => {
        // Trick to fix height to compose footer, that has absolute position from the beginning
        const composeFooter = jquery_pack_default()(dom.PWN_COMPOSE_FOOTER);
        const composeFooterHeight = composeFooter.height();
        composeFooter.parent().parent().height(composeFooterHeight);

        // Sanitize footer to ensure tabbing to Send Button
        // When this selector present it locks focus on itself preventing tabbing to inside the footer
        const sendButtonFocusTrap = self._element.find(dom.SEND_BUTTON_FOCUS_TRAP);
        if (sendButtonFocusTrap.length) {
          sendButtonFocusTrap.hide();
        }
      });
    } catch (err) {
      failure('caught', err);
    }
  }

  /**
   * Locates and sets up the editor window.
   * @private
   */
  _setupEditor(matches) {
    new_compose_console.debug(`Found editor... ${this._composeId}`);
    this._editor = jquery_pack_default()(matches);
    this.completeSetup();

    // required for scenario when user opens a compose pane
    // that has -defaulted- to virtru 'off'
    return this.setupSendSecureButtons().then(() => {
      this.setupScheduledSendButtons();
    });
  }

  /**
   * Loads draft (if applicable) and message metadata/attachments
   * @private
   */
  _loadMessage() {
    try {
      this.focusToField();
      this.policyHelper.loadEmailMetadata();
      if (this._isSecureDraft) {
        this.setupExistingAttachments();
        this.restoreTdfAttachmentMods();
      }
      this._attachmentService = new sites.AttachmentService(sdk.transports, this, this._settings);
    } catch (e) {
      new_compose_console.log('_loadMessage error: ', e);
      // TODO: check next line - is it possible to remove this catch
      return Promise.reject(e);
    }
  }
  completeSetup() {
    new_compose_console.debug(`Completing setup... ${this._composeId}`);
    const self = this;
    const {
      dom,
      user
    } = this._settings;
    compose_manager_default().register(this);
    setupExpandedTrimmedContent(this._element);
    this.handleKeyboardShortcuts();
    this.policyHelper = new PolicyHelper({
      editor: this._editor,
      policyConfigMenu: this._policyConfigMenu,
      composeId: this._composeId,
      stateManager: this._stateManager
    });
    this.attachmentsHelper = new AttachmentsHelper({
      /* TODO: SPIKE! Refactor! */
      context: this,
      dom: this._settings.dom,
      $element: this._element,
      gmailUtil: gmail_utility,
      $editor: this._editor,
      labels: {
        ATTACHMENT_NOT_READY_ERROR: ATTACHMENT_NOT_READY_ERROR
      },
      policyConfigMenu: this._policyConfigMenu
    });
    this.setupExistingAttachments();
    this.restoreTdfAttachmentMods();
    this.checkBrokenAttachments();

    // When we call context menu on empty line and past some text - this inserted text will disappear/or not be inserted.
    // This fix fill collapse default selection for empty line when context menu is shown.
    self._editor.on('contextmenu', contextHandler);
    // When we focus out of the editor, store the location of the last element that is
    // nearest to the cursor. This enables us to insert attachments nearby.
    self._editor.on('focusout', function onEditorFocusOut() {
      const sel = document.getSelection();
      if (sel.rangeCount > 0) {
        self.lastSelectedRange = sel.getRangeAt(0);
        self.lastSelectedElement = self.lastSelectedRange.commonAncestorContainer;
      } else {
        self.lastSelectedRange = null;
        self.lastSelectedElement = null;
      }
    });
    this.attachmentsHelper.registerListeners(user, this.onBeforeSetupSecureMode.bind(this), updateAttachmentSectionHeader.bind(null, this._editor), this.removeSectionTooltip.bind(this), doConvertInlineImagesToBase64.bind(this, user));
    this.subjectElem = this._element.find(dom.NEW_COMPOSE_SUBJECT);
    this._toggle.on('on', this.setupSecureModeManual);
    this._toggle.on('off', this.teardownSecureModeManual);
    this._toggle.on('beforeoff', this.onBeforeTeardownSecureMode);
    this._toggle.on('beforeon', this.onBeforeSetupSecureMode);
    const $close = this._element.closest(dom.GMAIL).prev(dom.NEW_COMPOSE_TITLEBAR).find(dom.EDITOR_CLOSE_BUTTON);
    const kill = () => {
      this._isAlive = false;
      jquery_pack_default()(dom.FULL_SCREEN_EDITOR_CONTAINER).hide();
      $close.off('click', kill);
      $close.off('mousedown', reset);
    };

    // Reset the metadata content to what it was originally so gmail doesn't see a change and save a draft
    const reset = () => {
      const bodyNowText = this.bodyText();
      const subject = this.subject();
      const recipients = this.recipients();

      // Extra comparison check for email signatures
      const bodyWasUnchanged = this._initialBodyText && this._initialBodyText === bodyNowText || !this._initialBodyText && !bodyNowText;
      const isEmptyDraft = !subject && bodyWasUnchanged && recipients.length === 0;
      const el = virtruMetadataElement();
      if (isEmptyDraft && this._initialMetadata) {
        el.val(this._initialMetadata);
      }
    };
    $close.on('click', kill);

    // Reset the content before gmail picks up on the click event
    $close.on('mousedown', reset);

    // these are for tracking currently uploading attachments
    this.attachmentsHelper._numUploadingAttachments = 0;
    this._animatedAttachments = {};
    this.tooltipHelper.updateToggleTooltip();

    // Force an initial resize of the compose window, this is to get
    // around an issue where the window resizes mid-click on the toggle
    // and 'accidentally' hits minimize, full-screen, or close
    forceInitialResize();
    if (this.getEmailMode() === EMAIL_MODE.New) {
      this._promoFooter = new PromoFooter(this);
      this._promoFooter.setFooter();
    }
    if (!this._onboardingMod && user.auth('status') !== 'active') {
      this._onboardingMod = onboarding.OnboardingMod.open(this._settings, this);
    }
    if (isOnboardingActive(user) && this.checkPermissions()) {
      this.setupOnboarding();
    }
    // Wrap this in try/catch so the MutationObserver doesn't break in IE10 and below.
    // This functionality is not vital so just keep going.
    try {
      const config = {
        attributes: true,
        attributeFilter: ['style']
      };
      const minimizingElement = this._element.parents(this._settings.dom.MINIMIZING_CONTAINER).parent();
      let isVisible = minimizingElement.css('display') !== 'none';
      const composeWindow = this._element.parents(this._settings.dom.NEW_COMPOSE_FULL_SCREEN_BACKGROUND);
      const composeWindowHeight = composeWindow.css('height');
      const contentDiv = this._element.find(this._settings.dom.NEW_COMPOSE_RESIZABLE_BODY);
      const banner = this._element.find('.virtru-new-compose-editor-banner');
      contentDiv.attr('updatedHeight', parseInt(contentDiv.css('maxHeight'), 10) - banner.height());
      this._element.parents('body').find(this._settings.dom.NEW_COMPOSE_MAIN_WRAPPER).addClass('VIRTRU_GMAIL_MAIN_WRAPPER');
      this._element.find(this._settings.dom.NEW_COMPOSE_NON_SECURE_ATTACHMENT_SECTION).addClass('VIRTRU_NON_SECURE_ATTACHMENT_SECTION');
      correctAttachementHeight(this._element, this._settings, banner);

      // this observer watches for the new compose window to be minimized. This happens automatically
      // when the user shrinks the browser window to about 550px in width.
      this._minimizeObserver = new MutationObserver(function () {
        const nowIsVisible = minimizingElement.css('display') !== 'none';
        // make sure this only fires when the visibility changes
        if (nowIsVisible !== isVisible) {
          // compose window is not minimized, so show the overlay and onboarding popover
          if (nowIsVisible) {
            self.resizeHandler();
          }
          if (self.newFeatureNotification) {
            if (nowIsVisible) {
              self.newFeatureNotification.updatePosition();
            } else {
              self.newFeatureNotification.dismiss();
              self.newFeatureNotification = null;
            }
          }
          // compose window is minimized, so hide the overlay and onboarding popover
          if (!nowIsVisible && self._onboardingTourMod._onboardingOverlay) {
            self._onboardingTourMod._onboardingOverlay._element.hide();
          }
          if (!nowIsVisible && self._onboardingTourMod._activeOnboardingPopover) {
            self._onboardingTourMod._activeOnboardingPopover.el.hide();
          }
          isVisible = nowIsVisible;
          if (self._settings.user.auth('status') !== 'active') {
            self._onboardingTourMod.showRestartBanner();
          }
        }
      });
      this._resizeObserver = new MutationObserver(() => {
        const currentComposeWindowHeight = composeWindow.css('height');
        const nowIsVisible = minimizingElement.css('display') !== 'none';
        // if the height of the compose window changes adjust popovers and the window is visable
        if (this.newFeatureNotification && nowIsVisible) {
          this.newFeatureNotification.updatePosition();
        }
        if (composeWindowHeight !== currentComposeWindowHeight && nowIsVisible) {
          if (self._onboardingTourMod._onboardingOverlay) {
            self._onboardingTourMod._onboardingOverlay._element.show();
            self._onboardingTourMod._onboardingOverlay.reposition();
          }
          if (self._onboardingTourMod._activeOnboardingPopover) {
            self._onboardingTourMod._activeOnboardingPopover.el.show();
            self._onboardingTourMod._activeOnboardingPopover.reposition();
          }
          if (this._settings.user.auth('status') !== 'active') {
            this._onboardingTourMod.showRestartBanner();
          }
        }
      });
      this._heightObserver = new MutationObserver(() => {
        const updatedMaxHeight = parseInt(contentDiv.attr('updatedHeight'));
        contentDiv.css('maxHeight', updatedMaxHeight);
        contentDiv.find('>:first-child').css('maxHeight', updatedMaxHeight);
      });
      this._minimizeObserver.observe(minimizingElement[0], config);
      this._resizeObserver.observe(composeWindow[0], config);
      this._heightObserver.observe(contentDiv[0], config);
    } catch (e) {
      // no need to report this, since it is a non-vital feature that only breaks in IE10 and below.
    }
    new_compose_console.debug(`Setup completed... ${this._composeId}`);
    correctComposeWindowHeight(this._element, this._settings);
  }
  removeSectionTooltip() {
    const {
      user
    } = this._settings;
    if ((0,utils.isFeatureEnabled)(user._profile, 'useAttachmentChipsV2')) {
      const tooltip = this._editor.find('.virtru-section-tooltip-wrapper')[0];
      if (tooltip) {
        tooltip.remove();
      }
    }
  }
  removePCMExtensionTooltip() {
    const tooltip = this._element.find('.virtru-pcm-info-wrapper')[0];
    if (tooltip) {
      tooltip.remove();
    }
  }
  isNewFeatureShown(feature) {
    const value = this._settings.user.setting(`preferences.${feature}`);
    if (typeof value === 'undefined' || typeof value === 'boolean') {
      return !!value;
    }
    throw new Error(`boolean value expected instead of: ${typeof value}`);
  }

  /**
   * Contextual enabling of secure-mode
   */
  configureSecureModeBasedOnContext() {
    try {
      const senderDomains = this._settings.user.setting('secureSendRules').senderDomains.secureDefault;
      const thisUser = this._settings.gmailGlobals.user;
      let secureDefault = false;
      let secureMode = false;
      for (let i = 0, len = senderDomains.length; i < len; ++i) {
        if (thisUser.indexOf(`@${senderDomains[i]}`) > -1) {
          secureDefault = true;
        }
      }

      // If it's a secure draft we should handle things slightly differently and not
      // validate the attachments, so we'll setup secure mode manually
      const numAttachments = this.attachmentsHelper.getUnsecureAttachments().length + this.attachmentsHelper.getUnsecureImageAttachments().length;
      const forwardWithAttachments = numAttachments > 0 && this.isForward;
      const composeWindowData = this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.COMPOSE_METADATA);
      const canCreatePolicies = this._settings.user.setting('permissions.canCreatePolicies');
      if (canCreatePolicies === false) {
        secureMode = false;
      } else if (this._isSecureDraft) {
        // If the mail merge is enabled, we should not enable secure mode automatically
        if (this._element.parents(this._settings.dom.MAIL_MERGE_COMPOSE_BODY).length > 0) {
          secureMode = false;
        } else {
          this.secureModeOn();
          return;
        }
      } else {
        const secureModeSetting = this._determineDefaultVirtruState();

        // If a compose window mutates in an unexpected way, the secure mode will
        // travel with the associated metadata. For now, only really used by popout
        // reply from inline reply and restoration to inline.
        if (composeWindowData && composeWindowData.secure) {
          secureMode = composeWindowData.secure;
        } else if (this.isNew) {
          secureMode = this._isExistingUnsecureDraft ? false : secureModeSetting;
          // If the secure default is set to true
        } else if (secureDefault === true) {
          secureMode = true;
          // If it's a forward and has attachments we want to leave secure
        } else if (this.isForward) {
          secureMode = !forwardWithAttachments && this.checkReplySecure();
          // If replying to a secure message
        } else if (!this.isNew) {
          secureMode = this.checkReplySecure();
        } else {
          secureMode = false;
        }
      }

      // Addition amplitude log
      new_compose_AnalyticsService.composeInfo(...getSecureModeStatusParams(this, {
        secureMode,
        secureDefault,
        composeWindowData,
        forwardWithAttachments
      }));
      if (secureMode === true) {
        this.secureModeOn();
      } else {
        this.secureModeOff();
      }
    } catch (e) {
      new_compose_console.log('configureSecureModeBasedOnContext error: ', e);
      return Promise.reject(e);
    }
  }

  /**
   * Determine the default state of Virtru for new compose messages based on a combination of
   * user preferences and organization-wide settings
   *
   * @returns {Boolean} - Default Virtru state
   */
  _determineDefaultVirtruState() {
    let previousVirtruState = this._settings.user.setting('preferences.previousVirtruState');
    let userDefaultVirtruState = this._settings.user.setting('preferences.secureMode');
    const orgDefaultVirtruState = this._settings.user.setting('orgSettings.defaultVirtruState');
    const orgDefaultVirtruStateOverride = this._settings.user.setting('orgSettings.defaultVirtruStateOverride');

    // This is to keep the existing behavior of Virtru for existing customers
    // This done by assigning the local copy of `preferences.secureMode` to `previousVirtruState` and then unsetting it.
    if (previousVirtruState === undefined) {
      if (typeof userDefaultVirtruState === 'boolean') {
        previousVirtruState = userDefaultVirtruState;
        userDefaultVirtruState = undefined;
        this._settings.user.setting('preferences.secureMode', undefined);
      } else {
        previousVirtruState = false;
      }
    }
    return (0,Compose.determineDefaultVirtruState)(previousVirtruState, userDefaultVirtruState, orgDefaultVirtruState, orgDefaultVirtruStateOverride);
  }

  /**
   * Returns the mode of the compose window.  One of:
   * ['reply', 'reply-all', 'forward', 'new']
   *
   * This function should ALWAYS return one of the above options or it will
   * mess up analytics. If for any reason the possible return values need to be updated,
   * do so while considering the impact on analytics. Ask Tyler for more details if need be.
   *
   * @returns {string}
   */
  getEmailMode() {
    const element = this._element;
    const {
      dom
    } = this._settings;
    if (element.find(dom.COMPOSE_REPLY).length > 0) {
      return EMAIL_MODE.Reply;
    } else if (element.find(dom.COMPOSE_REPLY_ALL).length > 0) {
      return EMAIL_MODE.ReplyAll;
    } else if (element.find(dom.COMPOSE_FORWARD).length > 0) {
      return EMAIL_MODE.Forward;
    }
    return EMAIL_MODE.New;
  }

  // Get the message immediately above the reply box
  getPreviousMessage() {
    // Check if we're in a reply thread...
    const {
      dom
    } = this._settings;
    // Navigate up the DOM to the message list div that contains
    // the reply
    // Method 1: Find message list then look at previous item in list
    const messageListItem = this._element.closest(dom.NEW_REPLY_DOM_CHILD);
    if (messageListItem.length > 0) {
      // Navigate to the previous sibling, which is the message
      // that is being replied to/forwarded
      return messageListItem.prev();
    }

    // Method 2: Find id of message we're replying to in the current compose,
    //  then look up that message in the read container
    const previousMessageId = this._element.find(dom.POPOUT_COMPOSE_PREVIOUS_MESSAGE).val();
    const previousMessage = jquery_pack_default()(dom.READ_CONTAINER).find(`[data-message-id='${previousMessageId}']`);
    if (previousMessage.length > 0) {
      return previousMessage;
    }
    return null;
  }
  checkReplySecure() {
    // Check if we're in a reply thread...
    const {
      dom
    } = this._settings;
    const previousMessage = this.getPreviousMessage();
    if (!previousMessage) {
      return false;
    }
    const virtruOpens = previousMessage.find('.virtru-email-decrypted');
    if (!virtruOpens.length) {
      return false;
    }
    const gmailExtras = previousMessage.find(dom.NEW_COMPOSE_TRIMMED_CONTENT);
    // All virtru-open must be inside of a gmail_extra to be treated as unsecure email
    // A single virtru-open not within a gmail_extra means the email was sent secure
    return virtruOpens.toArray().some(virtruOpen => !gmailExtras.toArray().some(gmailExtra => gmailExtra.contains(virtruOpen)));
  }
  readNewComposeInformation(formEle) {
    this._composeId = jquery_pack_default()('input[name="composeid"]', formEle).attr('value');
    this._draftId = jquery_pack_default()('input[name="draft"]', formEle).attr('value');
    this._threadId = jquery_pack_default()('input[name="rt"]', formEle).attr('value');
    this._element.attr('composeId', this._composeId);
  }
  getDraftId() {
    return jquery_pack_default()('input[name="draft"]', this._formElement).attr('value');
  }
  setupNewCompose() {
    this._isNewComposeWindow = true;
    this.animationHelper.resizeFullScreenElement();
  }
  setupEditorBanner(element, formEl, emailMode) {
    formEl.parent().prepend(jquery_pack_default()((0,templates.newComposeEditor)()));
    const win = jquery_pack_default()(window);
    win.triggerNative('resize');
    this._editorBanner = element.find(this.bannerSelector);
    // Reset the aria live region if we switch focus
    this._editorBanner.on('focusout', () => {
      this._editorBanner.find('.virtru-announce-status').text('');
    });

    // only affect the banner of the particular compose window
    this._gmailBanner = jquery_pack_default()(this._settings.dom.GMAIL_COMPOSE_BANNER).last();
    this._gmailBanner.addClass('virtru-gmail');
    const toggleEl = this._toggleEl = this._editorBanner.find('.virtru-toggle');
    this._toggle = Toggle.load(toggleEl, {
      emailMode
    });
    this.tooltipHelper.setToggleElement(this._toggle);
    const $replyParentContain = element.parents(this._settings.dom.NEW_REPLY_INDICATOR);

    // This checks if we're inside the reply thread compose window, if
    // we are then we don't need to apply the resize fix
    if ($replyParentContain.length === 0) {
      this.setupNewCompose();
    } else {
      $replyParentContain.addClass('virtru-reply-contain');
      this._isNewComposeWindow = false;
    }
    this.initTooltips();
    this.setupPolicyConfigMenu(element);
    this.tooltipHelper.updateToggleTooltip();
    this.configureForwardWarning();
    if (!this._onboardingTourMod) {
      this._onboardingTourMod = onboarding_tour.OnboardingTourMod.open(this._settings, this._element);
    }

    // If the user cannot use virtru do not show the info icon to restart the onboarding tour
    if (this.checkPermissions()) {
      const orgDefaultVirtruState = this._settings.user.setting('orgSettings.defaultVirtruState');
      const orgDefaultVirtruStateOverride = this._settings.user.setting('orgSettings.defaultVirtruStateOverride');
      // If org-wide default state is set and user is not allowed to override
      const orgOverride = orgDefaultVirtruState === 'on' && !orgDefaultVirtruStateOverride;
      this._onboardingTourMod.bindInfoIconLinks(this._editorBanner, orgOverride, this._toggle);
      this.handleInfoClick();
    } else {
      jquery_pack_default()(this._editorBanner).find('.virtru-show-info-btn').hide();
    }
    if (!this.isNewFeatureShown('persistentProtectionTipShown') && this._settings.user.permissions.canTogglePfp && this.getEmailMode() === emailMode.New) {
      this.displayPPTooltip();
    }
    this._onboardingTourMod.resizeHandler();
    if (this._settings.user.auth('status') !== 'active') {
      const isReactivation = !this._settings.user.setting('firstTime');
      this._onboardingTourMod.showRestartBanner();
      this._onboardingTourMod.bindActivateLink(isReactivation);
    }
    this.updateLabelCallback = this.updateLabel.bind(this);
    this.updateTooltipCallback = this.tooltipHelper.updateToggleTooltip.bind(this);
    // TODO: not working
    this._settings.on('load:user', this.updateLabelCallback);
    this._settings.on('profile-refreshed', this.onRefreshUserProfile.bind(this));
    this._settings.on('reactivation-completed', this.onRefreshUserProfile.bind(this));
    this._virtruOfflineMode.onChange(this.onConnectivityStateChange);
  }
  async onRefreshUserProfile() {
    if (this._settings.user.auth('status') == 'active') {
      this._onboardingTourMod.hideRestartBanner();
      if (this._emailError) {
        this._emailError.teardown();
        this._emailError = null;
        if (!this._messageIsSending) {
          // restore the message
          gmail_utility.unPwnCompose(this._element, this._settings.dom);
          this.restoreTdfAttachmentMods();
        }
      }
      if (this._messageIsSending) {
        // send the message
        this.covertLoadTrimmedContent();
        this.sendSecure();
      }
    } else {
      this._onboardingTourMod.showRestartBanner();
      this._onboardingTourMod.bindActivateLink(true);
    }
  }
  onConnectivityStateChange() {
    this.updateLabel();
    this.tooltipHelper.updateToggleTooltip();
  }
  updateLabel() {
    jquery_pack_default()(this._editorBanner).find('.virtru-label').text(this.getLabelStr());
    jquery_pack_default()(this._element).toggleClass('virtru-offline', this._virtruOfflineMode.isOffline());
    this.tooltipHelper.updateActivateTooltip();
  }
  handleInfoClick() {
    jquery_pack_default()(this._editorBanner).find('.virtru-show-info-btn').on('click', event => {
      if (this._virtruOfflineMode.isOffline()) {
        renderModal/* default */.A.offline(this.isSecureMode());
      } else {
        jquery_pack_default()(event.target).trigger('online_click', event);
      }
    });
  }
  getLabelStr() {
    const connectionStatus = this._virtruOfflineMode.isOnline() ? 'ONLINE' : 'OFFLINE';
    if (!isActivated(this._settings.user)) {
      return i18n.t('VIRTRU_PROTECTION_NOT_AUTH', {
        context: connectionStatus
      });
    } else if (this.isSecureMode()) {
      if (this._virtruOfflineMode.isOnline()) {
        const timeRemaining = getRemainingTime(this._policyConfigMenu._policyModel);
        if (timeRemaining) {
          return i18n.t('COMPOSE_EXPIRES', {
            timeRemaining
          });
        }
        return i18n.t('VIRTRU_PROTECTION_ON');
      }
    } else if (this._virtruOfflineMode.isOnline()) {
      return i18n.t('VIRTRU_PROTECTION_OFF');
    }
    return i18n.t('VIRTRU_PROTECTION_OFFLINE');
  }
  displayPPTooltip() {
    this.newFeatureNotification = new new_feature_notification.NewFeatureNotification({
      attachToElement: '.virtru-policy-config',
      position: 'northeast',
      template: (0,templates.virtruNewFeatureTipPopover)({
        label: i18n.t('NEW_FEATURE_POPOVER_PP_LABEL'),
        body: i18n.t('NEW_FEATURE_POPOVER_PP_BODY'),
        button: i18n.t('NEW_FEATURE_POPOVER_PP_BUTTON')
      }),
      dismissCallback: () => {
        this._settings.user.setting('preferences.persistentProtectionTipShown', true);
      }
    });
  }

  /**
   * This function is awful... It checks whether or not the forwarding
   * warning should be displayed.  It will look at the previous message
   * in the chain, grab the MessageMod for it, access the policy, and
   * check whether or not it has disable forwarding.
   */
  configureForwardWarning(clickedRecipients) {
    const {
      dom
    } = this._settings;
    if (!this._prevForwardDisabled) {
      return;
    }

    // Navigate up the DOM to the message list div that contains
    // the reply
    const messageListItem = this._element.parents(dom.NEW_REPLY_DOM_CHILD);
    if (messageListItem.length === 0) {
      return;
    }

    // Navigate to the previous sibling, which is the message
    // that is being replied to/forwarded
    const previousMessage = jquery_pack_default()(messageListItem[0]).prev();
    const messageModElement = previousMessage.find('.virtru-message');
    if (messageModElement.length === 0) {
      new_compose_console.warn('Couldn\'t find .virtru-message selector');
      return;
    }
    const classes = messageModElement.attr('class');
    if (classes == null || classes.split(' ').length < 2) {
      return;
    }
    const prevMessageId = classes.split(' ')[2];
    const mod = lib_mods.MessageManager.getMessage(prevMessageId);
    if (mod == null) {
      return;
    }
    const contract = mod.getPolicy();
    if (contract == null) {
      return;
    }
    this._prevForwardDisabled = !contract.authorizations.includes(EMAIL_MODE.Forward);
    if (!this._prevForwardDisabled) {
      return;
    }
    // Get the email mode, one of : ['reply', 'reply-all', 'forward', 'new']
    this._emailMode = this.getEmailMode();
    const $forwardWarning = this._element.find('.virtru-forward-warning');
    const $forwardWarningIcon = this._element.find('.virtru-forward-warning-icon');
    $forwardWarning.text(i18n.t('FORWARDING_RESTRICTED'));

    // If it's a forward or they clicked somewhere in the recipients area
    // show the warning
    if (this._emailMode === EMAIL_MODE.Forward || clickedRecipients) {
      $forwardWarning.show();
      $forwardWarningIcon.show();
    } else {
      $forwardWarning.hide();
      $forwardWarningIcon.hide();
    }
  }
  initTooltips() {
    this.tooltipHelper.generateForwardingTooltip();
    this.tooltipHelper.generateNoAuthTooltip();
    this.tooltipHelper.generateForwardWarningTooltip();
    this.tooltipHelper.generateWatermarkingTooltip();
    this.tooltipHelper.generatePersistentProtectionTooltip();
  }
  setupPolicyConfigMenu(element) {
    this._policyConfigMenu = policy_config_menu.PolicyConfigMenuFunctions;
    (0,policy_config_menu.attachPolicyMenu)(element.find('.virtru-policy-config')[0], this._settings, () => this.emailUsers(), this.limitedEncryptionCheck.bind(this), this.onPolicyConfigMenuClosed, callback => {
      this._toggle.on('off', callback);
    });
    this._policyConfigMenu.on('disable-forwarding-changed', this.onDisableForwardingChanged);
    this._policyConfigMenu.on('enable-sms-changed', this.onEnagleSMSChanged);
    this._policyConfigMenu.on('pfp-changed', this.onPfpChanged);
    this._policyConfigMenu.on('enable-noauth-changed', this.onEnableNoauthChanged);
    this._policyConfigMenu.on('enable-watermark-changed', this.onEnableWatermarkChanged);
    this._policyConfigMenu.on('is-managed-changed', this.onSetIsManaged);
    this._policyConfigMenu.on('expiration-date-changed', this.onExpirationDateChanged);
    this._policyConfigMenu.on('security-option-toggled', this.onSecurityOptionToggled);
  }
  onPolicyConfigMenuClosed(policy) {
    if (this.policyHelper) {
      this.policyHelper.setByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, policy, false);
    }
  }

  /**
   * Adds no-auth authorization to email policy to enable OneClick/NoAuth emails
   * Not supported by organizations with customer managed encryption keys (aka CKS org)
   * Not supported with disable forwarding option
   * @returns {boolean} whether NoAuth was enabled
   */
  turnOnNoAuthEmails() {
    if (!this._policyConfigMenu.getIsCksOrg()) {
      this.patchPolicyConfig({
        enableNoauth: true
      });
      return true;
    }
    return false;
  }
  patchPolicyConfig(policyConfigPatch) {
    const currentPolicy = this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, true);
    const resultPolicy = Object.assign(currentPolicy, policyConfigPatch);
    this.policyHelper.setByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, resultPolicy);
  }
  getPolicyConfig() {
    return this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, true);
  }
  togglePfpStyle(value) {
    const attachments = this._editor.find(this._settings.dom.VIRTRU_TDF_ATTACHMENT);
    jquery_pack_default()(attachments).toggleClass('pfp-enabled', value);
  }
  toggleEWStyle(value) {
    const attachments = this._editor.find(this._settings.dom.VIRTRU_TDF_ATTACHMENT);
    jquery_pack_default()(attachments).toggleClass('ew-enabled', value);
  }
  onDisableForwardingChanged(value) {
    this._element.find('.virtru-forwarding-icon').css('display', value ? 'inline-block' : 'none');
    AnimationHelper.toggleIconPadding();
  }
  onEnagleSMSChanged(value) {
    this._element.find('.virtru-sms-icon').css('display', value ? 'inline-block' : 'none');
    AnimationHelper.toggleIconPadding();
  }
  async onPfpChanged(value) {
    this._element.find('.virtru-pfp-icon').css('display', value ? 'inline-block' : 'none');
    AnimationHelper.toggleIconPadding();
    this.togglePfpStyle(value);
    this.attachmentsHelper._tdfAttachmentMods.forEach(mod => {
      const securityOptionData = {
        securityOption: PERSISTENT_PROTECTION,
        value
      };
      const {
        user
      } = this._settings;
      if ((0,utils.isFeatureEnabled)(user._profile, 'useAttachmentChipsV2')) {
        new_compose_dispatchToStore({
          type: 'UPDATE_ATTACHMENT_SECURITY_OPTION',
          id: mod.tdfData.tdo.id,
          data: securityOptionData
        });
      }
    });
  }
  onEnableNoauthChanged(value) {
    this._element.find('.virtru-noauth-icon').css('display', value ? 'inline-block' : 'none');
    AnimationHelper.toggleIconPadding();
  }
  async onEnableWatermarkChanged(value) {
    this._element.find('.virtru-watermark-icon').css('display', value ? 'inline-block' : 'none');
    const attachments = this.attachmentsHelper._tdfAttachmentMods;
    AnimationHelper.toggleIconPadding();
    this.toggleEWStyle(value);
    attachments.forEach(mod => {
      const securityOptionData = {
        securityOption: WATERMARK,
        value
      };
      const {
        user
      } = this._settings;
      if ((0,utils.isFeatureEnabled)(user._profile, 'useAttachmentChipsV2')) {
        new_compose_dispatchToStore({
          type: 'UPDATE_ATTACHMENT_SECURITY_OPTION',
          id: mod.tdfData.tdo.id,
          data: securityOptionData
        });
      }
      mod.setExpandedWatermarking(value);
    });
  }
  onExpirationDateChanged(expires, expirationDate, timeRemaining) {
    if (expirationDate) {
      this._policyConfigMenu._policyModel.expirationDate = expirationDate;
      this.tooltipHelper.onExpirationDateChanged(expirationDate, expires, timeRemaining);
    } else {
      const date = new Date();
      date.setDate(date.getDate() + 1);
      this._policyConfigMenu._policyModel.expirationDate = date;
      this.tooltipHelper.onExpirationDateChanged(date, expires, timeRemaining);
    }
    this._policyConfigMenu._policyModel.expires = expires;
    this.updateLabel();
  }

  /**
   * Triggered whenever a security option is toggled in policy-config-menu.
    * @param optionName {String} - readable name of the security option toggled
   * @param value {boolean} - the new value, coerced to "on" or "off"
   */
  async onSecurityOptionToggled(optionName, value) {
    const attachments = Object.values(this.attachmentsHelper._tdfAttachmentMods || {});
    new_compose_AnalyticsService.securityOptionToggled(...getSecurityOptionToggledParams(this, {
      optionName,
      value,
      attachments
    }));
  }

  /**
   * Triggered whenever a security option is toggled in policy-config-menu.
   * Checks if the option is applicable to the attached files so user can
   * cancel the option or continue with unsupported files
   * @param value {boolean} - the new value, coerced to "on" or "off"
   */
  limitedEncryptionCheck(value) {
    if (value) {
      const attachments = Object.values(this.attachmentsHelper._tdfAttachmentMods || {});
      return attachment_util.canProceedLimitedEncryption(attachments.map(attachment => attachment.fileData));
    }
    return true;
  }
  getAnalyticsObjectFromAttachments(attachments) {
    return attachments.map(attachment => attachment.getAnalyticsObject());
  }
  calculateExpandedProtectionCoverage(attachments) {
    if (!Array.isArray(attachments) || attachments.length === 0) {
      return 0;
    }
    const supportedAttachments = this.validateExpandedProtectionSupport(attachments);
    return supportedAttachments.length / attachments.length * 100;
  }
  calculateTotalFileSize(attachments) {
    if (!Array.isArray(attachments) || attachments.length === 0) {
      return 0;
    }
    return attachments.reduce((total, attachment) => total + parseInt(attachment.fileData.size, 10), 0);
  }
  calculateAverageFileSize(attachments) {
    if (!Array.isArray(attachments) || attachments.length === 0) {
      return 0;
    }
    return this.calculateTotalFileSize(attachments) / attachments.length;
  }
  validateExpandedProtectionSupport(attachments) {
    if (!Array.isArray(attachments) || attachments.length === 0) {
      return [];
    }
    return attachments.filter(attachment => (0,utils.supportsExpandedWatermarking)(attachment.fileData.name));
  }
  onSetIsManaged(value) {
    this._element.find('.virtru-is-managed-icon').css('display', value ? 'inline-block' : 'none');
    this.attachmentsHelper._tdfAttachmentMods.forEach(mod => {
      const {
        user
      } = this._settings;
      if ((0,utils.isFeatureEnabled)(user._profile, 'useAttachmentChipsV2')) {
        new_compose_dispatchToStore({
          type: 'UPDATE_ATTACHMENT_IS_MANAGED_OPTION',
          id: mod.tdfData.tdo.id,
          data: value
        });
        mod.setIsManaged(value);
      }
    });
    AnimationHelper.toggleIconPadding();
  }
  setupSecureModeManual() {
    this.saveInitialMetadata();
    if (this.attachmentsHelper.getAllUnsecureAttachments() > constants.ATTACHMENTS_LIMIT) {
      this.secureModeOff();
      return;
    }
    if (this.secureModeOn()) {
      if (this.isNew) {
        this._settings.user.setting('preferences.previousVirtruState', true);
      }
      new_compose_AnalyticsService.secureModeToggleOn({
        type: this._emailMode
      });
      this._recipientsMod.focusTo();
    }
  }
  teardownSecureModeManual() {
    this.saveInitialMetadata();
    if (this.secureModeOff()) {
      if (this.isNew) {
        this._settings.user.setting('preferences.previousVirtruState', false);
      }
      this.attachmentsHelper._unsecureAttachments = [];
      new_compose_AnalyticsService.secureModeToggleOff({
        type: this._emailMode
      });
      this._recipientsMod.focusTo();
    }
  }
  setupSecureMode() {
    this._predictiveInterceptor.start();
    this._editorBanner.addClass('virtru-read-write');
    this._gmailBanner.addClass('virtru-read-write-gmail');
    this.disableMailMerge();

    // Add a mail merge class to the compose window so the icons are light.
    this._gmailBanner.parents(this._settings.dom.COMPOSE_WINDOW_DIALOG).addClass(this._settings.dom.MAIL_MERGE_ACTIVE);

    // Remove any SSS application to this message when the user manually toggles
    // secure mode. Failure to do so creates several UI glitch vectors, and is
    // redundant.
    if (this._sendSecureMod) {
      this._sendSecureMod.remove();
    }
    this.setupSendSecureButtons();
    this.setupScheduledSendButtons();
    this.setupAttachmentButton();
    this.setupTrimmedContent();
    this.setupComposeTitle();
    if (this._promoFooter) {
      this._promoFooter.setFooter();
    }
    this._element.find(this._settings.dom.INSERT_PHOTO_BUTTON).hide();
    let borderModElement = this._element.parent().parent().parent().parent().parent().parent();

    // used for new compose in new window/tab
    if (!jquery_pack_default()(borderModElement).hasClass('aaZ')) {
      borderModElement = this._element.closest('table');
    }

    // Create the border mod
    this._newComposeBorderMod = NewComposeBorderMod.open(this._settings, this._isNewComposeWindow, borderModElement);
    // Register
    this.register(this._newComposeBorderMod);
    this._insertFromDriveMod = NewComposeInsertFromDriveMod.open(this._settings, this._element, this._composeId);
    this.setupPopoutReply();
    this.setupIntro();
    this.tooltipHelper.updateToggleTooltip();
    this.updateLabel();
  }

  /**
   * Gives focus to the To field
   */
  focusToField() {
    // Ignore if this is a reply - we only care about new emails
    if (this._emailMode === EMAIL_MODE.New || this._emailMode === EMAIL_MODE.Forward) {
      // Need a small delay for the recipient overlay to kick in
      // and appear, which is what we are focusing on
      setTimeout(() => {
        // this is default behavior now (may have changed over time?)
        // this._element.find(this._settings.dom.NEW_COMPOSE_TO_VISUALS).focus();
        this._initialBodyText = this._initialBodyText || this.bodyText();
      }, 10);
    }
  }

  /**
   * Hooks the 'Edit Subject' and 'Popout Reply' menu items
   * so that we can correctly restore state after the email
   * is popped out into the modal compose window.
   */
  setupPopoutReply() {
    if (this._emailMode === EMAIL_MODE.New) {
      return;
    }
    const self = this;
    const {
      dom
    } = this._settings;
    try {
      // Grab the reply/replyall/forward menu
      const container = this._element.parents(dom.NEW_COMPOSE_BODY);
      const menu = container.find('.HX.J-M.jQjAxd');
      this._formElement = this._element.find('form');
      this.readNewComposeInformation(this._formElement);

      // The menu items we want to hook come after the separator.
      // This is brittle b/c there's no uniquely identifying
      // attribute we can key off of to get the menu items.
      const editSubject = menu.find('[role="separator"]').next();
      const popoutReply = editSubject.next();
      const onClick = () => {
        new_compose_console.debug('onClick - popping out');

        // Register a fake mod that stores the state of the compose
        // window so that draft saving doesn't freak out...
        compose_manager_default().registerFaux({
          _state: self.getToggleState(),
          _composeId: self.composeId(),
          getToggleState: () => self.getToggleState(),
          composeId: () => self._composeId
        });

        // If security is on we need to reinstate the new compose window
        // that is created appropriately
        if (self.getToggleState() === 'on') {
          this.policyHelper.setByMetadataKey(sites.EmailMetadataEnum.COMPOSE_METADATA, {
            secure: true
          });
        }
      };
      if (editSubject[0]) {
        editSubject[0].addEventListener('mousedown', onClick, true);
      }
      if (popoutReply[0]) {
        popoutReply[0].addEventListener('mousedown', onClick, true);
      }
    } catch (err) {
      // Nothing here is in the critical path, so just log and continue
      // on errors.
      new_compose_console.warn('Couldn\'t set up popout reply.');
      new_compose_console.warn(err);
    }
  }
  setupOnboarding() {
    // this will only be called if onboarding is active.
    const self = this;
    const {
      dom,
      user
    } = this._settings;
    if (!this._onboardingTourMod) {
      this._onboardingTourMod = onboarding_tour.OnboardingTourMod.open(this._settings, this._element);
    }

    // Hooks mousedown for the 'reply' container
    jquery_pack_default()(dom.NEW_REPLY_REPLY_OPTIONS).on('mousedown', () => {
      self.configureForwardWarning(true);
    });
    if (isActivated(user)) {
      const seenTurnOnProtection = user.setting('onboarding.tour2') || false;
      const seenOnboardingTourControls = user.setting('onboarding.tour3') || false;
      const seenOnboardingTourPersonalize = user.setting('onboarding.tour4') || false;
      refreshFormattingButton(this._element, dom);
      jquery_pack_default()(window).triggerNative('resize');

      // only proceed if Onboarding is active
      if (this.isSecureMode()) {
        if (!seenOnboardingTourControls) {
          this._onboardingTourMod.openTourStepThree(this._editorBanner);
        } else if (!seenOnboardingTourPersonalize) {
          // If the user hasn't seen any popovers after popover 3, show popover 4
          this._onboardingTourMod.openTourStepFour();
        }
      } else if (!seenTurnOnProtection) {
        this._onboardingTourMod.openTourStepTwo(this._editorBanner);
      }
    }
  }

  // Record the initial metadata found as a hidden input. Used for fixing draft saves being created
  saveInitialMetadata() {
    this._initialMetadata = this._initialMetadata || virtruMetadataElement().val();
  }
  secureModeOn() {
    this.policyHelper.setByMetadataKey(sites.EmailMetadataEnum.COMPOSE_METADATA, {
      secure: true
    }, true);
    if (this.validateSecureModeCouldBeEnabled()) {
      var _this$_sendButtonsMod;
      this._toggle.setState('on');
      if (this.isNew) {
        this._settings.user.setting('preferences.previousVirtruState', true);
      }
      this.setupSecureMode();
      (_this$_sendButtonsMod = this._sendButtonsMod) === null || _this$_sendButtonsMod === void 0 ? void 0 : _this$_sendButtonsMod.addVirtruStyles();
      return true;
    }
    this.onBeforeTeardownSecureMode();
    this.teardownSecureMode();
    return false;
  }
  secureModeOff() {
    this.policyHelper.setByMetadataKey(sites.EmailMetadataEnum.COMPOSE_METADATA, {
      secure: false
    }, true);
    if (this.onBeforeTeardownSecureMode() !== false) {
      var _this$_sendButtonsMod2;
      this._toggle.setState('off');
      if (this.isNew) {
        this._settings.user.setting('preferences.previousVirtruState', false);
      }
      this.teardownSecureMode();
      (_this$_sendButtonsMod2 = this._sendButtonsMod) === null || _this$_sendButtonsMod2 === void 0 ? void 0 : _this$_sendButtonsMod2.revertToGmailStyles();
      return true;
    }
    this.onBeforeSetupSecureMode();
    this.setupSecureMode();
    return false;
  }

  // The "remove-me" class lets us keep track that we have clicked the delete button which takes effect in the next frame.
  hasSecureAttachmentChips() {
    return this._element.find('.virtru-attachment:not(.remove-me)').length > 0;
  }
  removeSecureAttachmentChips() {
    return this._element.find('.virtru-attachment').addClass('remove-me').find('.virtru-attachment-delete').click();
  }

  /**
   * Checks if there are any secure attachments on the e-mail prior to switching off
   * secure mode.  If there are, prompt the user to confirm, then remove them.
   *
   * @returns {boolean}
   */
  onBeforeTeardownSecureMode() {
    if (this.isAttachmentUploading()) {
      this.alert(i18n.t('COMPOSE_ATTACHMENTS_UPLOADING_WARN'));
      return false;
    }
    if (Object.keys(this._attachmentMods).length > 0) {
      if (confirm(i18n.t('COMPOSE_OFF_CONFIRM_REMOVE'))) {
        for (const key in this._attachmentMods) {
          if (Object.hasOwn(this._attachmentMods, key)) {
            const mod = this._attachmentMods[key];
            mod.getClonedDeleteButton().triggerNative('click');
          }
        }
        this._attachmentMods = {};
      } else {
        return false;
      }
    }
    if (this.hasSecureAttachmentChips()) {
      if (confirm(i18n.t('COMPOSE_OFF_CONFIRM_REMOVE'))) {
        this.removeSecureAttachmentChips();
      } else {
        return false;
      }
    }

    // make sure toggle is in the off state
    if (this.isSecureMode()) {
      this._toggle.setState('off');
    }
    // check for popover models that are not part of the tour i.e. have no overlay and close them
    if (this._onboardingTourMod && this._onboardingTourMod._activeOnboardingPopover && !this._onboardingTourMod._onboardingOverlay) {
      this._onboardingTourMod.onCloseOnboardingPopover();
    }
    return true;
  }
  checkPermissions() {
    const canCreatePolicies = this._settings.user.setting('permissions.canCreatePolicies');
    const canUseVirtru = this._settings.user.setting('permissions.canUseVirtru');
    // NOTE: if user use disabled domain (services not paid)
    // do not allow enabling secure mode and show popup with the information
    if (!canUseVirtru) {
      new_compose_AnalyticsService.tryUseDisabledDomain({
        'userId': this._settings.currentUser()
      });
      renderModal/* default */.A.virtruDisabledOnDomain();
    }
    return canCreatePolicies && canUseVirtru;
  }
  validateUnsupportedAttachmentTypes() {
    const driveAttachments = getDriveAttachments(this._settings.dom, this._editor);
    if (driveAttachments.length > 0) {
      new_compose_AnalyticsService.unsupportedFileFormat(...getUnsupportedFileFormatParams(this, driveAttachments));
      if (confirm(i18n.t('COMPOSE_DRIVE_ATTACHMENTS_UNSUPPORTED'))) {
        for (let i = 0, len = driveAttachments.length; i < len; ++i) {
          driveAttachments[i].chip.remove();
        }
      } else {
        return false;
      }
    }
    return true;
  }
  closeOnboardingPopoverIfRequired() {
    if (this._onboardingTourMod && this._onboardingTourMod._activeOnboardingPopover && !this._onboardingTourMod._onboardingOverlay) {
      this._onboardingTourMod.onCloseOnboardingPopover();
    }
  }

  /**
   * Upon toggling, convert any unsecure attachments to secure as long as the user is activated.
   *
   * @returns {Promise} resolves when attachments will be encrypted
   */
  beforeSetupSecureMode(supressAlerts) {
    return new Promise((resolve, reject) => {
      if (!this.checkPermissions()) {
        return reject(new Error('Virtru is disabled on this domain'));
      }
      if (!this.validateUnsupportedAttachmentTypes()) {
        return reject(new Error('Unsupported attachment type'));
      }
      if (this.isAttachmentUploading()) {
        if (!supressAlerts) {
          this.alert(i18n.t('COMPOSE_ATTACHMENTS_UPLOADING_WARN'));
        }
        return reject(new Error('Attachments still uploading'));
      }

      // If the user is in the middle of a mail merge, don't allow them to secure the message
      if (this._element.parents(this._settings.dom.MAIL_MERGE_COMPOSE_BODY).length > 0) {
        (0,attachments_warn_modal.showMailMergeModal)();
        return reject(errors.MAIL_MERGE_CONFLICT);
      }

      // NOTE: if we are not activated, we cannot upload attachments to S3.
      // Thus don't even bother to convert them. The attachments will remain on the
      // message unchanged, despite technically being in secure mode.
      // IMPORTANT: we are assuming that activation will hit this codepath again
      // when the user activates. Upon activation, we toggle off secure mode, then
      // toggle it back on again in order to start with a clean slate.
      const {
        user
      } = this._settings;
      this.closeOnboardingPopoverIfRequired();
      if (!isActivated(user)) {
        return resolve();
      }

      // Get a list of simulated file objects as if they were natively added via event handlers
      // This allows us to use existing attachment added callbacks
      if (doConvertInlineImagesToBase64(user)) {
        this.attachmentsHelper.convertInlineAttachmentsToBase64();
      }
      const attachments = this.attachmentsHelper.getAllUnsecureAttachments();
      const {
        dom
      } = this._settings;
      this.numAttachments = attachments.length;
      if (attachments.length > constants.ATTACHMENTS_LIMIT) {
        (0,attachments_warn_modal.showAttachmentsLimitModal)(attachments.length);
        return reject(errors.ATTACHMENT_LIMIT_ERROR);
      }
      if (!attachments.length) {
        return resolve();
      }

      // NOTE: Disable 'edit subject' in compose dropdown menu until attachments are
      // secured. This avoids a race-condition caused by inline compose windows
      // being forced into a modal view in the middle of DOM logic execution. It
      // manifests as an unreliable compose modal or a GMail error popup.
      const $editSubject = jquery_pack_default()(dom.NEW_COMPOSE_DROPDOWN_EDIT_SUBJECT);
      $editSubject.css({
        'pointer-events': 'none'
      });
      $editSubject.prepend('<div class="virtru-dropdown-overlay"></div>');
      const $ddOlay = $editSubject.find('.virtru-dropdown-overlay');
      $ddOlay.text(i18n.t('NEW_COMPOSE_DISABLED_WHILE_SECURING'));
      const deleteDivs = this._element.find(dom.NEW_COMPOSE_ATTACHMENT);
      // Hide attachments container
      deleteDivs.parent().hide();
      this._isSwitchingToSecureMode = true;
      return this.attachmentsHelper.convertAttachmentsToSecure(attachments).then(() => {
        // fade out and remove overlay
        $ddOlay.fadeOut(300, function () {
          jquery_pack_default()(this).remove();
          $editSubject.css({
            'pointer-events': 'auto'
          });
        });
        if (this._hasInitialAttachments) {
          this.secureModeOn();
        }
        resolve();
      }).catch(function (err) {
        reject(err);
      }).finally(() => {
        this._isSwitchingToSecureMode = false;
      });
    });
  }

  /**
   * Upon toggling, convert any unsecure attachments to secure as long as the user is activated.
   *
   * @returns {Promise} that will indicate whether all validations passed
   */
  onBeforeSetupSecureMode(supressAlerts) {
    return this.beforeSetupSecureMode(supressAlerts).then(() => true).catch(() => {
      this._toggle.setState('off');
      if (this.isNew) {
        this._settings.user.setting('preferences.previousVirtruState', false);
      }
      this.teardownSecureMode();
      return false;
    });
  }

  /**
   * Peform pre secure mode validations
   * @returns {*} whether it's ok to turn on secure mode
   */
  validateSecureModeCouldBeEnabled() {
    return this._virtruOfflineMode.isOnline() && this.checkPermissions() && this.validateUnsupportedAttachmentTypes();
  }
  async awaitUnsecureAttachments() {
    const self = this;
    const TIMEOUT_DURATION = 1000 * 60 * 5; // milliseconds * seconds * minutes = 5 minutes
    const WAIT_FOR_DRAFT_SAVE_DURATION = 1000 * 10; // 10 seconds
    const startTime = Date.now();
    return new Promise((resolve, reject) => {
      _checkAttachmentsLoaded();

      // This function will call itself until attachments are all loaded, up until the TIMEOUT_DURATION
      function _checkAttachmentsLoaded() {
        const elapsedTime = Date.now() - startTime;
        let attachmentsLoaded = true;
        let loadedAttachmentObjs = [];
        try {
          // Ideally we wait until we intercept a draft save so that we can retrieve a more stable image URL.
          // However this is not guaranteed to happen, so as a precaution we only make this check for a short duration of time.
          const imgAttachmentObjs = self.attachmentsHelper.getUnsecureImageAttachments(elapsedTime < WAIT_FOR_DRAFT_SAVE_DURATION);
          const attachmentObjs = self.attachmentsHelper.getUnsecureAttachments();
          loadedAttachmentObjs = loadedAttachmentObjs.concat(attachmentObjs).concat(imgAttachmentObjs);
        } catch (e) {
          if (!self._hasInitialAttachments) {
            new_compose_console.error(e);
          }
          attachmentsLoaded = false;
        }
        if (attachmentsLoaded) {
          resolve(loadedAttachmentObjs);
        } else {
          if (elapsedTime >= TIMEOUT_DURATION) {
            return reject('Unable to retrieve attachment, exceeded 5 minute timeout');
          }
          window.setTimeout(_checkAttachmentsLoaded, 1000);
        }
      }
    });
  }
  removeAllAttachments() {
    removeInlineImageAttachments(this._settings.dom, this._editor);
    const removeAttachmentBtnSelector = this._settings.dom.NEW_COMPOSE_DELETE_ATTACHMENT;
    const removeAttachmentElements = this._element.find(removeAttachmentBtnSelector);
    removeAttachmentElements.each((_, element) => {
      const $element = jquery_pack_default()(element);
      $element.triggerNative('mousedown');
      $element.triggerNative('mouseup');
      $element.triggerNative('click');
    });
    getDriveAttachments(this._settings.dom, this._editor).forEach(driveAttachment => driveAttachment.chip.remove());
    if (this._attachmentMods && Object.keys(this._attachmentMods).length > 0) {
      for (const key in this._attachmentMods) {
        if (Object.hasOwn(this._attachmentMods, key)) {
          const mod = this._attachmentMods[key];
          mod.getClonedDeleteButton().triggerNative('click');
        }
      }
      this._attachmentMods = {};
    }
    this._element.find('.virtru-attachment-section').remove();
    const metadata = this._element.find('input[name=virtru-metadata]');
    if (metadata.length > 0) {
      const metadataValue = JSON.parse(metadata.val());
      metadataValue.attachments = {};
      metadata.val(JSON.stringify(metadataValue));
    }
    this.removeSecureAttachmentChips();
  }

  // Check to see if any attachments or inline images in the DOM are in a loading state
  isAttachmentUploading() {
    const {
      dom
    } = this._settings;
    if (this.attachmentsHelper._numUploadingAttachments > 0) {
      return true;
    }
    const $uploadProgressBarElements = jquery_pack_default()(dom.UPLOAD_PROGRESS_BAR, this._element);
    if ($uploadProgressBarElements.length > 0) {
      return true;
    }
    const $uploadingInlineImages = this._editor.find(dom.NEW_COMPOSE_ATTACHMENT_INLINE_LOADING);
    if ($uploadingInlineImages.length > 0) {
      return true;
    }
    const $hasNoLinksYet = jquery_pack_default()(`${dom.NEW_COMPOSE_ATTACHMENT} > ${dom.NEW_COMPOSE_ATTACHMENT_FILENAME}`, this._element); // NEW_COMPOSE_ATTACHMENT_FILENAME should be wrapped in A
    return $hasNoLinksYet.length > 0;
  }
  teardownSecureMode() {
    var _this$_sendButtonsMod3, _this$_sendArchiveBut, _this$_promoFooter;
    this._predictiveInterceptor.stop();
    const {
      dom
    } = this._settings;
    this._editorBanner.removeClass('virtru-read-write');
    this._gmailBanner.removeClass('virtru-read-write-gmail');
    this._gmailBanner.parents(this._settings.dom.COMPOSE_WINDOW_DIALOG).removeClass(this._settings.dom.MAIL_MERGE_ACTIVE);
    this.setComposeTitleWithAccordance(i18n.t('NEW_MESSAGE_NOT_SECURE'));
    this.enableMailMerge();
    refreshFormattingButton(this._element, dom);
    this._element.find(this._settings.dom.INSERT_PHOTO_BUTTON).show();
    if (this._onboardingMod) {
      callTearDownAndClear.call(this._onboardingMod, '_newComposeActivationMod');
    }
    callTearDownAndClear.call(this, '_newComposePreMessageMod');
    callTearDownAndClear.call(this, '_trimmedContentMod');
    (_this$_sendButtonsMod3 = this._sendButtonsMod) === null || _this$_sendButtonsMod3 === void 0 ? void 0 : _this$_sendButtonsMod3.teardown();
    (_this$_sendArchiveBut = this._sendArchiveButtonMod) === null || _this$_sendArchiveBut === void 0 ? void 0 : _this$_sendArchiveBut.teardown();
    callTearDownAndClear.call(this, '_attachmentButtonMod');
    callTearDownAndClear.call(this, '_newComposeBorderMod');
    callTearDownAndClear.call(this, '_insertFromDriveMod');
    if (this._emailError) {
      gmail_utility.unPwnCompose(this._element, this._settings.dom);
      this._emailError.teardown();
      this._emailError = null;
    }
    (_this$_promoFooter = this._promoFooter) === null || _this$_promoFooter === void 0 ? void 0 : _this$_promoFooter.setFooter();
    if (this.newFeatureNotification) {
      this.newFeatureNotification.dismiss();
      this.newFeatureNotification = null;
    }
    this._settings.off('load:user', this.settingsLoaded);
    this._settings.off('load:user', this.updateLabelCallback);
    this.tooltipHelper.updateToggleTooltip();
    this.updateLabel();
  }
  setupIntro() {
    let status = 'inactive';
    let introMessage = '';

    // Load previous personal message if it exists
    if (this.policyHelper.checkIfEmailMetadataIsLoaded()) {
      const existingPersonalIntro = this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.PERSONAL_INTRO) || '';
      if (existingPersonalIntro) {
        introMessage = existingPersonalIntro;
        status = this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.PERSONAL_INTRO_STATUS);
      }
    }

    // Do not create a new intro if one already exists
    this._newComposePreMessageMod = this._newComposePreMessageMod || NewComposeIntroMessageMod.open(this._element, this._settings, this._emailMode === 'reply-all' ? 'reply' : this._emailMode, status, introMessage, this.policyHelper);
  }

  /**
   * Passes in a deferred object which is only resolved if it's handled here,
   * otherwise it just returns and lets the calling code handle it
   */
  restoreComposeMessage(options) {
    // This may happen when Gmail is failed to send the message
    if (this.isNewUnsentMessage()) {
      if (this._isSendRetryEnabled) {
        this.setupSendEmailError({
          name: 'SendError',
          ...options
        }, {
          canCancel: true,
          retry: i18n.t('COMMON_RETRY_SECURE_SEND')
        });
        return Promise.resolve();
      }
      return this._restoreUnsentMessage();
    }

    // only unsecure drafts would have metadata in cleartext
    this._isExistingUnsecureDraft = this._editor.find(email.Constants.METADATA_SELECTOR).length > 0;
    if (this._isExistingUnsecureDraft) {
      return Promise.resolve();
    }

    // Detect if it's a secure draft we're working with
    const secureDraftInput = this._editor.find(email.Constants.DRAFT_SELECTOR);
    this._isSecureDraft = secureDraftInput.length > 0;
    if (!this._isSecureDraft) {
      return Promise.resolve();
    }

    // Ensure we are activated
    if (!isActivated(this._settings.user)) {
      return Promise.resolve();
    }

    // Grab the div that actually contains the encoded TDF
    const tdfDiv = secureDraftInput.siblings('div[style*="font-size:0em"]');
    // AAD HACK: drafts are saved with 'display: none' to work around gmail taking a long time to
    // parse the encrypted payload when re-opening a secure draft.
    tdfDiv.addClass('virtru-hidden-tdf');

    // Test to make sure what we're grabbing is a TDF and then parse the
    // body out.
    const text = tdfDiv.text().trim();
    const matches = MESSAGE_REGEX.exec(text);
    if (matches === null) {
      // If the message is clipped because of size, we'll be here. Let's check to see if it's clipped.
      if (MESSAGE_REGEX_CLIPPED.exec(text) !== null) {
        const error_obj = {};
        error_obj.draftLength = text ? text.length : 0;

        // Send an error that the client couldn't decrypt due to the clipped message
        new_compose_AnalyticsService.clientError(...getErrorDraftParams(error_obj));
      }
      return Promise.resolve();
    }

    // We will append this again upon the next draft save
    secureDraftInput.remove();

    // Grab the TDF base64 and strip out any whitespace in it
    let message = matches[2];
    message = message.replace(/\s+/g, '');

    // Read the message
    return this._secureService.restoreDraft(this._composeId, message).then(result => {
      // Decode the URI encoded message and stuff it into the editor area
      const decoded = decodeURIComponent(result.secureMessage);
      const parsed = jquery_pack_default().parseHTML(decoded);
      this._editor.empty();

      // Remove attachments that had not finished uploading
      jquery_pack_default()('.virtru-attachment-is-uploading', parsed).remove();
      this._editor.append(parsed);
      if ((0,utils.isFeatureEnabled)(this._settings.user._profile, 'useAttachmentChipsV2')) {
        attachment_utils/* default.createSectionTooltip */.Ay.createSectionTooltip(this._editor);
      }
    }, err => {
      // If there's an error we just want to clear out the body...
      // and pop a message.
      new_compose_console.log(err);
      this._editor.empty();
      if (err.name !== 'AccessDisabled') {
        new_compose_console.warn('Draft policy is disabled.');
        return;
      }
      alert(i18n.t('RESTORE_DRAFT_FAILED'));
    }).catch(function (error) {
      return Promise.reject(error);
    });
  }
  isNewUnsentMessage() {
    return this.getEmailMode() === EMAIL_MODE.New && this._editor.find(email.Constants.TDF_METADATA_SELECTOR).length > 0 && this._editor.find(this._settings.dom.COLLAPSED_GMAIL_QUOTE).length === 0;
  }
  async _restoreUnsentMessage() {
    try {
      const secureEmailReader = secure_email_reader.SecureEmailReader.create({
        element: this._editor,
        settings: this._settings,
        secureService: this._secureService
      });
      const readerResponse = await secureEmailReader.startReading(this._element);
      const editorDiv = this._getEditorDiv();
      editorDiv.html(readerResponse.messageInfo.message);
      this.setupExistingAttachments();
      this.restoreTdfAttachmentMods();
      await _restoreDownloadVirtruAttachmentMods(this._settings, this._editor);
    } catch (error) {
      new_compose_console.error('Unable to restore unsent message', error);
      new_compose_AnalyticsService.clientError(...getErrorUnable2RestoreParams({
        userId: this._settings.currentUser(),
        error
      }));
    }
  }
  restoreTdfAttachmentMods() {
    try {
      // reset attachment mods, these will be rebuilt
      this.attachmentsHelper._tdfAttachmentMods.length = 0;
      const attachments = this._editor.find(this._settings.dom.VIRTRU_TDF_ATTACHMENT);
      for (let i = 0, len = attachments.length; i < len; ++i) {
        const $attachment = jquery_pack_default()(attachments[i]);
        // NOTE: the preview link is only available for stepchild attachments
        const previewLink = $attachment.find('.virtru-reattached-preview-link').html() || '';
        const attachmentMod = new sites.RemoteContentAttachment({
          name: $attachment.attr('data-name'),
          size: $attachment.attr('data-size')
        }, this);
        attachmentMod.restoreDraftAttachment($attachment, $attachment.attr('data-tdo-id'), $attachment.attr('data-policy-uuid'), previewLink);
        this.attachmentsHelper._tdfAttachmentMods.push(attachmentMod);
        this.policyHelper.setAttachmentMetadataForPolicy({
          policyUuid: attachmentMod.tdfData.policyUuid
        });
        attachmentMod.on('attachment-deleted', () => {
          this.attachmentsHelper.handleTdfAttachmentDeleted(attachmentMod.tdfData.policyUuid);
        });
      }
    } catch (e) {
      new_compose_console.log('restoreTdfAttachmentMods error: ', e);
      throw e;
    }
  }

  /**
   * Find broken attachments and fix them. It can happen when user clicks on 'Edit subject' or 'Ellipsis' button
   */
  checkBrokenAttachments() {
    const brokenAttachmentsObserver = new MutationObserver(() => {
      const brokenAttachmentSection = this._element.find('.gmail-virtru-attachment-section');
      if (brokenAttachmentSection.length > 0) {
        brokenAttachmentsObserver.disconnect();

        // remove all gmail- prefix from class names and IDs in all children elements
        const attachmentSection = this._element.find('.gmail-virtru-attachment-section');
        attachmentSection.addClass('virtru-attachment-section').removeClass('gmail-virtru-attachment-section');
        attachmentSection.attr('contenteditable', 'false');
        attachmentSection.find('*').each(function () {
          const $this = jquery_pack_default()(this);
          const classes = $this.attr('class');
          if (classes) {
            const newClasses = classes.replace(/gmail-/g, '');
            $this.attr('class', newClasses);
          }
          const id = $this.attr('id');
          if (id) {
            const newId = id.replace(/gmail-/g, '');
            $this.attr('id', newId);
          }
        });

        // get all .virtru-attachment and add data-attributes from the input-hidden value .virtru-attachment-data
        const virtruAttachments = attachmentSection.find('.virtru-attachment');
        virtruAttachments.each(function () {
          const $this = jquery_pack_default()(this);
          const inputHidden = $this.find('.virtru-attachment-data');
          const inputHiddenValueObj = JSON.parse(inputHidden.val());
          Object.keys(inputHiddenValueObj).forEach(key => {
            $this.attr(`data-${key}`, inputHiddenValueObj[key]);
          });
        });

        // move attachmentSection to the bottom of the parent's parent
        attachmentSection.appendTo(attachmentSection.parent().parent());

        // setup attachments
        this.setupExistingAttachments();
        this.restoreTdfAttachmentMods();
      }
    });
    brokenAttachmentsObserver.observe(this._element[0], {
      childList: true,
      subtree: true
    });
  }

  /**
   * Initializes the keyboard shortcut handling mod
   */
  handleKeyboardShortcuts() {
    this._keyboardShortcutsMod = ComposeKeyboardShortcuts.open(this);
    this._keyboardShortcutsMod.on(ComposeKeyboardShortcuts.Send_Email, () => this.sendInitiated(false));
  }

  /**
   * Hooks the show trimmed content button to intercept and replace
   * the invitation template with a placeholder message.
   */
  setupTrimmedContent() {
    const {
      dom
    } = this._settings;
    const trimmedContent = this._element.find(this._emailMode !== EMAIL_MODE.New ? dom.NEW_COMPOSE_TRIMMED_CONTENT_REVEAL : undefined);
    this._trimmedContentMod = NewComposeTrimmedContentMod.open(this._settings, trimmedContent, this._editor);
  }

  /**
   * Set compose window title
   */
  setComposeTitle(text) {
    this._gmailBanner.find(this._settings.dom.GMAIL_COMPOSE_BANNER_TEXT).text(text);
  }

  /**
   * Set compose window title based on appropriations map
   * The title will be changed when the appropriate phrase exists in the DOM.
   *
   * EN: 'New Message' => 'New Secure Message'
   * @param {string} text
   */
  setComposeTitleWithAccordance(text) {
    const actualText = this._gmailBanner.find(this._settings.dom.GMAIL_COMPOSE_BANNER_TEXT).text();
    const accordanceMap = {
      // [Expected Browser Extension phrase]: [Gmail phrase]
      [i18n.t('NEW_MESSAGE_NOT_SECURE')]: i18n.t('NEW_MESSAGE_SECURE'),
      [i18n.t('NEW_MESSAGE_SECURE')]: i18n.t('NEW_MESSAGE_NOT_SECURE')
    };
    if (Object.hasOwn(accordanceMap, text) && accordanceMap[text] === actualText) {
      this.setComposeTitle(text);
    }
  }

  /**
   * Provide actual compose window title
   */
  setupComposeTitle() {
    this.setComposeTitle(i18n.t('NEW_MESSAGE_SECURE'));
    if (!this._gmailBannerObserver) {
      const bannerArea = this._gmailBanner.find('td').first();
      const targetEl = bannerArea[0];
      const self = this;
      if (targetEl) {
        this._gmailBannerObserver = new MutationObserver(function () {
          if (self.isSecureMode()) {
            self.setComposeTitleWithAccordance(i18n.t('NEW_MESSAGE_SECURE'));
          }
        });
        this._gmailBannerObserver.observe(targetEl, {
          subtree: true,
          childList: true
        });
      }
    }
  }

  /**
   * Finds existing attachments if this is a draft and processes
   * them.
   */
  setupExistingAttachments() {
    const self = this;
    const {
      dom
    } = this._settings;
    this.onceFinds(dom.NEW_COMPOSE_ATTACHMENT_METADATA, self._editor).then(function success() {
      const metadatas = self.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS);
      if (metadatas) {
        Object.values(metadatas).forEach(function (attachment) {
          self.processAttachmentMetadata(attachment);
        });
      }
    }).catch(function (error) {
      return Promise.reject(error);
    });
  }
  resizeHandler() {
    if (this._onboardingTourMod) {
      if (this._onboardingTourMod._activeOnboardingPopover) {
        this._onboardingTourMod._activeOnboardingPopover.el.show();
        this._onboardingTourMod._activeOnboardingPopover.reposition();
      }
      if (this._onboardingTourMod._onboardingOverlay) {
        this._onboardingTourMod._onboardingOverlay._element.show();
        this._onboardingTourMod._onboardingOverlay.reposition();
      }
    }
  }
  teardown() {
    new_compose_console.debug(`Teardown... ${this._composeId}`);
    this.removeAttachmentTooltip();
    this.removeSectionTooltip();
    this.removePCMExtensionTooltip();
    this._editor.empty();
    compose_manager_default().unregister(this);
    if (this._minimizeObserver) {
      this._minimizeObserver.disconnect();
    }
    if (this._mailMergeContainerObserver) {
      this._mailMergeContainerObserver.disconnect();
    }
    this.teardownSecureMode();
    this.attachmentsHelper.teardown();
    this.policyHelper.tearDown();
    this.animationHelper.teardown();
    this.tooltipHelper.teardown();
    const banner = jquery_pack_default()(this.bannerSelector, this._element);
    if (banner.length > 0) {
      banner.remove();
    }
    if (this._sendSecureMod) {
      this._sendSecureMod.teardown();
      this._sendSecureMod = null;
    }
    callTearDownAndClear.call(this, '_sendButtonsMod');
    callTearDownAndClear.call(this, '_sendArchiveButtonMod');
    if (this._onboardingTourMod) {
      this._onboardingTourMod.onCloseOnboardingPopover();
    }
    if (this._onboardingMod) {
      this._callback && this._settings.user.off('update', this._callback);
      this.showOnboardOne && this._settings.user.off('restartTourNoAuth', this.showOnboardOne);
    }
    if (this.newFeatureNotification) {
      this.newFeatureNotification.dismiss();
    }
    callTearDownAndClear.call(this, '_keyboardShortcutsMod');
    if (this._promoFooter) {
      this._promoFooter.teardown();
    }
    try {
      this._secureService.closeDraft(this._composeId);
    } catch (err) {
      // ignore the error... this is just for cleanup
    }
    this.unsubscribeIsSecureMode();
    this.unsubscribeGetMailSendingState();
    this.usubscribeGetComposeMod();
    this.unsubscribeAttachmentService();
    this._virtruOfflineMode.dropChangeListener(this.onConnectivityStateChange);
    this._virtruOfflineMode.teardown();
  }
  setupScheduledSendButtons() {
    this._scheduledSendButtonsMod = {
      btn: null,
      triggerScheduledSend() {
        if (this.btn) {
          this.btn.triggerNative('mouseover');
          this.btn.triggerNative('mousedown');
          this.btn.triggerNative('mouseup');
          this.btn.triggerNative('mouseout');
          this.btn.triggerNative('click');
        }
      }
    };
    this._element.find('[selector="scheduledSend"]').each((_ix, _btn) => {
      const btn = jquery_pack_default()(_btn);
      const clone = jquery_pack_default()(_btn.cloneNode(true));
      if (!this._scheduledSendButtonsMod.btn) {
        this._scheduledSendButtonsMod.btn = btn;
      }
      clone.off('click mouseup mousedown keypress').addClass('virtru-scheduled-send').removeAttr('id').removeAttr('selector');
      btn.hide().attr('tabindex', '-1');
      clone.insertAfter(btn);
    });
    this._element.on('click', '.virtru-scheduled-send', e => {
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      this.sendInitiated(false, true);
    });
  }
  setupSendSecureButtons() {
    const {
      dom
    } = this._settings;
    if (this._settings.user.auth('status') !== 'active') {
      this.secureModeOff();
    }
    const sendButtonPromise = this.onceFinds(dom.NEW_COMPOSE_SEND_BUTTON).then(sendButtons => {
      if (sendButtons.hasClass('virtru-modded')) {
        // If we've already hooked the buttons just return
        this._sendButtonsMod.reinitializeButtons();
      } else {
        // This mod must be initialized before SendSecureMod, as it is used there
        if (!this._recipientsMod) {
          this._recipientsMod = new NewComposeRecipientsMod(this);
        }
        if (!this._sendSecureMod) {
          this._sendSecureMod = new (smart_send_secure_default())(this, sdk.transports);
          this._sendSecureMod.setup();
        }
        this._sendButtonsMod = NewComposeSendButtonsMod.open(this._settings, sendButtons, this);
        this._sendButtonsMod.on(NewComposeSendButtonsMod.Send_Email, () => this.sendInitiated(false));
      }

      // Need to make this check since existing attachments start encrypting before
      // the send secure button was set up.
      if (this.attachmentsHelper._numUploadingAttachments > 0) {
        this._sendButtonsMod.disableSendButton();
      }
    }).catch(function (error) {
      const error_obj = {};
      error_obj[dom.NEW_COMPOSE_SEND_BUTTON] = false;
      new_compose_AnalyticsService.clientError(...getErrorMissingElemParams(error_obj));
      throw error;
    });
    const sendButtonArchivePromise = this.onceFinds(dom.NEW_COMPOSE_SEND_ARCHIVE_BUTTON).then(button => {
      if (button.hasClass('virtru-modded')) {
        // If we've already hooked the buttons just return
        this._sendArchiveButtonMod.reinitializeButton();
      } else {
        // This mod must be initialized before SendSecureMod, as it is used there
        if (!this._recipientsMod) {
          this._recipientsMod = new NewComposeRecipientsMod(self);
        }
        if (!this._sendSecureMod) {
          this._sendSecureMod = new (smart_send_secure_default())(this, sdk.transports);
          this._sendSecureMod.setup();
        }
        this._sendArchiveButtonMod = Object.create((new_compose_send_archive_button_default()), {
          _settings: {
            value: this._settings
          },
          _element: {
            value: jquery_pack_default()(button)
          }
        }).constructor(this).on((new_compose_send_archive_button_default()).SendEmail, () => this.sendInitiated(true));
      }

      // Need to make this check since existing attachments start encrypting before
      // the send secure button was set up.
      if (this.attachmentsHelper._numUploadingAttachments > 0) {
        this._sendArchiveButtonsMod.disable();
      }
    });
    return Promise.race([sendButtonPromise, sendButtonArchivePromise]);
  }

  /**
   * Handles when a send is initiated from either the 'Send' button or a keyboard
   * shortcut.
   *
   * DO NOT COPY/PASTE OR OTHERWISE MOVE THIS FUCKING FUNCTION ANYWHERE ELSE
   *
   */
  sendInitiated(isArchive, isScheduledSend) {
    if (this._hasBeenSent === true) {
      new_compose_console.info('Already sent, returning from sendInitiated.');
      return;
    }
    if (this.attachmentsHelper._numUploadingAttachments > 0) {
      new_compose_console.info('Encrypting attachment, returning from sendInitiated.');
      return;
    }
    if (this.isAttachmentUploading()) {
      new_compose_console.info('Uploading attachment, returning from sendInitiated.');
      this.alert(i18n.t('ATTACHMENTS_UPLOADING_NO_SEND'));
      return;
    }
    const {
      emails = []
    } = this.emailUsers();
    if (this.policyHelper.hasError(emails.length) && this.isSecureMode()) {
      new_compose_console.info('Policy Menu has error');
      this.alert(i18n.t('POLICY_MENU_ERROR'));
      return;
    }
    const failure = _fail.bind(this);
    this.covertLoadTrimmedContent();
    try {
      this._sendSecureMod.check(true, undefined, isArchive, isScheduledSend).then(function sssComplete({
        check,
        blockSend
      }) {
        if (this._policyConfigMenu.isExpandedProtectionEnabled()) {
          const attachments = this.attachmentsHelper._tdfAttachmentMods;
          const supportedAttachments = this.validateExpandedProtectionSupport(attachments);
          new_compose_AnalyticsService.sendInitiated(...getSendInitiatedSupportedAttachmentsParams(this, {
            supportedAttachments
          }));
        }
        const VIRTRU_ON = this.getToggleState() === 'on';
        const attachments = Object.values(this.attachmentsHelper._tdfAttachmentMods || {});
        new_compose_AnalyticsService.sendInitiated(...getSendInitiatedAllAttachmentsParams(this, {
          isSecureMode: VIRTRU_ON,
          attachments
        }));
        if (!VIRTRU_ON) {
          globalStore_default().dispatch({
            type: messages_reducer/* actions */.o1.REMOVE_SECURE_MESSAGE,
            draftId: this._draftId,
            threadId: this._threadId
          });
        }

        // If there are violations
        if (check) {
          if (VIRTRU_ON && !blockSend) {
            this.showTrimmedContent();
            this.sendSecure(isArchive);
          }
        } else if (VIRTRU_ON) {
          this.showTrimmedContent();
          this.sendSecure(isArchive);
        } else if (isArchive) {
          this.showTrimmedContent();
          this._sendArchiveButtonMod.triggerGmailSendArchive();
        } else if (isScheduledSend) {
          this._scheduledSendButtonsMod.triggerScheduledSend();
        } else {
          this.showTrimmedContent();
          this._sendButtonsMod.triggerGmailSend();
        }
        if (this._sendButtonsMod) {
          this._sendButtonsMod.enableSendButton();
        }
      }.bind(this)).catch(function (err) {
        if (err === errors.ATTACHMENT_LIMIT_ERROR) {
          if (this._sendButtonsMod) {
            gmail_utility.unPwnCompose(this._element, this._settings.dom);
            this._sendButtonsMod.enableSendButton();
          }
        } else if ((err === null || err === void 0 ? void 0 : err.message) === 'Maximum call stack size exceeded') {
          showCallStackExceededModal();
          this._sendButtonsMod.enableSendButton();
        } else {
          failure('SSS check failed on send')(err);
        }
      }.bind(this));
    } catch (err) {
      failure('SSS check failed on send before promise chain')(err);
    }

    /**
     * Helper function to emit errors in the code above
     * @private
     */
    function _fail(context) {
      return function (err) {
        var _this$policyHelper, _this$policyHelper$_p, _this$policyHelper$_p2;
        const sanitizedError = (0,sanitizeAnalyticsError/* default */.A)(err);
        new_compose_AnalyticsService.clientError(...getErrorSmartSendParams({
          contextString: context,
          sanitizedError,
          sms2fa: !!((_this$policyHelper = this.policyHelper) !== null && _this$policyHelper !== void 0 && (_this$policyHelper$_p = _this$policyHelper._policyConfigMenu) !== null && _this$policyHelper$_p !== void 0 && (_this$policyHelper$_p2 = _this$policyHelper$_p._policyModel) !== null && _this$policyHelper$_p2 !== void 0 && _this$policyHelper$_p2.sms)
        }));
        new_compose_console.error(sanitizedError);
        this.setupSendEmailError({
          name: 'SmartSendSecureError'
        });
      }.bind(this);
    }
  }
  requestActivation(isReactivation) {
    // requstedFrom is used for analytics purposes, eventually it makes its way into webmail plugin,
    // and is sent to segment.io
    const requestedFrom = `email_compose_${this._emailMode === 'reply-all' ? 'reply' : this._emailMode}`;
    this._settings.requestActivation({
      requestedFrom,
      isReactivation
    });
  }
  settingsLoaded() {
    const settings = this._settings;
    if (isActivated(settings.user)) {
      settings.off('load:user', this.settingsLoaded);

      // NOTE: Toggling secure mode off and on again ensures that secure mode is initialized
      // without the activation overlay, and converts any lingering attachments.
      // IMPORTANT: if the user was not activated when toggling secure on, the attachments
      // remain on the message unsecure! Toggling off/on again converts them.
      // TODO: remove the activation overlay without toggling back off and on again
      this.secureModeOff();
      return this.restoreComposeMessage({
        callpoint: 'settingsLoaded'
      }).then(this._loadMessage).then(() => {
        // HACK: This should be changed...
        const titleText = this._element.find('.virtru-secure-mode-on').find('.virtru-label');
        titleText.text(i18n.t('VIRTRU_PROTECTION_ON'));
        this.secureModeOn();
      });
    }
  }
  setupAttachmentButton() {
    const {
      dom
    } = this._settings;
    const self = this;
    this.onceFinds(dom.NEW_COMPOSE_ATTACHMENTS_BUTTON).then(function success(attachmentButton) {
      attachmentButton.addClass('virtru-attachment-button');

      // Check for an input element that can get in the way
      const attachmentButtonOverlay = attachmentButton.siblings('input[type="file"]');
      if (attachmentButtonOverlay.length === 1) {
        attachmentButtonOverlay.height(0);
        attachmentButtonOverlay.width(0);
      }
      self._attachmentButtonMod = sites.AddAttachmentButtonMod.open(self._settings, attachmentButton, undefined, sdk.transports, self);
      self._attachmentButtonMod.on('attach-secure', self.attachmentsHelper.attachSecure.bind(self.attachmentsHelper));
      self._attachmentButtonMod.on('fail-attach-secure', self.attachmentsHelper.onAttachmentProcessed.bind(self.attachmentsHelper));
      self._attachmentButtonMod.on('attachment-attached', self.attachmentsHelper.onAttachmentAttached.bind(self.attachmentsHelper));
    }).catch(function (error) {
      new_compose_console.error(error);
      throw error;
    });
  }
  processAttachmentMetadata(metadata) {
    const self = this;
    const {
      dom
    } = this._settings;
    const attachments = jquery_pack_default()(dom.NEW_COMPOSE_ATTACHMENT, this._element);

    // Set the metadata
    this.policyHelper.setAttachmentMetadataForPolicy(metadata);
    attachments.each(function (_, attachment) {
      const $attachment = jquery_pack_default()(attachment);
      const inputUuid = $attachment.attr('policyUuid');
      if (typeof inputUuid === 'undefined') {
        const filename = jquery_pack_default()(dom.NEW_COMPOSE_ATTACHMENT_FILENAME, $attachment).text();
        if (filename !== metadata.filename) {
          return;
        }

        // Listen for the upload div to be removed, that is our trigger
        // to hook into the real div that will be created.
        $attachment.on('DOMNodeRemoved', function () {
          // Namespace the event so it's very targeted and we can later
          // remove it once we catch the creation of the new div
          self._element.on(`DOMNodeInserted.${metadata.policyUuid}`, metadata, self.interceptInsert);
        });
        $attachment.attr('policyUuid', metadata.policyUuid);
        $attachment.attr('filename', metadata.filename);

        // Create a new mod that hooks the attachment div
        const mod = NewComposeAttachmentMod.open(self._settings, $attachment);
        mod.on('attachment-deleted', self.handleAttachmentDeleted);
        self._attachmentMods[metadata.policyUuid] = mod;

        // Sometimes Gmail likes to update the attachment div...
        // not sure why, not sure really what's going on, but
        // we need to catch this and respond to it.
        $attachment.on('DOMNodeRemoved', metadata, self.doubleSecretDownloadDivRemoval);
      }
    });
  }

  /**
   * Intercepts the insertion of an element into the new compose
   * div.  This will intercept updating the attachment divs that
   * represent each attachment.
   *
   * @param event
   */
  interceptInsert(event) {
    const self = this;
    const $div = jquery_pack_default()(event.target);
    const metadata = event.data;
    const attachmentMetadata = this.policyHelper.getAttachmentMetadataForPolicy(metadata.policyUuid);

    // filter out events firing from attachments that no longer exist
    if (!attachmentMetadata) {
      return;
    }

    // update the filename to remove '.tdf' so we can animate it in later
    const filenameElement = jquery_pack_default()(this._settings.dom.NEW_COMPOSE_ATTACHMENT_FILENAME, $div);
    const filename = filenameElement.text();
    if (filename === metadata.filename) {
      jquery_pack_default()(this._settings.dom.NEW_COMPOSE_ATTACHMENT_FILENAME, $div).text(filename.substring(0, filename.lastIndexOf('.tdf')));
      if (!this._animatedAttachments[metadata.policyUuid]) {
        this._animatedAttachments[metadata.policyUuid] = $div;
        this.animationHelper.showIndividualAttachmentAnimation($div, filename);
      }
    }

    // We're looking for an <a> tag in the div that appears,
    // this is where we'll grab all the information about the
    // attachment
    const $a = jquery_pack_default()('a', $div);
    if ($a.length === 0) {
      return;
    }

    // If the attachment already has a policyUuid attached then
    // something weird happened.
    const attr = $div.attr('policyUuid');
    if (attr) {
      return;
    }

    // Grab the file name in the attachment div... and log if
    // it's not right...
    if (filename !== metadata.filename) {
      return;
    }
    $div.attr('policyUuid', metadata.policyUuid);
    $div.attr('filename', metadata.filename);
    let href = $a.attr('href');
    if (href.charAt(0) === '?') {
      href = href.substr(1);
    }

    // Parse and update attachment metadata
    let updated = false;
    const tokens = href.split('&');
    tokens.forEach(function (param) {
      const split = param.split('=');
      if (split.length === 2 && split[0] !== 'th' // This seems to be a 'version' so it's always changed on every update... so ignore it
      && split[1] !== attachmentMetadata[split[0]]) {
        attachmentMetadata[split[0]] = split[1];
        updated = true;
      }
    });

    // Update internal metadata
    if (updated) {
      this.policyHelper.setAttachmentMetadataForPolicy(metadata);
    }

    // Turn off listening for the inserted event for this policy
    self._element.off(`DOMNodeInserted.${metadata.policyUuid}`, self.interceptInsert);

    // Create a new mod that hooks the attachment div
    const mod = NewComposeAttachmentMod.open(self._settings, $div, filename);
    mod.on('attachment-deleted', self.handleAttachmentDeleted);
    self._attachmentMods[metadata.policyUuid] = mod;
    this.animationHelper.showIndividualAttachmentAnimation($div, filename);

    // Sometimes Gmail likes to update the attachment div...
    // not sure why, not sure really what's going on, but
    // we need to catch this and respond to it.
    $div.on('DOMNodeRemoved', metadata, self.doubleSecretDownloadDivRemoval);
  }

  /**
   * So if Gmail removes the attachment div to update it we need to listen
   * for the inserted event again so that we can hook it again.
   *
   * @param event
   */
  doubleSecretDownloadDivRemoval(event) {
    const metadata = event.data;
    this._element.on(`DOMNodeInserted.${metadata.policyUuid}`, metadata, this.interceptInsert);
  }

  /**
   * Removes the email metadata for the attachment
   *
   * @param policyUuid
   */
  handleAttachmentDeleted(policyUuid) {
    this._attachmentMods[policyUuid] = null;
    delete this._attachmentMods[policyUuid];
    this.policyHelper.removeAttachmentMetadataForPolicy(policyUuid);
    this._animatedAttachments[policyUuid] = null;
    this._element.off(`DOMNodeInserted.${policyUuid}`, this.interceptInsert);
  }
  isAlive() {
    return jquery_pack_default().contains(document.documentElement, this._element[0]) && this._isAlive;
  }
  sendSecure(isArchive) {
    var _this$_sendSecureMod;
    const {
      dom
    } = this._settings;
    if (this._hasBeenSent === true) {
      new_compose_console.info('Already sent, returning from sendSecure.');
      return;
    }
    if (this.attachmentsHelper._numUploadingAttachments > 0) {
      new_compose_console.info('Encrypting attachment, returning from sendSecure.');
      return;
    }
    if (this.isPlainTextMode()) {
      renderModal/* default */.A.plainTextNotSupported();
      return;
    }

    // Make sure no unsecure attachments can get through!
    const numUnsecureAttachments = this.attachmentsHelper.getUnsecureAttachments().length + this.attachmentsHelper.getUnsecureImageAttachments().length;
    if (numUnsecureAttachments > constants.ATTACHMENTS_LIMIT) {
      (0,attachments_warn_modal.showAttachmentsLimitModal)(numUnsecureAttachments);
      this.secureModeOff();
      this.removeComposeEditor();
      return;
    }
    if (numUnsecureAttachments > 0) {
      renderModal/* default */.A.unsecureAttachmentsPresent();
      return;
    }
    const emailUsers = this.emailUsers().emails;
    const emailValidationResult = email.utils.validateEmails(emailUsers);
    if (!emailValidationResult.valid) {
      if (emailValidationResult.email) {
        alert(i18n.t('EMAIL_INVALID_ADDRESS', {
          invalidAddress: emailValidationResult.email
        }));
      } else {
        alert(i18n.t('EMAIL_INVALID_ADDRESS_GENERIC'));
      }
      return;
    }

    // Do not rely on Gmail address handler. Show a message and not procceed forward if not able to find recipients
    if (emailUsers.length === 0) {
      alert(i18n.t('EMAIL_ADDRESS_NOT_FOUND'));
      return;
    }

    // Makes sure to ignore keyboard shortcuts to send secure
    // if there's an error showing
    if (this._emailError != null) {
      return;
    }

    // Stop the send process if any attachments are still uploading
    if (this.isAttachmentUploading()) {
      this.alert(i18n.t('ATTACHMENTS_UPLOADING_NO_SEND'));
      return;
    }
    new_compose_dispatchToStore({
      type: messages_reducer/* actions */.o1.ADD_SECURE_MESSAGE,
      draftId: this._draftId,
      threadId: this._threadId
    });

    // only remove SSS tooltip if message has been sent successfully
    if ((_this$_sendSecureMod = this._sendSecureMod) !== null && _this$_sendSecureMod !== void 0 && _this$_sendSecureMod.sendToolTip) {
      this._sendSecureMod.sendToolTip.hide();
    }

    // grab the height of the compose window before we show the nested content
    const windowHeight = this._element.find(dom.NEW_REPLY_TEXTAREA).height();
    this.inlinePersonalIntro = this._newComposePreMessageMod && this._newComposePreMessageMod.getIntroText();
    this._playEncryptionAnimation(this.sendSecureInternal.bind(this, isArchive), windowHeight);
  }
  async _getEmailChain() {
    const secureEmailReader = secure_email_reader.SecureEmailReader.create({
      element: this._editor,
      settings: this._settings,
      secureService: this._secureService
    });
    const readerResponse = await secureEmailReader.startReading(this._element);
    if (!readerResponse.messageInfo) {
      return [];
    }
    const remoteContentService = new (remote_content_service_default())(null, null, null, null, null);
    const {
      remoteContentLink
    } = readerResponse;
    try {
      const parsedLink = remoteContentService.parseLink(remoteContentLink);
      // This returns a Q promise, so wrap it in a real Promise.
      const previousEmailChain = await new Promise((resolve, reject) => {
        this._secureService.downloadAndDecryptRemoteManifest(parsedLink.metadataUrl, parsedLink.metadataKey, parsedLink.metadataIv).then(response => {
          resolve(response.emailChain || []);
        }).catch(reject);
      });
      const emailChain = Array.isArray(previousEmailChain) ? [...previousEmailChain] : [];
      emailChain.push(remoteContentLink);
      return emailChain;
    } catch (e) {
      return null;
    }
  }
  async sendSecureInternal(isArchive) {
    const {
      dom
    } = this._settings;
    try {
      const divEditor = this._getEditorDiv();

      // Remove the virtru metadata input
      const inputs = divEditor.find(dom.EMAIL_METADATA);
      if (inputs.length > 0) {
        inputs[0].remove();
      }
      // Make sure the TDF payload is visible or else it might not be detected
      divEditor.find('.virtru-hidden-tdf').css('display', '');

      // Show trimmed content if any
      this.showTrimmedContent();
      const owner = this._settings.currentUser();
      const subject = this.subject();
      const emailUsers = this.emailUsers();
      const children = this.children();
      const sender = getSender(this._element);
      const validatedSender = this.validateSender(sender, owner);

      // Ensure that the policy config menu is saved by forcibly closing the policy
      // config menu
      this._policyConfigMenu.close();
      let introToUse;
      const personalIntro = {
        isModified: false,
        type: 'default'
      };
      const {
        inlinePersonalIntro
      } = this;
      const userSettingsPersonalIntro = this._settings.user.setting('preferences.personalIntro');
      if (inlinePersonalIntro) {
        personalIntro.type = 'custom-single';
        personalIntro.isModified = true;
        introToUse = inlinePersonalIntro;
      } else if (userSettingsPersonalIntro) {
        personalIntro.type = 'custom-default';
        introToUse = userSettingsPersonalIntro;
      }

      // Get information about attachments
      let attachmentsType = undefined;
      if (children.length > 0) {
        attachmentsType = divEditor.find(dom.VIRTRU_TDF_ATTACHMENT).length > 0 ? 'remote_content' : 'regular';
      }
      const policyConfig = this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.EMAIL_POLICY, true);
      const emailChain = await this._getEmailChain();
      const canSendMilTemplates = this._settings.user.setting('permissions.canUseMilTemplates');
      let templateUri = this._settings.user.setting('templateUri');
      if (canSendMilTemplates) {
        var _emailUsers$emails;
        const customMilDomain = localStorage.getItem('customMilDomain'); // used for test purposes

        const milUsers = emailUsers === null || emailUsers === void 0 ? void 0 : (_emailUsers$emails = emailUsers.emails) === null || _emailUsers$emails === void 0 ? void 0 : _emailUsers$emails.filter(email => email.endsWith('.mil') || email.endsWith(customMilDomain));
        if (milUsers !== null && milUsers !== void 0 && milUsers.length) {
          templateUri = MIL_TEMPLATE_URI;
        }
      }
      templateService.fetch(templateUri).then(templateResponse => {
        var _this$_sendSecureMod2;
        const policyOptions = {
          ownerDisplayName: this._settings.currentUserDisplayName(),
          emailUsers: emailUsers.emails,
          emailUsersNoBcc: emailUsers.emailsNoBcc,
          displayName: subject,
          type: 'email',
          children: [],
          sentFrom: sender ? sender : owner,
          validatedSentFrom: validatedSender,
          authorizations: this.policyHelper.getAuthorizations(),
          activeEnd: policyConfig.expires ? policyConfig.expirationDate : undefined,
          composeId: this._composeId,
          welcomeMessage: introToUse,
          attachments: [],
          sms2faMap: policyConfig.sms2faMap,
          isManaged: policyConfig.isManaged,
          dlpAuditRecord: (_this$_sendSecureMod2 = this._sendSecureMod) === null || _this$_sendSecureMod2 === void 0 ? void 0 : _this$_sendSecureMod2._dlpAuditRecord,
          campaignId: templateResponse.templateInfo.campaignId,
          templateId: templateResponse.templateInfo.templateId,
          attachmentsType,
          personalIntro,
          emailChain,
          owner
        };
        if (!policyOptions.sms2faMap) {
          delete policyOptions.sms2faMap;
        }

        // Build the array of attachments to populate the policy
        const associatedAttachments = [];
        this.attachmentsHelper._tdfAttachmentMods.forEach(tdfAttachmentMod => {
          // If the attachment already has a preview link, it must already belong to a policy
          if (!tdfAttachmentMod.tdfData.previewLink) {
            policyOptions.attachments.push(tdfAttachmentMod.tdfData.tdo.id);
            policyOptions.children.push(tdfAttachmentMod.tdfData.policyUuid);
            tdfAttachmentMod.prepareForSend();
          }
          if (tdfAttachmentMod.tdfData.previewLink || tdfAttachmentMod.tdfData.isTdf3Html) {
            associatedAttachments.push(tdfAttachmentMod.tdfData);
          }
        });

        // Material design cuts off clipped messages, so we have to reinsert them into the compose area
        // TODO: find a more reliable way of doing this so we don't mess up people's messages
        // TODO use early return pattern here to avoid nesting
        // Insert the cached encrypted message back into the reply block
        // This is an extra precaution to override the default content in case it's trimmed
        const $messageContainer = this.getPreviousMessage();
        if ($messageContainer) {
          const messageId = String($messageContainer.data('message-id') || '').replace('#', '');
          if (messageId) {
            const replyHtml = window._virtruEncryptedMessageCache && window._virtruEncryptedMessageCache[messageId];
            if (replyHtml) {
              // Replace the bottom-most LTR element with the payload
              const ltr = divEditor.find(dom.NEW_COMPOSE_QUOTED_REPLY_CLIPPED_REPLACE);
              ltr.empty();
              ltr.append(replyHtml);
            }
          }
        }
        const {
          user
        } = this._settings;
        if ((0,utils.isFeatureEnabled)(user._profile, 'useAttachmentChipsV2')) {
          // Removing tooltip wrappers for attachment chips
          divEditor.find('.virtru-attachment').each(function () {
            divEditor.append(jquery_pack_default()(this));
            jquery_pack_default()(this)[0].className = 'virtru-attachment';
          });
          this.removeAttachmentTooltip();
          this.removeSectionTooltip();
          this.removePCMExtensionTooltip();
          divEditor.find('.virtru-attachment-section').remove();
        } else {
          divEditor.find('.virtru-attachment').each(function () {
            jquery_pack_default()(this)[0].className = 'virtru-attachment';
          });
        }
        divEditor.find('.virtru-attachment-data').remove();
        const emailHTML = getBodyHTML(divEditor);
        const composer = email.createComposer({
          settings: this._settings
        });
        const message = {
          body: emailHTML
        };
        return composer.compose(message, policyOptions, templateResponse.templateHtml, associatedAttachments);
      }).then(async secureEmail => {
        var _this$_sendButtonsMod5;
        await this._animationComplete;
        const {
          dom
        } = this._settings;
        const replyEmailsHTML = jquery_pack_default()('<div></div>').append(divEditor.find(dom.PLUS_REPLY_USER)).html();
        if (!this._settings.user.setting('preferences.seenSentFirstMessage')) {
          if (!this._onboardingMod) {
            this._onboardingMod = onboarding.OnboardingMod.open(this._settings, this);
          }
          this._onboardingMod.showOnboardingModalFinal();
        }
        if (secureEmail.isDevelopment) {
          const subjectEl = this._element.find(dom.NEW_COMPOSE_SUBJECT);
          subjectEl.val(subjectEl.val() + secureEmail.subjectPostfix);
        }
        divEditor.html(secureEmail.html);

        // Gmail can't parse tagged users from encrypted message, so we need to temporarily add it for Google parsing.
        this._addTemporaryDraftContent(replyEmailsHTML);
        this._hasBeenSent = true;
        if (isArchive && this._sendArchiveButtonMod) {
          this._sendArchiveButtonMod.triggerGmailSendArchive();
        } else {
          var _this$_sendButtonsMod4;
          (_this$_sendButtonsMod4 = this._sendButtonsMod) === null || _this$_sendButtonsMod4 === void 0 ? void 0 : _this$_sendButtonsMod4.triggerGmailSend();
        }
        (_this$_sendButtonsMod5 = this._sendButtonsMod) === null || _this$_sendButtonsMod5 === void 0 ? void 0 : _this$_sendButtonsMod5.revertToGmailStyles();
      }).catch(err => {
        new_compose_console.log(err);
        const options = {};
        if (err.name === 'InvalidAppId' || err.name === 'NoAppIdForDomain') {
          options.retry = i18n.t('EMAIL_ERROR_SEND_REACTIVATION_RETRY_BUTTON');
        }
        this.removeComposeEditor();
        this.setupSendEmailError(err, options);
      });
    } catch (err) {
      new_compose_console.log(err);
      const options = {};
      if (err.name === 'InvalidAppId' || err.name === 'NoAppIdForDomain') {
        options.retry = i18n.t('EMAIL_ERROR_SEND_REACTIVATION_RETRY_BUTTON');
      }
      this.removeComposeEditor();
      this._hasBeenSent = false;
      this.setupSendEmailError(err, options);
    }
  }

  // All added content will be removed on sending the message step by interceptor
  _addTemporaryDraftContent(content) {
    const divEditor = this._getEditorDiv();
    const replyEmailsTemplate = xhr_utils.TemporaryDraftContent.make(content);
    divEditor.html(`${divEditor.html()}${replyEmailsTemplate}`);
  }
  _getEditorDiv() {
    const {
      dom
    } = this._settings;
    let divEditor = this._editor;
    if (divEditor == null) {
      new_compose_console.error('Could not find editor selector...');
      divEditor = this._element.find(`${dom.NEW_COMPOSE_EDITOR}, ${dom.RICH_TEXT_EDITOR}`);
      // FIXME need to handle this a lot better
      if (divEditor.is('iframe')) {
        // If the match is an iframe then it's the old style editor.
        // Send the reference to it's body instead
        divEditor = divEditor.contents().find('body');
      }
    }
    return divEditor;
  }
  removeComposeEditor() {
    var _this$_animationEleme, _this$_editorBanner;
    this._editor.off('contextmenu');
    gmail_utility.unPwnCompose(this._element, this._settings.dom);
    (_this$_animationEleme = this._animationElement) === null || _this$_animationEleme === void 0 ? void 0 : _this$_animationEleme.remove();
    (_this$_editorBanner = this._editorBanner) === null || _this$_editorBanner === void 0 ? void 0 : _this$_editorBanner.removeClass('no-touch');
  }
  removeAttachmentTooltip() {
    if ((0,utils.isFeatureEnabled)(this._settings.user._profile, 'useAttachmentChipsV2')) {
      removeAttachmentWrapperTooltip(this._editor);
    }
  }
  setupSendEmailError(error, options = {}) {
    if (this._sendButtonsMod) {
      this._sendButtonsMod.enableSendButton();
    }
    const self = this;
    const onRetryClick = () => {
      if (error.name === 'InvalidAppId' || error.name === 'NoAppIdForDomain') {
        this._messageIsSending = true;
        this.requestActivation(true);
      } else if (error.name === 'SendError') {
        this.showTrimmedContent();
        this._sendButtonsMod.triggerGmailSend();
      } else {
        window.location.reload();
      }
    };
    const onCancelRetryClick = () => {
      this._isSendRetryEnabled = false;
      gmail_utility.unPwnCompose(self._element, self._settings.dom);
      self._emailError.teardown();
      self._emailError = null;
      this.restoreComposeMessage({
        callpoint: 'on-cancel-retry-click'
      });
    };
    const props = {
      errorMessage: i18n.t('EMAIL_ERROR_SEND'),
      canRetry: true,
      onRetryClick,
      onCancelRetryClick
    };
    if (error) {
      let header;
      let message;
      let linkHref;
      const sendErrorHref = 'https://support.virtru.com/hc/en-us/articles/115010393308';
      if (error.name === 'InvalidAppId' || error.name === 'NoAppIdForDomain') {
        header = i18n.t('EMAIL_ERROR_SEND_REACTIVATION_HEADER');
        message = i18n.t('EMAIL_ERROR_SEND_REACTIVATION');
      } else if (error.name === 'NetworkConnectionError') {
        header = i18n.t('EMAIL_ERROR_NETWORK_LOST_HEADER');
        message = i18n.t('EMAIL_ERROR_NETWORK_LOST');
      } else if (error.name === 'InternalServerError') {
        header = i18n.t('EMAIL_ERROR_INTERNAL_SERVER_ERROR_HEADER');
        message = i18n.t('EMAIL_ERROR_INTERNAL_SERVER_ERROR');
      } else if (error.name === 'CorruptTdfPackage') {
        header = i18n.t('EMAIL_ERROR_EMAIL_CORRUPT_HEADER');
        message = i18n.t('EMAIL_ERROR_EMAIL_CORRUPT');
      } else if (error.name === 'SmartSendSecureError') {
        header = i18n.t('EMAIL_ERROR_SMART_SEND_SECURE_HEADER');
        message = i18n.t('EMAIL_ERROR_SMART_SEND_SECURE');
        linkHref = sendErrorHref;
      } else if (error.name === 'SendError') {
        header = i18n.t('EMAIL_ERROR_SEND_UNKNOWN_HEADER');
        message = i18n.t('EMAIL_ERROR_SEND_UNKNOWN');
        linkHref = sendErrorHref;
      } else {
        header = i18n.t('EMAIL_ERROR_UNKNOWN_HEADER');
        message = i18n.t('EMAIL_ERROR_UNKNOWN');
        linkHref = sendErrorHref;
      }
      props.errorHeader = header;
      props.errorMessage = message;
      props.linkHref = linkHref;
      if (error.name !== 'NetworkConnectionError' && error.name !== 'SmartSendSecureError') {
        new_compose_AnalyticsService.clientError(...getErrorSendParams(error));
      }
    } else {
      new_compose_AnalyticsService.clientError(...getErrorSetupSendParams());
    }
    this._emailError = widgets_default().EmailError.create({
      ...props,
      ...options
    });
    gmail_utility.pwnCompose(this._element, this._emailError.container, this._settings.dom);
  }
  createEncryptionAnimation(windowHeight) {
    const {
      dom
    } = this._settings;
    const animationHeight = windowHeight || this._element.find(dom.NEW_REPLY_TEXTAREA).height();
    if (!this._animationElement) {
      this._animationElement = jquery_pack_default()((0,templates.sendAnimation)());
    }
    const timeline = new new_compose_TimelineLite();
    gmail_utility.pwnCompose(this._element, this._animationElement, this._settings.dom, animationHeight);
    this._editorBanner.addClass('no-touch');
    this._animationElement.css('opacity', 0);
    this._renderSpinner();
    timeline.to(this._animationElement, 0.25, {
      opacity: 1,
      ease: new_compose_Sine.easeOut
    });
    return timeline;
  }

  // @TODO move component to new file
  _renderSpinner() {
    const Scene = () => {
      let resolveAnimationComplete;
      this._animationComplete = new Promise(resolve => {
        resolveAnimationComplete = resolve;
        setTimeout(resolveAnimationComplete, 1500);
      });
      return /*#__PURE__*/react.createElement(VirtruLoadingAnimation/* default */.A, {
        text: i18n.t('SEND_ANIMATION_LOADING_TEXT'),
        variant: "page"
      });
    };
    const container = this._animationElement.find('td').get(0);
    (0,client/* createRoot */.H)(container).render(/*#__PURE__*/react.createElement(Scene, null));
  }
  _playEncryptionAnimation(callback, windowHeight) {
    this.createEncryptionAnimation(windowHeight).call(callback);
  }
  showTrimmedContent() {
    const {
      dom
    } = this._settings;
    const element = this._element;
    const trimmedButtons = element.find(dom.NEW_COMPOSE_TRIMMED_CONTENT_REVEAL);
    const $trimmedContent = element.find(dom.NEW_COMPOSE_TRIMMED_CONTENT).first();

    // Trigger a click if is there. Don't click again if we already have the content,
    // messes up violation warnings
    if (trimmedButtons.length > 0 && !$trimmedContent.length) {
      trimmedButtons.triggerNative('mouseover');
      trimmedButtons.triggerNative('mousedown');
      trimmedButtons.triggerNative('mouseup');
      trimmedButtons.triggerNative('mouseout');
      trimmedButtons.triggerNative('click');
    }
    $trimmedContent.show();
  }

  /**
   * Sends secure email with attachment encryption
   *
   * @param isArchive is send archive
   * @param isScheduledSend is scheduled send
   */
  sendSecureEmail(isArchive, isScheduledSend) {
    if (this.isSecureMode() || this.secureModeOn(true)) {
      this.sendSecure(isArchive, isScheduledSend);
    } else {
      this._sendButtonsMod.enableSendButton();
    }
  }
  encryptAttachmentsAndSendSecure(isArchive, applyPreSendActions, isScheduledSend) {
    return new Promise((resolve, reject) => {
      if (applyPreSendActions && applyPreSendActions instanceof Function) {
        applyPreSendActions();
      }
      const sendAndResolve = () => {
        this.sendSecureEmail(isArchive, isScheduledSend);
        resolve();
      };
      return this.beforeSetupSecureMode(true).then(sendAndResolve).catch(err => err === errors.ATTACHMENT_LIMIT_ERROR ? sendAndResolve() : reject(err));
    });
  }
  covertLoadTrimmedContent() {
    const {
      dom
    } = this._settings;
    this.showTrimmedContent();
    this._element.find(dom.NEW_COMPOSE_TRIMMED_CONTENT).first().hide();
  }
  subject() {
    return this.subjectElem.val();
  }
  bodyText() {
    const bodyHTML = getBodyHTML(this._editor);
    return jquery_pack_default()(jquery_pack_default().parseHTML(bodyHTML)).text();
  }
  recipients() {
    return this._element.find(this._settings.dom.NEW_COMPOSE_RECIPIENTS);
  }
  emailUsers() {
    const {
      dom
    } = this._settings;
    const el = this._element[0];
    const dataAttribute = dom.NEW_COMPOSE_DATA_ATTRIBUTE;
    const $tos = el.querySelectorAll(dom.NEW_COMPOSE_TO) || {};
    const $ccs = el.querySelectorAll(dom.NEW_COMPOSE_CC) || {};
    const $bccs = el.querySelectorAll(dom.NEW_COMPOSE_BCC) || {};
    const $typedTos = el.querySelectorAll(dom.TYPED_COMPOSE_TO);
    const $typedCCs = el.querySelectorAll(dom.TYPED_COMPOSE_CC);
    const $typedBCCs = el.querySelectorAll(dom.TYPED_COMPOSE_BCC);
    const tos = [...getSelectedRecipients($tos, dataAttribute), ...getTypedRecipients($typedTos)];
    const ccs = [...getSelectedRecipients($ccs, dataAttribute), ...getTypedRecipients($typedCCs)];
    const bccs = [...getSelectedRecipients($bccs, dataAttribute), ...getTypedRecipients($typedBCCs)];
    const emailsNoBcc = tos.concat(ccs);
    const emails = emailsNoBcc.concat(bccs);
    return {
      emails,
      emailsNoBcc,
      tos,
      ccs,
      bccs
    };
  }
  children() {
    const attachmentMetadata = this.policyHelper.getByMetadataKey(sites.EmailMetadataEnum.ATTACHMENTS);
    return Object.keys(attachmentMetadata);
  }

  /**
   * Validate the sender alias. Sender is only populated if using "Send From" feature
   * @returns {Boolean} - If the alias is in known aliases or if the domain is in known domains
   */
  validateSender(sender, owner) {
    if (!sender || sender === owner) {
      return true;
    }
    const aliases = this._settings.user.aliases();
    const domains = this._settings.user.domains();
    const senderDomain = sender.split('@')[1];
    return aliases.includes(sender) || domains.includes(senderDomain);
  }

  /**
   * Checks the compose window to see if it is in plain text mode.
   */
  isPlainTextMode() {
    const {
      dom
    } = this._settings;
    const $compose_body = this._element.closest(dom.NEW_COMPOSE_BODY);
    const $more_options_btn = jquery_pack_default()(dom.NEW_COMPOSE_MORE_OPTIONS_BTN, $compose_body);
    const $more_options = jquery_pack_default()(dom.NEW_COMPOSE_MORE_OPTIONS, $compose_body);

    // trigger menu creation so that we can determine 'plain text' state
    $more_options.css({
      'visibility': 'hidden'
    }); // hide
    fireEvent($more_options_btn[0], 'mousedown'); // open
    fireEvent($more_options_btn[0], 'mousedown'); // close

    // remove active state
    $more_options_btn.removeClass(dom.GMAIL_BUTTON_HOVER_CLASSNAME);
    $more_options.css({
      'visibility': 'visible'
    }); // show

    const $plain_text = jquery_pack_default()('.J-N.J-Ks[aria-checked]', $compose_body).last();
    const plain_text = $plain_text.attr('aria-checked');
    if (typeof plain_text !== 'undefined') {
      return plain_text === 'true';
    }

    /* fallbacks */
    // If a draft hasn't been saved yet then the ishtml input will
    // always contain '0' and we can't tell what mode it's in.
    const draft = this._element.find('input[name="draft"]');
    if (draft.length === 0 || draft.val() === 'undefined') {
      return false;
    }

    // Now check the ishtml input since it contains the value
    // of whether or not the compose is in HTML mode
    const data = this._element.find('input[name="ishtml"]');
    if (data.length === 0) {
      return false;
    }
    return data.attr('value') === '0';
  }

  /**
   *
   * @param encryptionPromise
   * @returns {*}
   */
  async promiseWithEncryptionAnimation(encryptionPromise) {
    let animation;
    try {
      animation = this.createEncryptionAnimation();
      animation.play();
      await encryptionPromise;
    } finally {
      var _animation;
      (_animation = animation) === null || _animation === void 0 ? void 0 : _animation.kill();
    }
  }
  handleSendError(error) {
    this.removeComposeEditor();
    this.setupSendEmailError(Object.assign(error, {
      name: 'SmartSendSecureError'
    }));
  }

  /**
   * We need to check and wait for attachments that were added automatically by Gmail (e.g. Forward as attachment)
   * @returns {Promise<void>}
   */
  checkInitialAttachments() {
    return new Promise(resolve => {
      const $regularAttachments = this._element.find(this._settings.dom.NEW_COMPOSE_ATTACHMENT);
      const attachmentsAreReady = () => this._element.find(this._settings.dom.NEW_COMPOSE_ATTACHMENT).find('a').length === $regularAttachments.length;
      if ($regularAttachments.length === 0 || attachmentsAreReady()) {
        resolve();
        return;
      }
      this._hasInitialAttachments = true;

      // If there are automatically added attachments we need to wait for them to load into Gmail.
      const waitForAttachmentsToLoad = () => {
        if (attachmentsAreReady()) {
          resolve();
          this.beforeSetupSecureMode(true);
        } else {
          setTimeout(waitForAttachmentsToLoad, 400);
        }
      };
      waitForAttachmentsToLoad();
    });
  }

  /**
   * Disables the mail merge button in the new compose window for a secure mode.
   */
  disableMailMerge() {
    const mailMergeButton = this._element.find(this._settings.dom.USE_MAIL_MERGE_BUTTON);
    const mailMergeButtonDisabled = mailMergeButton.clone();
    mailMergeButtonDisabled.addClass('virtru-mail-merge-disabled');
    mailMergeButtonDisabled.removeAttr('title');
    mailMergeButtonDisabled.removeAttr('data-tooltip');
    mailMergeButtonDisabled.removeAttr('aria-label');
    mailMergeButton.after(mailMergeButtonDisabled);
    mailMergeButton.hide();
    this.tooltipHelper.generateMailMergeTooltip();
  }

  /**
   * Enables the mail merge button for an unsecure mode.
   */
  enableMailMerge() {
    const mailMergeButton = this._element.find(this._settings.dom.USE_MAIL_MERGE_BUTTON);
    mailMergeButton.show();
    mailMergeButton.next('.virtru-mail-merge-disabled').remove();
  }
}
Object.assign(NewComposerMod.prototype, mod.ModWaiterPromises);
Object.assign(NewComposerMod.prototype, mod.ModElementShortcut);
Object.assign(NewComposerMod.prototype, mod.ModCSSClassShortcut);
Object.assign(NewComposerMod.prototype, mod.ModEventListenerShortcut);
(0,base.addOpen)(NewComposerMod);

/***/ }),

/***/ 18629:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
const ElementRegistry = __webpack_require__(98932);
function GmailElementWaiter(listeningSelectors, processedClass, modFactoriesMap) {
  this._listeningSelectors = listeningSelectors;
  this._processedClass = processedClass;
  this._modFactoriesMap = modFactoriesMap;
}
Emitter(GmailElementWaiter.prototype);
GmailElementWaiter.start = function (listeningSelectors, processedClass, modFactories) {
  var modFactoriesMap = {};
  modFactories.forEach(function (modFactory) {
    modFactoriesMap[modFactory.mainSelector] = modFactory;
  });
  var waiter = new GmailElementWaiter(listeningSelectors, processedClass, modFactoriesMap);
  waiter.startWaiter();
  return waiter;
};
GmailElementWaiter.prototype.startWaiter = function () {
  var self = this;
  for (var key in self._modFactoriesMap) {
    (function (factory, selector) {
      ElementRegistry.addListen(document.body, selector, function (addedElement) {
        if (document.body.contains(addedElement) && !$(addedElement).attr('data-virtru-hooked')) {
          $(addedElement).attr('data-virtru-hooked', 'true');
          self.emit('created-mods', factory.process([addedElement]));
        }
      }, function (removedElement) {
        if (!factory._modClass.skipAutoTeardown && !document.body.contains(removedElement)) {
          $(removedElement).attr('data-virtru-hooked', '');
          self.emit('removed-element', removedElement);
        }
      });
    })(self._modFactoriesMap[key], key);
  }
};
exports.GmailElementWaiter = GmailElementWaiter;

/***/ }),

/***/ 19806:
/***/ ((module, exports) => {

/**
 * This class manages message mods.
 *
 * @constructor
 */
function MessageManager() {
  this.messageMods = {};
}
MessageManager.prototype.register = function (messageMod) {
  if (messageMod === undefined || messageMod === null) {
    throw new Error('The parameter messageMod must have a value.');
  }
  this.messageMods[messageMod.getMessageId()] = messageMod;
};
MessageManager.prototype.unregister = function (messageMod) {
  delete this.messageMods[messageMod.getMessageId()];
};
MessageManager.prototype.getMessage = function (messageUuid) {
  return this.messageMods[messageUuid];
};
module.exports = exports = new MessageManager();

/***/ }),

/***/ 19950:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Highlight Overlay widget
 * darkens the screen and highlights an element
 */
var $ = __webpack_require__(55401);
var html = __webpack_require__(93622);
function HighlightOverlay(target) {
  this._element = $(html);
  this._target = $(target);
  this._offset = {
    left: 0,
    top: 0
  };
}
HighlightOverlay.create = function (target) {
  var overlay = new HighlightOverlay(target);
  return overlay;
};
HighlightOverlay.prototype.show = function (target) {
  if (target) {
    this._target = $(target);
  }

  // if element already exists, just replace it
  var existingElement = $('highlight-overlay');
  if (existingElement.length) {
    this._element = existingElement;
  }
  this._element.appendTo('body');

  // reposition overlay to match the target
  var offset = this._target.offset();
  this.adjustPosition(true, offset.top - 2, offset.left - 2, this._target.innerWidth(), this._target.innerHeight());
  this._element.hide().fadeIn(150);
};

/**
 * Makes adjustments to the position of the high
 * @param overwrite Boolean - whether or not the current values should be overwritten by the new ones
 * @param top - the top edge of the content window
 * @param left - the left edge of the content window
 * @param width - the width of the content window
 * @param height - the height of the content window
 */
HighlightOverlay.prototype.adjustPosition = function (overwrite, top, left, width, height) {
  var topElement = $('.highlight-overlay-top', this._element);
  var leftElement = $('.highlight-overlay-left', this._element);
  var content = $('.highlight-overlay-content', this._element);
  top = top || 0;
  left = left || 0;
  width = width || 0;
  height = height || 0;
  if (!overwrite) {
    this._offset.top = top;
    this._offset.left = left;
    top += parseInt(topElement.css('height'), 10);
    left += parseInt(leftElement.css('width'), 10);
    width += parseInt(content.css('width'), 10);
    height += parseInt(content.css('height'), 10);
  } else {
    this._offset.top = 0;
    this._offset.left = 0;
  }
  topElement.css('height', top);
  leftElement.css('width', left);
  content.css('width', width);
  content.css('height', height);
};
HighlightOverlay.prototype.reposition = function () {
  if (this._target && this._target.offset()) {
    var targetOffset = this._target.offset();
    var top = this._offset.top + targetOffset.top - 2;
    var left = this._offset.left + targetOffset.left - 2;
    $('.highlight-overlay-top', this._element).css('height', top);
    $('.highlight-overlay-left', this._element).css('width', left);
  }
};
HighlightOverlay.prototype.hide = function () {
  var self = this;
  this._element.fadeOut(150, function () {
    self._element.remove();
  });
};
exports.HighlightOverlay = HighlightOverlay;

/***/ }),

/***/ 20211:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 20299:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 20813:
/***/ ((module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

;// ./lib/utils/trusted-types.js
// todo: replace this eventually
const defaultHtmlPolicyOpts = {
  createHTML: string => string
};

// todo: possible this may just become a standard HTML sanitization policy
// todo: look into using DOMPurify for sanitization
const tweenMaxPolicy = window.trustedTypes.createPolicy('tweenMax', {
  ...defaultHtmlPolicyOpts
});
;// ./compatibility/tweenmax/TweenMax.js
/* module decorator */ module = __webpack_require__.hmd(module);
/* provided dependency */ var console = __webpack_require__(31799);


/*!
 * VERSION: 1.11.2
 * DATE: 2013-11-20
 * UPDATES AND DOCS AT: http://www.greensock.com
 * 
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2013, GreenSock. All rights reserved.
 * This work is subject to the terms at http://www.greensock.com/terms_of_use.html or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 * 
 * @author: Jack Doyle, jack@greensock.com
 **/

(window._gsQueue || (window._gsQueue = [])).push(function () {
  "use strict";

  window._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
    var _slice = [].slice,
      TweenMax = function (target, duration, vars) {
        TweenLite.call(this, target, duration, vars);
        this._cycle = 0;
        this._yoyo = this.vars.yoyo === true;
        this._repeat = this.vars.repeat || 0;
        this._repeatDelay = this.vars.repeatDelay || 0;
        this._dirty = true; //ensures that if there is any repeat, the totalDuration will get recalculated to accurately report it.
        this.render = TweenMax.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)
      },
      _tinyNum = 0.0000000001,
      _isSelector = TweenLite._internals.isSelector,
      _isArray = TweenLite._internals.isArray,
      p = TweenMax.prototype = TweenLite.to({}, 0.1, {}),
      _blankArray = [];
    TweenMax.version = "1.11.2";
    p.constructor = TweenMax;
    p.kill()._gc = false;
    TweenMax.killTweensOf = TweenMax.killDelayedCallsTo = TweenLite.killTweensOf;
    TweenMax.getTweensOf = TweenLite.getTweensOf;
    TweenMax.ticker = TweenLite.ticker;
    p.invalidate = function () {
      this._yoyo = this.vars.yoyo === true;
      this._repeat = this.vars.repeat || 0;
      this._repeatDelay = this.vars.repeatDelay || 0;
      this._uncache(true);
      return TweenLite.prototype.invalidate.call(this);
    };
    p.updateTo = function (vars, resetDuration) {
      var curRatio = this.ratio,
        p;
      if (resetDuration && this.timeline && this._startTime < this._timeline._time) {
        this._startTime = this._timeline._time;
        this._uncache(false);
        if (this._gc) {
          this._enabled(true, false);
        } else {
          this._timeline.insert(this, this._startTime - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
        }
      }
      for (p in vars) {
        this.vars[p] = vars[p];
      }
      if (this._initted) {
        if (resetDuration) {
          this._initted = false;
        } else {
          if (this._notifyPluginsOfEnabled && this._firstPT) {
            TweenLite._onPluginEvent("_onDisable", this); //in case a plugin like MotionBlur must perform some cleanup tasks
          }
          if (this._time / this._duration > 0.998) {
            //if the tween has finished (or come extremely close to finishing), we just need to rewind it to 0 and then render it again at the end which forces it to re-initialize (parsing the new vars). We allow tweens that are close to finishing (but haven't quite finished) to work this way too because otherwise, the values are so small when determining where to project the starting values that binary math issues creep in and can make the tween appear to render incorrectly when run backwards. 
            var prevTime = this._time;
            this.render(0, true, false);
            this._initted = false;
            this.render(prevTime, true, false);
          } else if (this._time > 0) {
            this._initted = false;
            this._init();
            var inv = 1 / (1 - curRatio),
              pt = this._firstPT,
              endValue;
            while (pt) {
              endValue = pt.s + pt.c;
              pt.c *= inv;
              pt.s = endValue - pt.c;
              pt = pt._next;
            }
          }
        }
      }
      return this;
    };
    p.render = function (time, suppressEvents, force) {
      if (!this._initted) if (this._duration === 0 && this.vars.repeat) {
        //zero duration tweens that render immediately have render() called from TweenLite's constructor, before TweenMax's constructor has finished setting _repeat, _repeatDelay, and _yoyo which are critical in determining totalDuration() so we need to call invalidate() which is a low-kb way to get those set properly.
        this.invalidate();
      }
      var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
        prevTime = this._time,
        prevTotalTime = this._totalTime,
        prevCycle = this._cycle,
        duration = this._duration,
        isComplete,
        callback,
        pt,
        cycleDuration,
        r,
        type,
        pow,
        rawPrevTime;
      if (time >= totalDur) {
        this._totalTime = totalDur;
        this._cycle = this._repeat;
        if (this._yoyo && (this._cycle & 1) !== 0) {
          this._time = 0;
          this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
        } else {
          this._time = duration;
          this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
        }
        if (!this._reversed) {
          isComplete = true;
          callback = "onComplete";
        }
        if (duration === 0) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          rawPrevTime = this._rawPrevTime;
          if (time === 0 || rawPrevTime < 0 || rawPrevTime === _tinyNum) if (rawPrevTime !== time) {
            force = true;
            if (rawPrevTime > _tinyNum) {
              callback = "onReverseComplete";
            }
          }
          this._rawPrevTime = rawPrevTime = !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      } else if (time < 0.0000001) {
        //to work around occasional floating point math artifacts, round super small values to 0.
        this._totalTime = this._time = this._cycle = 0;
        this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
        if (prevTotalTime !== 0 || duration === 0 && this._rawPrevTime > _tinyNum) {
          callback = "onReverseComplete";
          isComplete = this._reversed;
        }
        if (time < 0) {
          this._active = false;
          if (duration === 0) {
            //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
            if (this._rawPrevTime >= 0) {
              force = true;
            }
            this._rawPrevTime = rawPrevTime = !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
          }
        } else if (!this._initted) {
          //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
          force = true;
        }
      } else {
        this._totalTime = this._time = time;
        if (this._repeat !== 0) {
          cycleDuration = duration + this._repeatDelay;
          this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but Flash reports it as 0.79999999!)
          if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
            this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
          }
          this._time = this._totalTime - this._cycle * cycleDuration;
          if (this._yoyo) if ((this._cycle & 1) !== 0) {
            this._time = duration - this._time;
          }
          if (this._time > duration) {
            this._time = duration;
          } else if (this._time < 0) {
            this._time = 0;
          }
        }
        if (this._easeType) {
          r = this._time / duration;
          type = this._easeType;
          pow = this._easePower;
          if (type === 1 || type === 3 && r >= 0.5) {
            r = 1 - r;
          }
          if (type === 3) {
            r *= 2;
          }
          if (pow === 1) {
            r *= r;
          } else if (pow === 2) {
            r *= r * r;
          } else if (pow === 3) {
            r *= r * r * r;
          } else if (pow === 4) {
            r *= r * r * r * r;
          }
          if (type === 1) {
            this.ratio = 1 - r;
          } else if (type === 2) {
            this.ratio = r;
          } else if (this._time / duration < 0.5) {
            this.ratio = r / 2;
          } else {
            this.ratio = 1 - r / 2;
          }
        } else {
          this.ratio = this._ease.getRatio(this._time / duration);
        }
      }
      if (prevTime === this._time && !force && prevCycle === this._cycle) {
        if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
          //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
          this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
        }
        return;
      } else if (!this._initted) {
        this._init();
        if (!this._initted || this._gc) {
          //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
          return;
        }
        //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
        if (this._time && !isComplete) {
          this.ratio = this._ease.getRatio(this._time / duration);
        } else if (isComplete && this._ease._calcEnd) {
          this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
        }
      }
      if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
        this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
      }
      if (prevTotalTime === 0) {
        if (this._startAt) {
          if (time >= 0) {
            this._startAt.render(time, suppressEvents, force);
          } else if (!callback) {
            callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
          }
        }
        if (this.vars.onStart) if (this._totalTime !== 0 || duration === 0) if (!suppressEvents) {
          this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
        }
      }
      pt = this._firstPT;
      while (pt) {
        if (pt.f) {
          pt.t[pt.p](pt.c * this.ratio + pt.s);
        } else {
          pt.t[pt.p] = pt.c * this.ratio + pt.s;
        }
        pt = pt._next;
      }
      if (this._onUpdate) {
        if (time < 0) if (this._startAt && this._startTime) {
          //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
          this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
        }
        if (!suppressEvents) {
          this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
        }
      }
      if (this._cycle !== prevCycle) if (!suppressEvents) if (!this._gc) if (this.vars.onRepeat) {
        this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
      }
      if (callback) if (!this._gc) {
        //check gc because there's a chance that kill() could be called in an onUpdate
        if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
          //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
          this._startAt.render(time, suppressEvents, force);
        }
        if (isComplete) {
          if (this._timeline.autoRemoveChildren) {
            this._enabled(false, false);
          }
          this._active = false;
        }
        if (!suppressEvents && this.vars[callback]) {
          this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
        }
        if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
          //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
          this._rawPrevTime = 0;
        }
      }
    };

    //---- STATIC FUNCTIONS -----------------------------------------------------------------------------------------------------------

    TweenMax.to = function (target, duration, vars) {
      return new TweenMax(target, duration, vars);
    };
    TweenMax.from = function (target, duration, vars) {
      vars.runBackwards = true;
      vars.immediateRender = vars.immediateRender != false;
      return new TweenMax(target, duration, vars);
    };
    TweenMax.fromTo = function (target, duration, fromVars, toVars) {
      toVars.startAt = fromVars;
      toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
      return new TweenMax(target, duration, toVars);
    };
    TweenMax.staggerTo = TweenMax.allTo = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      stagger = stagger || 0;
      var delay = vars.delay || 0,
        a = [],
        finalComplete = function () {
          if (vars.onComplete) {
            vars.onComplete.apply(vars.onCompleteScope || this, arguments);
          }
          onCompleteAll.apply(onCompleteAllScope || this, onCompleteAllParams || _blankArray);
        },
        l,
        copy,
        i,
        p;
      if (!_isArray(targets)) {
        if (typeof targets === "string") {
          targets = TweenLite.selector(targets) || targets;
        }
        if (_isSelector(targets)) {
          targets = _slice.call(targets, 0);
        }
      }
      l = targets.length;
      for (i = 0; i < l; i++) {
        copy = {};
        for (p in vars) {
          copy[p] = vars[p];
        }
        copy.delay = delay;
        if (i === l - 1 && onCompleteAll) {
          copy.onComplete = finalComplete;
        }
        a[i] = new TweenMax(targets[i], duration, copy);
        delay += stagger;
      }
      return a;
    };
    TweenMax.staggerFrom = TweenMax.allFrom = function (targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      vars.runBackwards = true;
      vars.immediateRender = vars.immediateRender != false;
      return TweenMax.staggerTo(targets, duration, vars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };
    TweenMax.staggerFromTo = TweenMax.allFromTo = function (targets, duration, fromVars, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      toVars.startAt = fromVars;
      toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
      return TweenMax.staggerTo(targets, duration, toVars, stagger, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };
    TweenMax.delayedCall = function (delay, callback, params, scope, useFrames) {
      return new TweenMax(callback, 0, {
        delay: delay,
        onComplete: callback,
        onCompleteParams: params,
        onCompleteScope: scope,
        onReverseComplete: callback,
        onReverseCompleteParams: params,
        onReverseCompleteScope: scope,
        immediateRender: false,
        useFrames: useFrames,
        overwrite: 0
      });
    };
    TweenMax.set = function (target, vars) {
      return new TweenMax(target, 0, vars);
    };
    TweenMax.isTweening = function (target) {
      return TweenLite.getTweensOf(target, true).length > 0;
    };
    var _getChildrenOf = function (timeline, includeTimelines) {
        var a = [],
          cnt = 0,
          tween = timeline._first;
        while (tween) {
          if (tween instanceof TweenLite) {
            a[cnt++] = tween;
          } else {
            if (includeTimelines) {
              a[cnt++] = tween;
            }
            a = a.concat(_getChildrenOf(tween, includeTimelines));
            cnt = a.length;
          }
          tween = tween._next;
        }
        return a;
      },
      getAllTweens = TweenMax.getAllTweens = function (includeTimelines) {
        return _getChildrenOf(Animation._rootTimeline, includeTimelines).concat(_getChildrenOf(Animation._rootFramesTimeline, includeTimelines));
      };
    TweenMax.killAll = function (complete, tweens, delayedCalls, timelines) {
      if (tweens == null) {
        tweens = true;
      }
      if (delayedCalls == null) {
        delayedCalls = true;
      }
      var a = getAllTweens(timelines != false),
        l = a.length,
        allTrue = tweens && delayedCalls && timelines,
        isDC,
        tween,
        i;
      for (i = 0; i < l; i++) {
        tween = a[i];
        if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
          if (complete) {
            tween.totalTime(tween.totalDuration());
          } else {
            tween._enabled(false, false);
          }
        }
      }
    };
    TweenMax.killChildTweensOf = function (parent, complete) {
      if (parent == null) {
        return;
      }
      var tl = TweenLite._tweenLookup,
        a,
        curParent,
        p,
        i,
        l;
      if (typeof parent === "string") {
        parent = TweenLite.selector(parent) || parent;
      }
      if (_isSelector(parent)) {
        parent = _slice(parent, 0);
      }
      if (_isArray(parent)) {
        i = parent.length;
        while (--i > -1) {
          TweenMax.killChildTweensOf(parent[i], complete);
        }
        return;
      }
      a = [];
      for (p in tl) {
        curParent = tl[p].target.parentNode;
        while (curParent) {
          if (curParent === parent) {
            a = a.concat(tl[p].tweens);
          }
          curParent = curParent.parentNode;
        }
      }
      l = a.length;
      for (i = 0; i < l; i++) {
        if (complete) {
          a[i].totalTime(a[i].totalDuration());
        }
        a[i]._enabled(false, false);
      }
    };
    var _changePause = function (pause, tweens, delayedCalls, timelines) {
      tweens = tweens !== false;
      delayedCalls = delayedCalls !== false;
      timelines = timelines !== false;
      var a = getAllTweens(timelines),
        allTrue = tweens && delayedCalls && timelines,
        i = a.length,
        isDC,
        tween;
      while (--i > -1) {
        tween = a[i];
        if (allTrue || tween instanceof SimpleTimeline || (isDC = tween.target === tween.vars.onComplete) && delayedCalls || tweens && !isDC) {
          tween.paused(pause);
        }
      }
    };
    TweenMax.pauseAll = function (tweens, delayedCalls, timelines) {
      _changePause(true, tweens, delayedCalls, timelines);
    };
    TweenMax.resumeAll = function (tweens, delayedCalls, timelines) {
      _changePause(false, tweens, delayedCalls, timelines);
    };
    TweenMax.globalTimeScale = function (value) {
      var tl = Animation._rootTimeline,
        t = TweenLite.ticker.time;
      if (!arguments.length) {
        return tl._timeScale;
      }
      value = value || _tinyNum; //can't allow zero because it'll throw the math off
      tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
      tl = Animation._rootFramesTimeline;
      t = TweenLite.ticker.frame;
      tl._startTime = t - (t - tl._startTime) * tl._timeScale / value;
      tl._timeScale = Animation._rootTimeline._timeScale = value;
      return value;
    };

    //---- GETTERS / SETTERS ----------------------------------------------------------------------------------------------------------

    p.progress = function (value) {
      return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), false);
    };
    p.totalProgress = function (value) {
      return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, false);
    };
    p.time = function (value, suppressEvents) {
      if (!arguments.length) {
        return this._time;
      }
      if (this._dirty) {
        this.totalDuration();
      }
      if (value > this._duration) {
        value = this._duration;
      }
      if (this._yoyo && (this._cycle & 1) !== 0) {
        value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
      } else if (this._repeat !== 0) {
        value += this._cycle * (this._duration + this._repeatDelay);
      }
      return this.totalTime(value, suppressEvents);
    };
    p.duration = function (value) {
      if (!arguments.length) {
        return this._duration; //don't set _dirty = false because there could be repeats that haven't been factored into the _totalDuration yet. Otherwise, if you create a repeated TweenMax and then immediately check its duration(), it would cache the value and the totalDuration would not be correct, thus repeats wouldn't take effect.
      }
      return Animation.prototype.duration.call(this, value);
    };
    p.totalDuration = function (value) {
      if (!arguments.length) {
        if (this._dirty) {
          //instead of Infinity, we use 999999999999 so that we can accommodate reverses
          this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
          this._dirty = false;
        }
        return this._totalDuration;
      }
      return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
    };
    p.repeat = function (value) {
      if (!arguments.length) {
        return this._repeat;
      }
      this._repeat = value;
      return this._uncache(true);
    };
    p.repeatDelay = function (value) {
      if (!arguments.length) {
        return this._repeatDelay;
      }
      this._repeatDelay = value;
      return this._uncache(true);
    };
    p.yoyo = function (value) {
      if (!arguments.length) {
        return this._yoyo;
      }
      this._yoyo = value;
      return this;
    };
    return TweenMax;
  }, true);

  /*
   * ----------------------------------------------------------------
   * TimelineLite
   * ----------------------------------------------------------------
   */
  window._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (Animation, SimpleTimeline, TweenLite) {
    var TimelineLite = function (vars) {
        SimpleTimeline.call(this, vars);
        this._labels = {};
        this.autoRemoveChildren = this.vars.autoRemoveChildren === true;
        this.smoothChildTiming = this.vars.smoothChildTiming === true;
        this._sortChildren = true;
        this._onUpdate = this.vars.onUpdate;
        var v = this.vars,
          val,
          p;
        for (p in v) {
          val = v[p];
          if (_isArray(val)) if (val.join("").indexOf("{self}") !== -1) {
            v[p] = this._swapSelfInParams(val);
          }
        }
        if (_isArray(v.tweens)) {
          this.add(v.tweens, 0, v.align, v.stagger);
        }
      },
      _tinyNum = 0.0000000001,
      _isSelector = TweenLite._internals.isSelector,
      _isArray = TweenLite._internals.isArray,
      _blankArray = [],
      _copy = function (vars) {
        var copy = {},
          p;
        for (p in vars) {
          copy[p] = vars[p];
        }
        return copy;
      },
      _pauseCallback = function (tween, callback, params, scope) {
        tween._timeline.pause(tween._startTime);
        if (callback) {
          callback.apply(scope || tween._timeline, params || _blankArray);
        }
      },
      _slice = _blankArray.slice,
      p = TimelineLite.prototype = new SimpleTimeline();
    TimelineLite.version = "1.11.0";
    p.constructor = TimelineLite;
    p.kill()._gc = false;
    p.to = function (target, duration, vars, position) {
      return duration ? this.add(new TweenLite(target, duration, vars), position) : this.set(target, vars, position);
    };
    p.from = function (target, duration, vars, position) {
      return this.add(TweenLite.from(target, duration, vars), position);
    };
    p.fromTo = function (target, duration, fromVars, toVars, position) {
      return duration ? this.add(TweenLite.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
    };
    p.staggerTo = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      var tl = new TimelineLite({
          onComplete: onCompleteAll,
          onCompleteParams: onCompleteAllParams,
          onCompleteScope: onCompleteAllScope
        }),
        i;
      if (typeof targets === "string") {
        targets = TweenLite.selector(targets) || targets;
      }
      if (_isSelector(targets)) {
        //senses if the targets object is a selector. If it is, we should translate it into an array.
        targets = _slice.call(targets, 0);
      }
      stagger = stagger || 0;
      for (i = 0; i < targets.length; i++) {
        if (vars.startAt) {
          vars.startAt = _copy(vars.startAt);
        }
        tl.to(targets[i], duration, _copy(vars), i * stagger);
      }
      return this.add(tl, position);
    };
    p.staggerFrom = function (targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      vars.immediateRender = vars.immediateRender != false;
      vars.runBackwards = true;
      return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };
    p.staggerFromTo = function (targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope) {
      toVars.startAt = fromVars;
      toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
      return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams, onCompleteAllScope);
    };
    p.call = function (callback, params, scope, position) {
      return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
    };
    p.set = function (target, vars, position) {
      position = this._parseTimeOrLabel(position, 0, true);
      if (vars.immediateRender == null) {
        vars.immediateRender = position === this._time && !this._paused;
      }
      return this.add(new TweenLite(target, 0, vars), position);
    };
    TimelineLite.exportRoot = function (vars, ignoreDelayedCalls) {
      vars = vars || {};
      if (vars.smoothChildTiming == null) {
        vars.smoothChildTiming = true;
      }
      var tl = new TimelineLite(vars),
        root = tl._timeline,
        tween,
        next;
      if (ignoreDelayedCalls == null) {
        ignoreDelayedCalls = true;
      }
      root._remove(tl, true);
      tl._startTime = 0;
      tl._rawPrevTime = tl._time = tl._totalTime = root._time;
      tween = root._first;
      while (tween) {
        next = tween._next;
        if (!ignoreDelayedCalls || !(tween instanceof TweenLite && tween.target === tween.vars.onComplete)) {
          tl.add(tween, tween._startTime - tween._delay);
        }
        tween = next;
      }
      root.add(tl, 0);
      return tl;
    };
    p.add = function (value, position, align, stagger) {
      var curTime, l, i, child, tl, beforeRawTime;
      if (typeof position !== "number") {
        position = this._parseTimeOrLabel(position, 0, true, value);
      }
      if (!(value instanceof Animation)) {
        if (value instanceof Array || value && value.push && _isArray(value)) {
          align = align || "normal";
          stagger = stagger || 0;
          curTime = position;
          l = value.length;
          for (i = 0; i < l; i++) {
            if (_isArray(child = value[i])) {
              child = new TimelineLite({
                tweens: child
              });
            }
            this.add(child, curTime);
            if (typeof child !== "string" && typeof child !== "function") {
              if (align === "sequence") {
                curTime = child._startTime + child.totalDuration() / child._timeScale;
              } else if (align === "start") {
                child._startTime -= child.delay();
              }
            }
            curTime += stagger;
          }
          return this._uncache(true);
        } else if (typeof value === "string") {
          return this.addLabel(value, position);
        } else if (typeof value === "function") {
          value = TweenLite.delayedCall(0, value);
        } else {
          throw "Cannot add " + value + " into the timeline; it is not a tween, timeline, function, or string.";
        }
      }
      SimpleTimeline.prototype.add.call(this, value, position);

      //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly.
      if (this._gc) if (!this._paused) if (this._duration < this.duration()) {
        //in case any of the anscestors had completed but should now be enabled...
        tl = this;
        beforeRawTime = tl.rawTime() > value._startTime; //if the tween is placed on the timeline so that it starts BEFORE the current rawTime, we should align the playhead (move the timeline). This is because sometimes users will create a timeline, let it finish, and much later append a tween and expect it to run instead of jumping to its end state. While technically one could argue that it should jump to its end state, that's not what users intuitively expect.
        while (tl._gc && tl._timeline) {
          if (tl._timeline.smoothChildTiming && beforeRawTime) {
            tl.totalTime(tl._totalTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.
          } else {
            tl._enabled(true, false);
          }
          tl = tl._timeline;
        }
      }
      return this;
    };
    p.remove = function (value) {
      if (value instanceof Animation) {
        return this._remove(value, false);
      } else if (value instanceof Array || value && value.push && _isArray(value)) {
        var i = value.length;
        while (--i > -1) {
          this.remove(value[i]);
        }
        return this;
      } else if (typeof value === "string") {
        return this.removeLabel(value);
      }
      return this.kill(null, value);
    };
    p._remove = function (tween, skipDisable) {
      SimpleTimeline.prototype._remove.call(this, tween, skipDisable);
      var last = this._last;
      if (!last) {
        this._time = this._totalTime = 0;
      } else if (this._time > last._startTime + last._totalDuration / last._timeScale) {
        this._time = this.duration();
        this._totalTime = this._totalDuration;
      }
      return this;
    };
    p.append = function (value, offsetOrLabel) {
      return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
    };
    p.insert = p.insertMultiple = function (value, position, align, stagger) {
      return this.add(value, position || 0, align, stagger);
    };
    p.appendMultiple = function (tweens, offsetOrLabel, align, stagger) {
      return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
    };
    p.addLabel = function (label, position) {
      this._labels[label] = this._parseTimeOrLabel(position);
      return this;
    };
    p.addPause = function (position, callback, params, scope) {
      return this.call(_pauseCallback, ["{self}", callback, params, scope], this, position);
    };
    p.removeLabel = function (label) {
      delete this._labels[label];
      return this;
    };
    p.getLabelTime = function (label) {
      return this._labels[label] != null ? this._labels[label] : -1;
    };
    p._parseTimeOrLabel = function (timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
      var i;
      //if we're about to add a tween/timeline (or an array of them) that's already a child of this timeline, we should remove it first so that it doesn't contaminate the duration().
      if (ignore instanceof Animation && ignore.timeline === this) {
        this.remove(ignore);
      } else if (ignore && (ignore instanceof Array || ignore.push && _isArray(ignore))) {
        i = ignore.length;
        while (--i > -1) {
          if (ignore[i] instanceof Animation && ignore[i].timeline === this) {
            this.remove(ignore[i]);
          }
        }
      }
      if (typeof offsetOrLabel === "string") {
        return this._parseTimeOrLabel(offsetOrLabel, appendIfAbsent && typeof timeOrLabel === "number" && this._labels[offsetOrLabel] == null ? timeOrLabel - this.duration() : 0, appendIfAbsent);
      }
      offsetOrLabel = offsetOrLabel || 0;
      if (typeof timeOrLabel === "string" && (isNaN(timeOrLabel) || this._labels[timeOrLabel] != null)) {
        //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
        i = timeOrLabel.indexOf("=");
        if (i === -1) {
          if (this._labels[timeOrLabel] == null) {
            return appendIfAbsent ? this._labels[timeOrLabel] = this.duration() + offsetOrLabel : offsetOrLabel;
          }
          return this._labels[timeOrLabel] + offsetOrLabel;
        }
        offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
        timeOrLabel = i > 1 ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
      } else if (timeOrLabel == null) {
        timeOrLabel = this.duration();
      }
      return Number(timeOrLabel) + offsetOrLabel;
    };
    p.seek = function (position, suppressEvents) {
      return this.totalTime(typeof position === "number" ? position : this._parseTimeOrLabel(position), suppressEvents !== false);
    };
    p.stop = function () {
      return this.paused(true);
    };
    p.gotoAndPlay = function (position, suppressEvents) {
      return this.play(position, suppressEvents);
    };
    p.gotoAndStop = function (position, suppressEvents) {
      return this.pause(position, suppressEvents);
    };
    p.render = function (time, suppressEvents, force) {
      if (this._gc) {
        this._enabled(true, false);
      }
      var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
        prevTime = this._time,
        prevStart = this._startTime,
        prevTimeScale = this._timeScale,
        prevPaused = this._paused,
        tween,
        isComplete,
        next,
        callback,
        internalForce;
      if (time >= totalDur) {
        this._totalTime = this._time = totalDur;
        if (!this._reversed) if (!this._hasPausedChild()) {
          isComplete = true;
          callback = "onComplete";
          if (this._duration === 0) if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === _tinyNum) if (this._rawPrevTime !== time && this._first) {
            internalForce = true;
            if (this._rawPrevTime > _tinyNum) {
              callback = "onReverseComplete";
            }
          }
        }
        this._rawPrevTime = this._duration || !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        time = totalDur + 0.000001; //to avoid occasional floating point rounding errors - sometimes child tweens/timelines were not being fully completed (their progress might be 0.999999999999998 instead of 1 because when _time - tween._startTime is performed, floating point errors would return a value that was SLIGHTLY off)
      } else if (time < 0.0000001) {
        //to work around occasional floating point math artifacts, round super small values to 0.
        this._totalTime = this._time = 0;
        if (prevTime !== 0 || this._duration === 0 && (this._rawPrevTime > _tinyNum || time < 0 && this._rawPrevTime >= 0)) {
          callback = "onReverseComplete";
          isComplete = this._reversed;
        }
        if (time < 0) {
          this._active = false;
          if (this._duration === 0) if (this._rawPrevTime >= 0 && this._first) {
            //zero-duration timelines are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
            internalForce = true;
          }
          this._rawPrevTime = time;
        } else {
          this._rawPrevTime = this._duration || !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.

          time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
          if (!this._initted) {
            internalForce = true;
          }
        }
      } else {
        this._totalTime = this._time = this._rawPrevTime = time;
      }
      if ((this._time === prevTime || !this._first) && !force && !internalForce) {
        return;
      } else if (!this._initted) {
        this._initted = true;
      }
      if (!this._active) if (!this._paused && this._time !== prevTime && time > 0) {
        this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
      }
      if (prevTime === 0) if (this.vars.onStart) if (this._time !== 0) if (!suppressEvents) {
        this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
      }
      if (this._time >= prevTime) {
        tween = this._first;
        while (tween) {
          next = tween._next; //record it here because the value could change after rendering...
          if (this._paused && !prevPaused) {
            //in case a tween pauses the timeline when rendering
            break;
          } else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
            if (!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
            }
          }
          tween = next;
        }
      } else {
        tween = this._last;
        while (tween) {
          next = tween._prev; //record it here because the value could change after rendering...
          if (this._paused && !prevPaused) {
            //in case a tween pauses the timeline when rendering
            break;
          } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
            if (!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
            }
          }
          tween = next;
        }
      }
      if (this._onUpdate) if (!suppressEvents) {
        this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
      }
      if (callback) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
        //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
        if (isComplete) {
          if (this._timeline.autoRemoveChildren) {
            this._enabled(false, false);
          }
          this._active = false;
        }
        if (!suppressEvents && this.vars[callback]) {
          this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
        }
      }
    };
    p._hasPausedChild = function () {
      var tween = this._first;
      while (tween) {
        if (tween._paused || tween instanceof TimelineLite && tween._hasPausedChild()) {
          return true;
        }
        tween = tween._next;
      }
      return false;
    };
    p.getChildren = function (nested, tweens, timelines, ignoreBeforeTime) {
      ignoreBeforeTime = ignoreBeforeTime || -9999999999;
      var a = [],
        tween = this._first,
        cnt = 0;
      while (tween) {
        if (tween._startTime < ignoreBeforeTime) {
          //do nothing
        } else if (tween instanceof TweenLite) {
          if (tweens !== false) {
            a[cnt++] = tween;
          }
        } else {
          if (timelines !== false) {
            a[cnt++] = tween;
          }
          if (nested !== false) {
            a = a.concat(tween.getChildren(true, tweens, timelines));
            cnt = a.length;
          }
        }
        tween = tween._next;
      }
      return a;
    };
    p.getTweensOf = function (target, nested) {
      var tweens = TweenLite.getTweensOf(target),
        i = tweens.length,
        a = [],
        cnt = 0;
      while (--i > -1) {
        if (tweens[i].timeline === this || nested && this._contains(tweens[i])) {
          a[cnt++] = tweens[i];
        }
      }
      return a;
    };
    p._contains = function (tween) {
      var tl = tween.timeline;
      while (tl) {
        if (tl === this) {
          return true;
        }
        tl = tl.timeline;
      }
      return false;
    };
    p.shiftChildren = function (amount, adjustLabels, ignoreBeforeTime) {
      ignoreBeforeTime = ignoreBeforeTime || 0;
      var tween = this._first,
        labels = this._labels,
        p;
      while (tween) {
        if (tween._startTime >= ignoreBeforeTime) {
          tween._startTime += amount;
        }
        tween = tween._next;
      }
      if (adjustLabels) {
        for (p in labels) {
          if (labels[p] >= ignoreBeforeTime) {
            labels[p] += amount;
          }
        }
      }
      return this._uncache(true);
    };
    p._kill = function (vars, target) {
      if (!vars && !target) {
        return this._enabled(false, false);
      }
      var tweens = !target ? this.getChildren(true, true, false) : this.getTweensOf(target),
        i = tweens.length,
        changed = false;
      while (--i > -1) {
        if (tweens[i]._kill(vars, target)) {
          changed = true;
        }
      }
      return changed;
    };
    p.clear = function (labels) {
      var tweens = this.getChildren(false, true, true),
        i = tweens.length;
      this._time = this._totalTime = 0;
      while (--i > -1) {
        tweens[i]._enabled(false, false);
      }
      if (labels !== false) {
        this._labels = {};
      }
      return this._uncache(true);
    };
    p.invalidate = function () {
      var tween = this._first;
      while (tween) {
        tween.invalidate();
        tween = tween._next;
      }
      return this;
    };
    p._enabled = function (enabled, ignoreTimeline) {
      if (enabled === this._gc) {
        var tween = this._first;
        while (tween) {
          tween._enabled(enabled, true);
          tween = tween._next;
        }
      }
      return SimpleTimeline.prototype._enabled.call(this, enabled, ignoreTimeline);
    };
    p.duration = function (value) {
      if (!arguments.length) {
        if (this._dirty) {
          this.totalDuration(); //just triggers recalculation
        }
        return this._duration;
      }
      if (this.duration() !== 0 && value !== 0) {
        this.timeScale(this._duration / value);
      }
      return this;
    };
    p.totalDuration = function (value) {
      if (!arguments.length) {
        if (this._dirty) {
          var max = 0,
            tween = this._last,
            prevStart = 999999999999,
            prev,
            end;
          while (tween) {
            prev = tween._prev; //record it here in case the tween changes position in the sequence...
            if (tween._dirty) {
              tween.totalDuration(); //could change the tween._startTime, so make sure the tween's cache is clean before analyzing it.
            }
            if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
              //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
              this.add(tween, tween._startTime - tween._delay);
            } else {
              prevStart = tween._startTime;
            }
            if (tween._startTime < 0 && !tween._paused) {
              //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
              max -= tween._startTime;
              if (this._timeline.smoothChildTiming) {
                this._startTime += tween._startTime / this._timeScale;
              }
              this.shiftChildren(-tween._startTime, false, -9999999999);
              prevStart = 0;
            }
            end = tween._startTime + tween._totalDuration / tween._timeScale;
            if (end > max) {
              max = end;
            }
            tween = prev;
          }
          this._duration = this._totalDuration = max;
          this._dirty = false;
        }
        return this._totalDuration;
      }
      if (this.totalDuration() !== 0) if (value !== 0) {
        this.timeScale(this._totalDuration / value);
      }
      return this;
    };
    p.usesFrames = function () {
      var tl = this._timeline;
      while (tl._timeline) {
        tl = tl._timeline;
      }
      return tl === Animation._rootFramesTimeline;
    };
    p.rawTime = function () {
      return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
    };
    return TimelineLite;
  }, true);

  /*
   * ----------------------------------------------------------------
   * TimelineMax
   * ----------------------------------------------------------------
   */
  window._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (TimelineLite, TweenLite, Ease) {
    var TimelineMax = function (vars) {
        TimelineLite.call(this, vars);
        this._repeat = this.vars.repeat || 0;
        this._repeatDelay = this.vars.repeatDelay || 0;
        this._cycle = 0;
        this._yoyo = this.vars.yoyo === true;
        this._dirty = true;
      },
      _tinyNum = 0.0000000001,
      _blankArray = [],
      _easeNone = new Ease(null, null, 1, 0),
      p = TimelineMax.prototype = new TimelineLite();
    p.constructor = TimelineMax;
    p.kill()._gc = false;
    TimelineMax.version = "1.11.0";
    p.invalidate = function () {
      this._yoyo = this.vars.yoyo === true;
      this._repeat = this.vars.repeat || 0;
      this._repeatDelay = this.vars.repeatDelay || 0;
      this._uncache(true);
      return TimelineLite.prototype.invalidate.call(this);
    };
    p.addCallback = function (callback, position, params, scope) {
      return this.add(TweenLite.delayedCall(0, callback, params, scope), position);
    };
    p.removeCallback = function (callback, position) {
      if (callback) {
        if (position == null) {
          this._kill(null, callback);
        } else {
          var a = this.getTweensOf(callback, false),
            i = a.length,
            time = this._parseTimeOrLabel(position);
          while (--i > -1) {
            if (a[i]._startTime === time) {
              a[i]._enabled(false, false);
            }
          }
        }
      }
      return this;
    };
    p.tweenTo = function (position, vars) {
      vars = vars || {};
      var copy = {
          ease: _easeNone,
          overwrite: 2,
          useFrames: this.usesFrames(),
          immediateRender: false
        },
        p,
        t;
      for (p in vars) {
        copy[p] = vars[p];
      }
      copy.time = this._parseTimeOrLabel(position);
      t = new TweenLite(this, Math.abs(Number(copy.time) - this._time) / this._timeScale || 0.001, copy);
      copy.onStart = function () {
        t.target.paused(true);
        if (t.vars.time !== t.target.time()) {
          //don't make the duration zero - if it's supposed to be zero, don't worry because it's already initting the tween and will complete immediately, effectively making the duration zero anyway. If we make duration zero, the tween won't run at all.
          t.duration(Math.abs(t.vars.time - t.target.time()) / t.target._timeScale);
        }
        if (vars.onStart) {
          //in case the user had an onStart in the vars - we don't want to overwrite it.
          vars.onStart.apply(vars.onStartScope || t, vars.onStartParams || _blankArray);
        }
      };
      return t;
    };
    p.tweenFromTo = function (fromPosition, toPosition, vars) {
      vars = vars || {};
      fromPosition = this._parseTimeOrLabel(fromPosition);
      vars.startAt = {
        onComplete: this.seek,
        onCompleteParams: [fromPosition],
        onCompleteScope: this
      };
      vars.immediateRender = vars.immediateRender !== false;
      var t = this.tweenTo(toPosition, vars);
      return t.duration(Math.abs(t.vars.time - fromPosition) / this._timeScale || 0.001);
    };
    p.render = function (time, suppressEvents, force) {
      if (this._gc) {
        this._enabled(true, false);
      }
      var totalDur = !this._dirty ? this._totalDuration : this.totalDuration(),
        dur = this._duration,
        prevTime = this._time,
        prevTotalTime = this._totalTime,
        prevStart = this._startTime,
        prevTimeScale = this._timeScale,
        prevRawPrevTime = this._rawPrevTime,
        prevPaused = this._paused,
        prevCycle = this._cycle,
        tween,
        isComplete,
        next,
        callback,
        internalForce,
        cycleDuration;
      if (time >= totalDur) {
        if (!this._locked) {
          this._totalTime = totalDur;
          this._cycle = this._repeat;
        }
        if (!this._reversed) if (!this._hasPausedChild()) {
          isComplete = true;
          callback = "onComplete";
          if (this._duration === 0) if (time === 0 || prevRawPrevTime < 0 || prevRawPrevTime === _tinyNum) if (prevRawPrevTime !== time && this._first) {
            internalForce = true;
            if (prevRawPrevTime > _tinyNum) {
              callback = "onReverseComplete";
            }
          }
        }
        this._rawPrevTime = this._duration || !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        if (this._yoyo && (this._cycle & 1) !== 0) {
          this._time = time = 0;
        } else {
          this._time = dur;
          time = dur + 0.000001; //to avoid occasional floating point rounding errors
        }
      } else if (time < 0.0000001) {
        //to work around occasional floating point math artifacts, round super small values to 0.
        if (!this._locked) {
          this._totalTime = this._cycle = 0;
        }
        this._time = 0;
        if (prevTime !== 0 || dur === 0 && (prevRawPrevTime > _tinyNum || time < 0 && prevRawPrevTime >= 0) && !this._locked) {
          //edge case for checking time < 0 && prevRawPrevTime >= 0: a zero-duration fromTo() tween inside a zero-duration timeline (yeah, very rare)
          callback = "onReverseComplete";
          isComplete = this._reversed;
        }
        if (time < 0) {
          this._active = false;
          if (dur === 0) if (prevRawPrevTime >= 0 && this._first) {
            //zero-duration timelines are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
            internalForce = true;
          }
          this._rawPrevTime = time;
        } else {
          this._rawPrevTime = dur || !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline or tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
          time = 0; //to avoid occasional floating point rounding errors (could cause problems especially with zero-duration tweens at the very beginning of the timeline)
          if (!this._initted) {
            internalForce = true;
          }
        }
      } else {
        if (dur === 0 && prevRawPrevTime < 0) {
          //without this, zero-duration repeating timelines (like with a simple callback nested at the very beginning and a repeatDelay) wouldn't render the first time through.
          internalForce = true;
        }
        this._time = this._rawPrevTime = time;
        if (!this._locked) {
          this._totalTime = time;
          if (this._repeat !== 0) {
            cycleDuration = dur + this._repeatDelay;
            this._cycle = this._totalTime / cycleDuration >> 0; //originally _totalTime % cycleDuration but floating point errors caused problems, so I normalized it. (4 % 0.8 should be 0 but it gets reported as 0.79999999!)
            if (this._cycle !== 0) if (this._cycle === this._totalTime / cycleDuration) {
              this._cycle--; //otherwise when rendered exactly at the end time, it will act as though it is repeating (at the beginning)
            }
            this._time = this._totalTime - this._cycle * cycleDuration;
            if (this._yoyo) if ((this._cycle & 1) !== 0) {
              this._time = dur - this._time;
            }
            if (this._time > dur) {
              this._time = dur;
              time = dur + 0.000001; //to avoid occasional floating point rounding error
            } else if (this._time < 0) {
              this._time = time = 0;
            } else {
              time = this._time;
            }
          }
        }
      }
      if (this._cycle !== prevCycle) if (!this._locked) {
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get transated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the TimelineMax work.
        */
        var backwards = this._yoyo && (prevCycle & 1) !== 0,
          wrap = backwards === (this._yoyo && (this._cycle & 1) !== 0),
          recTotalTime = this._totalTime,
          recCycle = this._cycle,
          recRawPrevTime = this._rawPrevTime,
          recTime = this._time;
        this._totalTime = prevCycle * dur;
        if (this._cycle < prevCycle) {
          backwards = !backwards;
        } else {
          this._totalTime += dur;
        }
        this._time = prevTime; //temporarily revert _time so that render() renders the children in the correct order. Without this, tweens won't rewind correctly. We could arhictect things in a "cleaner" way by splitting out the rendering queue into a separate method but for performance reasons, we kept it all inside this method.

        this._rawPrevTime = dur === 0 ? prevRawPrevTime - 0.00001 : prevRawPrevTime;
        this._cycle = prevCycle;
        this._locked = true; //prevents changes to totalTime and skips repeat/yoyo behavior when we recursively call render()
        prevTime = backwards ? 0 : dur;
        this.render(prevTime, suppressEvents, dur === 0);
        if (!suppressEvents) if (!this._gc) {
          if (this.vars.onRepeat) {
            this.vars.onRepeat.apply(this.vars.onRepeatScope || this, this.vars.onRepeatParams || _blankArray);
          }
        }
        if (wrap) {
          prevTime = backwards ? dur + 0.000001 : -0.000001;
          this.render(prevTime, true, false);
        }
        this._locked = false;
        if (this._paused && !prevPaused) {
          //if the render() triggered callback that paused this timeline, we should abort (very rare, but possible)
          return;
        }
        this._time = recTime;
        this._totalTime = recTotalTime;
        this._cycle = recCycle;
        this._rawPrevTime = recRawPrevTime;
      }
      if ((this._time === prevTime || !this._first) && !force && !internalForce) {
        if (prevTotalTime !== this._totalTime) if (this._onUpdate) if (!suppressEvents) {
          //so that onUpdate fires even during the repeatDelay - as long as the totalTime changed, we should trigger onUpdate.
          this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
        }
        return;
      } else if (!this._initted) {
        this._initted = true;
      }
      if (!this._active) if (!this._paused && this._totalTime !== prevTotalTime && time > 0) {
        this._active = true; //so that if the user renders the timeline (as opposed to the parent timeline rendering it), it is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the timeline already finished but the user manually re-renders it as halfway done, for example.
      }
      if (prevTotalTime === 0) if (this.vars.onStart) if (this._totalTime !== 0) if (!suppressEvents) {
        this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
      }
      if (this._time >= prevTime) {
        tween = this._first;
        while (tween) {
          next = tween._next; //record it here because the value could change after rendering...
          if (this._paused && !prevPaused) {
            //in case a tween pauses the timeline when rendering
            break;
          } else if (tween._active || tween._startTime <= this._time && !tween._paused && !tween._gc) {
            if (!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
            }
          }
          tween = next;
        }
      } else {
        tween = this._last;
        while (tween) {
          next = tween._prev; //record it here because the value could change after rendering...
          if (this._paused && !prevPaused) {
            //in case a tween pauses the timeline when rendering
            break;
          } else if (tween._active || tween._startTime <= prevTime && !tween._paused && !tween._gc) {
            if (!tween._reversed) {
              tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
            } else {
              tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
            }
          }
          tween = next;
        }
      }
      if (this._onUpdate) if (!suppressEvents) {
        this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
      }
      if (callback) if (!this._locked) if (!this._gc) if (prevStart === this._startTime || prevTimeScale !== this._timeScale) if (this._time === 0 || totalDur >= this.totalDuration()) {
        //if one of the tweens that was rendered altered this timeline's startTime (like if an onComplete reversed the timeline), it probably isn't complete. If it is, don't worry, because whatever call altered the startTime would complete if it was necessary at the new time. The only exception is the timeScale property. Also check _gc because there's a chance that kill() could be called in an onUpdate
        if (isComplete) {
          if (this._timeline.autoRemoveChildren) {
            this._enabled(false, false);
          }
          this._active = false;
        }
        if (!suppressEvents && this.vars[callback]) {
          this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
        }
      }
    };
    p.getActive = function (nested, tweens, timelines) {
      if (nested == null) {
        nested = true;
      }
      if (tweens == null) {
        tweens = true;
      }
      if (timelines == null) {
        timelines = false;
      }
      var a = [],
        all = this.getChildren(nested, tweens, timelines),
        cnt = 0,
        l = all.length,
        i,
        tween;
      for (i = 0; i < l; i++) {
        tween = all[i];
        if (tween.isActive()) {
          a[cnt++] = tween;
        }
      }
      return a;
    };
    p.getLabelAfter = function (time) {
      if (!time) if (time !== 0) {
        //faster than isNan()
        time = this._time;
      }
      var labels = this.getLabelsArray(),
        l = labels.length,
        i;
      for (i = 0; i < l; i++) {
        if (labels[i].time > time) {
          return labels[i].name;
        }
      }
      return null;
    };
    p.getLabelBefore = function (time) {
      if (time == null) {
        time = this._time;
      }
      var labels = this.getLabelsArray(),
        i = labels.length;
      while (--i > -1) {
        if (labels[i].time < time) {
          return labels[i].name;
        }
      }
      return null;
    };
    p.getLabelsArray = function () {
      var a = [],
        cnt = 0,
        p;
      for (p in this._labels) {
        a[cnt++] = {
          time: this._labels[p],
          name: p
        };
      }
      a.sort(function (a, b) {
        return a.time - b.time;
      });
      return a;
    };

    //---- GETTERS / SETTERS -------------------------------------------------------------------------------------------------------

    p.progress = function (value) {
      return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * (this._yoyo && (this._cycle & 1) !== 0 ? 1 - value : value) + this._cycle * (this._duration + this._repeatDelay), false);
    };
    p.totalProgress = function (value) {
      return !arguments.length ? this._totalTime / this.totalDuration() : this.totalTime(this.totalDuration() * value, false);
    };
    p.totalDuration = function (value) {
      if (!arguments.length) {
        if (this._dirty) {
          TimelineLite.prototype.totalDuration.call(this); //just forces refresh
          //Instead of Infinity, we use 999999999999 so that we can accommodate reverses.
          this._totalDuration = this._repeat === -1 ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat;
        }
        return this._totalDuration;
      }
      return this._repeat === -1 ? this : this.duration((value - this._repeat * this._repeatDelay) / (this._repeat + 1));
    };
    p.time = function (value, suppressEvents) {
      if (!arguments.length) {
        return this._time;
      }
      if (this._dirty) {
        this.totalDuration();
      }
      if (value > this._duration) {
        value = this._duration;
      }
      if (this._yoyo && (this._cycle & 1) !== 0) {
        value = this._duration - value + this._cycle * (this._duration + this._repeatDelay);
      } else if (this._repeat !== 0) {
        value += this._cycle * (this._duration + this._repeatDelay);
      }
      return this.totalTime(value, suppressEvents);
    };
    p.repeat = function (value) {
      if (!arguments.length) {
        return this._repeat;
      }
      this._repeat = value;
      return this._uncache(true);
    };
    p.repeatDelay = function (value) {
      if (!arguments.length) {
        return this._repeatDelay;
      }
      this._repeatDelay = value;
      return this._uncache(true);
    };
    p.yoyo = function (value) {
      if (!arguments.length) {
        return this._yoyo;
      }
      this._yoyo = value;
      return this;
    };
    p.currentLabel = function (value) {
      if (!arguments.length) {
        return this.getLabelBefore(this._time + 0.00000001);
      }
      return this.seek(value, true);
    };
    return TimelineMax;
  }, true);

  /*
   * ----------------------------------------------------------------
   * BezierPlugin
   * ----------------------------------------------------------------
   */
  (function () {
    var _RAD2DEG = 180 / Math.PI,
      _r1 = [],
      _r2 = [],
      _r3 = [],
      _corProps = {},
      Segment = function (a, b, c, d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.da = d - a;
        this.ca = c - a;
        this.ba = b - a;
      },
      _correlate = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
      cubicToQuadratic = function (a, b, c, d) {
        var q1 = {
            a: a
          },
          q2 = {},
          q3 = {},
          q4 = {
            c: d
          },
          mab = (a + b) / 2,
          mbc = (b + c) / 2,
          mcd = (c + d) / 2,
          mabc = (mab + mbc) / 2,
          mbcd = (mbc + mcd) / 2,
          m8 = (mbcd - mabc) / 8;
        q1.b = mab + (a - mab) / 4;
        q2.b = mabc + m8;
        q1.c = q2.a = (q1.b + q2.b) / 2;
        q2.c = q3.a = (mabc + mbcd) / 2;
        q3.b = mbcd - m8;
        q4.b = mcd + (d - mcd) / 4;
        q3.c = q4.a = (q3.b + q4.b) / 2;
        return [q1, q2, q3, q4];
      },
      _calculateControlPoints = function (a, curviness, quad, basic, correlate) {
        var l = a.length - 1,
          ii = 0,
          cp1 = a[0].a,
          i,
          p1,
          p2,
          p3,
          seg,
          m1,
          m2,
          mm,
          cp2,
          qb,
          r1,
          r2,
          tl;
        for (i = 0; i < l; i++) {
          seg = a[ii];
          p1 = seg.a;
          p2 = seg.d;
          p3 = a[ii + 1].d;
          if (correlate) {
            r1 = _r1[i];
            r2 = _r2[i];
            tl = (r2 + r1) * curviness * 0.25 / (basic ? 0.5 : _r3[i] || 0.5);
            m1 = p2 - (p2 - p1) * (basic ? curviness * 0.5 : r1 !== 0 ? tl / r1 : 0);
            m2 = p2 + (p3 - p2) * (basic ? curviness * 0.5 : r2 !== 0 ? tl / r2 : 0);
            mm = p2 - (m1 + ((m2 - m1) * (r1 * 3 / (r1 + r2) + 0.5) / 4 || 0));
          } else {
            m1 = p2 - (p2 - p1) * curviness * 0.5;
            m2 = p2 + (p3 - p2) * curviness * 0.5;
            mm = p2 - (m1 + m2) / 2;
          }
          m1 += mm;
          m2 += mm;
          seg.c = cp2 = m1;
          if (i !== 0) {
            seg.b = cp1;
          } else {
            seg.b = cp1 = seg.a + (seg.c - seg.a) * 0.6; //instead of placing b on a exactly, we move it inline with c so that if the user specifies an ease like Back.easeIn or Elastic.easeIn which goes BEYOND the beginning, it will do so smoothly.
          }
          seg.da = p2 - p1;
          seg.ca = cp2 - p1;
          seg.ba = cp1 - p1;
          if (quad) {
            qb = cubicToQuadratic(p1, cp1, cp2, p2);
            a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
            ii += 4;
          } else {
            ii++;
          }
          cp1 = m2;
        }
        seg = a[ii];
        seg.b = cp1;
        seg.c = cp1 + (seg.d - cp1) * 0.4; //instead of placing c on d exactly, we move it inline with b so that if the user specifies an ease like Back.easeOut or Elastic.easeOut which goes BEYOND the end, it will do so smoothly.
        seg.da = seg.d - seg.a;
        seg.ca = seg.c - seg.a;
        seg.ba = cp1 - seg.a;
        if (quad) {
          qb = cubicToQuadratic(seg.a, cp1, seg.c, seg.d);
          a.splice(ii, 1, qb[0], qb[1], qb[2], qb[3]);
        }
      },
      _parseAnchors = function (values, p, correlate, prepend) {
        var a = [],
          l,
          i,
          p1,
          p2,
          p3,
          tmp;
        if (prepend) {
          values = [prepend].concat(values);
          i = values.length;
          while (--i > -1) {
            if (typeof (tmp = values[i][p]) === "string") if (tmp.charAt(1) === "=") {
              values[i][p] = prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)); //accommodate relative values. Do it inline instead of breaking it out into a function for speed reasons
            }
          }
        }
        l = values.length - 2;
        if (l < 0) {
          a[0] = new Segment(values[0][p], 0, 0, values[l < -1 ? 0 : 1][p]);
          return a;
        }
        for (i = 0; i < l; i++) {
          p1 = values[i][p];
          p2 = values[i + 1][p];
          a[i] = new Segment(p1, 0, 0, p2);
          if (correlate) {
            p3 = values[i + 2][p];
            _r1[i] = (_r1[i] || 0) + (p2 - p1) * (p2 - p1);
            _r2[i] = (_r2[i] || 0) + (p3 - p2) * (p3 - p2);
          }
        }
        a[i] = new Segment(values[i][p], 0, 0, values[i + 1][p]);
        return a;
      },
      bezierThrough = function (values, curviness, quadratic, basic, correlate, prepend) {
        var obj = {},
          props = [],
          first = prepend || values[0],
          i,
          p,
          a,
          j,
          r,
          l,
          seamless,
          last;
        correlate = typeof correlate === "string" ? "," + correlate + "," : _correlate;
        if (curviness == null) {
          curviness = 1;
        }
        for (p in values[0]) {
          props.push(p);
        }
        //check to see if the last and first values are identical (well, within 0.05). If so, make seamless by appending the second element to the very end of the values array and the 2nd-to-last element to the very beginning (we'll remove those segments later)
        if (values.length > 1) {
          last = values[values.length - 1];
          seamless = true;
          i = props.length;
          while (--i > -1) {
            p = props[i];
            if (Math.abs(first[p] - last[p]) > 0.05) {
              //build in a tolerance of +/-0.05 to accommodate rounding errors. For example, if you set an object's position to 4.945, Flash will make it 4.9
              seamless = false;
              break;
            }
          }
          if (seamless) {
            values = values.concat(); //duplicate the array to avoid contaminating the original which the user may be reusing for other tweens
            if (prepend) {
              values.unshift(prepend);
            }
            values.push(values[1]);
            prepend = values[values.length - 3];
          }
        }
        _r1.length = _r2.length = _r3.length = 0;
        i = props.length;
        while (--i > -1) {
          p = props[i];
          _corProps[p] = correlate.indexOf("," + p + ",") !== -1;
          obj[p] = _parseAnchors(values, p, _corProps[p], prepend);
        }
        i = _r1.length;
        while (--i > -1) {
          _r1[i] = Math.sqrt(_r1[i]);
          _r2[i] = Math.sqrt(_r2[i]);
        }
        if (!basic) {
          i = props.length;
          while (--i > -1) {
            if (_corProps[p]) {
              a = obj[props[i]];
              l = a.length - 1;
              for (j = 0; j < l; j++) {
                r = a[j + 1].da / _r2[j] + a[j].da / _r1[j];
                _r3[j] = (_r3[j] || 0) + r * r;
              }
            }
          }
          i = _r3.length;
          while (--i > -1) {
            _r3[i] = Math.sqrt(_r3[i]);
          }
        }
        i = props.length;
        j = quadratic ? 4 : 1;
        while (--i > -1) {
          p = props[i];
          a = obj[p];
          _calculateControlPoints(a, curviness, quadratic, basic, _corProps[p]); //this method requires that _parseAnchors() and _setSegmentRatios() ran first so that _r1, _r2, and _r3 values are populated for all properties
          if (seamless) {
            a.splice(0, j);
            a.splice(a.length - j, j);
          }
        }
        return obj;
      },
      _parseBezierData = function (values, type, prepend) {
        type = type || "soft";
        var obj = {},
          inc = type === "cubic" ? 3 : 2,
          soft = type === "soft",
          props = [],
          a,
          b,
          c,
          d,
          cur,
          i,
          j,
          l,
          p,
          cnt,
          tmp;
        if (soft && prepend) {
          values = [prepend].concat(values);
        }
        if (values == null || values.length < inc + 1) {
          throw "invalid Bezier data";
        }
        for (p in values[0]) {
          props.push(p);
        }
        i = props.length;
        while (--i > -1) {
          p = props[i];
          obj[p] = cur = [];
          cnt = 0;
          l = values.length;
          for (j = 0; j < l; j++) {
            a = prepend == null ? values[j][p] : typeof (tmp = values[j][p]) === "string" && tmp.charAt(1) === "=" ? prepend[p] + Number(tmp.charAt(0) + tmp.substr(2)) : Number(tmp);
            if (soft) if (j > 1) if (j < l - 1) {
              cur[cnt++] = (a + cur[cnt - 2]) / 2;
            }
            cur[cnt++] = a;
          }
          l = cnt - inc + 1;
          cnt = 0;
          for (j = 0; j < l; j += inc) {
            a = cur[j];
            b = cur[j + 1];
            c = cur[j + 2];
            d = inc === 2 ? 0 : cur[j + 3];
            cur[cnt++] = tmp = inc === 3 ? new Segment(a, b, c, d) : new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
          }
          cur.length = cnt;
        }
        return obj;
      },
      _addCubicLengths = function (a, steps, resolution) {
        var inc = 1 / resolution,
          j = a.length,
          d,
          d1,
          s,
          da,
          ca,
          ba,
          p,
          i,
          inv,
          bez,
          index;
        while (--j > -1) {
          bez = a[j];
          s = bez.a;
          da = bez.d - s;
          ca = bez.c - s;
          ba = bez.b - s;
          d = d1 = 0;
          for (i = 1; i <= resolution; i++) {
            p = inc * i;
            inv = 1 - p;
            d = d1 - (d1 = (p * p * da + 3 * inv * (p * ca + inv * ba)) * p);
            index = j * resolution + i - 1;
            steps[index] = (steps[index] || 0) + d * d;
          }
        }
      },
      _parseLengthData = function (obj, resolution) {
        resolution = resolution >> 0 || 6;
        var a = [],
          lengths = [],
          d = 0,
          total = 0,
          threshold = resolution - 1,
          segments = [],
          curLS = [],
          //current length segments array
          p,
          i,
          l,
          index;
        for (p in obj) {
          _addCubicLengths(obj[p], a, resolution);
        }
        l = a.length;
        for (i = 0; i < l; i++) {
          d += Math.sqrt(a[i]);
          index = i % resolution;
          curLS[index] = d;
          if (index === threshold) {
            total += d;
            index = i / resolution >> 0;
            segments[index] = curLS;
            lengths[index] = total;
            d = 0;
            curLS = [];
          }
        }
        return {
          length: total,
          lengths: lengths,
          segments: segments
        };
      },
      BezierPlugin = window._gsDefine.plugin({
        propName: "bezier",
        priority: -1,
        API: 2,
        global: true,
        //gets called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
        init: function (target, vars, tween) {
          this._target = target;
          if (vars instanceof Array) {
            vars = {
              values: vars
            };
          }
          this._func = {};
          this._round = {};
          this._props = [];
          this._timeRes = vars.timeResolution == null ? 6 : parseInt(vars.timeResolution, 10);
          var values = vars.values || [],
            first = {},
            second = values[0],
            autoRotate = vars.autoRotate || tween.vars.orientToBezier,
            p,
            isFunc,
            i,
            j,
            prepend;
          this._autoRotate = autoRotate ? autoRotate instanceof Array ? autoRotate : [["x", "y", "rotation", autoRotate === true ? 0 : Number(autoRotate) || 0]] : null;
          for (p in second) {
            this._props.push(p);
          }
          i = this._props.length;
          while (--i > -1) {
            p = this._props[i];
            this._overwriteProps.push(p);
            isFunc = this._func[p] = typeof target[p] === "function";
            first[p] = !isFunc ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
            if (!prepend) if (first[p] !== values[0][p]) {
              prepend = first;
            }
          }
          this._beziers = vars.type !== "cubic" && vars.type !== "quadratic" && vars.type !== "soft" ? bezierThrough(values, isNaN(vars.curviness) ? 1 : vars.curviness, false, vars.type === "thruBasic", vars.correlate, prepend) : _parseBezierData(values, vars.type, first);
          this._segCount = this._beziers[p].length;
          if (this._timeRes) {
            var ld = _parseLengthData(this._beziers, this._timeRes);
            this._length = ld.length;
            this._lengths = ld.lengths;
            this._segments = ld.segments;
            this._l1 = this._li = this._s1 = this._si = 0;
            this._l2 = this._lengths[0];
            this._curSeg = this._segments[0];
            this._s2 = this._curSeg[0];
            this._prec = 1 / this._curSeg.length;
          }
          if (autoRotate = this._autoRotate) {
            if (!(autoRotate[0] instanceof Array)) {
              this._autoRotate = autoRotate = [autoRotate];
            }
            i = autoRotate.length;
            while (--i > -1) {
              for (j = 0; j < 3; j++) {
                p = autoRotate[i][j];
                this._func[p] = typeof target[p] === "function" ? target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)] : false;
              }
            }
          }
          return true;
        },
        //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
        set: function (v) {
          var segments = this._segCount,
            func = this._func,
            target = this._target,
            curIndex,
            inv,
            i,
            p,
            b,
            t,
            val,
            l,
            lengths,
            curSeg;
          if (!this._timeRes) {
            curIndex = v < 0 ? 0 : v >= 1 ? segments - 1 : segments * v >> 0;
            t = (v - curIndex * (1 / segments)) * segments;
          } else {
            lengths = this._lengths;
            curSeg = this._curSeg;
            v *= this._length;
            i = this._li;
            //find the appropriate segment (if the currently cached one isn't correct)
            if (v > this._l2 && i < segments - 1) {
              l = segments - 1;
              while (i < l && (this._l2 = lengths[++i]) <= v) {}
              this._l1 = lengths[i - 1];
              this._li = i;
              this._curSeg = curSeg = this._segments[i];
              this._s2 = curSeg[this._s1 = this._si = 0];
            } else if (v < this._l1 && i > 0) {
              while (i > 0 && (this._l1 = lengths[--i]) >= v) {}
              if (i === 0 && v < this._l1) {
                this._l1 = 0;
              } else {
                i++;
              }
              this._l2 = lengths[i];
              this._li = i;
              this._curSeg = curSeg = this._segments[i];
              this._s1 = curSeg[(this._si = curSeg.length - 1) - 1] || 0;
              this._s2 = curSeg[this._si];
            }
            curIndex = i;
            //now find the appropriate sub-segment (we split it into the number of pieces that was defined by "precision" and measured each one)
            v -= this._l1;
            i = this._si;
            if (v > this._s2 && i < curSeg.length - 1) {
              l = curSeg.length - 1;
              while (i < l && (this._s2 = curSeg[++i]) <= v) {}
              this._s1 = curSeg[i - 1];
              this._si = i;
            } else if (v < this._s1 && i > 0) {
              while (i > 0 && (this._s1 = curSeg[--i]) >= v) {}
              if (i === 0 && v < this._s1) {
                this._s1 = 0;
              } else {
                i++;
              }
              this._s2 = curSeg[i];
              this._si = i;
            }
            t = (i + (v - this._s1) / (this._s2 - this._s1)) * this._prec;
          }
          inv = 1 - t;
          i = this._props.length;
          while (--i > -1) {
            p = this._props[i];
            b = this._beziers[p][curIndex];
            val = (t * t * b.da + 3 * inv * (t * b.ca + inv * b.ba)) * t + b.a;
            if (this._round[p]) {
              val = val + (val > 0 ? 0.5 : -0.5) >> 0;
            }
            if (func[p]) {
              target[p](val);
            } else {
              target[p] = val;
            }
          }
          if (this._autoRotate) {
            var ar = this._autoRotate,
              b2,
              x1,
              y1,
              x2,
              y2,
              add,
              conv;
            i = ar.length;
            while (--i > -1) {
              p = ar[i][2];
              add = ar[i][3] || 0;
              conv = ar[i][4] === true ? 1 : _RAD2DEG;
              b = this._beziers[ar[i][0]];
              b2 = this._beziers[ar[i][1]];
              if (b && b2) {
                //in case one of the properties got overwritten.
                b = b[curIndex];
                b2 = b2[curIndex];
                x1 = b.a + (b.b - b.a) * t;
                x2 = b.b + (b.c - b.b) * t;
                x1 += (x2 - x1) * t;
                x2 += (b.c + (b.d - b.c) * t - x2) * t;
                y1 = b2.a + (b2.b - b2.a) * t;
                y2 = b2.b + (b2.c - b2.b) * t;
                y1 += (y2 - y1) * t;
                y2 += (b2.c + (b2.d - b2.c) * t - y2) * t;
                val = Math.atan2(y2 - y1, x2 - x1) * conv + add;
                if (func[p]) {
                  target[p](val);
                } else {
                  target[p] = val;
                }
              }
            }
          }
        }
      }),
      p = BezierPlugin.prototype;
    BezierPlugin.bezierThrough = bezierThrough;
    BezierPlugin.cubicToQuadratic = cubicToQuadratic;
    BezierPlugin._autoCSS = true; //indicates that this plugin can be inserted into the "css" object using the autoCSS feature of TweenLite
    BezierPlugin.quadraticToCubic = function (a, b, c) {
      return new Segment(a, (2 * b + a) / 3, (2 * b + c) / 3, c);
    };
    BezierPlugin._cssRegister = function () {
      var CSSPlugin = window._gsDefine.globals.CSSPlugin;
      if (!CSSPlugin) {
        return;
      }
      var _internals = CSSPlugin._internals,
        _parseToProxy = _internals._parseToProxy,
        _setPluginRatio = _internals._setPluginRatio,
        CSSPropTween = _internals.CSSPropTween;
      _internals._registerComplexSpecialProp("bezier", {
        parser: function (t, e, prop, cssp, pt, plugin) {
          if (e instanceof Array) {
            e = {
              values: e
            };
          }
          plugin = new BezierPlugin();
          var values = e.values,
            l = values.length - 1,
            pluginValues = [],
            v = {},
            i,
            p,
            data;
          if (l < 0) {
            return pt;
          }
          for (i = 0; i <= l; i++) {
            data = _parseToProxy(t, values[i], cssp, pt, plugin, l !== i);
            pluginValues[i] = data.end;
          }
          for (p in e) {
            v[p] = e[p]; //duplicate the vars object because we need to alter some things which would cause problems if the user plans to reuse the same vars object for another tween.
          }
          v.values = pluginValues;
          pt = new CSSPropTween(t, "bezier", 0, 0, data.pt, 2);
          pt.data = data;
          pt.plugin = plugin;
          pt.setRatio = _setPluginRatio;
          if (v.autoRotate === 0) {
            v.autoRotate = true;
          }
          if (v.autoRotate && !(v.autoRotate instanceof Array)) {
            i = v.autoRotate === true ? 0 : Number(v.autoRotate);
            v.autoRotate = data.end.left != null ? [["left", "top", "rotation", i, false]] : data.end.x != null ? [["x", "y", "rotation", i, false]] : false;
          }
          if (v.autoRotate) {
            if (!cssp._transform) {
              cssp._enableTransforms(false);
            }
            data.autoRotate = cssp._target._gsTransform;
          }
          plugin._onInitTween(data.proxy, v, cssp._tween);
          return pt;
        }
      });
    };
    p._roundProps = function (lookup, value) {
      var op = this._overwriteProps,
        i = op.length;
      while (--i > -1) {
        if (lookup[op[i]] || lookup.bezier || lookup.bezierThrough) {
          this._round[op[i]] = value;
        }
      }
    };
    p._kill = function (lookup) {
      var a = this._props,
        p,
        i;
      for (p in this._beziers) {
        if (p in lookup) {
          delete this._beziers[p];
          delete this._func[p];
          i = a.length;
          while (--i > -1) {
            if (a[i] === p) {
              a.splice(i, 1);
            }
          }
        }
      }
      return this._super._kill.call(this, lookup);
    };
  })();

  /*
   * ----------------------------------------------------------------
   * CSSPlugin
   * ----------------------------------------------------------------
   */
  window._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (TweenPlugin, TweenLite) {
    /** @constructor **/
    var CSSPlugin = function () {
        TweenPlugin.call(this, "css");
        this._overwriteProps.length = 0;
        this.setRatio = CSSPlugin.prototype.setRatio; //speed optimization (avoid prototype lookup on this "hot" method)
      },
      _hasPriority,
      //turns true whenever a CSSPropTween instance is created that has a priority other than 0. This helps us discern whether or not we should spend the time organizing the linked list or not after a CSSPlugin's _onInitTween() method is called.
      _suffixMap,
      //we set this in _onInitTween() each time as a way to have a persistent variable we can use in other methods like _parse() without having to pass it around as a parameter and we keep _parse() decoupled from a particular CSSPlugin instance
      _cs,
      //computed style (we store this in a shared variable to conserve memory and make minification tighter
      _overwriteProps,
      //alias to the currently instantiating CSSPlugin's _overwriteProps array. We use this closure in order to avoid having to pass a reference around from method to method and aid in minification.
      _specialProps = {},
      p = CSSPlugin.prototype = new TweenPlugin("css");
    p.constructor = CSSPlugin;
    CSSPlugin.version = "1.11.2";
    CSSPlugin.API = 2;
    CSSPlugin.defaultTransformPerspective = 0;
    p = "px"; //we'll reuse the "p" variable to keep file size down
    CSSPlugin.suffixMap = {
      top: p,
      right: p,
      bottom: p,
      left: p,
      width: p,
      height: p,
      fontSize: p,
      padding: p,
      margin: p,
      perspective: p
    };
    var _numExp = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
      _relNumExp = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
      _valuesExp = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
      //finds all the values that begin with numbers or += or -= and then a number. Includes suffixes. We use this to split complex values apart like "1px 5px 20px rgb(255,102,51)"
      _NaNExp = /[^\d\-\.]/g,
      _suffixExp = /(?:\d|\-|\+|=|#|\.)*/g,
      _opacityExp = /opacity *= *([^)]*)/,
      _opacityValExp = /opacity:([^;]*)/,
      _alphaFilterExp = /alpha\(opacity *=.+?\)/i,
      _rgbhslExp = /^(rgb|hsl)/,
      _capsExp = /([A-Z])/g,
      _camelExp = /-([a-z])/gi,
      _urlExp = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
      //for pulling out urls from url(...) or url("...") strings (some browsers wrap urls in quotes, some don't when reporting things like backgroundImage)
      _camelFunc = function (s, g) {
        return g.toUpperCase();
      },
      _horizExp = /(?:Left|Right|Width)/i,
      _ieGetMatrixExp = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
      _ieSetMatrixExp = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
      _commasOutsideParenExp = /,(?=[^\)]*(?:\(|$))/gi,
      //finds any commas that are not within parenthesis
      _DEG2RAD = Math.PI / 180,
      _RAD2DEG = 180 / Math.PI,
      _forcePT = {},
      _doc = document,
      _tempDiv = _doc.createElement("div"),
      _tempImg = _doc.createElement("img"),
      _internals = CSSPlugin._internals = {
        _specialProps: _specialProps
      },
      //provides a hook to a few internal methods that we need to access from inside other plugins
      _agent = navigator.userAgent,
      _autoRound,
      _reqSafariFix,
      //we won't apply the Safari transform fix until we actually come across a tween that affects a transform property (to maintain best performance).

      _isSafari,
      _isFirefox,
      //Firefox has a bug that causes 3D transformed elements to randomly disappear unless a repaint is forced after each update on each element.
      _isSafariLT6,
      //Safari (and Android 4 which uses a flavor of Safari) has a bug that prevents changes to "top" and "left" properties from rendering properly if changed on the same frame as a transform UNLESS we set the element's WebkitBackfaceVisibility to hidden (weird, I know). Doing this for Android 3 and earlier seems to actually cause other problems, though (fun!)
      _ieVers,
      _supportsOpacity = function () {
        //we set _isSafari, _ieVers, _isFirefox, and _supportsOpacity all in one function here to reduce file size slightly, especially in the minified version.
        var i = _agent.indexOf("Android"),
          d = _doc.createElement("div"),
          a;
        _isSafari = _agent.indexOf("Safari") !== -1 && _agent.indexOf("Chrome") === -1 && (i === -1 || Number(_agent.substr(i + 8, 1)) > 3);
        _isSafariLT6 = _isSafari && Number(_agent.substr(_agent.indexOf("Version/") + 8, 1)) < 6;
        _isFirefox = _agent.indexOf("Firefox") !== -1;
        if (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(_agent)) {
          _ieVers = parseFloat(RegExp.$1);
        }
        d.innerHTML = tweenMaxPolicy.createHTML("<a style='top:1px;opacity:.55;'>a</a>");
        a = d.getElementsByTagName("a")[0];
        return a ? /^0.55/.test(a.style.opacity) : false;
      }(),
      _getIEOpacity = function (v) {
        return _opacityExp.test(typeof v === "string" ? v : (v.currentStyle ? v.currentStyle.filter : v.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1;
      },
      _log = function (s) {
        //for logging messages, but in a way that won't throw errors in old versions of IE.
        if (window.console) {
          console.log(s);
        }
      },
      _prefixCSS = "",
      //the non-camelCase vendor prefix like "-o-", "-moz-", "-ms-", or "-webkit-"
      _prefix = "",
      //camelCase vendor prefix like "O", "ms", "Webkit", or "Moz".

      //@private feed in a camelCase property name like "transform" and it will check to see if it is valid as-is or if it needs a vendor prefix. It returns the corrected camelCase property name (i.e. "WebkitTransform" or "MozTransform" or "transform" or null if no such property is found, like if the browser is IE8 or before, "transform" won't be found at all)
      _checkPropPrefix = function (p, e) {
        e = e || _tempDiv;
        var s = e.style,
          a,
          i;
        if (s[p] !== undefined) {
          return p;
        }
        p = p.charAt(0).toUpperCase() + p.substr(1);
        a = ["O", "Moz", "ms", "Ms", "Webkit"];
        i = 5;
        while (--i > -1 && s[a[i] + p] === undefined) {}
        if (i >= 0) {
          _prefix = i === 3 ? "ms" : a[i];
          _prefixCSS = "-" + _prefix.toLowerCase() + "-";
          return _prefix + p;
        }
        return null;
      },
      _getComputedStyle = _doc.defaultView ? _doc.defaultView.getComputedStyle : function () {},
      /**
       * @private Returns the css style for a particular property of an element. For example, to get whatever the current "left" css value for an element with an ID of "myElement", you could do:
       * var currentLeft = CSSPlugin.getStyle( document.getElementById("myElement"), "left");
       *
       * @param {!Object} t Target element whose style property you want to query
       * @param {!string} p Property name (like "left" or "top" or "marginTop", etc.)
       * @param {Object=} cs Computed style object. This just provides a way to speed processing if you're going to get several properties on the same element in quick succession - you can reuse the result of the getComputedStyle() call.
       * @param {boolean=} calc If true, the value will not be read directly from the element's "style" property (if it exists there), but instead the getComputedStyle() result will be used. This can be useful when you want to ensure that the browser itself is interpreting the value.
       * @param {string=} dflt Default value that should be returned in the place of null, "none", "auto" or "auto auto".
       * @return {?string} The current property value
       */
      _getStyle = CSSPlugin.getStyle = function (t, p, cs, calc, dflt) {
        var rv;
        if (!_supportsOpacity) if (p === "opacity") {
          //several versions of IE don't use the standard "opacity" property - they use things like filter:alpha(opacity=50), so we parse that here.
          return _getIEOpacity(t);
        }
        if (!calc && t.style[p]) {
          rv = t.style[p];
        } else if (cs = cs || _getComputedStyle(t, null)) {
          t = cs.getPropertyValue(p.replace(_capsExp, "-$1").toLowerCase());
          rv = t || cs.length ? t : cs[p]; //Opera behaves VERY strangely - length is usually 0 and cs[p] is the only way to get accurate results EXCEPT when checking for -o-transform which only works with cs.getPropertyValue()!
        } else if (t.currentStyle) {
          rv = t.currentStyle[p];
        }
        return dflt != null && (!rv || rv === "none" || rv === "auto" || rv === "auto auto") ? dflt : rv;
      },
      /**
       * @private Pass the target element, the property name, the numeric value, and the suffix (like "%", "em", "px", etc.) and it will spit back the equivalent pixel number.
       * @param {!Object} t Target element
       * @param {!string} p Property name (like "left", "top", "marginLeft", etc.)
       * @param {!number} v Value
       * @param {string=} sfx Suffix (like "px" or "%" or "em")
       * @param {boolean=} recurse If true, the call is a recursive one. In some browsers (like IE7/8), occasionally the value isn't accurately reported initially, but if we run the function again it will take effect.
       * @return {number} value in pixels
       */
      _convertToPixels = function (t, p, v, sfx, recurse) {
        if (sfx === "px" || !sfx) {
          return v;
        }
        if (sfx === "auto" || !v) {
          return 0;
        }
        var horiz = _horizExp.test(p),
          node = t,
          style = _tempDiv.style,
          neg = v < 0,
          pix;
        if (neg) {
          v = -v;
        }
        if (sfx === "%" && p.indexOf("border") !== -1) {
          pix = v / 100 * (horiz ? t.clientWidth : t.clientHeight);
        } else {
          style.cssText = "border:0 solid red;position:" + _getStyle(t, "position") + ";line-height:0;";
          if (sfx === "%" || !node.appendChild) {
            node = t.parentNode || _doc.body;
            style[horiz ? "width" : "height"] = v + sfx;
          } else {
            style[horiz ? "borderLeftWidth" : "borderTopWidth"] = v + sfx;
          }
          node.appendChild(_tempDiv);
          pix = parseFloat(_tempDiv[horiz ? "offsetWidth" : "offsetHeight"]);
          node.removeChild(_tempDiv);
          if (pix === 0 && !recurse) {
            pix = _convertToPixels(t, p, v, sfx, true);
          }
        }
        return neg ? -pix : pix;
      },
      _calculateOffset = function (t, p, cs) {
        //for figuring out "top" or "left" in px when it's "auto". We need to factor in margin with the offsetLeft/offsetTop
        if (_getStyle(t, "position", cs) !== "absolute") {
          return 0;
        }
        var dim = p === "left" ? "Left" : "Top",
          v = _getStyle(t, "margin" + dim, cs);
        return t["offset" + dim] - (_convertToPixels(t, p, parseFloat(v), v.replace(_suffixExp, "")) || 0);
      },
      //@private returns at object containing ALL of the style properties in camelCase and their associated values.
      _getAllStyles = function (t, cs) {
        var s = {},
          i,
          tr;
        if (cs = cs || _getComputedStyle(t, null)) {
          if (i = cs.length) {
            while (--i > -1) {
              s[cs[i].replace(_camelExp, _camelFunc)] = cs.getPropertyValue(cs[i]);
            }
          } else {
            //Opera behaves differently - cs.length is always 0, so we must do a for...in loop.
            for (i in cs) {
              s[i] = cs[i];
            }
          }
        } else if (cs = t.currentStyle || t.style) {
          for (i in cs) {
            if (typeof i === "string" && s[i] !== undefined) {
              s[i.replace(_camelExp, _camelFunc)] = cs[i];
            }
          }
        }
        if (!_supportsOpacity) {
          s.opacity = _getIEOpacity(t);
        }
        tr = _getTransform(t, cs, false);
        s.rotation = tr.rotation;
        s.skewX = tr.skewX;
        s.scaleX = tr.scaleX;
        s.scaleY = tr.scaleY;
        s.x = tr.x;
        s.y = tr.y;
        if (_supports3D) {
          s.z = tr.z;
          s.rotationX = tr.rotationX;
          s.rotationY = tr.rotationY;
          s.scaleZ = tr.scaleZ;
        }
        if (s.filters) {
          delete s.filters;
        }
        return s;
      },
      //@private analyzes two style objects (as returned by _getAllStyles()) and only looks for differences between them that contain tweenable values (like a number or color). It returns an object with a "difs" property which refers to an object containing only those isolated properties and values for tweening, and a "firstMPT" property which refers to the first MiniPropTween instance in a linked list that recorded all the starting values of the different properties so that we can revert to them at the end or beginning of the tween - we don't want the cascading to get messed up. The forceLookup parameter is an optional generic object with properties that should be forced into the results - this is necessary for className tweens that are overwriting others because imagine a scenario where a rollover/rollout adds/removes a class and the user swipes the mouse over the target SUPER fast, thus nothing actually changed yet and the subsequent comparison of the properties would indicate they match (especially when px rounding is taken into consideration), thus no tweening is necessary even though it SHOULD tween and remove those properties after the tween (otherwise the inline styles will contaminate things). See the className SpecialProp code for details.
      _cssDif = function (t, s1, s2, vars, forceLookup) {
        var difs = {},
          style = t.style,
          val,
          p,
          mpt;
        for (p in s2) {
          if (p !== "cssText") if (p !== "length") if (isNaN(p)) if (s1[p] !== (val = s2[p]) || forceLookup && forceLookup[p]) if (p.indexOf("Origin") === -1) if (typeof val === "number" || typeof val === "string") {
            difs[p] = val === "auto" && (p === "left" || p === "top") ? _calculateOffset(t, p) : (val === "" || val === "auto" || val === "none") && typeof s1[p] === "string" && s1[p].replace(_NaNExp, "") !== "" ? 0 : val; //if the ending value is defaulting ("" or "auto"), we check the starting value and if it can be parsed into a number (a string which could have a suffix too, like 700px), then we swap in 0 for "" or "auto" so that things actually tween.
            if (style[p] !== undefined) {
              //for className tweens, we must remember which properties already existed inline - the ones that didn't should be removed when the tween isn't in progress because they were only introduced to facilitate the transition between classes.
              mpt = new MiniPropTween(style, p, style[p], mpt);
            }
          }
        }
        if (vars) {
          for (p in vars) {
            //copy properties (except className)
            if (p !== "className") {
              difs[p] = vars[p];
            }
          }
        }
        return {
          difs: difs,
          firstMPT: mpt
        };
      },
      _dimensions = {
        width: ["Left", "Right"],
        height: ["Top", "Bottom"]
      },
      _margins = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
      /**
       * @private Gets the width or height of an element
       * @param {!Object} t Target element
       * @param {!string} p Property name ("width" or "height")
       * @param {Object=} cs Computed style object (if one exists). Just a speed optimization.
       * @return {number} Dimension (in pixels)
       */
      _getDimension = function (t, p, cs) {
        var v = parseFloat(p === "width" ? t.offsetWidth : t.offsetHeight),
          a = _dimensions[p],
          i = a.length;
        cs = cs || _getComputedStyle(t, null);
        while (--i > -1) {
          v -= parseFloat(_getStyle(t, "padding" + a[i], cs, true)) || 0;
          v -= parseFloat(_getStyle(t, "border" + a[i] + "Width", cs, true)) || 0;
        }
        return v;
      },
      //@private Parses position-related complex strings like "top left" or "50px 10px" or "70% 20%", etc. which are used for things like transformOrigin or backgroundPosition. Optionally decorates a supplied object (recObj) with the following properties: "ox" (offsetX), "oy" (offsetY), "oxp" (if true, "ox" is a percentage not a pixel value), and "oxy" (if true, "oy" is a percentage not a pixel value)
      _parsePosition = function (v, recObj) {
        if (v == null || v === "" || v === "auto" || v === "auto auto") {
          //note: Firefox uses "auto auto" as default whereas Chrome uses "auto".
          v = "0 0";
        }
        var a = v.split(" "),
          x = v.indexOf("left") !== -1 ? "0%" : v.indexOf("right") !== -1 ? "100%" : a[0],
          y = v.indexOf("top") !== -1 ? "0%" : v.indexOf("bottom") !== -1 ? "100%" : a[1];
        if (y == null) {
          y = "0";
        } else if (y === "center") {
          y = "50%";
        }
        if (x === "center" || isNaN(parseFloat(x)) && (x + "").indexOf("=") === -1) {
          //remember, the user could flip-flop the values and say "bottom center" or "center bottom", etc. "center" is ambiguous because it could be used to describe horizontal or vertical, hence the isNaN(). If there's an "=" sign in the value, it's relative.
          x = "50%";
        }
        if (recObj) {
          recObj.oxp = x.indexOf("%") !== -1;
          recObj.oyp = y.indexOf("%") !== -1;
          recObj.oxr = x.charAt(1) === "=";
          recObj.oyr = y.charAt(1) === "=";
          recObj.ox = parseFloat(x.replace(_NaNExp, ""));
          recObj.oy = parseFloat(y.replace(_NaNExp, ""));
        }
        return x + " " + y + (a.length > 2 ? " " + a[2] : "");
      },
      /**
       * @private Takes an ending value (typically a string, but can be a number) and a starting value and returns the change between the two, looking for relative value indicators like += and -= and it also ignores suffixes (but make sure the ending value starts with a number or +=/-= and that the starting value is a NUMBER!)
       * @param {(number|string)} e End value which is typically a string, but could be a number
       * @param {(number|string)} b Beginning value which is typically a string but could be a number
       * @return {number} Amount of change between the beginning and ending values (relative values that have a "+=" or "-=" are recognized)
       */
      _parseChange = function (e, b) {
        return typeof e === "string" && e.charAt(1) === "=" ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(b);
      },
      /**
       * @private Takes a value and a default number, checks if the value is relative, null, or numeric and spits back a normalized number accordingly. Primarily used in the _parseTransform() function.
       * @param {Object} v Value to be parsed
       * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
       * @return {number} Parsed value
       */
      _parseVal = function (v, d) {
        return v == null ? d : typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) + d : parseFloat(v);
      },
      /**
       * @private Translates strings like "40deg" or "40" or 40rad" or "+=40deg" or "270_short" or "-90_cw" or "+=45_ccw" to a numeric radian angle. Of course a starting/default value must be fed in too so that relative values can be calculated properly.
       * @param {Object} v Value to be parsed
       * @param {!number} d Default value (which is also used for relative calculations if "+=" or "-=" is found in the first parameter)
       * @param {string=} p property name for directionalEnd (optional - only used when the parsed value is directional ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation). Property name would be "rotation", "rotationX", or "rotationY"
       * @param {Object=} directionalEnd An object that will store the raw end values for directional angles ("_short", "_cw", or "_ccw" suffix). We need a way to store the uncompensated value so that at the end of the tween, we set it to exactly what was requested with no directional compensation.
       * @return {number} parsed angle in radians
       */
      _parseAngle = function (v, d, p, directionalEnd) {
        var min = 0.000001,
          cap,
          split,
          dif,
          result;
        if (v == null) {
          result = d;
        } else if (typeof v === "number") {
          result = v;
        } else {
          cap = 360;
          split = v.split("_");
          dif = Number(split[0].replace(_NaNExp, "")) * (v.indexOf("rad") === -1 ? 1 : _RAD2DEG) - (v.charAt(1) === "=" ? 0 : d);
          if (split.length) {
            if (directionalEnd) {
              directionalEnd[p] = d + dif;
            }
            if (v.indexOf("short") !== -1) {
              dif = dif % cap;
              if (dif !== dif % (cap / 2)) {
                dif = dif < 0 ? dif + cap : dif - cap;
              }
            }
            if (v.indexOf("_cw") !== -1 && dif < 0) {
              dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
            } else if (v.indexOf("ccw") !== -1 && dif > 0) {
              dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
            }
          }
          result = d + dif;
        }
        if (result < min && result > -min) {
          result = 0;
        }
        return result;
      },
      _colorLookup = {
        aqua: [0, 255, 255],
        lime: [0, 255, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, 255],
        navy: [0, 0, 128],
        white: [255, 255, 255],
        fuchsia: [255, 0, 255],
        olive: [128, 128, 0],
        yellow: [255, 255, 0],
        orange: [255, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [255, 0, 0],
        pink: [255, 192, 203],
        cyan: [0, 255, 255],
        transparent: [255, 255, 255, 0]
      },
      _hue = function (h, m1, m2) {
        h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
        return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < 0.5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * 255 + 0.5 | 0;
      },
      /**
       * @private Parses a color (like #9F0, #FF9900, or rgb(255,51,153)) into an array with 3 elements for red, green, and blue. Also handles rgba() values (splits into array of 4 elements of course)
       * @param {(string|number)} v The value the should be parsed which could be a string like #9F0 or rgb(255,102,51) or rgba(255,0,0,0.5) or it could be a number like 0xFF00CC or even a named color like red, blue, purple, etc.
       * @return {Array.<number>} An array containing red, green, and blue (and optionally alpha) in that order.
       */
      _parseColor = function (v) {
        var c1, c2, c3, h, s, l;
        if (!v || v === "") {
          return _colorLookup.black;
        }
        if (typeof v === "number") {
          return [v >> 16, v >> 8 & 255, v & 255];
        }
        if (v.charAt(v.length - 1) === ",") {
          //sometimes a trailing commma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
          v = v.substr(0, v.length - 1);
        }
        if (_colorLookup[v]) {
          return _colorLookup[v];
        }
        if (v.charAt(0) === "#") {
          if (v.length === 4) {
            //for shorthand like #9F0
            c1 = v.charAt(1), c2 = v.charAt(2), c3 = v.charAt(3);
            v = "#" + c1 + c1 + c2 + c2 + c3 + c3;
          }
          v = parseInt(v.substr(1), 16);
          return [v >> 16, v >> 8 & 255, v & 255];
        }
        if (v.substr(0, 3) === "hsl") {
          v = v.match(_numExp);
          h = Number(v[0]) % 360 / 360;
          s = Number(v[1]) / 100;
          l = Number(v[2]) / 100;
          c2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
          c1 = l * 2 - c2;
          if (v.length > 3) {
            v[3] = Number(v[3]);
          }
          v[0] = _hue(h + 1 / 3, c1, c2);
          v[1] = _hue(h, c1, c2);
          v[2] = _hue(h - 1 / 3, c1, c2);
          return v;
        }
        v = v.match(_numExp) || _colorLookup.transparent;
        v[0] = Number(v[0]);
        v[1] = Number(v[1]);
        v[2] = Number(v[2]);
        if (v.length > 3) {
          v[3] = Number(v[3]);
        }
        return v;
      },
      _colorExp = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#.+?\\b"; //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.

    for (p in _colorLookup) {
      _colorExp += "|" + p + "\\b";
    }
    _colorExp = new RegExp(_colorExp + ")", "gi");

    /**
     * @private Returns a formatter function that handles taking a string (or number in some cases) and returning a consistently formatted one in terms of delimiters, quantity of values, etc. For example, we may get boxShadow values defined as "0px red" or "0px 0px 10px rgb(255,0,0)" or "0px 0px 20px 20px #F00" and we need to ensure that what we get back is described with 4 numbers and a color. This allows us to feed it into the _parseComplex() method and split the values up appropriately. The neat thing about this _getFormatter() function is that the dflt defines a pattern as well as a default, so for example, _getFormatter("0px 0px 0px 0px #777", true) not only sets the default as 0px for all distances and #777 for the color, but also sets the pattern such that 4 numbers and a color will always get returned.
     * @param {!string} dflt The default value and pattern to follow. So "0px 0px 0px 0px #777" will ensure that 4 numbers and a color will always get returned.
     * @param {boolean=} clr If true, the values should be searched for color-related data. For example, boxShadow values typically contain a color whereas borderRadius don't.
     * @param {boolean=} collapsible If true, the value is a top/left/right/bottom style one that acts like margin or padding, where if only one value is received, it's used for all 4; if 2 are received, the first is duplicated for 3rd (bottom) and the 2nd is duplicated for the 4th spot (left), etc.
     * @return {Function} formatter function
     */
    var _getFormatter = function (dflt, clr, collapsible, multi) {
        if (dflt == null) {
          return function (v) {
            return v;
          };
        }
        var dColor = clr ? (dflt.match(_colorExp) || [""])[0] : "",
          dVals = dflt.split(dColor).join("").match(_valuesExp) || [],
          pfx = dflt.substr(0, dflt.indexOf(dVals[0])),
          sfx = dflt.charAt(dflt.length - 1) === ")" ? ")" : "",
          delim = dflt.indexOf(" ") !== -1 ? " " : ",",
          numVals = dVals.length,
          dSfx = numVals > 0 ? dVals[0].replace(_numExp, "") : "",
          formatter;
        if (!numVals) {
          return function (v) {
            return v;
          };
        }
        if (clr) {
          formatter = function (v) {
            var color, vals, i, a;
            if (typeof v === "number") {
              v += dSfx;
            } else if (multi && _commasOutsideParenExp.test(v)) {
              a = v.replace(_commasOutsideParenExp, "|").split("|");
              for (i = 0; i < a.length; i++) {
                a[i] = formatter(a[i]);
              }
              return a.join(",");
            }
            color = (v.match(_colorExp) || [dColor])[0];
            vals = v.split(color).join("").match(_valuesExp) || [];
            i = vals.length;
            if (numVals > i--) {
              while (++i < numVals) {
                vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
              }
            }
            return pfx + vals.join(delim) + delim + color + sfx + (v.indexOf("inset") !== -1 ? " inset" : "");
          };
          return formatter;
        }
        formatter = function (v) {
          var vals, a, i;
          if (typeof v === "number") {
            v += dSfx;
          } else if (multi && _commasOutsideParenExp.test(v)) {
            a = v.replace(_commasOutsideParenExp, "|").split("|");
            for (i = 0; i < a.length; i++) {
              a[i] = formatter(a[i]);
            }
            return a.join(",");
          }
          vals = v.match(_valuesExp) || [];
          i = vals.length;
          if (numVals > i--) {
            while (++i < numVals) {
              vals[i] = collapsible ? vals[(i - 1) / 2 | 0] : dVals[i];
            }
          }
          return pfx + vals.join(delim) + sfx;
        };
        return formatter;
      },
      /**
       * @private returns a formatter function that's used for edge-related values like marginTop, marginLeft, paddingBottom, paddingRight, etc. Just pass a comma-delimited list of property names related to the edges.
       * @param {!string} props a comma-delimited list of property names in order from top to left, like "marginTop,marginRight,marginBottom,marginLeft"
       * @return {Function} a formatter function
       */
      _getEdgeParser = function (props) {
        props = props.split(",");
        return function (t, e, p, cssp, pt, plugin, vars) {
          var a = (e + "").split(" "),
            i;
          vars = {};
          for (i = 0; i < 4; i++) {
            vars[props[i]] = a[i] = a[i] || a[(i - 1) / 2 >> 0];
          }
          return cssp.parse(t, vars, pt, plugin);
        };
      },
      //@private used when other plugins must tween values first, like BezierPlugin or ThrowPropsPlugin, etc. That plugin's setRatio() gets called first so that the values are updated, and then we loop through the MiniPropTweens  which handle copying the values into their appropriate slots so that they can then be applied correctly in the main CSSPlugin setRatio() method. Remember, we typically create a proxy object that has a bunch of uniquely-named properties that we feed to the sub-plugin and it does its magic normally, and then we must interpret those values and apply them to the css because often numbers must get combined/concatenated, suffixes added, etc. to work with css, like boxShadow could have 4 values plus a color.
      _setPluginRatio = _internals._setPluginRatio = function (v) {
        this.plugin.setRatio(v);
        var d = this.data,
          proxy = d.proxy,
          mpt = d.firstMPT,
          min = 0.000001,
          val,
          pt,
          i,
          str;
        while (mpt) {
          val = proxy[mpt.v];
          if (mpt.r) {
            val = val > 0 ? val + 0.5 | 0 : val - 0.5 | 0;
          } else if (val < min && val > -min) {
            val = 0;
          }
          mpt.t[mpt.p] = val;
          mpt = mpt._next;
        }
        if (d.autoRotate) {
          d.autoRotate.rotation = proxy.rotation;
        }
        //at the end, we must set the CSSPropTween's "e" (end) value dynamically here because that's what is used in the final setRatio() method.
        if (v === 1) {
          mpt = d.firstMPT;
          while (mpt) {
            pt = mpt.t;
            if (!pt.type) {
              pt.e = pt.s + pt.xs0;
            } else if (pt.type === 1) {
              str = pt.xs0 + pt.s + pt.xs1;
              for (i = 1; i < pt.l; i++) {
                str += pt["xn" + i] + pt["xs" + (i + 1)];
              }
              pt.e = str;
            }
            mpt = mpt._next;
          }
        }
      },
      /**
       * @private @constructor Used by a few SpecialProps to hold important values for proxies. For example, _parseToProxy() creates a MiniPropTween instance for each property that must get tweened on the proxy, and we record the original property name as well as the unique one we create for the proxy, plus whether or not the value needs to be rounded plus the original value.
       * @param {!Object} t target object whose property we're tweening (often a CSSPropTween)
       * @param {!string} p property name
       * @param {(number|string|object)} v value
       * @param {MiniPropTween=} next next MiniPropTween in the linked list
       * @param {boolean=} r if true, the tweened value should be rounded to the nearest integer
       */
      MiniPropTween = function (t, p, v, next, r) {
        this.t = t;
        this.p = p;
        this.v = v;
        this.r = r;
        if (next) {
          next._prev = this;
          this._next = next;
        }
      },
      /**
       * @private Most other plugins (like BezierPlugin and ThrowPropsPlugin and others) can only tween numeric values, but CSSPlugin must accommodate special values that have a bunch of extra data (like a suffix or strings between numeric values, etc.). For example, boxShadow has values like "10px 10px 20px 30px rgb(255,0,0)" which would utterly confuse other plugins. This method allows us to split that data apart and grab only the numeric data and attach it to uniquely-named properties of a generic proxy object ({}) so that we can feed that to virtually any plugin to have the numbers tweened. However, we must also keep track of which properties from the proxy go with which CSSPropTween values and instances. So we create a linked list of MiniPropTweens. Each one records a target (the original CSSPropTween), property (like "s" or "xn1" or "xn2") that we're tweening and the unique property name that was used for the proxy (like "boxShadow_xn1" and "boxShadow_xn2") and whether or not they need to be rounded. That way, in the _setPluginRatio() method we can simply copy the values over from the proxy to the CSSPropTween instance(s). Then, when the main CSSPlugin setRatio() method runs and applies the CSSPropTween values accordingly, they're updated nicely. So the external plugin tweens the numbers, _setPluginRatio() copies them over, and setRatio() acts normally, applying css-specific values to the element.
       * This method returns an object that has the following properties:
       *  - proxy: a generic object containing the starting values for all the properties that will be tweened by the external plugin.  This is what we feed to the external _onInitTween() as the target
       *  - end: a generic object containing the ending values for all the properties that will be tweened by the external plugin. This is what we feed to the external plugin's _onInitTween() as the destination values
       *  - firstMPT: the first MiniPropTween in the linked list
       *  - pt: the first CSSPropTween in the linked list that was created when parsing. If shallow is true, this linked list will NOT attach to the one passed into the _parseToProxy() as the "pt" (4th) parameter.
       * @param {!Object} t target object to be tweened
       * @param {!(Object|string)} vars the object containing the information about the tweening values (typically the end/destination values) that should be parsed
       * @param {!CSSPlugin} cssp The CSSPlugin instance
       * @param {CSSPropTween=} pt the next CSSPropTween in the linked list
       * @param {TweenPlugin=} plugin the external TweenPlugin instance that will be handling tweening the numeric values
       * @param {boolean=} shallow if true, the resulting linked list from the parse will NOT be attached to the CSSPropTween that was passed in as the "pt" (4th) parameter.
       * @return An object containing the following properties: proxy, end, firstMPT, and pt (see above for descriptions)
       */
      _parseToProxy = _internals._parseToProxy = function (t, vars, cssp, pt, plugin, shallow) {
        var bpt = pt,
          start = {},
          end = {},
          transform = cssp._transform,
          oldForce = _forcePT,
          i,
          p,
          xp,
          mpt,
          firstPT;
        cssp._transform = null;
        _forcePT = vars;
        pt = firstPT = cssp.parse(t, vars, pt, plugin);
        _forcePT = oldForce;
        //break off from the linked list so the new ones are isolated.
        if (shallow) {
          cssp._transform = transform;
          if (bpt) {
            bpt._prev = null;
            if (bpt._prev) {
              bpt._prev._next = null;
            }
          }
        }
        while (pt && pt !== bpt) {
          if (pt.type <= 1) {
            p = pt.p;
            end[p] = pt.s + pt.c;
            start[p] = pt.s;
            if (!shallow) {
              mpt = new MiniPropTween(pt, "s", p, mpt, pt.r);
              pt.c = 0;
            }
            if (pt.type === 1) {
              i = pt.l;
              while (--i > 0) {
                xp = "xn" + i;
                p = pt.p + "_" + xp;
                end[p] = pt.data[xp];
                start[p] = pt[xp];
                if (!shallow) {
                  mpt = new MiniPropTween(pt, xp, p, mpt, pt.rxp[xp]);
                }
              }
            }
          }
          pt = pt._next;
        }
        return {
          proxy: start,
          end: end,
          firstMPT: mpt,
          pt: firstPT
        };
      },
      /**
       * @constructor Each property that is tweened has at least one CSSPropTween associated with it. These instances store important information like the target, property, starting value, amount of change, etc. They can also optionally have a number of "extra" strings and numeric values named xs1, xn1, xs2, xn2, xs3, xn3, etc. where "s" indicates string and "n" indicates number. These can be pieced together in a complex-value tween (type:1) that has alternating types of data like a string, number, string, number, etc. For example, boxShadow could be "5px 5px 8px rgb(102, 102, 51)". In that value, there are 6 numbers that may need to tween and then pieced back together into a string again with spaces, suffixes, etc. xs0 is special in that it stores the suffix for standard (type:0) tweens, -OR- the first string (prefix) in a complex-value (type:1) CSSPropTween -OR- it can be the non-tweening value in a type:-1 CSSPropTween. We do this to conserve memory.
       * CSSPropTweens have the following optional properties as well (not defined through the constructor):
       *  - l: Length in terms of the number of extra properties that the CSSPropTween has (default: 0). For example, for a boxShadow we may need to tween 5 numbers in which case l would be 5; Keep in mind that the start/end values for the first number that's tweened are always stored in the s and c properties to conserve memory. All additional values thereafter are stored in xn1, xn2, etc.
       *  - xfirst: The first instance of any sub-CSSPropTweens that are tweening properties of this instance. For example, we may split up a boxShadow tween so that there's a main CSSPropTween of type:1 that has various xs* and xn* values associated with the h-shadow, v-shadow, blur, color, etc. Then we spawn a CSSPropTween for each of those that has a higher priority and runs BEFORE the main CSSPropTween so that the values are all set by the time it needs to re-assemble them. The xfirst gives us an easy way to identify the first one in that chain which typically ends at the main one (because they're all prepende to the linked list)
       *  - plugin: The TweenPlugin instance that will handle the tweening of any complex values. For example, sometimes we don't want to use normal subtweens (like xfirst refers to) to tween the values - we might want ThrowPropsPlugin or BezierPlugin some other plugin to do the actual tweening, so we create a plugin instance and store a reference here. We need this reference so that if we get a request to round values or disable a tween, we can pass along that request.
       *  - data: Arbitrary data that needs to be stored with the CSSPropTween. Typically if we're going to have a plugin handle the tweening of a complex-value tween, we create a generic object that stores the END values that we're tweening to and the CSSPropTween's xs1, xs2, etc. have the starting values. We store that object as data. That way, we can simply pass that object to the plugin and use the CSSPropTween as the target.
       *  - setRatio: Only used for type:2 tweens that require custom functionality. In this case, we call the CSSPropTween's setRatio() method and pass the ratio each time the tween updates. This isn't quite as efficient as doing things directly in the CSSPlugin's setRatio() method, but it's very convenient and flexible.
       * @param {!Object} t Target object whose property will be tweened. Often a DOM element, but not always. It could be anything.
       * @param {string} p Property to tween (name). For example, to tween element.width, p would be "width".
       * @param {number} s Starting numeric value
       * @param {number} c Change in numeric value over the course of the entire tween. For example, if element.width starts at 5 and should end at 100, c would be 95.
       * @param {CSSPropTween=} next The next CSSPropTween in the linked list. If one is defined, we will define its _prev as the new instance, and the new instance's _next will be pointed at it.
       * @param {number=} type The type of CSSPropTween where -1 = a non-tweening value, 0 = a standard simple tween, 1 = a complex value (like one that has multiple numbers in a comma- or space-delimited string like border:"1px solid red"), and 2 = one that uses a custom setRatio function that does all of the work of applying the values on each update.
       * @param {string=} n Name of the property that should be used for overwriting purposes which is typically the same as p but not always. For example, we may need to create a subtween for the 2nd part of a "clip:rect(...)" tween in which case "p" might be xs1 but "n" is still "clip"
       * @param {boolean=} r If true, the value(s) should be rounded
       * @param {number=} pr Priority in the linked list order. Higher priority CSSPropTweens will be updated before lower priority ones. The default priority is 0.
       * @param {string=} b Beginning value. We store this to ensure that it is EXACTLY what it was when the tween began without any risk of interpretation issues.
       * @param {string=} e Ending value. We store this to ensure that it is EXACTLY what the user defined at the end of the tween without any risk of interpretation issues.
       */
      CSSPropTween = _internals.CSSPropTween = function (t, p, s, c, next, type, n, r, pr, b, e) {
        this.t = t; //target
        this.p = p; //property
        this.s = s; //starting value
        this.c = c; //change value
        this.n = n || p; //name that this CSSPropTween should be associated to (usually the same as p, but not always - n is what overwriting looks at)
        if (!(t instanceof CSSPropTween)) {
          _overwriteProps.push(this.n);
        }
        this.r = r; //round (boolean)
        this.type = type || 0; //0 = normal tween, -1 = non-tweening (in which case xs0 will be applied to the target's property, like tp.t[tp.p] = tp.xs0), 1 = complex-value SpecialProp, 2 = custom setRatio() that does all the work
        if (pr) {
          this.pr = pr;
          _hasPriority = true;
        }
        this.b = b === undefined ? s : b;
        this.e = e === undefined ? s + c : e;
        if (next) {
          this._next = next;
          next._prev = this;
        }
      },
      /**
       * Takes a target, the beginning value and ending value (as strings) and parses them into a CSSPropTween (possibly with child CSSPropTweens) that accommodates multiple numbers, colors, comma-delimited values, etc. For example:
       * sp.parseComplex(element, "boxShadow", "5px 10px 20px rgb(255,102,51)", "0px 0px 0px red", true, "0px 0px 0px rgb(0,0,0,0)", pt);
       * It will walk through the beginning and ending values (which should be in the same format with the same number and type of values) and figure out which parts are numbers, what strings separate the numeric/tweenable values, and then create the CSSPropTweens accordingly. If a plugin is defined, no child CSSPropTweens will be created. Instead, the ending values will be stored in the "data" property of the returned CSSPropTween like: {s:-5, xn1:-10, xn2:-20, xn3:255, xn4:0, xn5:0} so that it can be fed to any other plugin and it'll be plain numeric tweens but the recomposition of the complex value will be handled inside CSSPlugin's setRatio().
       * If a setRatio is defined, the type of the CSSPropTween will be set to 2 and recomposition of the values will be the responsibility of that method.
       *
       * @param {!Object} t Target whose property will be tweened
       * @param {!string} p Property that will be tweened (its name, like "left" or "backgroundColor" or "boxShadow")
       * @param {string} b Beginning value
       * @param {string} e Ending value
       * @param {boolean} clrs If true, the value could contain a color value like "rgb(255,0,0)" or "#F00" or "red". The default is false, so no colors will be recognized (a performance optimization)
       * @param {(string|number|Object)} dflt The default beginning value that should be used if no valid beginning value is defined or if the number of values inside the complex beginning and ending values don't match
       * @param {?CSSPropTween} pt CSSPropTween instance that is the current head of the linked list (we'll prepend to this).
       * @param {number=} pr Priority in the linked list order. Higher priority properties will be updated before lower priority ones. The default priority is 0.
       * @param {TweenPlugin=} plugin If a plugin should handle the tweening of extra properties, pass the plugin instance here. If one is defined, then NO subtweens will be created for any extra properties (the properties will be created - just not additional CSSPropTween instances to tween them) because the plugin is expected to do so. However, the end values WILL be populated in the "data" property, like {s:100, xn1:50, xn2:300}
       * @param {function(number)=} setRatio If values should be set in a custom function instead of being pieced together in a type:1 (complex-value) CSSPropTween, define that custom function here.
       * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parseComplex() call.
       */
      _parseComplex = CSSPlugin.parseComplex = function (t, p, b, e, clrs, dflt, pt, pr, plugin, setRatio) {
        //DEBUG: _log("parseComplex: "+p+", b: "+b+", e: "+e);
        b = b || dflt || "";
        pt = new CSSPropTween(t, p, 0, 0, pt, setRatio ? 2 : 1, null, false, pr, b, e);
        e += ""; //ensures it's a string
        var ba = b.split(", ").join(",").split(" "),
          //beginning array
          ea = e.split(", ").join(",").split(" "),
          //ending array
          l = ba.length,
          autoRound = _autoRound !== false,
          i,
          xi,
          ni,
          bv,
          ev,
          bnums,
          enums,
          bn,
          rgba,
          temp,
          cv,
          str;
        if (e.indexOf(",") !== -1 || b.indexOf(",") !== -1) {
          ba = ba.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
          ea = ea.join(" ").replace(_commasOutsideParenExp, ", ").split(" ");
          l = ba.length;
        }
        if (l !== ea.length) {
          //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
          ba = (dflt || "").split(" ");
          l = ba.length;
        }
        pt.plugin = plugin;
        pt.setRatio = setRatio;
        for (i = 0; i < l; i++) {
          bv = ba[i];
          ev = ea[i];
          bn = parseFloat(bv);

          //if the value begins with a number (most common). It's fine if it has a suffix like px
          if (bn || bn === 0) {
            pt.appendXtra("", bn, _parseChange(ev, bn), ev.replace(_relNumExp, ""), autoRound && ev.indexOf("px") !== -1, true);

            //if the value is a color
          } else if (clrs && (bv.charAt(0) === "#" || _colorLookup[bv] || _rgbhslExp.test(bv))) {
            str = ev.charAt(ev.length - 1) === "," ? ")," : ")"; //if there's a comma at the end, retain it.
            bv = _parseColor(bv);
            ev = _parseColor(ev);
            rgba = bv.length + ev.length > 6;
            if (rgba && !_supportsOpacity && ev[3] === 0) {
              //older versions of IE don't support rgba(), so if the destination alpha is 0, just use "transparent" for the end color
              pt["xs" + pt.l] += pt.l ? " transparent" : "transparent";
              pt.e = pt.e.split(ea[i]).join("transparent");
            } else {
              if (!_supportsOpacity) {
                //old versions of IE don't support rgba().
                rgba = false;
              }
              pt.appendXtra(rgba ? "rgba(" : "rgb(", bv[0], ev[0] - bv[0], ",", true, true).appendXtra("", bv[1], ev[1] - bv[1], ",", true).appendXtra("", bv[2], ev[2] - bv[2], rgba ? "," : str, true);
              if (rgba) {
                bv = bv.length < 4 ? 1 : bv[3];
                pt.appendXtra("", bv, (ev.length < 4 ? 1 : ev[3]) - bv, str, false);
              }
            }
          } else {
            bnums = bv.match(_numExp); //gets each group of numbers in the beginning value string and drops them into an array

            //if no number is found, treat it as a non-tweening value and just append the string to the current xs.
            if (!bnums) {
              pt["xs" + pt.l] += pt.l ? " " + bv : bv;

              //loop through all the numbers that are found and construct the extra values on the pt.
            } else {
              enums = ev.match(_relNumExp); //get each group of numbers in the end value string and drop them into an array. We allow relative values too, like +=50 or -=.5
              if (!enums || enums.length !== bnums.length) {
                //DEBUG: _log("mismatched formatting detected on " + p + " (" + b + " vs " + e + ")");
                return pt;
              }
              ni = 0;
              for (xi = 0; xi < bnums.length; xi++) {
                cv = bnums[xi];
                temp = bv.indexOf(cv, ni);
                pt.appendXtra(bv.substr(ni, temp - ni), Number(cv), _parseChange(enums[xi], cv), "", autoRound && bv.substr(temp + cv.length, 2) === "px", xi === 0);
                ni = temp + cv.length;
              }
              pt["xs" + pt.l] += bv.substr(ni);
            }
          }
        }
        //if there are relative values ("+=" or "-=" prefix), we need to adjust the ending value to eliminate the prefixes and combine the values properly.
        if (e.indexOf("=") !== -1) if (pt.data) {
          str = pt.xs0 + pt.data.s;
          for (i = 1; i < pt.l; i++) {
            str += pt["xs" + i] + pt.data["xn" + i];
          }
          pt.e = str + pt["xs" + i];
        }
        if (!pt.l) {
          pt.type = -1;
          pt.xs0 = pt.e;
        }
        return pt.xfirst || pt;
      },
      i = 9;
    p = CSSPropTween.prototype;
    p.l = p.pr = 0; //length (number of extra properties like xn1, xn2, xn3, etc.
    while (--i > 0) {
      p["xn" + i] = 0;
      p["xs" + i] = "";
    }
    p.xs0 = "";
    p._next = p._prev = p.xfirst = p.data = p.plugin = p.setRatio = p.rxp = null;

    /**
     * Appends and extra tweening value to a CSSPropTween and automatically manages any prefix and suffix strings. The first extra value is stored in the s and c of the main CSSPropTween instance, but thereafter any extras are stored in the xn1, xn2, xn3, etc. The prefixes and suffixes are stored in the xs0, xs1, xs2, etc. properties. For example, if I walk through a clip value like "rect(10px, 5px, 0px, 20px)", the values would be stored like this:
     * xs0:"rect(", s:10, xs1:"px, ", xn1:5, xs2:"px, ", xn2:0, xs3:"px, ", xn3:20, xn4:"px)"
     * And they'd all get joined together when the CSSPlugin renders (in the setRatio() method).
     * @param {string=} pfx Prefix (if any)
     * @param {!number} s Starting value
     * @param {!number} c Change in numeric value over the course of the entire tween. For example, if the start is 5 and the end is 100, the change would be 95.
     * @param {string=} sfx Suffix (if any)
     * @param {boolean=} r Round (if true).
     * @param {boolean=} pad If true, this extra value should be separated by the previous one by a space. If there is no previous extra and pad is true, it will automatically drop the space.
     * @return {CSSPropTween} returns itself so that multiple methods can be chained together.
     */
    p.appendXtra = function (pfx, s, c, sfx, r, pad) {
      var pt = this,
        l = pt.l;
      pt["xs" + l] += pad && l ? " " + pfx : pfx || "";
      if (!c) if (l !== 0 && !pt.plugin) {
        //typically we'll combine non-changing values right into the xs to optimize performance, but we don't combine them when there's a plugin that will be tweening the values because it may depend on the values being split apart, like for a bezier, if a value doesn't change between the first and second iteration but then it does on the 3rd, we'll run into trouble because there's no xn slot for that value!
        pt["xs" + l] += s + (sfx || "");
        return pt;
      }
      pt.l++;
      pt.type = pt.setRatio ? 2 : 1;
      pt["xs" + pt.l] = sfx || "";
      if (l > 0) {
        pt.data["xn" + l] = s + c;
        pt.rxp["xn" + l] = r; //round extra property (we need to tap into this in the _parseToProxy() method)
        pt["xn" + l] = s;
        if (!pt.plugin) {
          pt.xfirst = new CSSPropTween(pt, "xn" + l, s, c, pt.xfirst || pt, 0, pt.n, r, pt.pr);
          pt.xfirst.xs0 = 0; //just to ensure that the property stays numeric which helps modern browsers speed up processing. Remember, in the setRatio() method, we do pt.t[pt.p] = val + pt.xs0 so if pt.xs0 is "" (the default), it'll cast the end value as a string. When a property is a number sometimes and a string sometimes, it prevents the compiler from locking in the data type, slowing things down slightly.
        }
        return pt;
      }
      pt.data = {
        s: s + c
      };
      pt.rxp = {};
      pt.s = s;
      pt.c = c;
      pt.r = r;
      return pt;
    };

    /**
     * @constructor A SpecialProp is basically a css property that needs to be treated in a non-standard way, like if it may contain a complex value like boxShadow:"5px 10px 15px rgb(255, 102, 51)" or if it is associated with another plugin like ThrowPropsPlugin or BezierPlugin. Every SpecialProp is associated with a particular property name like "boxShadow" or "throwProps" or "bezier" and it will intercept those values in the vars object that's passed to the CSSPlugin and handle them accordingly.
     * @param {!string} p Property name (like "boxShadow" or "throwProps")
     * @param {Object=} options An object containing any of the following configuration options:
     *                      - defaultValue: the default value
     *                      - parser: A function that should be called when the associated property name is found in the vars. This function should return a CSSPropTween instance and it should ensure that it is properly inserted into the linked list. It will receive 4 paramters: 1) The target, 2) The value defined in the vars, 3) The CSSPlugin instance (whose _firstPT should be used for the linked list), and 4) A computed style object if one was calculated (this is a speed optimization that allows retrieval of starting values quicker)
     *                      - formatter: a function that formats any value received for this special property (for example, boxShadow could take "5px 5px red" and format it to "5px 5px 0px 0px red" so that both the beginning and ending values have a common order and quantity of values.)
     *                      - prefix: if true, we'll determine whether or not this property requires a vendor prefix (like Webkit or Moz or ms or O)
     *                      - color: set this to true if the value for this SpecialProp may contain color-related values like rgb(), rgba(), etc.
     *                      - priority: priority in the linked list order. Higher priority SpecialProps will be updated before lower priority ones. The default priority is 0.
     *                      - multi: if true, the formatter should accommodate a comma-delimited list of values, like boxShadow could have multiple boxShadows listed out.
     *                      - collapsible: if true, the formatter should treat the value like it's a top/right/bottom/left value that could be collapsed, like "5px" would apply to all, "5px, 10px" would use 5px for top/bottom and 10px for right/left, etc.
     *                      - keyword: a special keyword that can [optionally] be found inside the value (like "inset" for boxShadow). This allows us to validate beginning/ending values to make sure they match (if the keyword is found in one, it'll be added to the other for consistency by default).
     */
    var SpecialProp = function (p, options) {
        options = options || {};
        this.p = options.prefix ? _checkPropPrefix(p) || p : p;
        _specialProps[p] = _specialProps[this.p] = this;
        this.format = options.formatter || _getFormatter(options.defaultValue, options.color, options.collapsible, options.multi);
        if (options.parser) {
          this.parse = options.parser;
        }
        this.clrs = options.color;
        this.multi = options.multi;
        this.keyword = options.keyword;
        this.dflt = options.defaultValue;
        this.pr = options.priority || 0;
      },
      //shortcut for creating a new SpecialProp that can accept multiple properties as a comma-delimited list (helps minification). dflt can be an array for multiple values (we don't do a comma-delimited list because the default value may contain commas, like rect(0px,0px,0px,0px)). We attach this method to the SpecialProp class/object instead of using a private _createSpecialProp() method so that we can tap into it externally if necessary, like from another plugin.
      _registerComplexSpecialProp = _internals._registerComplexSpecialProp = function (p, options, defaults) {
        if (typeof options !== "object") {
          options = {
            parser: defaults
          }; //to make backwards compatible with older versions of BezierPlugin and ThrowPropsPlugin
        }
        var a = p.split(","),
          d = options.defaultValue,
          i,
          temp;
        defaults = defaults || [d];
        for (i = 0; i < a.length; i++) {
          options.prefix = i === 0 && options.prefix;
          options.defaultValue = defaults[i] || d;
          temp = new SpecialProp(a[i], options);
        }
      },
      //creates a placeholder special prop for a plugin so that the property gets caught the first time a tween of it is attempted, and at that time it makes the plugin register itself, thus taking over for all future tweens of that property. This allows us to not mandate that things load in a particular order and it also allows us to log() an error that informs the user when they attempt to tween an external plugin-related property without loading its .js file.
      _registerPluginProp = function (p) {
        if (!_specialProps[p]) {
          var pluginName = p.charAt(0).toUpperCase() + p.substr(1) + "Plugin";
          _registerComplexSpecialProp(p, {
            parser: function (t, e, p, cssp, pt, plugin, vars) {
              var pluginClass = (window.GreenSockGlobals || window).com.greensock.plugins[pluginName];
              if (!pluginClass) {
                _log("Error: " + pluginName + " js file not loaded.");
                return pt;
              }
              pluginClass._cssRegister();
              return _specialProps[p].parse(t, e, p, cssp, pt, plugin, vars);
            }
          });
        }
      };
    p = SpecialProp.prototype;

    /**
     * Alias for _parseComplex() that automatically plugs in certain values for this SpecialProp, like its property name, whether or not colors should be sensed, the default value, and priority. It also looks for any keyword that the SpecialProp defines (like "inset" for boxShadow) and ensures that the beginning and ending values have the same number of values for SpecialProps where multi is true (like boxShadow and textShadow can have a comma-delimited list)
     * @param {!Object} t target element
     * @param {(string|number|object)} b beginning value
     * @param {(string|number|object)} e ending (destination) value
     * @param {CSSPropTween=} pt next CSSPropTween in the linked list
     * @param {TweenPlugin=} plugin If another plugin will be tweening the complex value, that TweenPlugin instance goes here.
     * @param {function=} setRatio If a custom setRatio() method should be used to handle this complex value, that goes here.
     * @return {CSSPropTween=} First CSSPropTween in the linked list
     */
    p.parseComplex = function (t, b, e, pt, plugin, setRatio) {
      var kwd = this.keyword,
        i,
        ba,
        ea,
        l,
        bi,
        ei;
      //if this SpecialProp's value can contain a comma-delimited list of values (like boxShadow or textShadow), we must parse them in a special way, and look for a keyword (like "inset" for boxShadow) and ensure that the beginning and ending BOTH have it if the end defines it as such. We also must ensure that there are an equal number of values specified (we can't tween 1 boxShadow to 3 for example)
      if (this.multi) if (_commasOutsideParenExp.test(e) || _commasOutsideParenExp.test(b)) {
        ba = b.replace(_commasOutsideParenExp, "|").split("|");
        ea = e.replace(_commasOutsideParenExp, "|").split("|");
      } else if (kwd) {
        ba = [b];
        ea = [e];
      }
      if (ea) {
        l = ea.length > ba.length ? ea.length : ba.length;
        for (i = 0; i < l; i++) {
          b = ba[i] = ba[i] || this.dflt;
          e = ea[i] = ea[i] || this.dflt;
          if (kwd) {
            bi = b.indexOf(kwd);
            ei = e.indexOf(kwd);
            if (bi !== ei) {
              e = ei === -1 ? ea : ba;
              e[i] += " " + kwd;
            }
          }
        }
        b = ba.join(", ");
        e = ea.join(", ");
      }
      return _parseComplex(t, this.p, b, e, this.clrs, this.dflt, pt, this.pr, plugin, setRatio);
    };

    /**
     * Accepts a target and end value and spits back a CSSPropTween that has been inserted into the CSSPlugin's linked list and conforms with all the conventions we use internally, like type:-1, 0, 1, or 2, setting up any extra property tweens, priority, etc. For example, if we have a boxShadow SpecialProp and call:
     * this._firstPT = sp.parse(element, "5px 10px 20px rgb(2550,102,51)", "boxShadow", this);
     * It should figure out the starting value of the element's boxShadow, compare it to the provided end value and create all the necessary CSSPropTweens of the appropriate types to tween the boxShadow. The CSSPropTween that gets spit back should already be inserted into the linked list (the 4th parameter is the current head, so prepend to that).
     * @param {!Object} t Target object whose property is being tweened
     * @param {Object} e End value as provided in the vars object (typically a string, but not always - like a throwProps would be an object).
     * @param {!string} p Property name
     * @param {!CSSPlugin} cssp The CSSPlugin instance that should be associated with this tween.
     * @param {?CSSPropTween} pt The CSSPropTween that is the current head of the linked list (we'll prepend to it)
     * @param {TweenPlugin=} plugin If a plugin will be used to tween the parsed value, this is the plugin instance.
     * @param {Object=} vars Original vars object that contains the data for parsing.
     * @return {CSSPropTween} The first CSSPropTween in the linked list which includes the new one(s) added by the parse() call.
     */
    p.parse = function (t, e, p, cssp, pt, plugin, vars) {
      return this.parseComplex(t.style, this.format(_getStyle(t, this.p, _cs, false, this.dflt)), this.format(e), pt, plugin);
    };

    /**
     * Registers a special property that should be intercepted from any "css" objects defined in tweens. This allows you to handle them however you want without CSSPlugin doing it for you. The 2nd parameter should be a function that accepts 3 parameters:
     *  1) Target object whose property should be tweened (typically a DOM element)
     *  2) The end/destination value (could be a string, number, object, or whatever you want)
     *  3) The tween instance (you probably don't need to worry about this, but it can be useful for looking up information like the duration)
     *
     * Then, your function should return a function which will be called each time the tween gets rendered, passing a numeric "ratio" parameter to your function that indicates the change factor (usually between 0 and 1). For example:
     *
     * CSSPlugin.registerSpecialProp("myCustomProp", function(target, value, tween) {
     *      var start = target.style.width;
     *      return function(ratio) {
     *              target.style.width = (start + value * ratio) + "px";
     *              console.log("set width to " + target.style.width);
     *          }
     * }, 0);
     *
     * Then, when I do this tween, it will trigger my special property:
     *
     * TweenLite.to(element, 1, {css:{myCustomProp:100}});
     *
     * In the example, of course, we're just changing the width, but you can do anything you want.
     *
     * @param {!string} name Property name (or comma-delimited list of property names) that should be intercepted and handled by your function. For example, if I define "myCustomProp", then it would handle that portion of the following tween: TweenLite.to(element, 1, {css:{myCustomProp:100}})
     * @param {!function(Object, Object, Object, string):function(number)} onInitTween The function that will be called when a tween of this special property is performed. The function will receive 4 parameters: 1) Target object that should be tweened, 2) Value that was passed to the tween, 3) The tween instance itself (rarely used), and 4) The property name that's being tweened. Your function should return a function that should be called on every update of the tween. That function will receive a single parameter that is a "change factor" value (typically between 0 and 1) indicating the amount of change as a ratio. You can use this to determine how to set the values appropriately in your function.
     * @param {number=} priority Priority that helps the engine determine the order in which to set the properties (default: 0). Higher priority properties will be updated before lower priority ones.
     */
    CSSPlugin.registerSpecialProp = function (name, onInitTween, priority) {
      _registerComplexSpecialProp(name, {
        parser: function (t, e, p, cssp, pt, plugin, vars) {
          var rv = new CSSPropTween(t, p, 0, 0, pt, 2, p, false, priority);
          rv.plugin = plugin;
          rv.setRatio = onInitTween(t, e, cssp._tween, p);
          return rv;
        },
        priority: priority
      });
    };

    //transform-related methods and properties
    var _transformProps = "scaleX,scaleY,scaleZ,x,y,z,skewX,rotation,rotationX,rotationY,perspective".split(","),
      _transformProp = _checkPropPrefix("transform"),
      //the Javascript (camelCase) transform property, like msTransform, WebkitTransform, MozTransform, or OTransform.
      _transformPropCSS = _prefixCSS + "transform",
      _transformOriginProp = _checkPropPrefix("transformOrigin"),
      _supports3D = _checkPropPrefix("perspective") !== null,
      /**
       * Parses the transform values for an element, returning an object with x, y, z, scaleX, scaleY, scaleZ, rotation, rotationX, rotationY, skewX, and skewY properties. Note: by default (for performance reasons), all skewing is combined into skewX and rotation but skewY still has a place in the transform object so that we can record how much of the skew is attributed to skewX vs skewY. Remember, a skewY of 10 looks the same as a rotation of 10 and skewX of -10.
       * @param {!Object} t target element
       * @param {Object=} cs computed style object (optional)
       * @param {boolean=} rec if true, the transform values will be recorded to the target element's _gsTransform object, like target._gsTransform = {x:0, y:0, z:0, scaleX:1...}
       * @param {boolean=} parse if true, we'll ignore any _gsTransform values that already exist on the element, and force a reparsing of the css (calculated style)
       * @return {object} object containing all of the transform properties/values like {x:0, y:0, z:0, scaleX:1...}
       */
      _getTransform = function (t, cs, rec, parse) {
        if (t._gsTransform && rec && !parse) {
          return t._gsTransform; //if the element already has a _gsTransform, use that. Note: some browsers don't accurately return the calculated style for the transform (particularly for SVG), so it's almost always safest to just use the values we've already applied rather than re-parsing things.
        }
        var tm = rec ? t._gsTransform || {
            skewY: 0
          } : {
            skewY: 0
          },
          invX = tm.scaleX < 0,
          //in order to interpret things properly, we need to know if the user applied a negative scaleX previously so that we can adjust the rotation and skewX accordingly. Otherwise, if we always interpret a flipped matrix as affecting scaleY and the user only wants to tween the scaleX on multiple sequential tweens, it would keep the negative scaleY without that being the user's intent.
          min = 0.00002,
          rnd = 100000,
          minAngle = 179.99,
          minPI = minAngle * _DEG2RAD,
          zOrigin = _supports3D ? parseFloat(_getStyle(t, _transformOriginProp, cs, false, "0 0 0").split(" ")[2]) || tm.zOrigin || 0 : 0,
          s,
          m,
          i,
          n,
          dec,
          scaleX,
          scaleY,
          rotation,
          skewX,
          difX,
          difY,
          difR,
          difS;
        if (_transformProp) {
          s = _getStyle(t, _transformPropCSS, cs, true);
        } else if (t.currentStyle) {
          //for older versions of IE, we need to interpret the filter portion that is in the format: progid:DXImageTransform.Microsoft.Matrix(M11=6.123233995736766e-17, M12=-1, M21=1, M22=6.123233995736766e-17, sizingMethod='auto expand') Notice that we need to swap b and c compared to a normal matrix.
          s = t.currentStyle.filter.match(_ieGetMatrixExp);
          s = s && s.length === 4 ? [s[0].substr(4), Number(s[2].substr(4)), Number(s[1].substr(4)), s[3].substr(4), tm.x || 0, tm.y || 0].join(",") : "";
        }
        //split the matrix values out into an array (m for matrix)
        m = (s || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [];
        i = m.length;
        while (--i > -1) {
          n = Number(m[i]);
          m[i] = (dec = n - (n |= 0)) ? (dec * rnd + (dec < 0 ? -0.5 : 0.5) | 0) / rnd + n : n; //convert strings to Numbers and round to 5 decimal places to avoid issues with tiny numbers. Roughly 20x faster than Number.toFixed(). We also must make sure to round before dividing so that values like 0.9999999999 become 1 to avoid glitches in browser rendering and interpretation of flipped/rotated 3D matrices. And don't just multiply the number by rnd, floor it, and then divide by rnd because the bitwise operations max out at a 32-bit signed integer, thus it could get clipped at a relatively low value (like 22,000.00000 for example).
        }
        if (m.length === 16) {
          //we'll only look at these position-related 6 variables first because if x/y/z all match, it's relatively safe to assume we don't need to re-parse everything which risks losing important rotational information (like rotationX:180 plus rotationY:180 would look the same as rotation:180 - there's no way to know for sure which direction was taken based solely on the matrix3d() values)
          var a13 = m[8],
            a23 = m[9],
            a33 = m[10],
            a14 = m[12],
            a24 = m[13],
            a34 = m[14];

          //we manually compensate for non-zero z component of transformOrigin to work around bugs in Safari
          if (tm.zOrigin) {
            a34 = -tm.zOrigin;
            a14 = a13 * a34 - m[12];
            a24 = a23 * a34 - m[13];
            a34 = a33 * a34 + tm.zOrigin - m[14];
          }

          //only parse from the matrix if we MUST because not only is it usually unnecessary due to the fact that we store the values in the _gsTransform object, but also because it's impossible to accurately interpret rotationX, rotationY, rotationZ, scaleX, and scaleY if all are applied, so it's much better to rely on what we store. However, we must parse the first time that an object is tweened. We also assume that if the position has changed, the user must have done some styling changes outside of CSSPlugin, thus we force a parse in that scenario.
          if (!rec || parse || tm.rotationX == null) {
            var a11 = m[0],
              a21 = m[1],
              a31 = m[2],
              a41 = m[3],
              a12 = m[4],
              a22 = m[5],
              a32 = m[6],
              a42 = m[7],
              a43 = m[11],
              angle = Math.atan2(a32, a33),
              xFlip = angle < -minPI || angle > minPI,
              t1,
              t2,
              t3,
              cos,
              sin,
              yFlip,
              zFlip;
            tm.rotationX = angle * _RAD2DEG;
            //rotationX
            if (angle) {
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a12 * cos + a13 * sin;
              t2 = a22 * cos + a23 * sin;
              t3 = a32 * cos + a33 * sin;
              a13 = a12 * -sin + a13 * cos;
              a23 = a22 * -sin + a23 * cos;
              a33 = a32 * -sin + a33 * cos;
              a43 = a42 * -sin + a43 * cos;
              a12 = t1;
              a22 = t2;
              a32 = t3;
            }
            //rotationY
            angle = Math.atan2(a13, a11);
            tm.rotationY = angle * _RAD2DEG;
            if (angle) {
              yFlip = angle < -minPI || angle > minPI;
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              t1 = a11 * cos - a13 * sin;
              t2 = a21 * cos - a23 * sin;
              t3 = a31 * cos - a33 * sin;
              a23 = a21 * sin + a23 * cos;
              a33 = a31 * sin + a33 * cos;
              a43 = a41 * sin + a43 * cos;
              a11 = t1;
              a21 = t2;
              a31 = t3;
            }
            //rotationZ
            angle = Math.atan2(a21, a22);
            tm.rotation = angle * _RAD2DEG;
            if (angle) {
              zFlip = angle < -minPI || angle > minPI;
              cos = Math.cos(-angle);
              sin = Math.sin(-angle);
              a11 = a11 * cos + a12 * sin;
              t2 = a21 * cos + a22 * sin;
              a22 = a21 * -sin + a22 * cos;
              a32 = a31 * -sin + a32 * cos;
              a21 = t2;
            }
            if (zFlip && xFlip) {
              tm.rotation = tm.rotationX = 0;
            } else if (zFlip && yFlip) {
              tm.rotation = tm.rotationY = 0;
            } else if (yFlip && xFlip) {
              tm.rotationY = tm.rotationX = 0;
            }
            tm.scaleX = (Math.sqrt(a11 * a11 + a21 * a21) * rnd + 0.5 | 0) / rnd;
            tm.scaleY = (Math.sqrt(a22 * a22 + a23 * a23) * rnd + 0.5 | 0) / rnd;
            tm.scaleZ = (Math.sqrt(a32 * a32 + a33 * a33) * rnd + 0.5 | 0) / rnd;
            tm.skewX = 0;
            tm.perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
            tm.x = a14;
            tm.y = a24;
            tm.z = a34;
          }
        } else if ((!_supports3D || parse || !m.length || tm.x !== m[4] || tm.y !== m[5] || !tm.rotationX && !tm.rotationY) && !(tm.x !== undefined && _getStyle(t, "display", cs) === "none")) {
          //sometimes a 6-element matrix is returned even when we performed 3D transforms, like if rotationX and rotationY are 180. In cases like this, we still need to honor the 3D transforms. If we just rely on the 2D info, it could affect how the data is interpreted, like scaleY might get set to -1 or rotation could get offset by 180 degrees. For example, do a TweenLite.to(element, 1, {css:{rotationX:180, rotationY:180}}) and then later, TweenLite.to(element, 1, {css:{rotationX:0}}) and without this conditional logic in place, it'd jump to a state of being unrotated when the 2nd tween starts. Then again, we need to honor the fact that the user COULD alter the transforms outside of CSSPlugin, like by manually applying new css, so we try to sense that by looking at x and y because if those changed, we know the changes were made outside CSSPlugin and we force a reinterpretation of the matrix values. Also, in Webkit browsers, if the element's "display" is "none", its calculated style value will always return empty, so if we've already recorded the values in the _gsTransform object, we'll just rely on those.
          var k = m.length >= 6,
            a = k ? m[0] : 1,
            b = m[1] || 0,
            c = m[2] || 0,
            d = k ? m[3] : 1;
          tm.x = m[4] || 0;
          tm.y = m[5] || 0;
          scaleX = Math.sqrt(a * a + b * b);
          scaleY = Math.sqrt(d * d + c * c);
          rotation = a || b ? Math.atan2(b, a) * _RAD2DEG : tm.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).
          skewX = c || d ? Math.atan2(c, d) * _RAD2DEG + rotation : tm.skewX || 0;
          difX = scaleX - Math.abs(tm.scaleX || 0);
          difY = scaleY - Math.abs(tm.scaleY || 0);
          if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
            if (invX) {
              scaleX *= -1;
              skewX += rotation <= 0 ? 180 : -180;
              rotation += rotation <= 0 ? 180 : -180;
            } else {
              scaleY *= -1;
              skewX += skewX <= 0 ? 180 : -180;
            }
          }
          difR = (rotation - tm.rotation) % 180; //note: matching ranges would be very small (+/-0.0001) or very close to 180.
          difS = (skewX - tm.skewX) % 180;
          //if there's already a recorded _gsTransform in place for the target, we should leave those values in place unless we know things changed for sure (beyond a super small amount). This gets around ambiguous interpretations, like if scaleX and scaleY are both -1, the matrix would be the same as if the rotation was 180 with normal scaleX/scaleY. If the user tweened to particular values, those must be prioritized to ensure animation is consistent.
          if (tm.skewX === undefined || difX > min || difX < -min || difY > min || difY < -min || difR > -minAngle && difR < minAngle && difR * rnd | 0 !== 0 || difS > -minAngle && difS < minAngle && difS * rnd | 0 !== 0) {
            tm.scaleX = scaleX;
            tm.scaleY = scaleY;
            tm.rotation = rotation;
            tm.skewX = skewX;
          }
          if (_supports3D) {
            tm.rotationX = tm.rotationY = tm.z = 0;
            tm.perspective = parseFloat(CSSPlugin.defaultTransformPerspective) || 0;
            tm.scaleZ = 1;
          }
        }
        tm.zOrigin = zOrigin;

        //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 0 in these cases. The conditional logic here is faster than calling Math.abs(). Also, browsers tend to render a SLIGHTLY rotated object in a fuzzy way, so we need to snap to exactly 0 when appropriate.
        for (i in tm) {
          if (tm[i] < min) if (tm[i] > -min) {
            tm[i] = 0;
          }
        }
        //DEBUG: _log("parsed rotation: "+(tm.rotationX)+", "+(tm.rotationY)+", "+(tm.rotation)+", scale: "+tm.scaleX+", "+tm.scaleY+", "+tm.scaleZ+", position: "+tm.x+", "+tm.y+", "+tm.z+", perspective: "+tm.perspective);
        if (rec) {
          t._gsTransform = tm; //record to the object's _gsTransform which we use so that tweens can control individual properties independently (we need all the properties to accurately recompose the matrix in the setRatio() method)
        }
        return tm;
      },
      //for setting 2D transforms in IE6, IE7, and IE8 (must use a "filter" to emulate the behavior of modern day browser transforms)
      _setIETransformRatio = function (v) {
        var t = this.data,
          //refers to the element's _gsTransform object
          ang = -t.rotation * _DEG2RAD,
          skew = ang + t.skewX * _DEG2RAD,
          rnd = 100000,
          a = (Math.cos(ang) * t.scaleX * rnd | 0) / rnd,
          b = (Math.sin(ang) * t.scaleX * rnd | 0) / rnd,
          c = (Math.sin(skew) * -t.scaleY * rnd | 0) / rnd,
          d = (Math.cos(skew) * t.scaleY * rnd | 0) / rnd,
          style = this.t.style,
          cs = this.t.currentStyle,
          filters,
          val;
        if (!cs) {
          return;
        }
        val = b; //just for swapping the variables an inverting them (reused "val" to avoid creating another variable in memory). IE's filter matrix uses a non-standard matrix configuration (angle goes the opposite way, and b and c are reversed and inverted)
        b = -c;
        c = -val;
        filters = cs.filter;
        style.filter = ""; //remove filters so that we can accurately measure offsetWidth/offsetHeight
        var w = this.t.offsetWidth,
          h = this.t.offsetHeight,
          clip = cs.position !== "absolute",
          m = "progid:DXImageTransform.Microsoft.Matrix(M11=" + a + ", M12=" + b + ", M21=" + c + ", M22=" + d,
          ox = t.x,
          oy = t.y,
          dx,
          dy;

        //if transformOrigin is being used, adjust the offset x and y
        if (t.ox != null) {
          dx = (t.oxp ? w * t.ox * 0.01 : t.ox) - w / 2;
          dy = (t.oyp ? h * t.oy * 0.01 : t.oy) - h / 2;
          ox += dx - (dx * a + dy * b);
          oy += dy - (dx * c + dy * d);
        }
        if (!clip) {
          m += ", sizingMethod='auto expand')";
        } else {
          dx = w / 2;
          dy = h / 2;
          //translate to ensure that transformations occur around the correct origin (default is center).
          m += ", Dx=" + (dx - (dx * a + dy * b) + ox) + ", Dy=" + (dy - (dx * c + dy * d) + oy) + ")";
        }
        if (filters.indexOf("DXImageTransform.Microsoft.Matrix(") !== -1) {
          style.filter = filters.replace(_ieSetMatrixExp, m);
        } else {
          style.filter = m + " " + filters; //we must always put the transform/matrix FIRST (before alpha(opacity=xx)) to avoid an IE bug that slices part of the object when rotation is applied with alpha.
        }

        //at the end or beginning of the tween, if the matrix is normal (1, 0, 0, 1) and opacity is 100 (or doesn't exist), remove the filter to improve browser performance.
        if (v === 0 || v === 1) if (a === 1) if (b === 0) if (c === 0) if (d === 1) if (!clip || m.indexOf("Dx=0, Dy=0") !== -1) if (!_opacityExp.test(filters) || parseFloat(RegExp.$1) === 100) if (filters.indexOf( true && filters.indexOf("Alpha")) === -1) {
          style.removeAttribute("filter");
        }

        //we must set the margins AFTER applying the filter in order to avoid some bugs in IE8 that could (in rare scenarios) cause them to be ignored intermittently (vibration).
        if (!clip) {
          var mult = _ieVers < 8 ? 1 : -1,
            //in Internet Explorer 7 and before, the box model is broken, causing the browser to treat the width/height of the actual rotated filtered image as the width/height of the box itself, but Microsoft corrected that in IE8. We must use a negative offset in IE8 on the right/bottom
            marg,
            prop,
            dif;
          dx = t.ieOffsetX || 0;
          dy = t.ieOffsetY || 0;
          t.ieOffsetX = Math.round((w - ((a < 0 ? -a : a) * w + (b < 0 ? -b : b) * h)) / 2 + ox);
          t.ieOffsetY = Math.round((h - ((d < 0 ? -d : d) * h + (c < 0 ? -c : c) * w)) / 2 + oy);
          for (i = 0; i < 4; i++) {
            prop = _margins[i];
            marg = cs[prop];
            //we need to get the current margin in case it is being tweened separately (we want to respect that tween's changes)
            val = marg.indexOf("px") !== -1 ? parseFloat(marg) : _convertToPixels(this.t, prop, parseFloat(marg), marg.replace(_suffixExp, "")) || 0;
            if (val !== t[prop]) {
              dif = i < 2 ? -t.ieOffsetX : -t.ieOffsetY; //if another tween is controlling a margin, we cannot only apply the difference in the ieOffsets, so we essentially zero-out the dx and dy here in that case. We record the margin(s) later so that we can keep comparing them, making this code very flexible.
            } else {
              dif = i < 2 ? dx - t.ieOffsetX : dy - t.ieOffsetY;
            }
            style[prop] = (t[prop] = Math.round(val - dif * (i === 0 || i === 2 ? 1 : mult))) + "px";
          }
        }
      },
      _set3DTransformRatio = function (v) {
        var t = this.data,
          //refers to the element's _gsTransform object
          style = this.t.style,
          angle = t.rotation * _DEG2RAD,
          sx = t.scaleX,
          sy = t.scaleY,
          sz = t.scaleZ,
          perspective = t.perspective,
          a11,
          a12,
          a13,
          a14,
          a21,
          a22,
          a23,
          a24,
          a31,
          a32,
          a33,
          a34,
          a41,
          a42,
          a43,
          zOrigin,
          rnd,
          cos,
          sin,
          t1,
          t2,
          t3,
          t4;
        if (_isFirefox) {
          //Firefox has a
          /*
          // It seems Firefox fixed the bug that causes 3D elements to randomly disappear during animation unless a repaint is forced (in version 25), so we're commenting out the fix as of CSSPlugin version 1.11.2, but leaving it in the source in case it's useful later. One way we were working around this was change "top" or "bottom" by 0.05 which is imperceptible, so we go back and forth. Another way is to change the display to "none", read the clientTop, and then revert the display but that is much slower.
          var ffProp = style.top ? "top" : style.bottom ? "bottom" : parseFloat(_getStyle(this.t, "top", null, false)) ? "bottom" : "top";
          t1 = _getStyle(this.t, ffProp, null, false);
          n = parseFloat(t1) || 0;
          var sfx = t1.substr((n + "").length) || "px";
          t._ffFix = !t._ffFix;
          style[ffProp] = (t._ffFix ? n + 0.05 : n - 0.05) + sfx;
          */
          var n = 0.0001;
          if (sx < n && sx > -n) {
            //Firefox has a bug (at least in v25) that causes it to render the transparent part of 32-bit PNG images as black when displayed inside an iframe and the 3D scale is very small and doesn't change sufficiently enough between renders (like if you use a Power4.easeInOut to scale from 0 to 1 where the beginning values only change a tiny amount to begin the tween before accelerating). In this case, we force the scale to be 0.00002 instead which is visually the same but works around the Firefox issue.
            sx = sz = 0.00002;
          }
          if (sy < n && sy > -n) {
            sy = sz = 0.00002;
          }
          if (perspective && !t.z && !t.rotationX && !t.rotationY) {
            //Firefox has a bug that causes elements to have an odd super-thin, broken/dotted black border on elements that have a perspective set but aren't utilizing 3D space (no rotationX, rotationY, or z).
            perspective = 0;
          }
        }
        if (angle || t.skewX) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          a11 = cos;
          a21 = sin;
          if (t.skewX) {
            angle -= t.skewX * _DEG2RAD;
            cos = Math.cos(angle);
            sin = Math.sin(angle);
          }
          a12 = -sin;
          a22 = cos;
        } else if (!t.rotationY && !t.rotationX && sz === 1 && !perspective) {
          //if we're only translating and/or 2D scaling, this is faster...
          style[_transformProp] = "translate3d(" + t.x + "px," + t.y + "px," + t.z + "px)" + (sx !== 1 || sy !== 1 ? " scale(" + sx + "," + sy + ")" : "");
          return;
        } else {
          a11 = a22 = 1;
          a12 = a21 = 0;
        }
        a33 = 1;
        a13 = a14 = a23 = a24 = a31 = a32 = a34 = a41 = a42 = 0;
        a43 = perspective ? -1 / perspective : 0;
        zOrigin = t.zOrigin;
        rnd = 100000;
        angle = t.rotationY * _DEG2RAD;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          a31 = a33 * -sin;
          a41 = a43 * -sin;
          a13 = a11 * sin;
          a23 = a21 * sin;
          a33 *= cos;
          a43 *= cos;
          a11 *= cos;
          a21 *= cos;
        }
        angle = t.rotationX * _DEG2RAD;
        if (angle) {
          cos = Math.cos(angle);
          sin = Math.sin(angle);
          t1 = a12 * cos + a13 * sin;
          t2 = a22 * cos + a23 * sin;
          t3 = a32 * cos + a33 * sin;
          t4 = a42 * cos + a43 * sin;
          a13 = a12 * -sin + a13 * cos;
          a23 = a22 * -sin + a23 * cos;
          a33 = a32 * -sin + a33 * cos;
          a43 = a42 * -sin + a43 * cos;
          a12 = t1;
          a22 = t2;
          a32 = t3;
          a42 = t4;
        }
        if (sz !== 1) {
          a13 *= sz;
          a23 *= sz;
          a33 *= sz;
          a43 *= sz;
        }
        if (sy !== 1) {
          a12 *= sy;
          a22 *= sy;
          a32 *= sy;
          a42 *= sy;
        }
        if (sx !== 1) {
          a11 *= sx;
          a21 *= sx;
          a31 *= sx;
          a41 *= sx;
        }
        if (zOrigin) {
          a34 -= zOrigin;
          a14 = a13 * a34;
          a24 = a23 * a34;
          a34 = a33 * a34 + zOrigin;
        }
        //we round the x, y, and z slightly differently to allow even larger values.
        a14 = (t1 = (a14 += t.x) - (a14 |= 0)) ? (t1 * rnd + (t1 < 0 ? -0.5 : 0.5) | 0) / rnd + a14 : a14;
        a24 = (t1 = (a24 += t.y) - (a24 |= 0)) ? (t1 * rnd + (t1 < 0 ? -0.5 : 0.5) | 0) / rnd + a24 : a24;
        a34 = (t1 = (a34 += t.z) - (a34 |= 0)) ? (t1 * rnd + (t1 < 0 ? -0.5 : 0.5) | 0) / rnd + a34 : a34;
        style[_transformProp] = "matrix3d(" + [(a11 * rnd | 0) / rnd, (a21 * rnd | 0) / rnd, (a31 * rnd | 0) / rnd, (a41 * rnd | 0) / rnd, (a12 * rnd | 0) / rnd, (a22 * rnd | 0) / rnd, (a32 * rnd | 0) / rnd, (a42 * rnd | 0) / rnd, (a13 * rnd | 0) / rnd, (a23 * rnd | 0) / rnd, (a33 * rnd | 0) / rnd, (a43 * rnd | 0) / rnd, a14, a24, a34, perspective ? 1 + -a34 / perspective : 1].join(",") + ")";
      },
      _set2DTransformRatio = function (v) {
        var t = this.data,
          //refers to the element's _gsTransform object
          targ = this.t,
          style = targ.style,
          ffProp,
          t1,
          n,
          sfx,
          ang,
          skew,
          rnd,
          sx,
          sy;
        if (_isFirefox) {
          //Firefox has a bug that causes elements to randomly disappear during animation unless a repaint is forced. One way to do this is change "top" or "bottom" by 0.05 which is imperceptible, so we go back and forth. Another way is to change the display to "none", read the clientTop, and then revert the display but that is much slower.
          ffProp = style.top ? "top" : style.bottom ? "bottom" : parseFloat(_getStyle(targ, "top", null, false)) ? "bottom" : "top";
          t1 = _getStyle(targ, ffProp, null, false);
          n = parseFloat(t1) || 0;
          sfx = t1.substr((n + "").length) || "px";
          t._ffFix = !t._ffFix;
          style[ffProp] = (t._ffFix ? n + 0.05 : n - 0.05) + sfx;
        }
        if (!t.rotation && !t.skewX) {
          style[_transformProp] = "matrix(" + t.scaleX + ",0,0," + t.scaleY + "," + t.x + "," + t.y + ")";
        } else {
          ang = t.rotation * _DEG2RAD;
          skew = ang - t.skewX * _DEG2RAD;
          rnd = 100000;
          sx = t.scaleX * rnd;
          sy = t.scaleY * rnd;
          //some browsers have a hard time with very small values like 2.4492935982947064e-16 (notice the "e-" towards the end) and would render the object slightly off. So we round to 5 decimal places.
          style[_transformProp] = "matrix(" + (Math.cos(ang) * sx | 0) / rnd + "," + (Math.sin(ang) * sx | 0) / rnd + "," + (Math.sin(skew) * -sy | 0) / rnd + "," + (Math.cos(skew) * sy | 0) / rnd + "," + t.x + "," + t.y + ")";
        }
      };
    _registerComplexSpecialProp("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,transformPerspective,directionalRotation,parseTransform,force3D", {
      parser: function (t, e, p, cssp, pt, plugin, vars) {
        if (cssp._transform) {
          return pt;
        } //only need to parse the transform once, and only if the browser supports it.
        var m1 = cssp._transform = _getTransform(t, _cs, true, vars.parseTransform),
          style = t.style,
          min = 0.000001,
          i = _transformProps.length,
          v = vars,
          endRotations = {},
          m2,
          skewY,
          copy,
          orig,
          has3D,
          hasChange,
          dr;
        if (typeof v.transform === "string" && _transformProp) {
          //for values like transform:"rotate(60deg) scale(0.5, 0.8)"
          copy = style.cssText;
          style[_transformProp] = v.transform;
          style.display = "block"; //if display is "none", the browser often refuses to report the transform properties correctly.
          m2 = _getTransform(t, null, false);
          style.cssText = copy;
        } else if (typeof v === "object") {
          //for values like scaleX, scaleY, rotation, x, y, skewX, and skewY or transform:{...} (object)
          m2 = {
            scaleX: _parseVal(v.scaleX != null ? v.scaleX : v.scale, m1.scaleX),
            scaleY: _parseVal(v.scaleY != null ? v.scaleY : v.scale, m1.scaleY),
            scaleZ: _parseVal(v.scaleZ != null ? v.scaleZ : v.scale, m1.scaleZ),
            x: _parseVal(v.x, m1.x),
            y: _parseVal(v.y, m1.y),
            z: _parseVal(v.z, m1.z),
            perspective: _parseVal(v.transformPerspective, m1.perspective)
          };
          dr = v.directionalRotation;
          if (dr != null) {
            if (typeof dr === "object") {
              for (copy in dr) {
                v[copy] = dr[copy];
              }
            } else {
              v.rotation = dr;
            }
          }
          m2.rotation = _parseAngle("rotation" in v ? v.rotation : "shortRotation" in v ? v.shortRotation + "_short" : "rotationZ" in v ? v.rotationZ : m1.rotation, m1.rotation, "rotation", endRotations);
          if (_supports3D) {
            m2.rotationX = _parseAngle("rotationX" in v ? v.rotationX : "shortRotationX" in v ? v.shortRotationX + "_short" : m1.rotationX || 0, m1.rotationX, "rotationX", endRotations);
            m2.rotationY = _parseAngle("rotationY" in v ? v.rotationY : "shortRotationY" in v ? v.shortRotationY + "_short" : m1.rotationY || 0, m1.rotationY, "rotationY", endRotations);
          }
          m2.skewX = v.skewX == null ? m1.skewX : _parseAngle(v.skewX, m1.skewX);

          //note: for performance reasons, we combine all skewing into the skewX and rotation values, ignoring skewY but we must still record it so that we can discern how much of the overall skew is attributed to skewX vs. skewY. Otherwise, if the skewY would always act relative (tween skewY to 10deg, for example, multiple times and if we always combine things into skewX, we can't remember that skewY was 10 from last time). Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of -10 degrees.
          m2.skewY = v.skewY == null ? m1.skewY : _parseAngle(v.skewY, m1.skewY);
          if (skewY = m2.skewY - m1.skewY) {
            m2.skewX += skewY;
            m2.rotation += skewY;
          }
        }
        if (v.force3D != null) {
          m1.force3D = v.force3D;
          hasChange = true;
        }
        has3D = m1.force3D || m1.z || m1.rotationX || m1.rotationY || m2.z || m2.rotationX || m2.rotationY || m2.perspective;
        if (!has3D && v.scale != null) {
          m2.scaleZ = 1; //no need to tween scaleZ.
        }
        while (--i > -1) {
          p = _transformProps[i];
          orig = m2[p] - m1[p];
          if (orig > min || orig < -min || _forcePT[p] != null) {
            hasChange = true;
            pt = new CSSPropTween(m1, p, m1[p], orig, pt);
            if (p in endRotations) {
              pt.e = endRotations[p]; //directional rotations typically have compensated values during the tween, but we need to make sure they end at exactly what the user requested
            }
            pt.xs0 = 0; //ensures the value stays numeric in setRatio()
            pt.plugin = plugin;
            cssp._overwriteProps.push(pt.n);
          }
        }
        orig = v.transformOrigin;
        if (orig || _supports3D && has3D && m1.zOrigin) {
          //if anything 3D is happening and there's a transformOrigin with a z component that's non-zero, we must ensure that the transformOrigin's z-component is set to 0 so that we can manually do those calculations to get around Safari bugs. Even if the user didn't specifically define a "transformOrigin" in this particular tween (maybe they did it via css directly).
          if (_transformProp) {
            hasChange = true;
            p = _transformOriginProp;
            orig = (orig || _getStyle(t, p, _cs, false, "50% 50%")) + ""; //cast as string to avoid errors
            pt = new CSSPropTween(style, p, 0, 0, pt, -1, "transformOrigin");
            pt.b = style[p];
            pt.plugin = plugin;
            if (_supports3D) {
              copy = m1.zOrigin;
              orig = orig.split(" ");
              m1.zOrigin = (orig.length > 2 && !(copy !== 0 && orig[2] === "0px") ? parseFloat(orig[2]) : copy) || 0; //Safari doesn't handle the z part of transformOrigin correctly, so we'll manually handle it in the _set3DTransformRatio() method.
              pt.xs0 = pt.e = style[p] = orig[0] + " " + (orig[1] || "50%") + " 0px"; //we must define a z value of 0px specifically otherwise iOS 5 Safari will stick with the old one (if one was defined)!
              pt = new CSSPropTween(m1, "zOrigin", 0, 0, pt, -1, pt.n); //we must create a CSSPropTween for the _gsTransform.zOrigin so that it gets reset properly at the beginning if the tween runs backward (as opposed to just setting m1.zOrigin here)
              pt.b = copy;
              pt.xs0 = pt.e = m1.zOrigin;
            } else {
              pt.xs0 = pt.e = style[p] = orig;
            }

            //for older versions of IE (6-8), we need to manually calculate things inside the setRatio() function. We record origin x and y (ox and oy) and whether or not the values are percentages (oxp and oyp).
          } else {
            _parsePosition(orig + "", m1);
          }
        }
        if (hasChange) {
          cssp._transformType = has3D || this._transformType === 3 ? 3 : 2; //quicker than calling cssp._enableTransforms();
        }
        return pt;
      },
      prefix: true
    });
    _registerComplexSpecialProp("boxShadow", {
      defaultValue: "0px 0px 0px 0px #999",
      prefix: true,
      color: true,
      multi: true,
      keyword: "inset"
    });
    _registerComplexSpecialProp("borderRadius", {
      defaultValue: "0px",
      parser: function (t, e, p, cssp, pt, plugin) {
        e = this.format(e);
        var props = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
          style = t.style,
          ea1,
          i,
          es2,
          bs2,
          bs,
          es,
          bn,
          en,
          w,
          h,
          esfx,
          bsfx,
          rel,
          hn,
          vn,
          em;
        w = parseFloat(t.offsetWidth);
        h = parseFloat(t.offsetHeight);
        ea1 = e.split(" ");
        for (i = 0; i < props.length; i++) {
          //if we're dealing with percentages, we must convert things separately for the horizontal and vertical axis!
          if (this.p.indexOf("border")) {
            //older browsers used a prefix
            props[i] = _checkPropPrefix(props[i]);
          }
          bs = bs2 = _getStyle(t, props[i], _cs, false, "0px");
          if (bs.indexOf(" ") !== -1) {
            bs2 = bs.split(" ");
            bs = bs2[0];
            bs2 = bs2[1];
          }
          es = es2 = ea1[i];
          bn = parseFloat(bs);
          bsfx = bs.substr((bn + "").length);
          rel = es.charAt(1) === "=";
          if (rel) {
            en = parseInt(es.charAt(0) + "1", 10);
            es = es.substr(2);
            en *= parseFloat(es);
            esfx = es.substr((en + "").length - (en < 0 ? 1 : 0)) || "";
          } else {
            en = parseFloat(es);
            esfx = es.substr((en + "").length);
          }
          if (esfx === "") {
            esfx = _suffixMap[p] || bsfx;
          }
          if (esfx !== bsfx) {
            hn = _convertToPixels(t, "borderLeft", bn, bsfx); //horizontal number (we use a bogus "borderLeft" property just because the _convertToPixels() method searches for the keywords "Left", "Right", "Top", and "Bottom" to determine of it's a horizontal or vertical property, and we need "border" in the name so that it knows it should measure relative to the element itself, not its parent.
            vn = _convertToPixels(t, "borderTop", bn, bsfx); //vertical number
            if (esfx === "%") {
              bs = hn / w * 100 + "%";
              bs2 = vn / h * 100 + "%";
            } else if (esfx === "em") {
              em = _convertToPixels(t, "borderLeft", 1, "em");
              bs = hn / em + "em";
              bs2 = vn / em + "em";
            } else {
              bs = hn + "px";
              bs2 = vn + "px";
            }
            if (rel) {
              es = parseFloat(bs) + en + esfx;
              es2 = parseFloat(bs2) + en + esfx;
            }
          }
          pt = _parseComplex(style, props[i], bs + " " + bs2, es + " " + es2, false, "0px", pt);
        }
        return pt;
      },
      prefix: true,
      formatter: _getFormatter("0px 0px 0px 0px", false, true)
    });
    _registerComplexSpecialProp("backgroundPosition", {
      defaultValue: "0 0",
      parser: function (t, e, p, cssp, pt, plugin) {
        var bp = "background-position",
          cs = _cs || _getComputedStyle(t, null),
          bs = this.format((cs ? _ieVers ? cs.getPropertyValue(bp + "-x") + " " + cs.getPropertyValue(bp + "-y") : cs.getPropertyValue(bp) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
          //Internet Explorer doesn't report background-position correctly - we must query background-position-x and background-position-y and combine them (even in IE10). Before IE9, we must do the same with the currentStyle object and use camelCase
          es = this.format(e),
          ba,
          ea,
          i,
          pct,
          overlap,
          src;
        if (bs.indexOf("%") !== -1 !== (es.indexOf("%") !== -1)) {
          src = _getStyle(t, "backgroundImage").replace(_urlExp, "");
          if (src && src !== "none") {
            ba = bs.split(" ");
            ea = es.split(" ");
            _tempImg.setAttribute("src", src); //set the temp <img>'s src to the background-image so that we can measure its width/height
            i = 2;
            while (--i > -1) {
              bs = ba[i];
              pct = bs.indexOf("%") !== -1;
              if (pct !== (ea[i].indexOf("%") !== -1)) {
                overlap = i === 0 ? t.offsetWidth - _tempImg.width : t.offsetHeight - _tempImg.height;
                ba[i] = pct ? parseFloat(bs) / 100 * overlap + "px" : parseFloat(bs) / overlap * 100 + "%";
              }
            }
            bs = ba.join(" ");
          }
        }
        return this.parseComplex(t.style, bs, es, pt, plugin);
      },
      formatter: _parsePosition
    });
    _registerComplexSpecialProp("backgroundSize", {
      defaultValue: "0 0",
      formatter: _parsePosition
    });
    _registerComplexSpecialProp("perspective", {
      defaultValue: "0px",
      prefix: true
    });
    _registerComplexSpecialProp("perspectiveOrigin", {
      defaultValue: "50% 50%",
      prefix: true
    });
    _registerComplexSpecialProp("transformStyle", {
      prefix: true
    });
    _registerComplexSpecialProp("backfaceVisibility", {
      prefix: true
    });
    _registerComplexSpecialProp("userSelect", {
      prefix: true
    });
    _registerComplexSpecialProp("margin", {
      parser: _getEdgeParser("marginTop,marginRight,marginBottom,marginLeft")
    });
    _registerComplexSpecialProp("padding", {
      parser: _getEdgeParser("paddingTop,paddingRight,paddingBottom,paddingLeft")
    });
    _registerComplexSpecialProp("clip", {
      defaultValue: "rect(0px,0px,0px,0px)",
      parser: function (t, e, p, cssp, pt, plugin) {
        var b, cs, delim;
        if (_ieVers < 9) {
          //IE8 and earlier don't report a "clip" value in the currentStyle - instead, the values are split apart into clipTop, clipRight, clipBottom, and clipLeft. Also, in IE7 and earlier, the values inside rect() are space-delimited, not comma-delimited.
          cs = t.currentStyle;
          delim = _ieVers < 8 ? " " : ",";
          b = "rect(" + cs.clipTop + delim + cs.clipRight + delim + cs.clipBottom + delim + cs.clipLeft + ")";
          e = this.format(e).split(",").join(delim);
        } else {
          b = this.format(_getStyle(t, this.p, _cs, false, this.dflt));
          e = this.format(e);
        }
        return this.parseComplex(t.style, b, e, pt, plugin);
      }
    });
    _registerComplexSpecialProp("textShadow", {
      defaultValue: "0px 0px 0px #999",
      color: true,
      multi: true
    });
    _registerComplexSpecialProp("autoRound,strictUnits", {
      parser: function (t, e, p, cssp, pt) {
        return pt;
      }
    }); //just so that we can ignore these properties (not tween them)
    _registerComplexSpecialProp("border", {
      defaultValue: "0px solid #000",
      parser: function (t, e, p, cssp, pt, plugin) {
        return this.parseComplex(t.style, this.format(_getStyle(t, "borderTopWidth", _cs, false, "0px") + " " + _getStyle(t, "borderTopStyle", _cs, false, "solid") + " " + _getStyle(t, "borderTopColor", _cs, false, "#000")), this.format(e), pt, plugin);
      },
      color: true,
      formatter: function (v) {
        var a = v.split(" ");
        return a[0] + " " + (a[1] || "solid") + " " + (v.match(_colorExp) || ["#000"])[0];
      }
    });
    _registerComplexSpecialProp("float,cssFloat,styleFloat", {
      parser: function (t, e, p, cssp, pt, plugin) {
        var s = t.style,
          prop = "cssFloat" in s ? "cssFloat" : "styleFloat";
        return new CSSPropTween(s, prop, 0, 0, pt, -1, p, false, 0, s[prop], e);
      }
    });

    //opacity-related
    var _setIEOpacityRatio = function (v) {
      var t = this.t,
        //refers to the element's style property
        filters = t.filter || _getStyle(this.data, "filter"),
        val = this.s + this.c * v | 0,
        skip;
      if (val === 100) {
        //for older versions of IE that need to use a filter to apply opacity, we should remove the filter if opacity hits 1 in order to improve performance, but make sure there isn't a transform (matrix) or gradient in the filters.
        if (filters.indexOf("atrix(") === -1 && filters.indexOf("radient(") === -1 && filters.indexOf("oader(") === -1) {
          t.removeAttribute("filter");
          skip = !_getStyle(this.data, "filter"); //if a class is applied that has an alpha filter, it will take effect (we don't want that), so re-apply our alpha filter in that case. We must first remove it and then check.
        } else {
          t.filter = filters.replace(_alphaFilterExp, "");
          skip = true;
        }
      }
      if (!skip) {
        if (this.xn1) {
          t.filter = filters = filters || "alpha(opacity=" + val + ")"; //works around bug in IE7/8 that prevents changes to "visibility" from being applied properly if the filter is changed to a different alpha on the same frame.
        }
        if (filters.indexOf("opacity") === -1) {
          //only used if browser doesn't support the standard opacity style property (IE 7 and 8)
          if (val !== 0 || !this.xn1) {
            //bugs in IE7/8 won't render the filter properly if opacity is ADDED on the same frame/render as "visibility" changes (this.xn1 is 1 if this tween is an "autoAlpha" tween)
            t.filter = filters + " alpha(opacity=" + val + ")"; //we round the value because otherwise, bugs in IE7/8 can prevent "visibility" changes from being applied properly.
          }
        } else {
          t.filter = filters.replace(_opacityExp, "opacity=" + val);
        }
      }
    };
    _registerComplexSpecialProp("opacity,alpha,autoAlpha", {
      defaultValue: "1",
      parser: function (t, e, p, cssp, pt, plugin) {
        var b = parseFloat(_getStyle(t, "opacity", _cs, false, "1")),
          style = t.style,
          isAutoAlpha = p === "autoAlpha";
        if (typeof e === "string" && e.charAt(1) === "=") {
          e = (e.charAt(0) === "-" ? -1 : 1) * parseFloat(e.substr(2)) + b;
        }
        if (isAutoAlpha && b === 1 && _getStyle(t, "visibility", _cs) === "hidden" && e !== 0) {
          //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
          b = 0;
        }
        if (_supportsOpacity) {
          pt = new CSSPropTween(style, "opacity", b, e - b, pt);
        } else {
          pt = new CSSPropTween(style, "opacity", b * 100, (e - b) * 100, pt);
          pt.xn1 = isAutoAlpha ? 1 : 0; //we need to record whether or not this is an autoAlpha so that in the setRatio(), we know to duplicate the setting of the alpha in order to work around a bug in IE7 and IE8 that prevents changes to "visibility" from taking effect if the filter is changed to a different alpha(opacity) at the same time. Setting it to the SAME value first, then the new value works around the IE7/8 bug.
          style.zoom = 1; //helps correct an IE issue.
          pt.type = 2;
          pt.b = "alpha(opacity=" + pt.s + ")";
          pt.e = "alpha(opacity=" + (pt.s + pt.c) + ")";
          pt.data = t;
          pt.plugin = plugin;
          pt.setRatio = _setIEOpacityRatio;
        }
        if (isAutoAlpha) {
          //we have to create the "visibility" PropTween after the opacity one in the linked list so that they run in the order that works properly in IE8 and earlier
          pt = new CSSPropTween(style, "visibility", 0, 0, pt, -1, null, false, 0, b !== 0 ? "inherit" : "hidden", e === 0 ? "hidden" : "inherit");
          pt.xs0 = "inherit";
          cssp._overwriteProps.push(pt.n);
          cssp._overwriteProps.push(p);
        }
        return pt;
      }
    });
    var _removeProp = function (s, p) {
        if (p) {
          if (s.removeProperty) {
            s.removeProperty(p.replace(_capsExp, "-$1").toLowerCase());
          } else {
            //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
            s.removeAttribute(p);
          }
        }
      },
      _setClassNameRatio = function (v) {
        this.t._gsClassPT = this;
        if (v === 1 || v === 0) {
          this.t.className = v === 0 ? this.b : this.e;
          var mpt = this.data,
            //first MiniPropTween
            s = this.t.style;
          while (mpt) {
            if (!mpt.v) {
              _removeProp(s, mpt.p);
            } else {
              s[mpt.p] = mpt.v;
            }
            mpt = mpt._next;
          }
          if (v === 1 && this.t._gsClassPT === this) {
            this.t._gsClassPT = null;
          }
        } else if (this.t.className !== this.e) {
          this.t.className = this.e;
        }
      };
    _registerComplexSpecialProp("className", {
      parser: function (t, e, p, cssp, pt, plugin, vars) {
        var b = t.className,
          cssText = t.style.cssText,
          difData,
          bs,
          cnpt,
          cnptLookup,
          mpt;
        pt = cssp._classNamePT = new CSSPropTween(t, p, 0, 0, pt, 2);
        pt.setRatio = _setClassNameRatio;
        pt.pr = -11;
        _hasPriority = true;
        pt.b = b;
        bs = _getAllStyles(t, _cs);
        //if there's a className tween already operating on the target, force it to its end so that the necessary inline styles are removed and the class name is applied before we determine the end state (we don't want inline styles interfering that were there just for class-specific values)
        cnpt = t._gsClassPT;
        if (cnpt) {
          cnptLookup = {};
          mpt = cnpt.data; //first MiniPropTween which stores the inline styles - we need to force these so that the inline styles don't contaminate things. Otherwise, there's a small chance that a tween could start and the inline values match the destination values and they never get cleaned.
          while (mpt) {
            cnptLookup[mpt.p] = 1;
            mpt = mpt._next;
          }
          cnpt.setRatio(1);
        }
        t._gsClassPT = pt;
        pt.e = e.charAt(1) !== "=" ? e : b.replace(new RegExp("\\s*\\b" + e.substr(2) + "\\b"), "") + (e.charAt(0) === "+" ? " " + e.substr(2) : "");
        if (cssp._tween._duration) {
          //if it's a zero-duration tween, there's no need to tween anything or parse the data. In fact, if we switch classes temporarily (which we must do for proper parsing) and the class has a transition applied, it could cause a quick flash to the end state and back again initially in some browsers.
          t.className = pt.e;
          difData = _cssDif(t, bs, _getAllStyles(t), vars, cnptLookup);
          t.className = b;
          pt.data = difData.firstMPT;
          t.style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
          pt = pt.xfirst = cssp.parse(t, difData.difs, pt, plugin); //we record the CSSPropTween as the xfirst so that we can handle overwriting propertly (if "className" gets overwritten, we must kill all the properties associated with the className part of the tween, so we can loop through from xfirst to the pt itself)
        }
        return pt;
      }
    });
    var _setClearPropsRatio = function (v) {
      if (v === 1 || v === 0) if (this.data._totalTime === this.data._totalDuration && this.data.data !== "isFromStart") {
        //this.data refers to the tween. Only clear at the END of the tween (remember, from() tweens make the ratio go from 1 to 0, so we can't just check that and if the tween is the zero-duration one that's created internally to render the starting values in a from() tween, ignore that because otherwise, for example, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in).
        var s = this.t.style,
          transformParse = _specialProps.transform.parse,
          a,
          p,
          i,
          clearTransform;
        if (this.e === "all") {
          s.cssText = "";
          clearTransform = true;
        } else {
          a = this.e.split(",");
          i = a.length;
          while (--i > -1) {
            p = a[i];
            if (_specialProps[p]) {
              if (_specialProps[p].parse === transformParse) {
                clearTransform = true;
              } else {
                p = p === "transformOrigin" ? _transformOriginProp : _specialProps[p].p; //ensures that special properties use the proper browser-specific property name, like "scaleX" might be "-webkit-transform" or "boxShadow" might be "-moz-box-shadow"
              }
            }
            _removeProp(s, p);
          }
        }
        if (clearTransform) {
          _removeProp(s, _transformProp);
          if (this.t._gsTransform) {
            delete this.t._gsTransform;
          }
        }
      }
    };
    _registerComplexSpecialProp("clearProps", {
      parser: function (t, e, p, cssp, pt) {
        pt = new CSSPropTween(t, p, 0, 0, pt, 2);
        pt.setRatio = _setClearPropsRatio;
        pt.e = e;
        pt.pr = -10;
        pt.data = cssp._tween;
        _hasPriority = true;
        return pt;
      }
    });
    p = "bezier,throwProps,physicsProps,physics2D".split(",");
    i = p.length;
    while (i--) {
      _registerPluginProp(p[i]);
    }
    p = CSSPlugin.prototype;
    p._firstPT = null;

    //gets called when the tween renders for the first time. This kicks everything off, recording start/end values, etc.
    p._onInitTween = function (target, vars, tween) {
      if (!target.nodeType) {
        //css is only for dom elements
        return false;
      }
      this._target = target;
      this._tween = tween;
      this._vars = vars;
      _autoRound = vars.autoRound;
      _hasPriority = false;
      _suffixMap = vars.suffixMap || CSSPlugin.suffixMap;
      _cs = _getComputedStyle(target, "");
      _overwriteProps = this._overwriteProps;
      var style = target.style,
        v,
        pt,
        pt2,
        first,
        last,
        next,
        zIndex,
        tpt,
        threeD;
      if (_reqSafariFix) if (style.zIndex === "") {
        v = _getStyle(target, "zIndex", _cs);
        if (v === "auto" || v === "") {
          //corrects a bug in [non-Android] Safari that prevents it from repainting elements in their new positions if they don't have a zIndex set. We also can't just apply this inside _parseTransform() because anything that's moved in any way (like using "left" or "top" instead of transforms like "x" and "y") can be affected, so it is best to ensure that anything that's tweening has a z-index. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly. Plus zIndex is less memory-intensive.
          style.zIndex = 0;
        }
      }
      if (typeof vars === "string") {
        first = style.cssText;
        v = _getAllStyles(target, _cs);
        style.cssText = first + ";" + vars;
        v = _cssDif(target, v, _getAllStyles(target)).difs;
        if (!_supportsOpacity && _opacityValExp.test(vars)) {
          v.opacity = parseFloat(RegExp.$1);
        }
        vars = v;
        style.cssText = first;
      }
      this._firstPT = pt = this.parse(target, vars, null);
      if (this._transformType) {
        threeD = this._transformType === 3;
        if (!_transformProp) {
          style.zoom = 1; //helps correct an IE issue.
        } else if (_isSafari) {
          _reqSafariFix = true;
          //if zIndex isn't set, iOS Safari doesn't repaint things correctly sometimes (seemingly at random).
          if (style.zIndex === "") {
            zIndex = _getStyle(target, "zIndex", _cs);
            if (zIndex === "auto" || zIndex === "") {
              style.zIndex = 0;
            }
          }
          //Setting WebkitBackfaceVisibility corrects 3 bugs:
          // 1) [non-Android] Safari skips rendering changes to "top" and "left" that are made on the same frame/render as a transform update.
          // 2) iOS Safari sometimes neglects to repaint elements in their new positions. Setting "WebkitPerspective" to a non-zero value worked too except that on iOS Safari things would flicker randomly.
          // 3) Safari sometimes displayed odd artifacts when tweening the transform (or WebkitTransform) property, like ghosts of the edges of the element remained. Definitely a browser bug.
          //Note: we allow the user to override the auto-setting by defining WebkitBackfaceVisibility in the vars of the tween.
          if (_isSafariLT6) {
            style.WebkitBackfaceVisibility = this._vars.WebkitBackfaceVisibility || (threeD ? "visible" : "hidden");
          }
        }
        pt2 = pt;
        while (pt2 && pt2._next) {
          pt2 = pt2._next;
        }
        tpt = new CSSPropTween(target, "transform", 0, 0, null, 2);
        this._linkCSSP(tpt, null, pt2);
        tpt.setRatio = threeD && _supports3D ? _set3DTransformRatio : _transformProp ? _set2DTransformRatio : _setIETransformRatio;
        tpt.data = this._transform || _getTransform(target, _cs, true);
        _overwriteProps.pop(); //we don't want to force the overwrite of all "transform" tweens of the target - we only care about individual transform properties like scaleX, rotation, etc. The CSSPropTween constructor automatically adds the property to _overwriteProps which is why we need to pop() here.
      }
      if (_hasPriority) {
        //reorders the linked list in order of pr (priority)
        while (pt) {
          next = pt._next;
          pt2 = first;
          while (pt2 && pt2.pr > pt.pr) {
            pt2 = pt2._next;
          }
          if (pt._prev = pt2 ? pt2._prev : last) {
            pt._prev._next = pt;
          } else {
            first = pt;
          }
          if (pt._next = pt2) {
            pt2._prev = pt;
          } else {
            last = pt;
          }
          pt = next;
        }
        this._firstPT = first;
      }
      return true;
    };
    p.parse = function (target, vars, pt, plugin) {
      var style = target.style,
        p,
        sp,
        bn,
        en,
        bs,
        es,
        bsfx,
        esfx,
        isStr,
        rel;
      for (p in vars) {
        es = vars[p]; //ending value string
        sp = _specialProps[p]; //SpecialProp lookup.
        if (sp) {
          pt = sp.parse(target, es, p, this, pt, plugin, vars);
        } else {
          bs = _getStyle(target, p, _cs) + "";
          isStr = typeof es === "string";
          if (p === "color" || p === "fill" || p === "stroke" || p.indexOf("Color") !== -1 || isStr && _rgbhslExp.test(es)) {
            //Opera uses background: to define color sometimes in addition to backgroundColor:
            if (!isStr) {
              es = _parseColor(es);
              es = (es.length > 3 ? "rgba(" : "rgb(") + es.join(",") + ")";
            }
            pt = _parseComplex(style, p, bs, es, true, "transparent", pt, 0, plugin);
          } else if (isStr && (es.indexOf(" ") !== -1 || es.indexOf(",") !== -1)) {
            pt = _parseComplex(style, p, bs, es, true, null, pt, 0, plugin);
          } else {
            bn = parseFloat(bs);
            bsfx = bn || bn === 0 ? bs.substr((bn + "").length) : ""; //remember, bs could be non-numeric like "normal" for fontWeight, so we should default to a blank suffix in that case.

            if (bs === "" || bs === "auto") {
              if (p === "width" || p === "height") {
                bn = _getDimension(target, p, _cs);
                bsfx = "px";
              } else if (p === "left" || p === "top") {
                bn = _calculateOffset(target, p, _cs);
                bsfx = "px";
              } else {
                bn = p !== "opacity" ? 0 : 1;
                bsfx = "";
              }
            }
            rel = isStr && es.charAt(1) === "=";
            if (rel) {
              en = parseInt(es.charAt(0) + "1", 10);
              es = es.substr(2);
              en *= parseFloat(es);
              esfx = es.replace(_suffixExp, "");
            } else {
              en = parseFloat(es);
              esfx = isStr ? es.substr((en + "").length) || "" : "";
            }
            if (esfx === "") {
              esfx = _suffixMap[p] || bsfx; //populate the end suffix, prioritizing the map, then if none is found, use the beginning suffix.
            }
            es = en || en === 0 ? (rel ? en + bn : en) + esfx : vars[p]; //ensures that any += or -= prefixes are taken care of. Record the end value before normalizing the suffix because we always want to end the tween on exactly what they intended even if it doesn't match the beginning value's suffix.

            //if the beginning/ending suffixes don't match, normalize them...
            if (bsfx !== esfx) if (esfx !== "") if (en || en === 0) if (bn || bn === 0) {
              bn = _convertToPixels(target, p, bn, bsfx);
              if (esfx === "%") {
                bn /= _convertToPixels(target, p, 100, "%") / 100;
                if (bn > 100) {
                  //extremely rare
                  bn = 100;
                }
                if (vars.strictUnits !== true) {
                  //some browsers report only "px" values instead of allowing "%" with getComputedStyle(), so we assume that if we're tweening to a %, we should start there too unless strictUnits:true is defined. This approach is particularly useful for responsive designs that use from() tweens.
                  bs = bn + "%";
                }
              } else if (esfx === "em") {
                bn /= _convertToPixels(target, p, 1, "em");

                //otherwise convert to pixels.
              } else {
                en = _convertToPixels(target, p, en, esfx);
                esfx = "px"; //we don't use bsfx after this, so we don't need to set it to px too.
              }
              if (rel) if (en || en === 0) {
                es = en + bn + esfx; //the changes we made affect relative calculations, so adjust the end value here.
              }
            }
            if (rel) {
              en += bn;
            }
            if ((bn || bn === 0) && (en || en === 0)) {
              //faster than isNaN(). Also, previously we required en !== bn but that doesn't really gain much performance and it prevents _parseToProxy() from working properly if beginning and ending values match but need to get tweened by an external plugin anyway. For example, a bezier tween where the target starts at left:0 and has these points: [{left:50},{left:0}] wouldn't work properly because when parsing the last point, it'd match the first (current) one and a non-tweening CSSPropTween would be recorded when we actually need a normal tween (type:0) so that things get updated during the tween properly.
              pt = new CSSPropTween(style, p, bn, en - bn, pt, 0, p, _autoRound !== false && (esfx === "px" || p === "zIndex"), 0, bs, es);
              pt.xs0 = esfx;
              //DEBUG: _log("tween "+p+" from "+pt.b+" ("+bn+esfx+") to "+pt.e+" with suffix: "+pt.xs0);
            } else if (style[p] === undefined || !es && (es + "" === "NaN" || es == null)) {
              _log("invalid " + p + " tween value: " + vars[p]);
            } else {
              pt = new CSSPropTween(style, p, en || bn || 0, 0, pt, -1, p, false, 0, bs, es);
              pt.xs0 = es === "none" && (p === "display" || p.indexOf("Style") !== -1) ? bs : es; //intermediate value should typically be set immediately (end value) except for "display" or things like borderTopStyle, borderBottomStyle, etc. which should use the beginning value during the tween.
              //DEBUG: _log("non-tweening value "+p+": "+pt.xs0);
            }
          }
        }
        if (plugin) if (pt && !pt.plugin) {
          pt.plugin = plugin;
        }
      }
      return pt;
    };

    //gets called every time the tween updates, passing the new ratio (typically a value between 0 and 1, but not always (for example, if an Elastic.easeOut is used, the value can jump above 1 mid-tween). It will always start and 0 and end at 1.
    p.setRatio = function (v) {
      var pt = this._firstPT,
        min = 0.000001,
        val,
        str,
        i;

      //at the end of the tween, we set the values to exactly what we received in order to make sure non-tweening values (like "position" or "float" or whatever) are set and so that if the beginning/ending suffixes (units) didn't match and we normalized to px, the value that the user passed in is used here. We check to see if the tween is at its beginning in case it's a from() tween in which case the ratio will actually go from 1 to 0 over the course of the tween (backwards).
      if (v === 1 && (this._tween._time === this._tween._duration || this._tween._time === 0)) {
        while (pt) {
          if (pt.type !== 2) {
            pt.t[pt.p] = pt.e;
          } else {
            pt.setRatio(v);
          }
          pt = pt._next;
        }
      } else if (v || !(this._tween._time === this._tween._duration || this._tween._time === 0) || this._tween._rawPrevTime === -0.000001) {
        while (pt) {
          val = pt.c * v + pt.s;
          if (pt.r) {
            val = val > 0 ? val + 0.5 | 0 : val - 0.5 | 0;
          } else if (val < min) if (val > -min) {
            val = 0;
          }
          if (!pt.type) {
            pt.t[pt.p] = val + pt.xs0;
          } else if (pt.type === 1) {
            //complex value (one that typically has multiple numbers inside a string, like "rect(5px,10px,20px,25px)"
            i = pt.l;
            if (i === 2) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2;
            } else if (i === 3) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3;
            } else if (i === 4) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4;
            } else if (i === 5) {
              pt.t[pt.p] = pt.xs0 + val + pt.xs1 + pt.xn1 + pt.xs2 + pt.xn2 + pt.xs3 + pt.xn3 + pt.xs4 + pt.xn4 + pt.xs5;
            } else {
              str = pt.xs0 + val + pt.xs1;
              for (i = 1; i < pt.l; i++) {
                str += pt["xn" + i] + pt["xs" + (i + 1)];
              }
              pt.t[pt.p] = str;
            }
          } else if (pt.type === -1) {
            //non-tweening value
            pt.t[pt.p] = pt.xs0;
          } else if (pt.setRatio) {
            //custom setRatio() for things like SpecialProps, external plugins, etc.
            pt.setRatio(v);
          }
          pt = pt._next;
        }

        //if the tween is reversed all the way back to the beginning, we need to restore the original values which may have different units (like % instead of px or em or whatever).
      } else {
        while (pt) {
          if (pt.type !== 2) {
            pt.t[pt.p] = pt.b;
          } else {
            pt.setRatio(v);
          }
          pt = pt._next;
        }
      }
    };

    /**
     * @private
     * Forces rendering of the target's transforms (rotation, scale, etc.) whenever the CSSPlugin's setRatio() is called.
     * Basically, this tells the CSSPlugin to create a CSSPropTween (type 2) after instantiation that runs last in the linked
     * list and calls the appropriate (3D or 2D) rendering function. We separate this into its own method so that we can call
     * it from other plugins like BezierPlugin if, for example, it needs to apply an autoRotation and this CSSPlugin
     * doesn't have any transform-related properties of its own. You can call this method as many times as you
     * want and it won't create duplicate CSSPropTweens.
     *
     * @param {boolean} threeD if true, it should apply 3D tweens (otherwise, just 2D ones are fine and typically faster)
     */
    p._enableTransforms = function (threeD) {
      this._transformType = threeD || this._transformType === 3 ? 3 : 2;
      this._transform = this._transform || _getTransform(this._target, _cs, true); //ensures that the element has a _gsTransform property with the appropriate values.
    };

    /** @private **/
    p._linkCSSP = function (pt, next, prev, remove) {
      if (pt) {
        if (next) {
          next._prev = pt;
        }
        if (pt._next) {
          pt._next._prev = pt._prev;
        }
        if (pt._prev) {
          pt._prev._next = pt._next;
        } else if (this._firstPT === pt) {
          this._firstPT = pt._next;
          remove = true; //just to prevent resetting this._firstPT 5 lines down in case pt._next is null. (optimized for speed)
        }
        if (prev) {
          prev._next = pt;
        } else if (!remove && this._firstPT === null) {
          this._firstPT = pt;
        }
        pt._next = next;
        pt._prev = prev;
      }
      return pt;
    };

    //we need to make sure that if alpha or autoAlpha is killed, opacity is too. And autoAlpha affects the "visibility" property.
    p._kill = function (lookup) {
      var copy = lookup,
        pt,
        p,
        xfirst;
      if (lookup.autoAlpha || lookup.alpha) {
        copy = {};
        for (p in lookup) {
          //copy the lookup so that we're not changing the original which may be passed elsewhere.
          copy[p] = lookup[p];
        }
        copy.opacity = 1;
        if (copy.autoAlpha) {
          copy.visibility = 1;
        }
      }
      if (lookup.className && (pt = this._classNamePT)) {
        //for className tweens, we need to kill any associated CSSPropTweens too; a linked list starts at the className's "xfirst".
        xfirst = pt.xfirst;
        if (xfirst && xfirst._prev) {
          this._linkCSSP(xfirst._prev, pt._next, xfirst._prev._prev); //break off the prev
        } else if (xfirst === this._firstPT) {
          this._firstPT = pt._next;
        }
        if (pt._next) {
          this._linkCSSP(pt._next, pt._next._next, xfirst._prev);
        }
        this._classNamePT = null;
      }
      return TweenPlugin.prototype._kill.call(this, copy);
    };

    //used by cascadeTo() for gathering all the style properties of each child element into an array for comparison.
    var _getChildStyles = function (e, props, targets) {
      var children, i, child, type;
      if (e.slice) {
        i = e.length;
        while (--i > -1) {
          _getChildStyles(e[i], props, targets);
        }
        return;
      }
      children = e.childNodes;
      i = children.length;
      while (--i > -1) {
        child = children[i];
        type = child.type;
        if (child.style) {
          props.push(_getAllStyles(child));
          if (targets) {
            targets.push(child);
          }
        }
        if ((type === 1 || type === 9 || type === 11) && child.childNodes.length) {
          _getChildStyles(child, props, targets);
        }
      }
    };

    /**
     * Typically only useful for className tweens that may affect child elements, this method creates a TweenLite
     * and then compares the style properties of all the target's child elements at the tween's start and end, and
     * if any are different, it also creates tweens for those and returns an array containing ALL of the resulting
     * tweens (so that you can easily add() them to a TimelineLite, for example). The reason this functionality is
     * wrapped into a separate static method of CSSPlugin instead of being integrated into all regular className tweens
     * is because it creates entirely new tweens that may have completely different targets than the original tween,
     * so if they were all lumped into the original tween instance, it would be inconsistent with the rest of the API
     * and it would create other problems. For example:
     *  - If I create a tween of elementA, that tween instance may suddenly change its target to include 50 other elements (unintuitive if I specifically defined the target I wanted)
     *  - We can't just create new independent tweens because otherwise, what happens if the original/parent tween is reversed or pause or dropped into a TimelineLite for tight control? You'd expect that tween's behavior to affect all the others.
     *  - Analyzing every style property of every child before and after the tween is an expensive operation when there are many children, so this behavior shouldn't be imposed on all className tweens by default, especially since it's probably rare that this extra functionality is needed.
     *
     * @param {Object} target object to be tweened
     * @param {number} Duration in seconds (or frames for frames-based tweens)
     * @param {Object} Object containing the end values, like {className:"newClass", ease:Linear.easeNone}
     * @return {Array} An array of TweenLite instances
     */
    CSSPlugin.cascadeTo = function (target, duration, vars) {
      var tween = TweenLite.to(target, duration, vars),
        results = [tween],
        b = [],
        e = [],
        targets = [],
        _reservedProps = TweenLite._internals.reservedProps,
        i,
        difs,
        p;
      target = tween._targets || tween.target;
      _getChildStyles(target, b, targets);
      tween.render(duration, true);
      _getChildStyles(target, e);
      tween.render(0, true);
      tween._enabled(true);
      i = targets.length;
      while (--i > -1) {
        difs = _cssDif(targets[i], b[i], e[i]);
        if (difs.firstMPT) {
          difs = difs.difs;
          for (p in vars) {
            if (_reservedProps[p]) {
              difs[p] = vars[p];
            }
          }
          results.push(TweenLite.to(targets[i], duration, difs));
        }
      }
      return results;
    };
    TweenPlugin.activate([CSSPlugin]);
    return CSSPlugin;
  }, true);

  /*
   * ----------------------------------------------------------------
   * RoundPropsPlugin
   * ----------------------------------------------------------------
   */
  (function () {
    var RoundPropsPlugin = window._gsDefine.plugin({
        propName: "roundProps",
        priority: -1,
        API: 2,
        //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
        init: function (target, value, tween) {
          this._tween = tween;
          return true;
        }
      }),
      p = RoundPropsPlugin.prototype;
    p._onInitAllProps = function () {
      var tween = this._tween,
        rp = tween.vars.roundProps instanceof Array ? tween.vars.roundProps : tween.vars.roundProps.split(","),
        i = rp.length,
        lookup = {},
        rpt = tween._propLookup.roundProps,
        prop,
        pt,
        next;
      while (--i > -1) {
        lookup[rp[i]] = 1;
      }
      i = rp.length;
      while (--i > -1) {
        prop = rp[i];
        pt = tween._firstPT;
        while (pt) {
          next = pt._next; //record here, because it may get removed
          if (pt.pg) {
            pt.t._roundProps(lookup, true);
          } else if (pt.n === prop) {
            this._add(pt.t, prop, pt.s, pt.c);
            //remove from linked list
            if (next) {
              next._prev = pt._prev;
            }
            if (pt._prev) {
              pt._prev._next = next;
            } else if (tween._firstPT === pt) {
              tween._firstPT = next;
            }
            pt._next = pt._prev = null;
            tween._propLookup[prop] = rpt;
          }
          pt = next;
        }
      }
      return false;
    };
    p._add = function (target, p, s, c) {
      this._addTween(target, p, s, s + c, p, true);
      this._overwriteProps.push(p);
    };
  })();

  /*
   * ----------------------------------------------------------------
   * AttrPlugin
   * ----------------------------------------------------------------
   */
  window._gsDefine.plugin({
    propName: "attr",
    API: 2,
    //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
    init: function (target, value, tween) {
      var p;
      if (typeof target.setAttribute !== "function") {
        return false;
      }
      this._target = target;
      this._proxy = {};
      for (p in value) {
        if (this._addTween(this._proxy, p, parseFloat(target.getAttribute(p)), value[p], p)) {
          this._overwriteProps.push(p);
        }
      }
      return true;
    },
    //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
    set: function (ratio) {
      this._super.setRatio.call(this, ratio);
      var props = this._overwriteProps,
        i = props.length,
        p;
      while (--i > -1) {
        p = props[i];
        this._target.setAttribute(p, this._proxy[p] + "");
      }
    }
  });

  /*
   * ----------------------------------------------------------------
   * DirectionalRotationPlugin
   * ----------------------------------------------------------------
   */
  window._gsDefine.plugin({
    propName: "directionalRotation",
    API: 2,
    //called when the tween renders for the first time. This is where initial values should be recorded and any setup routines should run.
    init: function (target, value, tween) {
      if (typeof value !== "object") {
        value = {
          rotation: value
        };
      }
      this.finals = {};
      var cap = value.useRadians === true ? Math.PI * 2 : 360,
        min = 0.000001,
        p,
        v,
        start,
        end,
        dif,
        split;
      for (p in value) {
        if (p !== "useRadians") {
          split = (value[p] + "").split("_");
          v = split[0];
          start = parseFloat(typeof target[p] !== "function" ? target[p] : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]());
          end = this.finals[p] = typeof v === "string" && v.charAt(1) === "=" ? start + parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) || 0;
          dif = end - start;
          if (split.length) {
            v = split.join("_");
            if (v.indexOf("short") !== -1) {
              dif = dif % cap;
              if (dif !== dif % (cap / 2)) {
                dif = dif < 0 ? dif + cap : dif - cap;
              }
            }
            if (v.indexOf("_cw") !== -1 && dif < 0) {
              dif = (dif + cap * 9999999999) % cap - (dif / cap | 0) * cap;
            } else if (v.indexOf("ccw") !== -1 && dif > 0) {
              dif = (dif - cap * 9999999999) % cap - (dif / cap | 0) * cap;
            }
          }
          if (dif > min || dif < -min) {
            this._addTween(target, p, start, start + dif, p);
            this._overwriteProps.push(p);
          }
        }
      }
      return true;
    },
    //called each time the values should be updated, and the ratio gets passed as the only parameter (typically it's a value between 0 and 1, but it can exceed those when using an ease like Elastic.easeOut or Back.easeOut, etc.)
    set: function (ratio) {
      var pt;
      if (ratio !== 1) {
        this._super.setRatio.call(this, ratio);
      } else {
        pt = this._firstPT;
        while (pt) {
          if (pt.f) {
            pt.t[pt.p](this.finals[pt.p]);
          } else {
            pt.t[pt.p] = this.finals[pt.p];
          }
          pt = pt._next;
        }
      }
    }
  })._autoCSS = true;

  /*
   * ----------------------------------------------------------------
   * EasePack
   * ----------------------------------------------------------------
   */
  window._gsDefine("easing.Back", ["easing.Ease"], function (Ease) {
    var w = window.GreenSockGlobals || window,
      gs = w.com.greensock,
      _2PI = Math.PI * 2,
      _HALF_PI = Math.PI / 2,
      _class = gs._class,
      _create = function (n, f) {
        var C = _class("easing." + n, function () {}, true),
          p = C.prototype = new Ease();
        p.constructor = C;
        p.getRatio = f;
        return C;
      },
      _easeReg = Ease.register || function () {},
      //put an empty function in place just as a safety measure in case someone loads an OLD version of TweenLite.js where Ease.register doesn't exist.
      _wrap = function (name, EaseOut, EaseIn, EaseInOut, aliases) {
        var C = _class("easing." + name, {
          easeOut: new EaseOut(),
          easeIn: new EaseIn(),
          easeInOut: new EaseInOut()
        }, true);
        _easeReg(C, name);
        return C;
      },
      EasePoint = function (time, value, next) {
        this.t = time;
        this.v = value;
        if (next) {
          this.next = next;
          next.prev = this;
          this.c = next.v - value;
          this.gap = next.t - time;
        }
      },
      //Back
      _createBack = function (n, f) {
        var C = _class("easing." + n, function (overshoot) {
            this._p1 = overshoot || overshoot === 0 ? overshoot : 1.70158;
            this._p2 = this._p1 * 1.525;
          }, true),
          p = C.prototype = new Ease();
        p.constructor = C;
        p.getRatio = f;
        p.config = function (overshoot) {
          return new C(overshoot);
        };
        return C;
      },
      Back = _wrap("Back", _createBack("BackOut", function (p) {
        return (p = p - 1) * p * ((this._p1 + 1) * p + this._p1) + 1;
      }), _createBack("BackIn", function (p) {
        return p * p * ((this._p1 + 1) * p - this._p1);
      }), _createBack("BackInOut", function (p) {
        return (p *= 2) < 1 ? 0.5 * p * p * ((this._p2 + 1) * p - this._p2) : 0.5 * ((p -= 2) * p * ((this._p2 + 1) * p + this._p2) + 2);
      })),
      //SlowMo
      SlowMo = _class("easing.SlowMo", function (linearRatio, power, yoyoMode) {
        power = power || power === 0 ? power : 0.7;
        if (linearRatio == null) {
          linearRatio = 0.7;
        } else if (linearRatio > 1) {
          linearRatio = 1;
        }
        this._p = linearRatio !== 1 ? power : 0;
        this._p1 = (1 - linearRatio) / 2;
        this._p2 = linearRatio;
        this._p3 = this._p1 + this._p2;
        this._calcEnd = yoyoMode === true;
      }, true),
      p = SlowMo.prototype = new Ease(),
      SteppedEase,
      RoughEase,
      _createElastic;
    p.constructor = SlowMo;
    p.getRatio = function (p) {
      var r = p + (0.5 - p) * this._p;
      if (p < this._p1) {
        return this._calcEnd ? 1 - (p = 1 - p / this._p1) * p : r - (p = 1 - p / this._p1) * p * p * p * r;
      } else if (p > this._p3) {
        return this._calcEnd ? 1 - (p = (p - this._p3) / this._p1) * p : r + (p - r) * (p = (p - this._p3) / this._p1) * p * p * p;
      }
      return this._calcEnd ? 1 : r;
    };
    SlowMo.ease = new SlowMo(0.7, 0.7);
    p.config = SlowMo.config = function (linearRatio, power, yoyoMode) {
      return new SlowMo(linearRatio, power, yoyoMode);
    };

    //SteppedEase
    SteppedEase = _class("easing.SteppedEase", function (steps) {
      steps = steps || 1;
      this._p1 = 1 / steps;
      this._p2 = steps + 1;
    }, true);
    p = SteppedEase.prototype = new Ease();
    p.constructor = SteppedEase;
    p.getRatio = function (p) {
      if (p < 0) {
        p = 0;
      } else if (p >= 1) {
        p = 0.999999999;
      }
      return (this._p2 * p >> 0) * this._p1;
    };
    p.config = SteppedEase.config = function (steps) {
      return new SteppedEase(steps);
    };

    //RoughEase
    RoughEase = _class("easing.RoughEase", function (vars) {
      vars = vars || {};
      var taper = vars.taper || "none",
        a = [],
        cnt = 0,
        points = (vars.points || 20) | 0,
        i = points,
        randomize = vars.randomize !== false,
        clamp = vars.clamp === true,
        template = vars.template instanceof Ease ? vars.template : null,
        strength = typeof vars.strength === "number" ? vars.strength * 0.4 : 0.4,
        x,
        y,
        bump,
        invX,
        obj,
        pnt;
      while (--i > -1) {
        x = randomize ? Math.random() : 1 / points * i;
        y = template ? template.getRatio(x) : x;
        if (taper === "none") {
          bump = strength;
        } else if (taper === "out") {
          invX = 1 - x;
          bump = invX * invX * strength;
        } else if (taper === "in") {
          bump = x * x * strength;
        } else if (x < 0.5) {
          //"both" (start)
          invX = x * 2;
          bump = invX * invX * 0.5 * strength;
        } else {
          //"both" (end)
          invX = (1 - x) * 2;
          bump = invX * invX * 0.5 * strength;
        }
        if (randomize) {
          y += Math.random() * bump - bump * 0.5;
        } else if (i % 2) {
          y += bump * 0.5;
        } else {
          y -= bump * 0.5;
        }
        if (clamp) {
          if (y > 1) {
            y = 1;
          } else if (y < 0) {
            y = 0;
          }
        }
        a[cnt++] = {
          x: x,
          y: y
        };
      }
      a.sort(function (a, b) {
        return a.x - b.x;
      });
      pnt = new EasePoint(1, 1, null);
      i = points;
      while (--i > -1) {
        obj = a[i];
        pnt = new EasePoint(obj.x, obj.y, pnt);
      }
      this._prev = new EasePoint(0, 0, pnt.t !== 0 ? pnt : pnt.next);
    }, true);
    p = RoughEase.prototype = new Ease();
    p.constructor = RoughEase;
    p.getRatio = function (p) {
      var pnt = this._prev;
      if (p > pnt.t) {
        while (pnt.next && p >= pnt.t) {
          pnt = pnt.next;
        }
        pnt = pnt.prev;
      } else {
        while (pnt.prev && p <= pnt.t) {
          pnt = pnt.prev;
        }
      }
      this._prev = pnt;
      return pnt.v + (p - pnt.t) / pnt.gap * pnt.c;
    };
    p.config = function (vars) {
      return new RoughEase(vars);
    };
    RoughEase.ease = new RoughEase();

    //Bounce
    _wrap("Bounce", _create("BounceOut", function (p) {
      if (p < 1 / 2.75) {
        return 7.5625 * p * p;
      } else if (p < 2 / 2.75) {
        return 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
      } else if (p < 2.5 / 2.75) {
        return 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
      }
      return 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
    }), _create("BounceIn", function (p) {
      if ((p = 1 - p) < 1 / 2.75) {
        return 1 - 7.5625 * p * p;
      } else if (p < 2 / 2.75) {
        return 1 - (7.5625 * (p -= 1.5 / 2.75) * p + 0.75);
      } else if (p < 2.5 / 2.75) {
        return 1 - (7.5625 * (p -= 2.25 / 2.75) * p + 0.9375);
      }
      return 1 - (7.5625 * (p -= 2.625 / 2.75) * p + 0.984375);
    }), _create("BounceInOut", function (p) {
      var invert = p < 0.5;
      if (invert) {
        p = 1 - p * 2;
      } else {
        p = p * 2 - 1;
      }
      if (p < 1 / 2.75) {
        p = 7.5625 * p * p;
      } else if (p < 2 / 2.75) {
        p = 7.5625 * (p -= 1.5 / 2.75) * p + 0.75;
      } else if (p < 2.5 / 2.75) {
        p = 7.5625 * (p -= 2.25 / 2.75) * p + 0.9375;
      } else {
        p = 7.5625 * (p -= 2.625 / 2.75) * p + 0.984375;
      }
      return invert ? (1 - p) * 0.5 : p * 0.5 + 0.5;
    }));

    //CIRC
    _wrap("Circ", _create("CircOut", function (p) {
      return Math.sqrt(1 - (p = p - 1) * p);
    }), _create("CircIn", function (p) {
      return -(Math.sqrt(1 - p * p) - 1);
    }), _create("CircInOut", function (p) {
      return (p *= 2) < 1 ? -0.5 * (Math.sqrt(1 - p * p) - 1) : 0.5 * (Math.sqrt(1 - (p -= 2) * p) + 1);
    }));

    //Elastic
    _createElastic = function (n, f, def) {
      var C = _class("easing." + n, function (amplitude, period) {
          this._p1 = amplitude || 1;
          this._p2 = period || def;
          this._p3 = this._p2 / _2PI * (Math.asin(1 / this._p1) || 0);
        }, true),
        p = C.prototype = new Ease();
      p.constructor = C;
      p.getRatio = f;
      p.config = function (amplitude, period) {
        return new C(amplitude, period);
      };
      return C;
    };
    _wrap("Elastic", _createElastic("ElasticOut", function (p) {
      return this._p1 * Math.pow(2, -10 * p) * Math.sin((p - this._p3) * _2PI / this._p2) + 1;
    }, 0.3), _createElastic("ElasticIn", function (p) {
      return -(this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2));
    }, 0.3), _createElastic("ElasticInOut", function (p) {
      return (p *= 2) < 1 ? -0.5 * (this._p1 * Math.pow(2, 10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2)) : this._p1 * Math.pow(2, -10 * (p -= 1)) * Math.sin((p - this._p3) * _2PI / this._p2) * 0.5 + 1;
    }, 0.45));

    //Expo
    _wrap("Expo", _create("ExpoOut", function (p) {
      return 1 - Math.pow(2, -10 * p);
    }), _create("ExpoIn", function (p) {
      return Math.pow(2, 10 * (p - 1)) - 0.001;
    }), _create("ExpoInOut", function (p) {
      return (p *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (p - 1)) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
    }));

    //Sine
    _wrap("Sine", _create("SineOut", function (p) {
      return Math.sin(p * _HALF_PI);
    }), _create("SineIn", function (p) {
      return -Math.cos(p * _HALF_PI) + 1;
    }), _create("SineInOut", function (p) {
      return -0.5 * (Math.cos(Math.PI * p) - 1);
    }));
    _class("easing.EaseLookup", {
      find: function (s) {
        return Ease.map[s];
      }
    }, true);

    //register the non-standard eases
    _easeReg(w.SlowMo, "SlowMo", "ease,");
    _easeReg(RoughEase, "RoughEase", "ease,");
    _easeReg(SteppedEase, "SteppedEase", "ease,");
    return Back;
  }, true);
});

/*
 * ----------------------------------------------------------------
 * Base classes like TweenLite, SimpleTimeline, Ease, Ticker, etc.
 * ----------------------------------------------------------------
 */
(function (window) {
  "use strict";

  var _globals = window.GreenSockGlobals || window;
  if (_globals.TweenLite) {
    return; //in case the core set of classes is already loaded, don't instantiate twice.
  }
  var _namespace = function (ns) {
      var a = ns.split("."),
        p = _globals,
        i;
      for (i = 0; i < a.length; i++) {
        p[a[i]] = p = p[a[i]] || {};
      }
      return p;
    },
    gs = _namespace("com.greensock"),
    _tinyNum = 0.0000000001,
    _slice = [].slice,
    _emptyFunc = function () {},
    _isArray = function () {
      //works around issues in iframe environments where the Array global isn't shared, thus if the object originates in a different window/iframe, "(obj instanceof Array)" will evaluate false. We added some speed optimizations to avoid Object.prototype.toString.call() unless it's absolutely necessary because it's VERY slow (like 20x slower)
      var toString = Object.prototype.toString,
        array = toString.call([]);
      return function (obj) {
        return obj instanceof Array || typeof obj === "object" && !!obj.push && toString.call(obj) === array;
      };
    }(),
    a,
    i,
    p,
    _ticker,
    _tickerActive,
    _defLookup = {},
    /**
     * @constructor
     * Defines a GreenSock class, optionally with an array of dependencies that must be instantiated first and passed into the definition.
     * This allows users to load GreenSock JS files in any order even if they have interdependencies (like CSSPlugin extends TweenPlugin which is
     * inside TweenLite.js, but if CSSPlugin is loaded first, it should wait to run its code until TweenLite.js loads and instantiates TweenPlugin
     * and then pass TweenPlugin to CSSPlugin's definition). This is all done automatically and internally.
     *
     * Every definition will be added to a "com.greensock" global object (typically window, but if a window.GreenSockGlobals object is found,
     * it will go there as of v1.7). For example, TweenLite will be found at window.com.greensock.TweenLite and since it's a global class that should be available anywhere,
     * it is ALSO referenced at window.TweenLite. However some classes aren't considered global, like the base com.greensock.core.Animation class, so
     * those will only be at the package like window.com.greensock.core.Animation. Again, if you define a GreenSockGlobals object on the window, everything
     * gets tucked neatly inside there instead of on the window directly. This allows you to do advanced things like load multiple versions of GreenSock
     * files and put them into distinct objects (imagine a banner ad uses a newer version but the main site uses an older one). In that case, you could
     * sandbox the banner one like:
     *
     * <script>
     *     var gs = window.GreenSockGlobals = {}; //the newer version we're about to load could now be referenced in a "gs" object, like gs.TweenLite.to(...). Use whatever alias you want as long as it's unique, "gs" or "banner" or whatever.
     * </script>
     * <script src="js/greensock/v1.7/TweenMax.js"></script>
     * <script>
     *     window.GreenSockGlobals = null; //reset it back to null so that the next load of TweenMax affects the window and we can reference things directly like TweenLite.to(...)
     * </script>
     * <script src="js/greensock/v1.6/TweenMax.js"></script>
     * <script>
     *     gs.TweenLite.to(...); //would use v1.7
     *     TweenLite.to(...); //would use v1.6
     * </script>
     *
     * @param {!string} ns The namespace of the class definition, leaving off "com.greensock." as that's assumed. For example, "TweenLite" or "plugins.CSSPlugin" or "easing.Back".
     * @param {!Array.<string>} dependencies An array of dependencies (described as their namespaces minus "com.greensock." prefix). For example ["TweenLite","plugins.TweenPlugin","core.Animation"]
     * @param {!function():Object} func The function that should be called and passed the resolved dependencies which will return the actual class for this definition.
     * @param {boolean=} global If true, the class will be added to the global scope (typically window unless you define a window.GreenSockGlobals object)
     */
    Definition = function (ns, dependencies, func, global) {
      this.sc = _defLookup[ns] ? _defLookup[ns].sc : []; //subclasses
      _defLookup[ns] = this;
      this.gsClass = null;
      this.func = func;
      var _classes = [];
      this.check = function (init) {
        var i = dependencies.length,
          missing = i,
          cur,
          a,
          n,
          cl;
        while (--i > -1) {
          if ((cur = _defLookup[dependencies[i]] || new Definition(dependencies[i], [])).gsClass) {
            _classes[i] = cur.gsClass;
            missing--;
          } else if (init) {
            cur.sc.push(this);
          }
        }
        if (missing === 0 && func) {
          a = ("com.greensock." + ns).split(".");
          n = a.pop();
          cl = _namespace(a.join("."))[n] = this.gsClass = func.apply(func, _classes);

          //exports to multiple environments
          if (global) {
            _globals[n] = cl; //provides a way to avoid global namespace pollution. By default, the main classes like TweenLite, Power1, Strong, etc. are added to window unless a GreenSockGlobals is defined. So if you want to have things added to a custom object instead, just do something like window.GreenSockGlobals = {} before loading any GreenSock files. You can even set up an alias like window.GreenSockGlobals = windows.gs = {} so that you can access everything like gs.TweenLite. Also remember that ALL classes are added to the window.com.greensock object (in their respective packages, like com.greensock.easing.Power1, com.greensock.TweenLite, etc.)
            if (typeof define === "function" && define.amd) {
              //AMD
              define((window.GreenSockAMDPath ? window.GreenSockAMDPath + "/" : "") + ns.split(".").join("/"), [], function () {
                return cl;
              });
            } else if ( true && module.exports) {
              //node
              module.exports = cl;
            }
          }
          for (i = 0; i < this.sc.length; i++) {
            this.sc[i].check();
          }
        }
      };
      this.check(true);
    },
    //used to create Definition instances (which basically registers a class that has dependencies).
    _gsDefine = window._gsDefine = function (ns, dependencies, func, global) {
      return new Definition(ns, dependencies, func, global);
    },
    //a quick way to create a class that doesn't have any dependencies. Returns the class, but first registers it in the GreenSock namespace so that other classes can grab it (other classes might be dependent on the class).
    _class = gs._class = function (ns, func, global) {
      func = func || function () {};
      _gsDefine(ns, [], function () {
        return func;
      }, global);
      return func;
    };
  _gsDefine.globals = _globals;

  /*
   * ----------------------------------------------------------------
   * Ease
   * ----------------------------------------------------------------
   */
  var _baseParams = [0, 0, 1, 1],
    _blankArray = [],
    Ease = _class("easing.Ease", function (func, extraParams, type, power) {
      this._func = func;
      this._type = type || 0;
      this._power = power || 0;
      this._params = extraParams ? _baseParams.concat(extraParams) : _baseParams;
    }, true),
    _easeMap = Ease.map = {},
    _easeReg = Ease.register = function (ease, names, types, create) {
      var na = names.split(","),
        i = na.length,
        ta = (types || "easeIn,easeOut,easeInOut").split(","),
        e,
        name,
        j,
        type;
      while (--i > -1) {
        name = na[i];
        e = create ? _class("easing." + name, null, true) : gs.easing[name] || {};
        j = ta.length;
        while (--j > -1) {
          type = ta[j];
          _easeMap[name + "." + type] = _easeMap[type + name] = e[type] = ease.getRatio ? ease : ease[type] || new ease();
        }
      }
    };
  p = Ease.prototype;
  p._calcEnd = false;
  p.getRatio = function (p) {
    if (this._func) {
      this._params[0] = p;
      return this._func.apply(null, this._params);
    }
    var t = this._type,
      pw = this._power,
      r = t === 1 ? 1 - p : t === 2 ? p : p < 0.5 ? p * 2 : (1 - p) * 2;
    if (pw === 1) {
      r *= r;
    } else if (pw === 2) {
      r *= r * r;
    } else if (pw === 3) {
      r *= r * r * r;
    } else if (pw === 4) {
      r *= r * r * r * r;
    }
    return t === 1 ? 1 - r : t === 2 ? r : p < 0.5 ? r / 2 : 1 - r / 2;
  };

  //create all the standard eases like Linear, Quad, Cubic, Quart, Quint, Strong, Power0, Power1, Power2, Power3, and Power4 (each with easeIn, easeOut, and easeInOut)
  a = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"];
  i = a.length;
  while (--i > -1) {
    p = a[i] + ",Power" + i;
    _easeReg(new Ease(null, null, 1, i), p, "easeOut", true);
    _easeReg(new Ease(null, null, 2, i), p, "easeIn" + (i === 0 ? ",easeNone" : ""));
    _easeReg(new Ease(null, null, 3, i), p, "easeInOut");
  }
  _easeMap.linear = gs.easing.Linear.easeIn;
  _easeMap.swing = gs.easing.Quad.easeInOut; //for jQuery folks

  /*
   * ----------------------------------------------------------------
   * EventDispatcher
   * ----------------------------------------------------------------
   */
  var EventDispatcher = _class("events.EventDispatcher", function (target) {
    this._listeners = {};
    this._eventTarget = target || this;
  });
  p = EventDispatcher.prototype;
  p.addEventListener = function (type, callback, scope, useParam, priority) {
    priority = priority || 0;
    var list = this._listeners[type],
      index = 0,
      listener,
      i;
    if (list == null) {
      this._listeners[type] = list = [];
    }
    i = list.length;
    while (--i > -1) {
      listener = list[i];
      if (listener.c === callback && listener.s === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.pr < priority) {
        index = i + 1;
      }
    }
    list.splice(index, 0, {
      c: callback,
      s: scope,
      up: useParam,
      pr: priority
    });
    if (this === _ticker && !_tickerActive) {
      _ticker.wake();
    }
  };
  p.removeEventListener = function (type, callback) {
    var list = this._listeners[type],
      i;
    if (list) {
      i = list.length;
      while (--i > -1) {
        if (list[i].c === callback) {
          list.splice(i, 1);
          return;
        }
      }
    }
  };
  p.dispatchEvent = function (type) {
    var list = this._listeners[type],
      i,
      t,
      listener;
    if (list) {
      i = list.length;
      t = this._eventTarget;
      while (--i > -1) {
        listener = list[i];
        if (listener.up) {
          listener.c.call(listener.s || t, {
            type: type,
            target: t
          });
        } else {
          listener.c.call(listener.s || t);
        }
      }
    }
  };

  /*
   * ----------------------------------------------------------------
   * Ticker
   * ----------------------------------------------------------------
   */
  var _reqAnimFrame = window.requestAnimationFrame,
    _cancelAnimFrame = window.cancelAnimationFrame,
    _getTime = Date.now || function () {
      return new Date().getTime();
    },
    _lastUpdate = _getTime();

  //now try to determine the requestAnimationFrame and cancelAnimationFrame functions and if none are found, we'll use a setTimeout()/clearTimeout() polyfill.
  a = ["ms", "moz", "webkit", "o"];
  i = a.length;
  while (--i > -1 && !_reqAnimFrame) {
    _reqAnimFrame = window[a[i] + "RequestAnimationFrame"];
    _cancelAnimFrame = window[a[i] + "CancelAnimationFrame"] || window[a[i] + "CancelRequestAnimationFrame"];
  }
  _class("Ticker", function (fps, useRAF) {
    var _self = this,
      _startTime = _getTime(),
      _useRAF = useRAF !== false && _reqAnimFrame,
      _fps,
      _req,
      _id,
      _gap,
      _nextTime,
      _tick = function (manual) {
        _lastUpdate = _getTime();
        _self.time = (_lastUpdate - _startTime) / 1000;
        var overlap = _self.time - _nextTime,
          dispatch;
        if (!_fps || overlap > 0 || manual === true) {
          _self.frame++;
          _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
          dispatch = true;
        }
        if (manual !== true) {
          //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
          _id = _req(_tick);
        }
        if (dispatch) {
          _self.dispatchEvent("tick");
        }
      };
    EventDispatcher.call(_self);
    _self.time = _self.frame = 0;
    _self.tick = function () {
      _tick(true);
    };
    _self.sleep = function () {
      if (_id == null) {
        return;
      }
      if (!_useRAF || !_cancelAnimFrame) {
        clearTimeout(_id);
      } else {
        _cancelAnimFrame(_id);
      }
      _req = _emptyFunc;
      _id = null;
      if (_self === _ticker) {
        _tickerActive = false;
      }
    };
    _self.wake = function () {
      if (_id !== null) {
        _self.sleep();
      }
      _req = _fps === 0 ? _emptyFunc : !_useRAF || !_reqAnimFrame ? function (f) {
        return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
      } : _reqAnimFrame;
      if (_self === _ticker) {
        _tickerActive = true;
      }
      _tick(2);
    };
    _self.fps = function (value) {
      if (!arguments.length) {
        return _fps;
      }
      _fps = value;
      _gap = 1 / (_fps || 60);
      _nextTime = this.time + _gap;
      _self.wake();
    };
    _self.useRAF = function (value) {
      if (!arguments.length) {
        return _useRAF;
      }
      _self.sleep();
      _useRAF = value;
      _self.fps(_fps);
    };
    _self.fps(fps);

    //a bug in iOS 6 Safari occasionally prevents the requestAnimationFrame from working initially, so we use a 1.5-second timeout that automatically falls back to setTimeout() if it senses this condition.
    setTimeout(function () {
      if (_useRAF && (!_id || _self.frame < 5)) {
        _self.useRAF(false);
      }
    }, 1500);
  });
  p = gs.Ticker.prototype = new gs.events.EventDispatcher();
  p.constructor = gs.Ticker;

  /*
   * ----------------------------------------------------------------
   * Animation
   * ----------------------------------------------------------------
   */
  var Animation = _class("core.Animation", function (duration, vars) {
    this.vars = vars = vars || {};
    this._duration = this._totalDuration = duration || 0;
    this._delay = Number(vars.delay) || 0;
    this._timeScale = 1;
    this._active = vars.immediateRender === true;
    this.data = vars.data;
    this._reversed = vars.reversed === true;
    if (!_rootTimeline) {
      return;
    }
    if (!_tickerActive) {
      //some browsers (like iOS 6 Safari) shut down JavaScript execution when the tab is disabled and they [occasionally] neglect to start up requestAnimationFrame again when returning - this code ensures that the engine starts up again properly.
      _ticker.wake();
    }
    var tl = this.vars.useFrames ? _rootFramesTimeline : _rootTimeline;
    tl.add(this, tl._time);
    if (this.vars.paused) {
      this.paused(true);
    }
  });
  _ticker = Animation.ticker = new gs.Ticker();
  p = Animation.prototype;
  p._dirty = p._gc = p._initted = p._paused = false;
  p._totalTime = p._time = 0;
  p._rawPrevTime = -1;
  p._next = p._last = p._onUpdate = p._timeline = p.timeline = null;
  p._paused = false;

  //some browsers (like iOS) occasionally drop the requestAnimationFrame event when the user switches to a different tab and then comes back again, so we use a 2-second setTimeout() to sense if/when that condition occurs and then wake() the ticker.
  var _checkTimeout = function () {
    if (_tickerActive && _getTime() - _lastUpdate > 2000) {
      _ticker.wake();
    }
    setTimeout(_checkTimeout, 2000);
  };
  _checkTimeout();
  p.play = function (from, suppressEvents) {
    if (arguments.length) {
      this.seek(from, suppressEvents);
    }
    return this.reversed(false).paused(false);
  };
  p.pause = function (atTime, suppressEvents) {
    if (arguments.length) {
      this.seek(atTime, suppressEvents);
    }
    return this.paused(true);
  };
  p.resume = function (from, suppressEvents) {
    if (arguments.length) {
      this.seek(from, suppressEvents);
    }
    return this.paused(false);
  };
  p.seek = function (time, suppressEvents) {
    return this.totalTime(Number(time), suppressEvents !== false);
  };
  p.restart = function (includeDelay, suppressEvents) {
    return this.reversed(false).paused(false).totalTime(includeDelay ? -this._delay : 0, suppressEvents !== false, true);
  };
  p.reverse = function (from, suppressEvents) {
    if (arguments.length) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }
    return this.reversed(true).paused(false);
  };
  p.render = function (time, suppressEvents, force) {
    //stub - we override this method in subclasses.
  };
  p.invalidate = function () {
    return this;
  };
  p.isActive = function () {
    var tl = this._timeline,
      //the 2 root timelines won't have a _timeline; they're always active.
      startTime = this._startTime,
      rawTime;
    return !tl || !this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= startTime && rawTime < startTime + this.totalDuration() / this._timeScale;
  };
  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }
    this._gc = !enabled;
    this._active = this.isActive();
    if (ignoreTimeline !== true) {
      if (enabled && !this.timeline) {
        this._timeline.add(this, this._startTime - this._delay);
      } else if (!enabled && this.timeline) {
        this._timeline._remove(this, true);
      }
    }
    return false;
  };
  p._kill = function (vars, target) {
    return this._enabled(false, false);
  };
  p.kill = function (vars, target) {
    this._kill(vars, target);
    return this;
  };
  p._uncache = function (includeSelf) {
    var tween = includeSelf ? this : this.timeline;
    while (tween) {
      tween._dirty = true;
      tween = tween.timeline;
    }
    return this;
  };
  p._swapSelfInParams = function (params) {
    var i = params.length,
      copy = params.concat();
    while (--i > -1) {
      if (params[i] === "{self}") {
        copy[i] = this;
      }
    }
    return copy;
  };

  //----Animation getters/setters --------------------------------------------------------

  p.eventCallback = function (type, callback, params, scope) {
    if ((type || "").substr(0, 2) === "on") {
      var v = this.vars;
      if (arguments.length === 1) {
        return v[type];
      }
      if (callback == null) {
        delete v[type];
      } else {
        v[type] = callback;
        v[type + "Params"] = _isArray(params) && params.join("").indexOf("{self}") !== -1 ? this._swapSelfInParams(params) : params;
        v[type + "Scope"] = scope;
      }
      if (type === "onUpdate") {
        this._onUpdate = callback;
      }
    }
    return this;
  };
  p.delay = function (value) {
    if (!arguments.length) {
      return this._delay;
    }
    if (this._timeline.smoothChildTiming) {
      this.startTime(this._startTime + value - this._delay);
    }
    this._delay = value;
    return this;
  };
  p.duration = function (value) {
    if (!arguments.length) {
      this._dirty = false;
      return this._duration;
    }
    this._duration = this._totalDuration = value;
    this._uncache(true); //true in case it's a TweenMax or TimelineMax that has a repeat - we'll need to refresh the totalDuration.
    if (this._timeline.smoothChildTiming) if (this._time > 0) if (this._time < this._duration) if (value !== 0) {
      this.totalTime(this._totalTime * (value / this._duration), true);
    }
    return this;
  };
  p.totalDuration = function (value) {
    this._dirty = false;
    return !arguments.length ? this._totalDuration : this.duration(value);
  };
  p.time = function (value, suppressEvents) {
    if (!arguments.length) {
      return this._time;
    }
    if (this._dirty) {
      this.totalDuration();
    }
    return this.totalTime(value > this._duration ? this._duration : value, suppressEvents);
  };
  p.totalTime = function (time, suppressEvents, uncapped) {
    if (!_tickerActive) {
      _ticker.wake();
    }
    if (!arguments.length) {
      return this._totalTime;
    }
    if (this._timeline) {
      if (time < 0 && !uncapped) {
        time += this.totalDuration();
      }
      if (this._timeline.smoothChildTiming) {
        if (this._dirty) {
          this.totalDuration();
        }
        var totalDuration = this._totalDuration,
          tl = this._timeline;
        if (time > totalDuration && !uncapped) {
          time = totalDuration;
        }
        this._startTime = (this._paused ? this._pauseTime : tl._time) - (!this._reversed ? time : totalDuration - time) / this._timeScale;
        if (!tl._dirty) {
          //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
          this._uncache(false);
        }
        //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The startTime of that child would get pushed out, but one of the ancestors may have completed.
        if (tl._timeline) {
          while (tl._timeline) {
            if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
              tl.totalTime(tl._totalTime, true);
            }
            tl = tl._timeline;
          }
        }
      }
      if (this._gc) {
        this._enabled(true, false);
      }
      if (this._totalTime !== time || this._duration === 0) {
        this.render(time, suppressEvents, false);
      }
    }
    return this;
  };
  p.progress = p.totalProgress = function (value, suppressEvents) {
    return !arguments.length ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
  };
  p.startTime = function (value) {
    if (!arguments.length) {
      return this._startTime;
    }
    if (value !== this._startTime) {
      this._startTime = value;
      if (this.timeline) if (this.timeline._sortChildren) {
        this.timeline.add(this, value - this._delay); //ensures that any necessary re-sequencing of Animations in the timeline occurs to make sure the rendering order is correct.
      }
    }
    return this;
  };
  p.timeScale = function (value) {
    if (!arguments.length) {
      return this._timeScale;
    }
    value = value || _tinyNum; //can't allow zero because it'll throw the math off
    if (this._timeline && this._timeline.smoothChildTiming) {
      var pauseTime = this._pauseTime,
        t = pauseTime || pauseTime === 0 ? pauseTime : this._timeline.totalTime();
      this._startTime = t - (t - this._startTime) * this._timeScale / value;
    }
    this._timeScale = value;
    return this._uncache(false);
  };
  p.reversed = function (value) {
    if (!arguments.length) {
      return this._reversed;
    }
    if (value != this._reversed) {
      this._reversed = value;
      this.totalTime(this._totalTime, true);
    }
    return this;
  };
  p.paused = function (value) {
    if (!arguments.length) {
      return this._paused;
    }
    if (value != this._paused) if (this._timeline) {
      if (!_tickerActive && !value) {
        _ticker.wake();
      }
      var tl = this._timeline,
        raw = tl.rawTime(),
        elapsed = raw - this._pauseTime;
      if (!value && tl.smoothChildTiming) {
        this._startTime += elapsed;
        this._uncache(false);
      }
      this._pauseTime = value ? raw : null;
      this._paused = value;
      this._active = this.isActive();
      if (!value && elapsed !== 0 && this._initted && this.duration()) {
        this.render(tl.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale, true, true); //in case the target's properties changed via some other tween or manual update by the user, we should force a render.
      }
    }
    if (this._gc && !value) {
      this._enabled(true, false);
    }
    return this;
  };

  /*
   * ----------------------------------------------------------------
   * SimpleTimeline
   * ----------------------------------------------------------------
   */
  var SimpleTimeline = _class("core.SimpleTimeline", function (vars) {
    Animation.call(this, 0, vars);
    this.autoRemoveChildren = this.smoothChildTiming = true;
  });
  p = SimpleTimeline.prototype = new Animation();
  p.constructor = SimpleTimeline;
  p.kill()._gc = false;
  p._first = p._last = null;
  p._sortChildren = false;
  p.add = p.insert = function (child, position, align, stagger) {
    var prevTween, st;
    child._startTime = Number(position || 0) + child._delay;
    if (child._paused) if (this !== child._timeline) {
      //we only adjust the _pauseTime if it wasn't in this timeline already. Remember, sometimes a tween will be inserted again into the same timeline when its startTime is changed so that the tweens in the TimelineLite/Max are re-ordered properly in the linked list (so everything renders in the proper order).
      child._pauseTime = child._startTime + (this.rawTime() - child._startTime) / child._timeScale;
    }
    if (child.timeline) {
      child.timeline._remove(child, true); //removes from existing timeline so that it can be properly added to this one.
    }
    child.timeline = child._timeline = this;
    if (child._gc) {
      child._enabled(true, true);
    }
    prevTween = this._last;
    if (this._sortChildren) {
      st = child._startTime;
      while (prevTween && prevTween._startTime > st) {
        prevTween = prevTween._prev;
      }
    }
    if (prevTween) {
      child._next = prevTween._next;
      prevTween._next = child;
    } else {
      child._next = this._first;
      this._first = child;
    }
    if (child._next) {
      child._next._prev = child;
    } else {
      this._last = child;
    }
    child._prev = prevTween;
    if (this._timeline) {
      this._uncache(true);
    }
    return this;
  };
  p._remove = function (tween, skipDisable) {
    if (tween.timeline === this) {
      if (!skipDisable) {
        tween._enabled(false, true);
      }
      tween.timeline = null;
      if (tween._prev) {
        tween._prev._next = tween._next;
      } else if (this._first === tween) {
        this._first = tween._next;
      }
      if (tween._next) {
        tween._next._prev = tween._prev;
      } else if (this._last === tween) {
        this._last = tween._prev;
      }
      if (this._timeline) {
        this._uncache(true);
      }
    }
    return this;
  };
  p.render = function (time, suppressEvents, force) {
    var tween = this._first,
      next;
    this._totalTime = this._time = this._rawPrevTime = time;
    while (tween) {
      next = tween._next; //record it here because the value could change after rendering...
      if (tween._active || time >= tween._startTime && !tween._paused) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render((!tween._dirty ? tween._totalDuration : tween.totalDuration()) - (time - tween._startTime) * tween._timeScale, suppressEvents, force);
        }
      }
      tween = next;
    }
  };
  p.rawTime = function () {
    if (!_tickerActive) {
      _ticker.wake();
    }
    return this._totalTime;
  };

  /*
   * ----------------------------------------------------------------
   * TweenLite
   * ----------------------------------------------------------------
   */
  var TweenLite = _class("TweenLite", function (target, duration, vars) {
      Animation.call(this, duration, vars);
      this.render = TweenLite.prototype.render; //speed optimization (avoid prototype lookup on this "hot" method)

      if (target == null) {
        throw "Cannot tween a null target.";
      }
      this.target = target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
      var isSelector = target.jquery || target.length && target !== window && target[0] && (target[0] === window || target[0].nodeType && target[0].style && !target.nodeType),
        overwrite = this.vars.overwrite,
        i,
        targ,
        targets;
      this._overwrite = overwrite = overwrite == null ? _overwriteLookup[TweenLite.defaultOverwrite] : typeof overwrite === "number" ? overwrite >> 0 : _overwriteLookup[overwrite];
      if ((isSelector || target instanceof Array || target.push && _isArray(target)) && typeof target[0] !== "number") {
        this._targets = targets = _slice.call(target, 0);
        this._propLookup = [];
        this._siblings = [];
        for (i = 0; i < targets.length; i++) {
          targ = targets[i];
          if (!targ) {
            targets.splice(i--, 1);
            continue;
          } else if (typeof targ === "string") {
            targ = targets[i--] = TweenLite.selector(targ); //in case it's an array of strings
            if (typeof targ === "string") {
              targets.splice(i + 1, 1); //to avoid an endless loop (can't imagine why the selector would return a string, but just in case)
            }
            continue;
          } else if (targ.length && targ !== window && targ[0] && (targ[0] === window || targ[0].nodeType && targ[0].style && !targ.nodeType)) {
            //in case the user is passing in an array of selector objects (like jQuery objects), we need to check one more level and pull things out if necessary. Also note that <select> elements pass all the criteria regarding length and the first child having style, so we must also check to ensure the target isn't an HTML node itself.
            targets.splice(i--, 1);
            this._targets = targets = targets.concat(_slice.call(targ, 0));
            continue;
          }
          this._siblings[i] = _register(targ, this, false);
          if (overwrite === 1) if (this._siblings[i].length > 1) {
            _applyOverwrite(targ, this, null, 1, this._siblings[i]);
          }
        }
      } else {
        this._propLookup = {};
        this._siblings = _register(target, this, false);
        if (overwrite === 1) if (this._siblings.length > 1) {
          _applyOverwrite(target, this, null, 1, this._siblings);
        }
      }
      if (this.vars.immediateRender || duration === 0 && this._delay === 0 && this.vars.immediateRender !== false) {
        this.render(-this._delay, false, true);
      }
    }, true),
    _isSelector = function (v) {
      return v.length && v !== window && v[0] && (v[0] === window || v[0].nodeType && v[0].style && !v.nodeType); //we cannot check "nodeType" if the target is window from within an iframe, otherwise it will trigger a security error in some browsers like Firefox.
    },
    _autoCSS = function (vars, target) {
      var css = {},
        p;
      for (p in vars) {
        if (!_reservedProps[p] && (!(p in target) || p === "x" || p === "y" || p === "width" || p === "height" || p === "className" || p === "border") && (!_plugins[p] || _plugins[p] && _plugins[p]._autoCSS)) {
          //note: <img> elements contain read-only "x" and "y" properties. We should also prioritize editing css width/height rather than the element's properties.
          css[p] = vars[p];
          delete vars[p];
        }
      }
      vars.css = css;
    };
  p = TweenLite.prototype = new Animation();
  p.constructor = TweenLite;
  p.kill()._gc = false;

  //----TweenLite defaults, overwrite management, and root updates ----------------------------------------------------

  p.ratio = 0;
  p._firstPT = p._targets = p._overwrittenProps = p._startAt = null;
  p._notifyPluginsOfEnabled = false;
  TweenLite.version = "1.11.2";
  TweenLite.defaultEase = p._ease = new Ease(null, null, 1, 1);
  TweenLite.defaultOverwrite = "auto";
  TweenLite.ticker = _ticker;
  TweenLite.autoSleep = true;
  TweenLite.selector = window.$ || window.jQuery || function (e) {
    if (window.$) {
      TweenLite.selector = window.$;
      return window.$(e);
    }
    return window.document ? window.document.getElementById(e.charAt(0) === "#" ? e.substr(1) : e) : e;
  };
  var _internals = TweenLite._internals = {
      isArray: _isArray,
      isSelector: _isSelector
    },
    //gives us a way to expose certain private values to other GreenSock classes without contaminating tha main TweenLite object.
    _plugins = TweenLite._plugins = {},
    _tweenLookup = TweenLite._tweenLookup = {},
    _tweenLookupNum = 0,
    _reservedProps = _internals.reservedProps = {
      ease: 1,
      delay: 1,
      overwrite: 1,
      onComplete: 1,
      onCompleteParams: 1,
      onCompleteScope: 1,
      useFrames: 1,
      runBackwards: 1,
      startAt: 1,
      onUpdate: 1,
      onUpdateParams: 1,
      onUpdateScope: 1,
      onStart: 1,
      onStartParams: 1,
      onStartScope: 1,
      onReverseComplete: 1,
      onReverseCompleteParams: 1,
      onReverseCompleteScope: 1,
      onRepeat: 1,
      onRepeatParams: 1,
      onRepeatScope: 1,
      easeParams: 1,
      yoyo: 1,
      immediateRender: 1,
      repeat: 1,
      repeatDelay: 1,
      data: 1,
      paused: 1,
      reversed: 1,
      autoCSS: 1
    },
    _overwriteLookup = {
      none: 0,
      all: 1,
      auto: 2,
      concurrent: 3,
      allOnStart: 4,
      preexisting: 5,
      "true": 1,
      "false": 0
    },
    _rootFramesTimeline = Animation._rootFramesTimeline = new SimpleTimeline(),
    _rootTimeline = Animation._rootTimeline = new SimpleTimeline();
  _rootTimeline._startTime = _ticker.time;
  _rootFramesTimeline._startTime = _ticker.frame;
  _rootTimeline._active = _rootFramesTimeline._active = true;
  Animation._updateRoot = function () {
    _rootTimeline.render((_ticker.time - _rootTimeline._startTime) * _rootTimeline._timeScale, false, false);
    _rootFramesTimeline.render((_ticker.frame - _rootFramesTimeline._startTime) * _rootFramesTimeline._timeScale, false, false);
    if (!(_ticker.frame % 120)) {
      //dump garbage every 120 frames...
      var i, a, p;
      for (p in _tweenLookup) {
        a = _tweenLookup[p].tweens;
        i = a.length;
        while (--i > -1) {
          if (a[i]._gc) {
            a.splice(i, 1);
          }
        }
        if (a.length === 0) {
          delete _tweenLookup[p];
        }
      }
      //if there are no more tweens in the root timelines, or if they're all paused, make the _timer sleep to reduce load on the CPU slightly
      p = _rootTimeline._first;
      if (!p || p._paused) if (TweenLite.autoSleep && !_rootFramesTimeline._first && _ticker._listeners.tick.length === 1) {
        while (p && p._paused) {
          p = p._next;
        }
        if (!p) {
          _ticker.sleep();
        }
      }
    }
  };
  _ticker.addEventListener("tick", Animation._updateRoot);
  var _register = function (target, tween, scrub) {
      var id = target._gsTweenID,
        a,
        i;
      if (!_tweenLookup[id || (target._gsTweenID = id = "t" + _tweenLookupNum++)]) {
        _tweenLookup[id] = {
          target: target,
          tweens: []
        };
      }
      if (tween) {
        a = _tweenLookup[id].tweens;
        a[i = a.length] = tween;
        if (scrub) {
          while (--i > -1) {
            if (a[i] === tween) {
              a.splice(i, 1);
            }
          }
        }
      }
      return _tweenLookup[id].tweens;
    },
    _applyOverwrite = function (target, tween, props, mode, siblings) {
      var i, changed, curTween, l;
      if (mode === 1 || mode >= 4) {
        l = siblings.length;
        for (i = 0; i < l; i++) {
          if ((curTween = siblings[i]) !== tween) {
            if (!curTween._gc) if (curTween._enabled(false, false)) {
              changed = true;
            }
          } else if (mode === 5) {
            break;
          }
        }
        return changed;
      }
      //NOTE: Add 0.0000000001 to overcome floating point errors that can cause the startTime to be VERY slightly off (when a tween's time() is set for example)
      var startTime = tween._startTime + _tinyNum,
        overlaps = [],
        oCount = 0,
        zeroDur = tween._duration === 0,
        globalStart;
      i = siblings.length;
      while (--i > -1) {
        if ((curTween = siblings[i]) === tween || curTween._gc || curTween._paused) {
          //ignore
        } else if (curTween._timeline !== tween._timeline) {
          globalStart = globalStart || _checkOverlap(tween, 0, zeroDur);
          if (_checkOverlap(curTween, globalStart, zeroDur) === 0) {
            overlaps[oCount++] = curTween;
          }
        } else if (curTween._startTime <= startTime) if (curTween._startTime + curTween.totalDuration() / curTween._timeScale + _tinyNum > startTime) if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
          overlaps[oCount++] = curTween;
        }
      }
      i = oCount;
      while (--i > -1) {
        curTween = overlaps[i];
        if (mode === 2) if (curTween._kill(props, target)) {
          changed = true;
        }
        if (mode !== 2 || !curTween._firstPT && curTween._initted) {
          if (curTween._enabled(false, false)) {
            //if all property tweens have been overwritten, kill the tween.
            changed = true;
          }
        }
      }
      return changed;
    },
    _checkOverlap = function (tween, reference, zeroDur) {
      var tl = tween._timeline,
        ts = tl._timeScale,
        t = tween._startTime;
      while (tl._timeline) {
        t += tl._startTime;
        ts *= tl._timeScale;
        if (tl._paused) {
          return -100;
        }
        tl = tl._timeline;
      }
      t /= ts;
      return t > reference ? t - reference : zeroDur && t === reference || !tween._initted && t - reference < 2 * _tinyNum ? _tinyNum : (t += tween.totalDuration() / tween._timeScale / ts) > reference + _tinyNum ? 0 : t - reference - _tinyNum;
    };

  //---- TweenLite instance methods -----------------------------------------------------------------------------

  p._init = function () {
    var v = this.vars,
      op = this._overwrittenProps,
      dur = this._duration,
      immediate = v.immediateRender,
      ease = v.ease,
      i,
      initPlugins,
      pt,
      p;
    if (v.startAt) {
      if (this._startAt) {
        this._startAt.render(-1, true); //if we've run a startAt previously (when the tween instantiated), we should revert it so that the values re-instantiate correctly particularly for relative tweens. Without this, a TweenLite.fromTo(obj, 1, {x:"+=100"}, {x:"-=100"}), for example, would actually jump to +=200 because the startAt would run twice, doubling the relative change.
      }
      v.startAt.overwrite = 0;
      v.startAt.immediateRender = true;
      this._startAt = TweenLite.to(this.target, 0, v.startAt);
      if (immediate) {
        if (this._time > 0) {
          this._startAt = null; //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in TimelineLite/Max instances where immediateRender was false (which is the default in the convenience methods like from()).
        } else if (dur !== 0) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a TimelineLite or TimelineMax, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (v.runBackwards && dur !== 0) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (this._startAt) {
        this._startAt.render(-1, true);
        this._startAt = null;
      } else {
        pt = {};
        for (p in v) {
          //copy props into a new object and skip any reserved props, otherwise onComplete or onUpdate or onStart could fire. We should, however, permit autoCSS to go through.
          if (!_reservedProps[p] || p === "autoCSS") {
            pt[p] = v[p];
          }
        }
        pt.overwrite = 0;
        pt.data = "isFromStart"; //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
        this._startAt = TweenLite.to(this.target, 0, pt);
        if (!v.immediateRender) {
          this._startAt.render(-1, true); //for tweens that aren't rendered immediately, we still need to use the _startAt to record the starting values so that we can revert to them if the parent timeline's playhead goes backward beyond the beginning, but we immediately revert the tween back otherwise the parent tween that's currently instantiating wouldn't see the wrong starting values (since they were changed by the _startAt tween)
        } else if (this._time === 0) {
          return;
        }
      }
    }
    if (!ease) {
      this._ease = TweenLite.defaultEase;
    } else if (ease instanceof Ease) {
      this._ease = v.easeParams instanceof Array ? ease.config.apply(ease, v.easeParams) : ease;
    } else {
      this._ease = typeof ease === "function" ? new Ease(ease, v.easeParams) : _easeMap[ease] || TweenLite.defaultEase;
    }
    this._easeType = this._ease._type;
    this._easePower = this._ease._power;
    this._firstPT = null;
    if (this._targets) {
      i = this._targets.length;
      while (--i > -1) {
        if (this._initProps(this._targets[i], this._propLookup[i] = {}, this._siblings[i], op ? op[i] : null)) {
          initPlugins = true;
        }
      }
    } else {
      initPlugins = this._initProps(this.target, this._propLookup, this._siblings, op);
    }
    if (initPlugins) {
      TweenLite._onPluginEvent("_onInitAllProps", this); //reorders the array in order of priority. Uses a static TweenPlugin method in order to minimize file size in TweenLite
    }
    if (op) if (!this._firstPT) if (typeof this.target !== "function") {
      //if all tweening properties have been overwritten, kill the tween. If the target is a function, it's probably a delayedCall so let it live.
      this._enabled(false, false);
    }
    if (v.runBackwards) {
      pt = this._firstPT;
      while (pt) {
        pt.s += pt.c;
        pt.c = -pt.c;
        pt = pt._next;
      }
    }
    this._onUpdate = v.onUpdate;
    this._initted = true;
  };
  p._initProps = function (target, propLookup, siblings, overwrittenProps) {
    var p, i, initPlugins, plugin, a, pt, v;
    if (target == null) {
      return false;
    }
    if (!this.vars.css) if (target.style) if (target !== window && target.nodeType) if (_plugins.css) if (this.vars.autoCSS !== false) {
      //it's so common to use TweenLite/Max to animate the css of DOM elements, we assume that if the target is a DOM element, that's what is intended (a convenience so that users don't have to wrap things in css:{}, although we still recommend it for a slight performance boost and better specificity). Note: we cannot check "nodeType" on the window inside an iframe.
      _autoCSS(this.vars, target);
    }
    for (p in this.vars) {
      v = this.vars[p];
      if (_reservedProps[p]) {
        if (v) if (v instanceof Array || v.push && _isArray(v)) if (v.join("").indexOf("{self}") !== -1) {
          this.vars[p] = v = this._swapSelfInParams(v, this);
        }
      } else if (_plugins[p] && (plugin = new _plugins[p]())._onInitTween(target, this.vars[p], this)) {
        //t - target 		[object]
        //p - property 		[string]
        //s - start			[number]
        //c - change		[number]
        //f - isFunction	[boolean]
        //n - name			[string]
        //pg - isPlugin 	[boolean]
        //pr - priority		[number]
        this._firstPT = pt = {
          _next: this._firstPT,
          t: plugin,
          p: "setRatio",
          s: 0,
          c: 1,
          f: true,
          n: p,
          pg: true,
          pr: plugin._priority
        };
        i = plugin._overwriteProps.length;
        while (--i > -1) {
          propLookup[plugin._overwriteProps[i]] = this._firstPT;
        }
        if (plugin._priority || plugin._onInitAllProps) {
          initPlugins = true;
        }
        if (plugin._onDisable || plugin._onEnable) {
          this._notifyPluginsOfEnabled = true;
        }
      } else {
        this._firstPT = propLookup[p] = pt = {
          _next: this._firstPT,
          t: target,
          p: p,
          f: typeof target[p] === "function",
          n: p,
          pg: false,
          pr: 0
        };
        pt.s = !pt.f ? parseFloat(target[p]) : target[p.indexOf("set") || typeof target["get" + p.substr(3)] !== "function" ? p : "get" + p.substr(3)]();
        pt.c = typeof v === "string" && v.charAt(1) === "=" ? parseInt(v.charAt(0) + "1", 10) * Number(v.substr(2)) : Number(v) - pt.s || 0;
      }
      if (pt) if (pt._next) {
        pt._next._prev = pt;
      }
    }
    if (overwrittenProps) if (this._kill(overwrittenProps, target)) {
      //another tween may have tried to overwrite properties of this tween before init() was called (like if two tweens start at the same time, the one created second will run first)
      return this._initProps(target, propLookup, siblings, overwrittenProps);
    }
    if (this._overwrite > 1) if (this._firstPT) if (siblings.length > 1) if (_applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
      this._kill(propLookup, target);
      return this._initProps(target, propLookup, siblings, overwrittenProps);
    }
    return initPlugins;
  };
  p.render = function (time, suppressEvents, force) {
    var prevTime = this._time,
      duration = this._duration,
      isComplete,
      callback,
      pt,
      rawPrevTime;
    if (time >= duration) {
      this._totalTime = this._time = duration;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
      if (!this._reversed) {
        isComplete = true;
        callback = "onComplete";
      }
      if (duration === 0) {
        //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
        rawPrevTime = this._rawPrevTime;
        if (time === 0 || rawPrevTime < 0 || rawPrevTime === _tinyNum) if (rawPrevTime !== time) {
          force = true;
          if (rawPrevTime > _tinyNum) {
            callback = "onReverseComplete";
          }
        }
        this._rawPrevTime = rawPrevTime = !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
      }
    } else if (time < 0.0000001) {
      //to work around occasional floating point math artifacts, round super small values to 0.
      this._totalTime = this._time = 0;
      this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
      if (prevTime !== 0 || duration === 0 && this._rawPrevTime > _tinyNum) {
        callback = "onReverseComplete";
        isComplete = this._reversed;
      }
      if (time < 0) {
        this._active = false;
        if (duration === 0) {
          //zero-duration tweens are tricky because we must discern the momentum/direction of time in order to determine whether the starting values should be rendered or the ending values. If the "playhead" of its timeline goes past the zero-duration tween in the forward direction or lands directly on it, the end values should be rendered, but if the timeline's "playhead" moves past it in the backward direction (from a postitive time to a negative time), the starting values must be rendered.
          if (this._rawPrevTime >= 0) {
            force = true;
          }
          this._rawPrevTime = rawPrevTime = !suppressEvents || time ? time : _tinyNum; //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect. We set the _rawPrevTime to be a precise tiny number to indicate this scenario rather than using another property/variable which would increase memory usage. This technique is less readable, but more efficient.
        }
      } else if (!this._initted) {
        //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
        force = true;
      }
    } else {
      this._totalTime = this._time = time;
      if (this._easeType) {
        var r = time / duration,
          type = this._easeType,
          pow = this._easePower;
        if (type === 1 || type === 3 && r >= 0.5) {
          r = 1 - r;
        }
        if (type === 3) {
          r *= 2;
        }
        if (pow === 1) {
          r *= r;
        } else if (pow === 2) {
          r *= r * r;
        } else if (pow === 3) {
          r *= r * r * r;
        } else if (pow === 4) {
          r *= r * r * r * r;
        }
        if (type === 1) {
          this.ratio = 1 - r;
        } else if (type === 2) {
          this.ratio = r;
        } else if (time / duration < 0.5) {
          this.ratio = r / 2;
        } else {
          this.ratio = 1 - r / 2;
        }
      } else {
        this.ratio = this._ease.getRatio(time / duration);
      }
    }
    if (this._time === prevTime && !force) {
      return;
    } else if (!this._initted) {
      this._init();
      if (!this._initted || this._gc) {
        //immediateRender tweens typically won't initialize until the playhead advances (_time is greater than 0) in order to ensure that overwriting occurs properly. Also, if all of the tweening properties have been overwritten (which would cause _gc to be true, as set in _init()), we shouldn't continue otherwise an onStart callback could be called for example.
        return;
      }
      //_ease is initially set to defaultEase, so now that init() has run, _ease is set properly and we need to recalculate the ratio. Overall this is faster than using conditional logic earlier in the method to avoid having to set ratio twice because we only init() once but renderTime() gets called VERY frequently.
      if (this._time && !isComplete) {
        this.ratio = this._ease.getRatio(this._time / duration);
      } else if (isComplete && this._ease._calcEnd) {
        this.ratio = this._ease.getRatio(this._time === 0 ? 0 : 1);
      }
    }
    if (!this._active) if (!this._paused && this._time !== prevTime && time >= 0) {
      this._active = true; //so that if the user renders a tween (as opposed to the timeline rendering it), the timeline is forced to re-render and align it with the proper time/frame on the next rendering cycle. Maybe the tween already finished but the user manually re-renders it as halfway done.
    }
    if (prevTime === 0) {
      if (this._startAt) {
        if (time >= 0) {
          this._startAt.render(time, suppressEvents, force);
        } else if (!callback) {
          callback = "_dummyGS"; //if no callback is defined, use a dummy value just so that the condition at the end evaluates as true because _startAt should render AFTER the normal render loop when the time is negative. We could handle this in a more intuitive way, of course, but the render loop is the MOST important thing to optimize, so this technique allows us to avoid adding extra conditional logic in a high-frequency area.
        }
      }
      if (this.vars.onStart) if (this._time !== 0 || duration === 0) if (!suppressEvents) {
        this.vars.onStart.apply(this.vars.onStartScope || this, this.vars.onStartParams || _blankArray);
      }
    }
    pt = this._firstPT;
    while (pt) {
      if (pt.f) {
        pt.t[pt.p](pt.c * this.ratio + pt.s);
      } else {
        pt.t[pt.p] = pt.c * this.ratio + pt.s;
      }
      pt = pt._next;
    }
    if (this._onUpdate) {
      if (time < 0) if (this._startAt && this._startTime) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        this._startAt.render(time, suppressEvents, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.
      }
      if (!suppressEvents) if (!(force && this._time === 0 && prevTime === 0)) {
        this._onUpdate.apply(this.vars.onUpdateScope || this, this.vars.onUpdateParams || _blankArray);
      }
    }
    if (callback) if (!this._gc) {
      //check _gc because there's a chance that kill() could be called in an onUpdate
      if (time < 0 && this._startAt && !this._onUpdate && this._startTime) {
        //if the tween is positioned at the VERY beginning (_startTime 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
        this._startAt.render(time, suppressEvents, force);
      }
      if (isComplete) {
        if (this._timeline.autoRemoveChildren) {
          this._enabled(false, false);
        }
        this._active = false;
      }
      if (!suppressEvents && this.vars[callback]) {
        this.vars[callback].apply(this.vars[callback + "Scope"] || this, this.vars[callback + "Params"] || _blankArray);
      }
      if (duration === 0 && this._rawPrevTime === _tinyNum && rawPrevTime !== _tinyNum) {
        //the onComplete or onReverseComplete could trigger movement of the playhead and for zero-duration tweens (which must discern direction) that land directly back on their start time, we don't want to fire again on the next render. Think of several addPause()'s in a timeline that forces the playhead to a certain spot, but what if it's already paused and another tween is tweening the "time" of the timeline? Each time it moves [forward] past that spot, it would move back, and since suppressEvents is true, it'd reset _rawPrevTime to _tinyNum so that when it begins again, the callback would fire (so ultimately it could bounce back and forth during that tween). Again, this is a very uncommon scenario, but possible nonetheless.
        this._rawPrevTime = 0;
      }
    }
  };
  p._kill = function (vars, target) {
    if (vars === "all") {
      vars = null;
    }
    if (vars == null) if (target == null || target === this.target) {
      return this._enabled(false, false);
    }
    target = typeof target !== "string" ? target || this._targets || this.target : TweenLite.selector(target) || target;
    var i, overwrittenProps, p, pt, propLookup, changed, killProps, record;
    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      while (--i > -1) {
        if (this._kill(vars, target[i])) {
          changed = true;
        }
      }
    } else {
      if (this._targets) {
        i = this._targets.length;
        while (--i > -1) {
          if (target === this._targets[i]) {
            propLookup = this._propLookup[i] || {};
            this._overwrittenProps = this._overwrittenProps || [];
            overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
            break;
          }
        }
      } else if (target !== this.target) {
        return false;
      } else {
        propLookup = this._propLookup;
        overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
      }
      if (propLookup) {
        killProps = vars || propLookup;
        record = vars !== overwrittenProps && overwrittenProps !== "all" && vars !== propLookup && (typeof vars !== "object" || !vars._tempKill); //_tempKill is a super-secret way to delete a particular tweening property but NOT have it remembered as an official overwritten property (like in BezierPlugin)
        for (p in killProps) {
          if (pt = propLookup[p]) {
            if (pt.pg && pt.t._kill(killProps)) {
              changed = true; //some plugins need to be notified so they can perform cleanup tasks first
            }
            if (!pt.pg || pt.t._overwriteProps.length === 0) {
              if (pt._prev) {
                pt._prev._next = pt._next;
              } else if (pt === this._firstPT) {
                this._firstPT = pt._next;
              }
              if (pt._next) {
                pt._next._prev = pt._prev;
              }
              pt._next = pt._prev = null;
            }
            delete propLookup[p];
          }
          if (record) {
            overwrittenProps[p] = 1;
          }
        }
        if (!this._firstPT && this._initted) {
          //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
          this._enabled(false, false);
        }
      }
    }
    return changed;
  };
  p.invalidate = function () {
    if (this._notifyPluginsOfEnabled) {
      TweenLite._onPluginEvent("_onDisable", this);
    }
    this._firstPT = null;
    this._overwrittenProps = null;
    this._onUpdate = null;
    this._startAt = null;
    this._initted = this._active = this._notifyPluginsOfEnabled = false;
    this._propLookup = this._targets ? {} : [];
    return this;
  };
  p._enabled = function (enabled, ignoreTimeline) {
    if (!_tickerActive) {
      _ticker.wake();
    }
    if (enabled && this._gc) {
      var targets = this._targets,
        i;
      if (targets) {
        i = targets.length;
        while (--i > -1) {
          this._siblings[i] = _register(targets[i], this, true);
        }
      } else {
        this._siblings = _register(this.target, this, true);
      }
    }
    Animation.prototype._enabled.call(this, enabled, ignoreTimeline);
    if (this._notifyPluginsOfEnabled) if (this._firstPT) {
      return TweenLite._onPluginEvent(enabled ? "_onEnable" : "_onDisable", this);
    }
    return false;
  };

  //----TweenLite static methods -----------------------------------------------------

  TweenLite.to = function (target, duration, vars) {
    return new TweenLite(target, duration, vars);
  };
  TweenLite.from = function (target, duration, vars) {
    vars.runBackwards = true;
    vars.immediateRender = vars.immediateRender != false;
    return new TweenLite(target, duration, vars);
  };
  TweenLite.fromTo = function (target, duration, fromVars, toVars) {
    toVars.startAt = fromVars;
    toVars.immediateRender = toVars.immediateRender != false && fromVars.immediateRender != false;
    return new TweenLite(target, duration, toVars);
  };
  TweenLite.delayedCall = function (delay, callback, params, scope, useFrames) {
    return new TweenLite(callback, 0, {
      delay: delay,
      onComplete: callback,
      onCompleteParams: params,
      onCompleteScope: scope,
      onReverseComplete: callback,
      onReverseCompleteParams: params,
      onReverseCompleteScope: scope,
      immediateRender: false,
      useFrames: useFrames,
      overwrite: 0
    });
  };
  TweenLite.set = function (target, vars) {
    return new TweenLite(target, 0, vars);
  };
  TweenLite.getTweensOf = function (target, onlyActive) {
    if (target == null) {
      return [];
    }
    target = typeof target !== "string" ? target : TweenLite.selector(target) || target;
    var i, a, j, t;
    if ((_isArray(target) || _isSelector(target)) && typeof target[0] !== "number") {
      i = target.length;
      a = [];
      while (--i > -1) {
        a = a.concat(TweenLite.getTweensOf(target[i], onlyActive));
      }
      i = a.length;
      //now get rid of any duplicates (tweens of arrays of objects could cause duplicates)
      while (--i > -1) {
        t = a[i];
        j = i;
        while (--j > -1) {
          if (t === a[j]) {
            a.splice(i, 1);
          }
        }
      }
    } else {
      a = _register(target).concat();
      i = a.length;
      while (--i > -1) {
        if (a[i]._gc || onlyActive && !a[i].isActive()) {
          a.splice(i, 1);
        }
      }
    }
    return a;
  };
  TweenLite.killTweensOf = TweenLite.killDelayedCallsTo = function (target, onlyActive, vars) {
    if (typeof onlyActive === "object") {
      vars = onlyActive; //for backwards compatibility (before "onlyActive" parameter was inserted)
      onlyActive = false;
    }
    var a = TweenLite.getTweensOf(target, onlyActive),
      i = a.length;
    while (--i > -1) {
      a[i]._kill(vars, target);
    }
  };

  /*
   * ----------------------------------------------------------------
   * TweenPlugin   (could easily be split out as a separate file/class, but included for ease of use (so that people don't need to include another <script> call before loading plugins which is easy to forget)
   * ----------------------------------------------------------------
   */
  var TweenPlugin = _class("plugins.TweenPlugin", function (props, priority) {
    this._overwriteProps = (props || "").split(",");
    this._propName = this._overwriteProps[0];
    this._priority = priority || 0;
    this._super = TweenPlugin.prototype;
  }, true);
  p = TweenPlugin.prototype;
  TweenPlugin.version = "1.10.1";
  TweenPlugin.API = 2;
  p._firstPT = null;
  p._addTween = function (target, prop, start, end, overwriteProp, round) {
    var c, pt;
    if (end != null && (c = typeof end === "number" || end.charAt(1) !== "=" ? Number(end) - start : parseInt(end.charAt(0) + "1", 10) * Number(end.substr(2)))) {
      this._firstPT = pt = {
        _next: this._firstPT,
        t: target,
        p: prop,
        s: start,
        c: c,
        f: typeof target[prop] === "function",
        n: overwriteProp || prop,
        r: round
      };
      if (pt._next) {
        pt._next._prev = pt;
      }
      return pt;
    }
  };
  p.setRatio = function (v) {
    var pt = this._firstPT,
      min = 0.000001,
      val;
    while (pt) {
      val = pt.c * v + pt.s;
      if (pt.r) {
        val = val + (val > 0 ? 0.5 : -0.5) | 0; //about 4x faster than Math.round()
      } else if (val < min) if (val > -min) {
        //prevents issues with converting very small numbers to strings in the browser
        val = 0;
      }
      if (pt.f) {
        pt.t[pt.p](val);
      } else {
        pt.t[pt.p] = val;
      }
      pt = pt._next;
    }
  };
  p._kill = function (lookup) {
    var a = this._overwriteProps,
      pt = this._firstPT,
      i;
    if (lookup[this._propName] != null) {
      this._overwriteProps = [];
    } else {
      i = a.length;
      while (--i > -1) {
        if (lookup[a[i]] != null) {
          a.splice(i, 1);
        }
      }
    }
    while (pt) {
      if (lookup[pt.n] != null) {
        if (pt._next) {
          pt._next._prev = pt._prev;
        }
        if (pt._prev) {
          pt._prev._next = pt._next;
          pt._prev = null;
        } else if (this._firstPT === pt) {
          this._firstPT = pt._next;
        }
      }
      pt = pt._next;
    }
    return false;
  };
  p._roundProps = function (lookup, value) {
    var pt = this._firstPT;
    while (pt) {
      if (lookup[this._propName] || pt.n != null && lookup[pt.n.split(this._propName + "_").join("")]) {
        //some properties that are very plugin-specific add a prefix named after the _propName plus an underscore, so we need to ignore that extra stuff here.
        pt.r = value;
      }
      pt = pt._next;
    }
  };
  TweenLite._onPluginEvent = function (type, tween) {
    var pt = tween._firstPT,
      changed,
      pt2,
      first,
      last,
      next;
    if (type === "_onInitAllProps") {
      //sorts the PropTween linked list in order of priority because some plugins need to render earlier/later than others, like MotionBlurPlugin applies its effects after all x/y/alpha tweens have rendered on each frame.
      while (pt) {
        next = pt._next;
        pt2 = first;
        while (pt2 && pt2.pr > pt.pr) {
          pt2 = pt2._next;
        }
        if (pt._prev = pt2 ? pt2._prev : last) {
          pt._prev._next = pt;
        } else {
          first = pt;
        }
        if (pt._next = pt2) {
          pt2._prev = pt;
        } else {
          last = pt;
        }
        pt = next;
      }
      pt = tween._firstPT = first;
    }
    while (pt) {
      if (pt.pg) if (typeof pt.t[type] === "function") if (pt.t[type]()) {
        changed = true;
      }
      pt = pt._next;
    }
    return changed;
  };
  TweenPlugin.activate = function (plugins) {
    var i = plugins.length;
    while (--i > -1) {
      if (plugins[i].API === TweenPlugin.API) {
        _plugins[new plugins[i]()._propName] = plugins[i];
      }
    }
    return true;
  };

  //provides a more concise way to define plugins that have no dependencies besides TweenPlugin and TweenLite, wrapping common boilerplate stuff into one function (added in 1.9.0). You don't NEED to use this to define a plugin - the old way still works and can be useful in certain (rare) situations.
  _gsDefine.plugin = function (config) {
    if (!config || !config.propName || !config.init || !config.API) {
      throw "illegal plugin definition.";
    }
    var propName = config.propName,
      priority = config.priority || 0,
      overwriteProps = config.overwriteProps,
      map = {
        init: "_onInitTween",
        set: "setRatio",
        kill: "_kill",
        round: "_roundProps",
        initAll: "_onInitAllProps"
      },
      Plugin = _class("plugins." + propName.charAt(0).toUpperCase() + propName.substr(1) + "Plugin", function () {
        TweenPlugin.call(this, propName, priority);
        this._overwriteProps = overwriteProps || [];
      }, config.global === true),
      p = Plugin.prototype = new TweenPlugin(propName),
      prop;
    p.constructor = Plugin;
    Plugin.API = config.API;
    for (prop in map) {
      if (typeof config[prop] === "function") {
        p[map[prop]] = config[prop];
      }
    }
    Plugin.version = config.version;
    TweenPlugin.activate([Plugin]);
    return Plugin;
  };

  //now run through all the dependencies discovered and if any are missing, log that to the console as a warning. This is why it's best to have TweenLite load last - it can check all the dependencies for you.
  a = window._gsQueue;
  if (a) {
    for (i = 0; i < a.length; i++) {
      a[i]();
    }
    for (p in _defLookup) {
      if (!_defLookup[p].func) {
        window.console.log("GSAP encountered missing dependency: com.greensock." + p);
      }
    }
  }
  _tickerActive = false; //ensures that the first official animation forces a ticker.tick() to update the time when it is instantiated
})(window);

/***/ }),

/***/ 21638:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 21771:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NewComposeActivationMod: () => (/* binding */ NewComposeActivationMod)
/* harmony export */ });
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4424);

var $ = __webpack_require__(55401);
var contexts = __webpack_require__(47446);
var mods = __webpack_require__(25939);
var Emitter = __webpack_require__(16502);
var gmailUtil = __webpack_require__(2090);
var i18n = __webpack_require__(2622);
var Templates = __webpack_require__(5749);

/**
 * The new compose activation mod
 */
class NewComposeActivationMod extends mods.Mod {
  constructor(element, currentUser, activationStatus, selectors) {
    super({}, element);
    this._element = $(element);
    this._html = $(Templates.newComposeActivation({
      expired: activationStatus === 'expired',
      currentUser
    }));
    this._selectors = selectors;
    (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__._bindAllMethods)(this);
  }
  setup() {
    var element = this._element;
    gmailUtil.pwnCompose(this._element, this._html, this._selectors);

    // Turn off the policy config menu
    this._element.find('.virtru-policy-config').addClass('no-touch');
    var sizingDiv = element.find(this._selectors.NEW_COMPOSE_SIZING_DIV);
    if (sizingDiv.length === 0) {
      // if we're in the reply window, move the footer back up
      this._html.find('.virtru-receiver-footer-image-yellow').css('margin-top', 0);
    }
    this._html.find('.virtru-firsttime-activation-button').on('click', this._activationRequested);
    this._html.find('.virtru-reactivation-button').on('click', this._reactivationRequested);
    var titleText = element.find('.virtru-secure-mode-on').find('.virtru-label');
    titleText.text(i18n.t('COMPOSE_ACTIVATION_REQUIRED'));
  }
  _activationRequested() {
    // The boolean is isReactivation it's used for analytics
    this.emit('activationRequested', false);
  }
  _reactivationRequested() {
    // The boolean is isReactivation it's used for analytics
    this.emit('activationRequested', true);
  }
  teardown() {
    gmailUtil.unPwnCompose(this._element, this._selectors);
    this._element.find('.virtru-policy-config').removeClass('no-touch');
  }
}
Object.assign(NewComposeActivationMod.prototype, mods.ModElementShortcut);
contexts.addOpen(NewComposeActivationMod);

// Add events to this class
Emitter(NewComposeActivationMod.prototype);

/***/ }),

/***/ 22592:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module lib/constants/errors
 */

var {
  cksErrors
} = (__webpack_require__(82672).modules);
module.exports = {
  CORRUPT_TDF_PACKAGE: 'CorruptTdfPackage',
  INTEGRITY_COMPROMISED_ERROR: 'IntegrityCompromisedError',
  INTERNAL_SERVER_ERROR: 'InternalServerError',
  INVALID_APP_ID: 'InvalidAppId',
  NETWORK_CONNECTION_ERROR: 'NetworkConnectionError',
  NO_APP_ID_FOR_DOMAIN: 'NoAppIdForDomain',
  NOT_A_SECURE_EMAIL: 'NotASecureEmail',
  COMPROMISED_KEY_ERROR: 'CompromisedKeyError',
  TWO_FACTOR_REQUIRED: 'TwoFactorRequired',
  cks: cksErrors.ERRORS,
  UNAUTHORIZED: 'Unauthorized',
  ATTACHMENT_LIMIT_ERROR: 'Attachment limit',
  MAIL_MERGE_CONFLICT: 'Mail Merge Conflict',
  PFP_PARSE_ERROR: 'PfpParseError'
};

/***/ }),

/***/ 22885:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ff: () => (/* binding */ reducer),
/* harmony export */   o1: () => (/* binding */ actions)
/* harmony export */ });
const actionHandlers = {
  ADD_SECURE_MESSAGE({
    draftIds = {},
    threadIds = {},
    ...state
  }, {
    draftId,
    threadId
  }) {
    return {
      ...state,
      draftIds: draftId ? {
        ...draftIds,
        [draftId]: true
      } : draftIds,
      threadIds: threadId ? {
        ...threadIds,
        [threadId]: true
      } : threadIds
    };
  },
  REMOVE_SECURE_MESSAGE({
    draftIds = {},
    threadIds = {},
    ...state
  }, {
    draftId,
    threadId
  }) {
    return {
      ...state,
      draftIds: draftId ? Object.keys(draftIds).filter(id => id !== draftId).reduce((newDraftIds, id) => {
        newDraftIds[id] = draftIds[id];
        return newDraftIds;
      }, {}) : draftIds,
      threadIds: threadId ? Object.keys(threadIds).filter(id => id !== threadId).reduce((newThreadIds, id) => {
        newThreadIds[id] = threadIds[id];
        return newThreadIds;
      }, {}) : threadIds
    };
  }
};
function reducer(state = {}, action = {}) {
  const actionHandler = actionHandlers[action.type];
  return actionHandler ? actionHandler(state, action) : state;
}
const actions = Object.keys(actionHandlers).reduce((actionMap, actionType) => {
  actionMap[actionType] = actionType;
  return actionMap;
}, {});
/* unused harmony default export */ var __WEBPACK_DEFAULT_EXPORT__ = ((/* unused pure expression or super */ null && (reducer)));

/***/ }),

/***/ 23774:
/***/ ((module) => {

"use strict";
module.exports = "<div class=\"virtru-attachment\" id=\"\" data-size=\"\" data-name=\"\" data-tdo-id=\"\" data-policy-uuid=\"\" contenteditable=\"false\" style=\"position: relative; width: 396px; height: 30px; line-height: 30px; border: 1px solid #dcdcdc; background-color: #F5F5F5; z-index: 1; -webkit-border-radius: 1px; border-radius: 1px; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;\">\n  <div class=\"virtru-attachment-content\" style=\"height: 30px; width: 100%; overflow: hidden; white-space: nowrap; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;\">\n    <div class=\"virtru-attachment-icons\" style=\"display: inline-block; margin-left: 8px; margin-right: 3px; float: left; cursor: default; height: 30px;\">\n      <div class=\"virtru-attachment-shield\" style=\"display: inline-block; vertical-align: middle; margin: 7px 0; width: 18px; height: 16px; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpENzE0QTFFNDY5M0IxMUUzQkM4N0E2NDZERTREOUU4MiIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpENzE0QTFFNTY5M0IxMUUzQkM4N0E2NDZERTREOUU4MiI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkQ3MTRBMUUyNjkzQjExRTNCQzg3QTY0NkRFNEQ5RTgyIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkQ3MTRBMUUzNjkzQjExRTNCQzg3QTY0NkRFNEQ5RTgyIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+3JOfTwAAAYJJREFUeNpi/P//PwMy8Dh7QgtIpQCxJxArQoXvAfEOIJ6zw9jiGrJ6RpgBQI1sQKoPiDOBmIkBO/gHxLOBuBBo0He4AVDNW4HYhYE4sBeIvYCG/ILZ1E+CZhBwhrqWgdH9zHFtIH0RiJlhst2KqmC69fF9hg9//jCwMjIy9ADFPv39y1D78C5M2V8g1meBBhgzsvHKHJxgmgWoEQTEWNkYZNk5GP6iBjhITwrICx6E3KvCyQWmX/z+hS7lATJACZ9mkCuChcXA7JOfP6JLK7Hg08zJxMyQJC3FIMPOzvAV6P8t796gK/nFAk0kGtgMaJVXZuBhZmb4A/R7/7NH4ABFAw9ZoCkMqwEgzc9//WKY/Owxw43vX7Ep2QMyYC4Q5yLHBMim29+/MRwH+vnIpw9gF2ABoGicA0uJU4GcLAbSwDRgSsyGpcRCkHNI0LwXqgeSaUBpGkh5A/FUaIZhwJOZZgKxL1QPIjciZWdQ0k6FJjBQGgEpfAB1ISg7X0FWDxBgAGgthAatWVThAAAAAElFTkSuQmCC');\"></div>\n    </div>\n    <a class=\"virtru-attachment-link\" style=\"text-decoration: none; font-size: 0; font-family: Arial, Helvetica, sans-serif; font-weight: bold; float: left; height:30px; line-height: 30px;\">\n      <span class=\"virtru-attachment-file-name\" style=\"font-size: 13px; color: #1155CC; max-width: 220px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; float: left; margin-left: 5px; height:30px; line-height: 30px;\">{{FILENAME}}</span>\n      <span class=\"virtru-attachment-tdf-extension\" style=\"font-size: 13px; color: #47ccc7; height:30px; line-height: 30px;\">.tdf</span>\n      <span class=\"virtru-attachment-file-size\" style=\"margin-left: 5px; font-size: 13px; color: #808080; height:30px; line-height: 30px;\">({{FILESIZE}})</span>\n    </a>\n    <div class=\"virtru-attachment-delete\" style=\"display: none; width: 21px; height: 21px; width: 21px; height: 21px; float: right; margin-top: 5px; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABUAAAAVCAYAAACpF6WWAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDIxIDc5LjE1NDkxMSwgMjAxMy8xMC8yOS0xMTo0NzoxNiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxQjRCMzFGMEZDQjMxMUUzOTI4NzgyODdDREYyMDk2MCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxQjRCMzFGMUZDQjMxMUUzOTI4NzgyODdDREYyMDk2MCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjFCNEIzMUVFRkNCMzExRTM5Mjg3ODI4N0NERjIwOTYwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjFCNEIzMUVGRkNCMzExRTM5Mjg3ODI4N0NERjIwOTYwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+sNsBywAAAIFJREFUeNpi/P//PwO1ARMDDcCooXQ0lJGREYQzgFgUyoZhUag4blNBSQobBoIckDQQXwFiUahyUSgfJJ6DUy8eQ8WQDADRGmh8MXIMRXfZD3SXk2soA9SFP5AM1iAYdPR2qSiBMBUlx1CaxD4IZCAZiBwkGfi8zzha9I1gQwECDADtzkhyEeGqBgAAAABJRU5ErkJggg==');\"></div>\n  </div>\n  <div class=\"virtru-attachment-progress-bar\" style=\"height: 2px; opacity: 0.7; width: 0; overflow: hidden; white-space: nowrap; background-color: #1155CC;\"></div>\n</div><br>\n";

/***/ }),

/***/ 23832:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   virtruTourRestart: () => (/* binding */ virtruTourRestart)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const virtruTourRestart = () => `
  <div aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('PROTECTION_OVERVIEW_POPUP')}" class="virtru-onboarding-modal-v2">
    <div class="tourv2 tourv2--restart">
      <div class="tour-popover-close">
        <button aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('PROTECTION_OVERVIEW_POPUP_CLOSE')}" class="tour-x-button" tabIndex="1" role="button"></button>
      </div>
      <p class="onboardv2__body"></p>
      <div class="onboardv2__actions">
        <button class="onboardv2__okay" tabIndex="1" role="button"></button>
      </div>
    </div>

  </div>
`;

/***/ }),

/***/ 23871:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   messageIntegrityError: () => (/* binding */ messageIntegrityError)
/* harmony export */ });
const messageIntegrityError = ({
  header,
  message,
  help
}) => `
  <div class="virtru-integrity-compromised-template">
    <div>
      <div class="vic-icon"/>
      <div class="vic-header">
        ${header}
      </div>
      <div class="vic-message">
        <div>${message}</div>
      </div>
    </div>

    <div class="vic-footer">
      <a class="vic-link vic-get-help" href="https://www.virtru.com/resources/product-support/">${help}</a>
    </div>
  </div>
`;

/***/ }),

/***/ 24361:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ACTIVATION_BUTTON_ACTIVATE":"Activer {{currentUser}}","ACTIVATION_BUTTON_REACTIVATE":"Ractiver {{currentUser}}","ACTIVATION_FAILED":"chec de lactivation","ACTIVATION_FAILED_GENERAL_BODY":"Impossible dactiver la protection Virtru. Veuillez patienter un instant et ressayer, ou contactez votre administrateur.","ACTIVATION_HEADER_USER_NOT_ACTIVATED":"{{currentUser}} nest pas activ pour utiliser Virtru","ACTIVATION_LINK":"Fonctionnement","ACTIVATION_MESSAGE_DELEGATION_LINK":"Activer","ACTIVATION_SUBTEXT":"Afin de protger votre vie prive, nous devons vrifier rgulirement votre identit. Cela ne prend quune minute, la ractivation seffectue en un clic.","ACTIVATION_TEXT_ACTIVATE":"ACTIVER VIRTRU POUR<br>RDIGER DES E-MAILS SCURISS","ACTIVATION_TEXT_REACTIVATE":"RACTIVER VIRTRU POUR CONTINUER","ACTIVATION_WAIT_CANCELED":"Virtru na pas pu authentifier votre compte de messagerie, car longlet dauthentification a t ferm.<br/><br/>Cliquez sur le lien \\"Ressayer\\" ci-dessous pour redmarrer le processus.","ACTIVATION_WAIT_ERROR":"Virtru - Authentification impossible","ACTIVATION_WAIT_FAILED":"Virtru na pas pu authentifier votre compte de messagerie, car les paramtres actuels de votre navigateur nautorisent pas la cration de cookies, ou car vous avez rejet la demande de Virtru de vrifier votre adresse e-mail.</br><br/>Le processus dauthentification requiert des cookies. Si vous avez modifi les paramtres de cookies par dfaut de votre navigateur, configurez ce dernier de faon  autoriser tous les cookies, puis cliquez sur le bouton \\"Ressayer\\". Une fois votre compte authentifi, vous pouvez ractiver les limitations de cookies et continuer  utiliser Virtru.</br><br/>Virtru demande lautorisation \\"Voir votre adresse e-mail\\"  votre fournisseur de messagerie Web afin de vrifier que vous possdez bien le compte que vous activez. Pour plus dinformations sur la faon dont nous utilisons votre adresse e-mail, consultez nos <a href=\\"https://www.virtru.com/terms-of-service\\" target=\\"_blank\\">Conditions de service<a/> et notre <a href=\\"https://www.virtru.com/privacy-policy\\" target=\\"_blank\\">Politique de confidentialit</a>. Cliquez sur le bouton \\"Ressayer\\" pour accorder cette autorisation.","ACTIVATION_WAIT_HEADER":"Virtru - Authentification en cours...","ACTIVATION_WAIT_IN_PRIVATE":"Virtru na pas pu authentifier votre compte de messagerie, car votre navigateur est en mode priv, galement appel mode \\"Incognito\\" ou \\"InPrivate\\". Le processus dauthentification requiert des cookies, qui sont limits en mode priv.</br><br/>Pour continuer, dsactivez le mode priv, et revenez  votre fentre ou onglet de messagerie Web pour redmarrer le processus dauthentification.</br><br/>Une fois votre compte authentifi, vous pouvez ractiver le mode priv et continuer  utiliser Virtru.","ACTIVATION_WAIT_MESSAGE":"Virtru est toujours en train dauthentifier votre compte de messagerie sur ce navigateur. Tant que lauthentification nest pas termine, vous ne pouvez pas envoyer ni lire de messages scuriss.","ANIMATION_WIDGET_LOADING_TEXT":"Dchiffrement de le-mail...","ATTACHMENTS_UPLOADING_NO_SEND":"Le tlchargement des pices jointes doit tre termin avant de lancer lenvoi.","ATTACHMENT_APPID_ERROR_HEADER":"Activation arrive  expiration","ATTACHMENT_APPID_ERROR_TEXT":"Impossible de tlcharger les pices jointes car votre activation a expir. Veuillez ractiver et ressayer.","ATTACHMENT_CONNECTION_ERROR_HEADER":"Erreur rseau","ATTACHMENT_CONNECTION_ERROR_TEXT":"Un problme est survenu lors du tlchargement de vos pices jointes. Vrifiez votre connexion et ressayez.","ATTACHMENT_CONTENT":"Contenu de la pice jointe","ATTACHMENT_ERROR_CORRUPT":"La pice jointe est corrompue et ne peut pas tre dchiffre. Demandez  lexpditeur de renvoyer la pice jointe.","ATTACHMENT_ERROR_UNAUTHORIZED":"Vous ntes pas autoris  accder  ce fichier.","ATTACHMENT_ERROR_UNKNOWN":"Une erreur est survenue et Virtru na pas pu tlcharger ou dchiffrer ce fichier. Veuillez ressayer ultrieurement.","ATTACHMENT_GENERIC_ERROR_BUTTON":"Ignorer","ATTACHMENT_GENERIC_ERROR_HEADER":"Erreur de pice jointe","ATTACHMENT_GENERIC_ERROR_TEXT":"Un problme est survenu lors du tlchargement de vos pices jointes. Vrifiez vos fichiers, votre navigateur et votre plug-in avant de ressayer.","ATTACHMENT_INTEGRITY_COMPROMISED":"Virtru ne peut pas dchiffrer cette pice jointe. Cette situation a gnralement lieu lorsque le texte chiffr dun message a t modifi, ce qui rend le chiffrement illisible.","ATTACHMENT_ERROR_CLOSE_BUTTON":"Fermer","ATTACHMENT_NOT_READY_ERROR":"Pice jointe non prte","ATTACHMENT_OPTIONS":"Options de pice jointe","ATTACHMENT_PFP_ERROR_HEADER":"Erreur de pice jointe","ATTACHMENT_REVOKED_HEADER":"Accs rvoqu","ATTACHMENT_REVOKED_TEXT":"Vous navez plus lautorisation dafficher ce fichier","ATTACHMENT_TOO_LARGE_HEADER":"Pice jointe trop volumineuse","ATTACHMENT_TOO_LARGE_TEXT":"Certaines pices jointes sont trop volumineuses pour tre chiffres. Joignez des fichiers dune taille infrieure  {{maxSizeMb}}Mo.","ATTACHMENT_TOO_LARGE_SUGGEST_SECURE_SHARE_TEXT":"Une ou plusieurs de vos pices jointes dpassent la taille limite pour le cryptage des e-mails. Veuillez joindre des fichiers de moins de {{maxSizeMb}} Mo ou utiliser Virtru Secure Share pour envoyer des fichiers jusqu\' {{secureShareMaxSize}} Go  vos destinataires en toute scurit.","CANNOT_DECRYPT_GET_HELP":"Pour en savoir plus, consultez la FAQ de Virtru.","CANNOT_DECRYPT_HEADER":"Message probablement modifi","CANNOT_DECRYPT_MESSAGE_CKS":"Le serveur de chiffrement {{ownerName}} est inaccessible.<br/>Pour obtenir de laide, <a href=\\"{{ownerSupportUrl}}\\">contactez le <br/>support technique {{ownerName}}</a>.","CANNOT_DECRYPT_MESSAGE_CKS_TROUBLE_READING_EMAIL":"Nous ne parvenons pas  lire votre e-mail. Ressayez ultrieurement!","CANNOT_DECRYPT_MESSAGE_INTEGRITY_COMPROMISED":"Virtru a dtect que ce message a peut-tre t falsifi. Essayez de demander  <span class=\\"vic-message-bold\\">{{sender}}</span> de renvoyer le message.","CHROME_POPUP_ABOUT_VIRTRU_BUTTON":" propos de Virtru","CHROME_POPUP_ACTIVATION_BUTTON":"Activer Virtru pour {{userId}}","CHROME_POPUP_ACTIVATION_LABEL":"Protection des e-mails Virtru","CHROME_POPUP_SIGN_OUT_BUTTON":"Se dconnecter","CHROME_POPUP_VIRTRU_CONTROL_CENTER_BUTTON":"Centre de contrle Virtru","CHROME_POPUP_SUPPORT_BUTTON":"Support technique","CHROME_POPUP_UNINSTALL_BUTTON":"Dsinstaller","CHROME_POPUP_DRIVE_CROSS_SELL":"Obtenir Virtru pour Drive","CHROME_POPUP_SECURE_SHARE_CROSS_SELL":"Obtenez Virtru Secure Share pour Drive","COMMON_RETRY_SECURE_SEND":"Ressayer lenvoi scuris","COMMON_CANCEL":"Annuler","COMMON_CLOSE":"Fermer","COMMON_OK":"OK","COMMON_SEND":"Envoyer","COMMON_SEND_SECURE":"Scuriser l\'envoi","COMMON_SEND_SECURE_TOOLTIP_OFFLINE":"Le message protg ne peut pas tre envoy car Virtru est hors ligne","COMMON_TRY_AGAIN":"Ressayer","COMMON_REFRESH":"actualiser","COMMON_REFRESH_PAGE":"Actualiser la page","COMPOSE_ACTIVATION_REQUIRED":"Activation requise par Virtru","COMPOSE_ATTACHMENTS_UPLOADING_WARN":"Le mode scuris ne peut pas tre modifi pendant le tlchargement des pices jointes. Attendez la fin du tlchargement des pices jointes, puis modifiez le mode scuris.","COMPOSE_DRIVE_ATTACHMENTS_UNSUPPORTED":"Virtru ne prend pas en charge les pices jointes Drive actuellement. Voulez-vous les supprimer?","COMPOSE_EXPIRES":"Expire {{timeRemaining}}","COMPOSE_INSERT_DRIVE_INSERT_FILE":"Linsertion de fichiers  partir de GoogleDrive nest pas prise en charge en mode scuris.","COMPOSE_INSERT_PHOTOS_INLINE_IMAGES":"Actuellement, Virtru ne prend pas en charge les images intgres.","COMPOSE_OFF_CONFIRM_REMOVE":"Si le mode scuris est dsactiv, toutes les pices jointes scurises seront supprimes. Voulez-vous vraiment effectuer cette opration?","CONTENT_IS_MANAGED":"Lexpditeur a dsactiv le tlchargement pour ce fichier.","CONTEXTUAL_ACTIVATE_INFO":"Le compte {{currentUser}} na pas t activ auprs de Virtru. Une fois votre compte activ, votre identit est vrifie et Virtru vous envoie les cls de dchiffrement de vos messages scuriss. Virtru na jamais accs  votre contenu.","DISMISS_POPOVER_DEFAULT_OPTIONS_TEXT":"Ok, jai compris.","DOWNLOAD_ATTACHMENT_DECRYPTING":"Dchiffrement","EMAIL_BODY_CONTENT":"Contenu du corps de le-mail","EMAIL_ERROR_EMAIL_CORRUPT":"Ce message est corrompu et ne peut pas tre dchiffr. Demandez  lexpditeur de renvoyer le message.","EMAIL_ERROR_EMAIL_CORRUPT_HEADER":"E-mail corrompu","EMAIL_ERROR_INTERNAL_SERVER_ERROR":"Les serveurs de Virtru nont pas rpondu. Patientez quelques minutes et ressayez.","EMAIL_ERROR_INTERNAL_SERVER_ERROR_HEADER":"Erreur du serveur","EMAIL_ERROR_NETWORK_LOST":"Virtru na pas pu se connecter  Internet. Vrifiez votre connexion Internet et ressayez.","EMAIL_ERROR_NETWORK_LOST_HEADER":"Erreur de connexion rseau","EMAIL_ERROR_READ":"Le message na pas pu tre dchiffr. Vrifiez votre connexion Internet et ressayez.","EMAIL_ERROR_SEND":"Une erreur est survenue et le message na pas pu tre envoy. Vrifiez votre connexion Internet et ressayez.","EMAIL_ERROR_SMART_SEND_SECURE":"Une erreur est survenue lors de la tentative denvoi de votre message. Si le problme persiste, contactez Virtru.","EMAIL_ERROR_SMART_SEND_SECURE_HEADER":"Erreur denvoi","EMAIL_ERROR_TEMPLATE_SUPPORT_LINK":"Support technique Virtru","EMAIL_ERROR_UNKNOWN":"Virtru a rencontr une erreur et ne peut pas envoyer ce message. Actualisez la page et ressayez.","EMAIL_ERROR_UNKNOWN_HEADER":"Erreur inconnue","EMAIL_ERROR_YOURE_ON_STAGING":"Attention! Il semblerait que vous tentiez de lire un e-mail provenant du mauvais serveur (intermdiaire/de production). Consultez la page des options pour connatre le serveur vers lequel vous pointez. Il se peut quil sagisse dun serveur incorrect.","EMAIL_ERROR_YOURE_ON_STAGING_HEADER":"Attention! Il semblerait que vous tentiez de lire un e-mail provenant de ","EMAIL_ERROR_SEND_UNKNOWN":"Virtru a rencontr une erreur et ne peut pas envoyer ce message. Cliquez sur le bouton ci-dessous pour tenter un nouvel envoi.","EMAIL_ERROR_SEND_UNKNOWN_HEADER":"Erreur inconnue","EMAIL_ERROR_SEND_REACTIVATION":"Activation expire, veuillez ractiver pour envoyer votre message.","EMAIL_ERROR_SEND_REACTIVATION_HEADER":"Erreur denvoi","EMAIL_ERROR_SEND_REACTIVATION_RETRY_BUTTON":"Ractiver et Envoyer","EMAIL_ERROR_READ_SECURE_READER_LABEL":"Cliquez ici pour afficher le message dans le lecteur scuris de Virtru","EMAIL_EXPIRATION":"Date dexpiration","EMAIL_INVALID_ADDRESS":"Ladresse \\"{{invalidAddress}}\\" na pas t reconnue. Assurez-vous que le format de toutes les adresses est correct.","EMAIL_INVALID_ADDRESS_GENERIC":"Certaines adresses e-mail nont pas t reconnues. Assurez-vous que le format de toutes les adresses est correct.","EMAIL_TEMPLATE_FOOTER":"Scuris par Virtru","EMAIL_TEMPLATE_SENDER_HEADER":"Votre message, protg par Virtru","ENCRYPTED_SEARCH_REMINDER_HEADER":"La recherche chiffre napparatra pas dans les rsultats de recherche.","ENCRYPTED_SEARCH_REMINDER_SUBTEXT":"La recherche dans les corps de messages chiffrs par Virtru n\'est actuellement pas active. Cliquez ici pour savoir comment activer la recherche chiffre.","ENHANCEDPDF_DL_DISABLED_TOOLTIP":"Lexpditeur a dsactiv le tlchargement pour ce fichier. Cliquez ci-dessous pour afficher le message dans Virtru SecureReader.","ENHANCEDPDF_DL_DISABLED_TOOLTIP_TITLE":"Protection de PDF amliore","EXPANDED_WATERMARKING_DL_DISABLED_TOOLTIP_TITLE":"Protection amliore","FAQ":"FAQ","FEATURE_CHIP_TEXT":"Nouvelle fonctionnalit","FEATURE_ENCRYPTED_SEARCH_FAQ":"En savoir plus grce  notre FAQ","FEATURE_ENCRYPTED_SEARCH_POPUP_DESCRIPTION":"Afin dactiver la recherche de vos e-mails chiffrs par Virtru, cliquez ci-dessous pour accder  longlet \\"Fonctionnalits\\" de votre centre de contrle Virtru.","FEATURE_ENCRYPTED_SEARCH_BUTTON":"Aller au centre de contrle","FEATURE_ENCRYPTED_SEARCH_CANCEL":"Plus tard","FEATURE_ENCRYPTED_SEARCH_DESCRIPTION":["Dans le Centre de contrle, accdez  l\'onglet Fonctionnalits et activez la recherche.","Ou consultez notre FAQ pour en savoir plus."],"FEATURE_ENCRYPTED_SEARCH_TITLE_TEXT":"Rechercher vos e-mails chiffrs","FEATURE_ENCRYPTED_SEARCH_SUB_TITLE_TEXT":"Activer la recherche de vos e-mails crypts Virtru","FEATURE_VAULT_BUTTON":"Commencer","FEATURE_VAULT_CANCEL":"Non, merci","FEATURE_VAULT_DESCRIPTION":["Recherchez des e-mails crypts et dcryptez-les directement","Maintenir la sensibilit avec le cryptage Virtru","Facilement dtectable par les parties autorises","Intgr  votre interface Google existante","Contactez un reprsentant Virtru pour plus dinformations"],"FEATURE_VAULT_TITLE_TEXT":"Rechercher des e-mails Virtru dans GoogleVault","FEATURE_VAULT_SUB_TITLE_TEXT":"Ajoutez le package Google Vault  votre chiffrement de bout en bout Virtru","FILE_SIZES":{"BYTES":"o","UNITS":["ko","Mo","Go","To","Po","Eo","Zo","Yo"]},"DELIMITERS":{"DECIMAL":","},"FIRST_TIME_ONBOARD_LINK_ACTIVATE":"Activer","FOOTER_POPOVER_BODY":"Indiquez  vos amis et  vos collgues quils peuvent vous envoyer un e-mail en toute scurit avec Virtru.","FOOTER_POPOVER_HEADER":"Communiquer en toute confidentialit","FOOTER_POPOVER_REMOVE_SIGNATURE":" Supprimer de ma signature de-mail ","FOOTER_PROMO":"Vous devez menvoyer un e-mail priv? Jutilise","FOOTER_PROMO_USE":"Virtru","FORWARDING_RESTRICTED":"- Transfert limit","GMAIL_BASIC_MODE_UNSUPPORTED_MAIN":"LaffichageHTML de base de Gmail nest pas pris en charge","GMAIL_BASIC_MODE_UNSUPPORTED_SUB":"Passez en affichage standard pour utiliser Virtru.","GO_TO_SECURE_SHARE":"Accdez au Secure Share","INTRO_MESSAGE_FOOTER_TEXT":"Le texte prsent au-dessus de cette ligne ne sera pas chiffr.","INVITATION_EMAIL_REPLACE_TEXT_DEFAULT":"Il sagit dune chane de messages scurise, protge par Virtru.","LEARN_MORE":"En savoir plus","LIMITED_ENCRYPTION_BUTTON_CANCEL":"Annuler","LIMITED_ENCRYPTION_BUTTON_OK":"Continuer","LIMITED_ENCRYPTION_CHECKBOX":"Ne plus afficher ce message","LIMITED_ENCRYPTION_HEADER":"Protection limite","LIMITED_ENCRYPTION_TEXT":"Des fonctionnalits de scurit supplmentaires telles que la protection persistante et le tatouage numrique ne seront pas appliques aux pices jointes suivantes car les types de fichier ne sont pas pris en charge ou car leurs paramtres de scurit sont grs indpendamment de ce message:","MESSAGE_OPTIONS":"Options des messages","MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE":{"lastDay":"[Hier ] LT","lastWeek":"dddd [dernier] [] LT","nextDay":"[Demain ] LT","nextWeek":"dddd [] LT","sameDay":"[Aujourdhui ] LT","sameElse":"dddd Do MMM YYYY [] LT"},"MOMENT_CALENDAR_RECIPIENT_EXPIRATION":{"lastDay":"[] LT [hier]","lastWeek":"[] LT dddd [dernier]","nextDay":"[] LT [demain]","nextWeek":"[] LT dddd","sameDay":"[] LT [aujourdhui]","sameElse":"[] LT dddd Do MMM YYYY"},"MOMENT_CALENDAR_SENDER_EXPIRED":{"lastDay":"[hier ] LT","lastWeek":"dddd [dernier] [] LT","nextDay":"[demain ] LT","nextWeek":"dddd [] LT","sameDay":"[aujourdhui ] LT","sameElse":"dddd Do MMM YYYY [] LT"},"MOMENT_CALENDAR_SENDER_EXPIRING_SOON":{"lastDay":"LT [hier]","lastWeek":"LT dddd [dernier]","nextDay":"LT [demain]","nextWeek":"LT dddd","sameDay":"LT [aujourdhui]","sameElse":"LT dddd Do MMM YYYY"},"NESTED_MESSAGE_PLACEHOLDER_TEXT_DEFAULT":"Afficher le dernier message scuris","NESTED_MESSAGE_PLACEHOLDER_TEXT_LOADING":"Chargement du message scuris...","NEW_COMPOSE_ARCHIVE_SEND":"Envoyer+","NEW_COMPOSE_ARCHIVE_SEND_SECURE":"Scuriser l\'envoi+","NEW_COMPOSE_DISABLED_WHILE_SECURING":"Dsactiv pendant la scurisation du message (et des pices jointes)","NEW_MESSAGE_NOT_SECURE":"Nouveau message","NEW_FEATURE_POPOVER_PP_BODY":"Grce  Virtru, vos pices jointes restent scurises une fois quelles ont t partages et tlcharges. <br><br><a href=\'https://support.virtru.com/hc/en-us/articles/360022693153\'>En savoir plus</a> sur cette fonctionnalit, y compris sur lexprience du destinataire.","NEW_FEATURE_POPOVER_PP_BUTTON":"Ignorer","NEW_FEATURE_POPOVER_PP_LABEL":"Nouveau! Protection persistante","NEW_MESSAGE_SECURE":"Nouveau message scuris","OFFLINE_MODE_MODAL":{"PROTECTION_OFF":{"ACTION":"Fermer","BODY":"La protection Virtru est actuellement dsactive car votre connexion rseau est hors ligne.","TITLE":"Aucun rseau dtect"},"PROTECTION_ON":{"ACTION":"Fermer","BODY":"La protection Virtru est actuellement dsactive car votre connexion rseau est hors ligne. Toute rvision effectue hors ligne ne sera pas enregistre.","TITLE":"Aucun rseau dtect"}},"OKGOTIT":"OK, JAI COMPRIS!","ONBOARDING_POPOVER_1_CONFIRM":"Activer","ONBOARDING_POPOVER_1_ENTERPRISE_BODY":"Votre entreprise utilise Virtru pour protger ses e-mails et la confidentialit de ses donnes. Pour commencer  envoyer des messages scuriss, activez votre compte de messagerie.","ONBOARDING_POPOVER_1_HEADER":"Bienvenue sur Virtru","ONBOARDING_POPOVER_1_INDIVIDUAL_BODY":"Avec Virtru, la protection des e-mails et de la confidentialit de vos donnes est un jeu denfant. Pour commencer  envoyer des messages scuriss, activez votre compte de messagerie.","ONBOARDING_POPOVER_2_BODY":"Vous pouvez dsormais envoyer des messages scuriss depuis {{currentUser}}  laide de Virtru.","ONBOARDING_POPOVER_2_CONFIRM":"Suivant","ONBOARDING_POPOVER_2_HEADER":"Votre adresse e-mail est active.","ONBOARDING_POPOVER_2_SKIP_CHECKBOX_LABEL":"Ne plus afficher","ONBOARDING_POPOVER_3_BODY":"Vous avez chang davis? Rvoquez laccs ou mettez  jour les contrles  partir de votre dossier Gmail Messages envoys ou dans le <a href=\'https://secure.virtru.com/control-center\'>centre de contrle Virtru</a>.","ONBOARDING_POPOVER_3_CONFIRM":"Termin","ONBOARDING_POPOVER_3_HEADER":"Vous venez denvoyer votre premier message scuris.","ONBOARDING_RESTART_4_BODY":"Virtru protge vos messages et vos pices jointes. Pour en savoir plus sur la faon dont Virtru vous protge, rendez-vous sur la page <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>.","ONBOARDING_RESTART_4_ORG_BODY":"La protectionVirtru a t dfinie sur Active par votre administrateur. Elle protgera donc vos messages et vos pices jointes.<br><br>Pour en savoir plus sur la faon dont Virtru vous protge, rendez-vous sur la page <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>.","ONBOARDING_RESTART_4_ORG_HEADING":"ProtectionVirtru","ONBOARDING_RESTART_CONFIRM":"Commencer la visite","ONBOARDING_SEND_VERIFICATION":"Envoyer le-mail dactivation","ONBOARDING_TOUR_1_BODY":"Une fois prt  envoyer un message scuris, slectionnez <span class=\\"bold\\">Rdiger</span> pour commencer.","ONBOARDING_TOUR_1_HEADER":"Commencer  rdiger un message","ONBOARDING_TOUR_2_BODY":"Lorsque vous avez besoin denvoyer un message scuris, activez Virtru en haut  droite de la fentre de message. Les brouillons sont galement protgs, mme avant davoir t envoys.","ONBOARDING_TOUR_2_HEADER":"Activer la protectionVirtru","ONBOARDING_TOUR_3_BODY":"Contrlez laccs  votre message scuris: dfinissez une date dexpiration, empchez le transfert ou tatouez numriquement les pices jointes.","ONBOARDING_TOUR_3_HEADER":"Ajouter des options de scurit","ONBOARDING_TOUR_4_BODY":"Les messages scuriss peuvent comporter un texte dintroduction que le destinataire peut lire sans avoir  dchiffrer tout le message. Vous pouvez personnaliser ce texte en slectionnant <span class=\\"bold\\">Message dintroduction personnel</span>.","ONBOARDING_TOUR_4_HEADER":"Message dintroduction personnel","ONBOARDING_TOUR_CONFIRM":"OK","ONE_CLICK_OPTION":"Accs en un clic","PAGE_ACTIONS_FORMAT_NON_PROD_MESSAGE":"Ce message a t envoy  laide de {{acmUrl}}","PERSONAL_INTRO_ADD":"Message dintroduction personnel","ARIA_PERSONAL_INTRO":"Message dintroduction personnel","PERSONAL_INTRO_ONBOARD":"Ajoutez une prsentation personnelle non chiffre  votre e-mail priv. Les destinataires savent ainsi que le message est authentique et nest pas un courrier indsirable.","PERSONAL_INTRO_PLACEHOLDER_TEXT":"[Saisissez votre message de prsentation ici. Intgrez des informations que seul votre destinataire connat ou crivez-les dune faon qui lui permettra de vous reconnatre.]","PLAINTEXT_NOT_SUPPORTED_HEADER":"Le mode de texte clair nest pas pris en charge","PLAINTEXT_NOT_SUPPORTED_TEXT":"Dsactivez le mode de texte clair avant de continuer.","PLAINTEXT_NOT_SUPPORTED_TITLE":"chec de lenvoi","POLICY_MENU_DISABLE_FORWARDING":"Dsactiver le transfert","POLICY_MENU_EXPANDED_WATERMARKING":"Tatouage numrique","POLICY_MENU_PERSISTENT_PROTECTION":"Protection persistante","POLICY_MENU_WATERMARKING":"Tatouage numrique de PDF","POLICY_MENU_SUPPORTED_FILES_INFO_TITLE":"Formats pris en charge","PROTECTION_REQUIRED":"Protection obligatoire","PROTECT_AND_SEND":"Protger et envoyer","READ_RECEIPT_FORWARD_COUNT_DETAILS":"(cliquez pour en savoir plus)","RECIPIENT":"Champ du destinataire","RECIPIENT_WIDGET_EXPIRATION_DATE":"Expire {{datetime}}","RECIPIENT_WIDGET_EXPIRED":"Ce message a expir","RECIPIENT_WIDGET_EXPIRED_BODY":"ACCS EXPIR","RECIPIENT_WIDGET_EXPIRED_DATE":"Ce message a expir le {{datetime}}","RECIPIENT_WIDGET_HEADER":"Vous consultez un message scuris, protg par Virtru.","RECIPIENT_WIDGET_NO_EXPIRATION":"Aucune date dexpiration","RECIPIENT_WIDGET_OFFLINE_BODY":"CONNEXION INTERNET PERDUE","RECIPIENT_WIDGET_OFFLINE_HEADER":"Laccs aux messages scuriss nest pas autoris dans connexion Internet.","RECIPIENT_WIDGET_REVOKED_BODY":"ACCS RVOQU","RECIPIENT_WIDGET_REVOKED_HEADER":"Lauteur a supprim votre accs.","RECIPIENT_WIDGET_UNAUTHORIZED_BODY":"CETTE ADRESSE E-MAIL NEST PAS AUTORISE  VISUALISER CET E-MAIL","RECIPIENT_WIDGET_UNAUTHORIZED_HEADER":"Cette adresse e-mail nest pas autorise  lire cet e-mail","RESTORE_DRAFT_FAILED":"Un problme est survenu lors de la restauration de ce brouillon. Vrifiez votre connexion rseau et ressayez.","SCREENREADER_CLOSED_POLICY_MENU":"Menu Politique ferm","SCREENREADER_DISABLED_EXPIRATION":"Expiration dsactive","SCREENREADER_DISABLED_FORWARDING":"Transfert dsactiv","SCREENREADER_DISABLED_ONECLICK":"Accs en un clic dsactiv","SCREENREADER_DISABLED_WATERMARK":"Tatouage numrique dsactiv","SCREENREADER_DISABLED_WATERMARK_PDF":"Tatouage numrique du PDF dsactiv","SCREENREADER_DISABLED_PFP":"Protection persistante dsactive","SCREENREADER_DISABLE_FORWARDING":"Dsactiver le transfert","SCREENREADER_ENABLED_EXPIRATION":"Expiration active","SCREENREADER_ENABLED_FORWARDING":"Transfert activ","SCREENREADER_ENABLED_ONECLICK":"Accs en un clic activ","SCREENREADER_ENABLED_WATERMARK":"Tatouage numrique activ","SCREENREADER_ENABLED_WATERMARK_PDF":"Tatouage numrique du PDF activ","SCREENREADER_ENABLED_PFP":"Protection persistante active","SCREENREADER_EXPIRATION":"Expiration dfinie","SCREENREADER_ONECLICK":"Activer laccs en un clic","SCREENREADER_OPENED_POLICY_MENU":"Menu Politique ouvert","SCREENREADER_VIRTRU_POLICY_MENU":"Options de scurit Virtru","SCREENREADER_VIRTRU_SECURE_TOGGLE":"Bouton Scuriser Virtru","SCREENREADER_WATERMARK_PDF":"Tatouer numriquement le PDF","SCREENREADER_WATERMARK":"Tatouer numriquement","SCREENREADER_PFP":"Protection persistante","SECURE_EMAIL_COMPOSER_PLACEHOLDER_HTML":"La chane de-mails a t scurise par Virtru.","SECURE_EMAIL_COMPOSER_POLICY_OPTIONS_DEFAULT":"(Sans objet)","SECURE_MESSAGE_CONTROL_ENABLE":"Activer","SECURE_MESSAGE_CONTROL_REVOKE":"Rvoquer","SECURE_MESSAGE_LABEL":"Vous lisez un message scuris","SECURE_MESSAGE_SENT_NOTIFICATION":"Message scuris envoy.","SECURED_ATTACHMENTS_HEADER":"{{count}} PICE JOINTE SCURISE","SECURED_ATTACHMENTS_HEADER_plural":"{{count}} PICES JOINTES SCURISES","SENDER_WIDGET_ERROR_ENABLE_MESSAGE":"Une erreur est survenue lors du traitement de lactivation de ce message.","SENDER_WIDGET_ERROR_REVOCATION":"Une erreur est survenue lors du traitement de la rvocation.","SENDER_WIDGET_ERROR_UPDATE_POLICY":"Une erreur est survenue lors de la mise  jour de la politique.","SENDER_WIDGET_EXPIRED_DATE":"Arriv  expiration le {{datetime}}","SENDER_WIDGET_EXPIRES_DATE":"Expire le {{datetime}}","SENDER_WIDGET_MESSAGE_REVOKED":"Ce message a t rvoqu","SENDER_WIDGET_NO_EXPIRATION":"Aucune date dexpiration","SENDER_WIDGET_REVOKED_DATE":"Rvoqu {{datetime}}","SEND_ANIMATION_LOADING_TEXT":"Chiffrement de le-mail","SEND_ANYWAY":"Envoyer quand mme","SEND_ANYWAY_OFFLINE":"Placer quand mme dans la file dattente","SCHEDULE_SEND":"Programmer lenvoi","GO_BACK":"Revenir","SEND_BLOCK_HEADER":"Violation dtecte","SEND_BLOCK_SUBTEXT":"Conformment  la politique de scurit du contenu de votre organisation, cet e-mail comprend des informations confidentielles et ne peut pas tre envoy sans protection Virtru.","SEND_WARNING_BUTTON_SEND":"ENVOYER","SEND_WARNING_BUTTON_SEND_SECURE":"ENVOI SCURIS","SEND_WARNING_BUTTON_SEND_SECURE_IMMEDIATELY":"Effectuer lenvoi scuris maintenant","SEND_WARNING_WARNING_SEND_SCHEDULED_LABEL":"Toutefois, lenvoi programm nest pas pris en charge avec la protection Virtru pour le moment. Effectuez lenvoi scuris maintenant ou enlevez les informations confidentielles pour effectuer un envoi programm.","SEND_WARNING_SCHEDULE_SEND_NOT_SUPPORTED":"Lenvoi programm nest pas pris en charge pour le moment. Utilisez loption Effectuer lenvoi scuris maintenant ou envoyez votre e-mail sans protection Virtru.","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE":"Envoi programm non disponible","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE_TOOLTIP":"Lenvoi programm nest pas pris en charge avec la protection Virtru pour le moment","SENSITIVE_DATA_FOUND":"Des donnes confidentielles ont t dtectes","WARN_SENSITIVE_DATA_FOUND_BODY":"Le message que vous souhaitez envoyer contient des informations confidentielles. Votre organisation vous recommande dactiver la protectionVirtru avant denvoyer cet e-mail.","WARN_SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE":"Vous pourrez activer la protection pour ce brouillon et lenvoyer lorsque vous aurez rcupr la connectivit rseau, ou vous pouvez placer cet e-mail dans la file dattente de votre bote denvoi sans la protection Virtru.","WARN_SENSITIVE_DATA_FOUND_BODY_OFFLINE":"Le message que vous souhaitez envoyer contient des informations confidentielles.","WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE":"Cependant, la protection Virtru n\'est pas compatible avec la fusion d\'e-mails dans Gmail. Veuillez slectionner {{button}} sur cette page et dsactiver la fusion d\'e-mails pour continuer.","SENSITIVE_DATA_FOUND_BODY":"Le message que vous souhaitez envoyer contient des informations confidentielles. Votre organisation a automatiquement appliqu la protection Virtru.","SENSITIVE_DATA_FOUND_BODY_OFFLINE":"Le message que vous souhaitez envoyer contient des informations confidentielles.","SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE":"Vous pourrez activer la protection pour ce brouillon et lenvoyer lorsque vous aurez rcupr la connectivit rseau, ou vous pouvez supprimer les informations confidentielles afin de placer cet e-mail dans la file dattente de votre bote denvoi sans la protection Virtru.","WARN_ATTACHMENTS_LIMIT_REACHED":"Nombre maximal de pices jointes atteint","ATTACHMENTS_LIMIT_REACHED_BODY":"Vous avez joint [ATTACHMENTS_COUNT] fichiers  ce message. La protection Virtru prend en charge jusqu [ATTACHMENTS_LIMIT] pices jointes par message scuris. Veuillez retirer [ATTACHMENTS_REMOVE_COUNT] fichiers du message scuris, puis ressayez.","TOOLTIP_DISABLE_FORWARDING":"Dsactiver le transfert","TOOLTIP_EXPIRATION":"Date dexpiration","TOOLTIP_EXPIRES":"Expire le: {{date}}","TOOLTIP_FORWARDING_RESTRICTED":"Transfert limit","TOOLTIP_FORWARDING_RESTRICTED_CONTENT":"Le transfert a t limit sur un message scuris de la chane. Il se peut que les destinataires ajouts  votre message naient pas accs au message transfr. Le propritaire du message scuris doit accorder laccs aux nouveaux destinataires.","TOOLTIP_ONE_CLICK":"Accs en un clic","TOOLTIP_REAUTHORIZE_BUTTON_CONTENT":"Ce message a t rvoqu auparavant. Si vous le rautorisez, il sera  nouveau visible.","TOOLTIP_REAUTHORIZE_BUTTON_TITLE":"Rautoriser le message","TOOLTIP_RECIPIENT_DISABLE_FORWARDING":"Ce message scuris par Virtru fait lobjet de limitations de transfert par son expditeur.","TOOLTIP_RECIPIENT_EXPIRATION":"Ce message scuris par Virtru expire le {{date}}. Pour visualiser ce message aprs son expiration, contactez lexpditeur.","TOOLTIP_RECIPIENT_ONE_CLICK":"Vous navez pas besoin dune autorisation pour lire ce message scuris Virtru.","TOOLTIP_RECIPIENT_UNAUTHORIZED_INFO":"Lauteur dorigine de cet e-mail a limit laccs au message. Par consquent, si vous navez pas reu ce message directement de lauteur dorigine, vous ne pourrez peut-tre pas visualiser son contenu.<br><br>Pour obtenir laccs, contactez lauteur dorigine.","TOOLTIP_REVOKE_BUTTON_CONTENT":"Dsactive laccs  votre message.  part vous, personne ne pourra visualiser ce message.","TOOLTIP_REVOKE_BUTTON_TITLE":"Rvoquer le message","TOOLTIP_SECURE_ATTACHMENT_CONTENT":"{{filename}} a t scuris par Virtru","TOOLTIP_SECURE_ATTACHMENT_DOWNLOAD":"Dchiffrer et tlcharger","TOOLTIP_SECURE_ATTACHMENT_DRIVE":"Lenregistrement sur GoogleDrive nest pas pris en charge par Virtru","TOOLTIP_SECURE_ATTACHMENT_TITLE":"Pice jointe scurise Virtru","TOOLTIP_SENDER_DISABLE_FORWARDING_CONTENT":"Ce paramtre permet de rendre votre message illisible sil a t transfr","TOOLTIP_SENDER_ENABLE_SMS2FA":"L\'accs  ce message ncessitera une vrification par SMS","TOOLTIP_SENDER_EXPIRATION_CONTENT":"Une fois le temps que vous avez indiqu coul, vos destinataires nauront plus accs  ce message","TOOLTIP_SENDER_ONE_CLICK_CONTENT":"Si vous activez cette option, les utilisateurs nauront pas besoin de sauthentifier pour visualiser votre message chiffr","TOOLTIP_TOGGLE_DISABLED":"Vous ntes pas autoris  effectuer un envoi scuris. Contactez votre administrateur si vous avez des questions.","TOOLTIP_TOGGLE_ON":"La protectionVirtru est active","TOOLTIP_TOGGLE_ON_ORG":"La protectionVirtru est active par dfaut. Vous pouvez la dsactiver si vous nen avez pas besoin.","TOOLTIP_SENDER_WATERMARK":"Tatouage numrique","TOOLTIP_SENDER_WATERMARK_CONTENT":"Les pices jointes prises en charge seront tatoues numriquement dans SecureReader.","TOOLTIP_SENDER_PFP":"Protection persistante","TOOLTIP_SENDER_PFP_CONTENT":"Ce paramtre protge les fichiers en rendant lauthentification obligatoire, mme en cas de partage ou de tlchargement sur un ordinateur","TOOLTIP_TOGGLE_OFF":"Protgez votre message avec Virtru","TOOLTIP_TOGGLE_OFF_OFFLINE":"La protection Virtru ne peut pas tre active en mode hors-ligne","TOOLTIP_UPSELL_POSTFIX":"<br/><br/>Cette fonctionnalit est disponible dans la version Pro de Virtru.","TOOLTIP_VIRTRU_OPTIONS":"Options de scurit","UNSECURE_ATTACHMENTS_EXIST_HEADER":"Prsence de pices jointes non scurises","UNSECURE_ATTACHMENTS_EXIST_TEXT":"Envoi scuris impossible si des pices jointes sont dtectes.","UNSECURE_ATTACHMENTS_EXIST_TITLE":"chec de lenvoi","UPDATE_MODAL_HEADER":"Virtru a t mis  jour.","UPDATE_MODAL_REFRESH_BUTTON":"Cliquez ici pour actualiser la page","UPDATE_MODAL_SUBHEADER":"Actualisez cette page pour vous assurer <br>que vous utilisez la dernire version.","VIRTRU_ATTACHMENT_DECRYPTING":"Dchiffrement","VIRTRU_ATTACHMENT_DOWNLOAD":"Tlcharger","VIRTRU_ATTACHMENT_VIEW":"Visualiser","VIRTRU_ATTACHMENT_REMOVE":"Supprimer","VIRTRU_AUTH_LINK":"Activer Virtru","VIRTRU_AUTH_LINK_REACTIVATE":"Ractiver Virtru","VIRTRU_CONTACT_US":"Contactez votre administrateur informatique","VIRTRU_DISABLED_ON_DOMAIN":"Virtru a t dsactiv pour votre domaine","VIRTRU_PROTECTION_NOT_AUTH":"Virtru doit tre activ pour que la protection soit effective.","VIRTRU_PROTECTION_NOT_AUTH_OFFLINE":"Une connexion rseau est requise pour lactivation de Virtru.","VIRTRU_PROTECTION_NOT_AUTH_SHORT":"Veuillez activer Virtru.","VIRTRU_PROTECTION_ON":"ProtectionVirtru active","VIRTRU_PROTECTION_OFF":"ProtectionVirtru dsactive","VIRTRU_PROTECTION_OFFLINE":"La protection Virtru est hors ligne","VIRTRU_SECURE_DRAFT_PREFIX":"Il sagit dun brouillon scuris par Virtru","WEBMAIL_PLUGIN_ACTIVATION_LINK_RETRY":"Renvoyer","WEBMAIL_PLUGIN_ACTIVATION_TEXT":"E-mail de vrification envoy.<br>Consultez cette bote de rception dici peu.","WEBMAIL_PLUGIN_INIT_ERROR":"Initialisation de Virtru impossible. Cela peut tre d  des erreurs de connectivit rseau ou  une configuration utilisateur incomplte. Essayez dactualiser la page dans quelques instants ou contactez le support client Virtru sur la page <a href=\\"https://support.virtru.com/hc/en-us/\\">https://support.virtru.com/hc/en-us/</a>.","WEBMAIL_PLUGIN_INIT_ERROR_HEADER":"chec de linitialisation du plug-in Virtru","WIDGET_BASE_BODY_REVOKED":"ACCS REFUS","WIDGET_BASE_EXPIRATION_OPTIONS_CUSTOM":"Ajouter une date/heure personnalise","WIDGET_BASE_FOOTER":"Scuris par la technologie Virtru","WIDGET_BASE_HEADER_MESSAGE_RECIPIENT":"Vous consultez un message scuris, protg par Virtru.","WIDGET_BASE_HEADER_MESSAGE_SENDER":"Votre message, protg par Virtru","WIDGET_BASE_MENU_OPTION_EXPIRES":"Ajouter une expiration","WIDGET_BASE_MENU_OPTION_FORWARDING":"Dsactiver le transfert","EXPIRATION_UNIT_DAYS":"jour","EXPIRATION_UNIT_DAYS_plural":"jours","EXPIRATION_UNIT_HOURS":"heure","EXPIRATION_UNIT_HOURS_plural":"heures","EXPIRATION_UNIT_MINS":"minute","EXPIRATION_UNIT_MINS_plural":"minutes","EXPIRATION_UNIT_MONTHS":"mois","EXPIRATION_UNIT_MONTHS_plural":"mois","EXPIRATION_UNIT_WEEKS":"semaine","EXPIRATION_UNIT_WEEKS_plural":"semaines","EXPIRATION_UNIT_YEARS":"an","EXPIRATION_UNIT_YEARS_plural":"ans","READ_RECEIPT_READBY_COUNT":"Lu par {{accessors}} destinataire sur {{count}}","READ_RECEIPT_READBY_COUNT_plural":"Lu par {{accessors}} destinataires sur {{count}}","READ_RECEIPT_FORWARD_COUNT":"<div style=\\"text-align:center;\\">Transfr {{count}}fois<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","READ_RECEIPT_FORWARD_COUNT_plural":"<div style=\\"text-align:center;\\">Transfr {{count}}fois<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","ATTACHMENTS_TOOLTIP_CONTENT":{"RECIPIENT":{"SUPPORTED_FILE":{"NONE_SECURE":"Ce fichier est chiffr sans aucune autre option de scurit active.","EXPANDED_WATERMARKING":"Ce fichier sera tatou numriquement lorsquil sera visualis dans VirtruSecureReader.","IS_MANAGED":"Ce fichier sera tatou numriquement lorsquil sera visualis dans VirtruSecureReader.","EXPANDED_IS_MANAGED":"Dautres options de scurit sont actives sur ce fichier. Il sera tatou numriquement et restera scuris une fois tlcharg ou partag.","PERSISTENT_PROTECTION":"La protection persistante est active sur ce fichier. Celui-ci restera scuris une fois tlcharg ou partag.","EXPANDED_PROTECTION":"Dautres options de scurit sont actives sur ce fichier. Il sera tatou numriquement et restera scuris une fois tlcharg ou partag."},"UNSUPPORTED_FILE":{"NONE_SECURE":"Ce fichier est chiffr sans aucune autre option de scurit active.","EXPANDED_WATERMARKING":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","IS_MANAGED":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","EXPANDED_IS_MANAGED":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","PERSISTENT_PROTECTION":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","EXPANDED_PROTECTION":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge."},"STEPCHILD":"Cette pice jointe est dote de paramtres de scurit grs indpendamment de ce message."},"SENDER":{"SUPPORTED_FILE":{"NONE_SECURE":"Ce fichier est chiffr sans aucune autre option de scurit active.","EXPANDED_WATERMARKING":"<p>Options de scurit supplmentaires:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Tatouage numrique</p>","IS_MANAGED":"<p>Options de scurit supplmentaires:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Tatouage numrique de PDF</p>","EXPANDED_IS_MANAGED":"<p>Options de scurit supplmentaires:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Tatouage numrique de PDF</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Protection persistante</p>","PERSISTENT_PROTECTION":"<p>Options de scurit supplmentaires:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Protection persistante</p>","EXPANDED_PROTECTION":"<p>Options de scurit supplmentaires:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Tatouage numrique</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Protection persistante</p>"},"UNSUPPORTED_FILE":{"NONE_SECURE":"Ce fichier est chiffr sans aucune autre option de scurit active.","EXPANDED_WATERMARKING":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","IS_MANAGED":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","EXPANDED_IS_MANAGED":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","PERSISTENT_PROTECTION":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge.","EXPANDED_PROTECTION":"Aucune protection supplmentaire active en raison dun format de fichier non pris en charge."},"STEPCHILD":"Cette pice jointe est dote de paramtres de scurit grs indpendamment de ce message."}},"ATTACHMENT_SECTION_TOOLTIP_TITLE":"Pices jointes scurises","ATTACHMENT_SECTION_TOOLTIP_CONTENT":"Les pices jointes ci-dessous sont chiffres par Virtru. Les fichiers avec licne en forme de verrou sont ceux pour lesquels la protection persistante est active. Ils restent protgs aprs avoir t partags ou tlchargs.","ERROR_REFRESH_TOAST_MESSAGE":"Virtru a rencontr une erreur et risque de ne pas fonctionner correctement. Veuillez actualiser la page pour continuer.","REATTACH_FILE_WARNING_MESSAGE_POP_IN":"Vous devrez joindre votre fichier  nouveau. Voulez-vous afficher quand mme?","REATTACH_FILE_WARNING_MESSAGE_POP_OUT":"Vous devrez joindre votre fichier  nouveau. Voulez-vous masquer quand mme?","CKS_INDICATOR_TITLE":"Identit vrifie","CKS_INDICATOR_BODY":"Identit de lexpditeur vrifie par Virtru  des fins de prvention de la fraude.","CKS_INDICATOR_LINK":"En savoir plus","MAIL_MERGE_CONFLICT_MODAL_TITLE":"Conflit de fusion d\'e-mails","MAIL_MERGE_CONFLICT_MODAL_BODY":"La protection Virtru n\'est pas compatible avec la fusion d\'e-mails dans Gmail. Veuillez dsactiver la fusion d\'e-mails pour continuer.","MAIL_MERGE_CONFLICT_TOOLTIP":"La fusion d\'e-mails n\'est pas prise en charge avec la protection Virtru"}');

/***/ }),

/***/ 24427:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var mods = __webpack_require__(25939);
var $ = __webpack_require__(55401);
var {
  ElementWaiter
} = __webpack_require__(36469);
var {
  ModFactory
} = mods;
var {
  ModCollection
} = mods;

/**
 * Gmail DOM Monitor
 *
 * This manages a set of mods using waiters and timers.
 */
function MonitorBase(listeningSelectors, settings, modClasses, collection) {
  this._settings = settings;
  this._modClasses = modClasses;
  this._collection = collection;
  this._initialCleanUpTimeout = 1000; // Clean up periodically
  this._maximumCleanUpTimeout = 240000; // Wait up to 4 minutes
  this._cleanUpTimeout = this._initialCleanUpTimeout;
  this._currentTimeout = null;
  this.addMods = this.addMods.bind(this);
  this.removeMods = this.removeMods.bind(this);
  this.cleanUp = this.cleanUp.bind(this);
  this.initializeCleanUpLoop = this.initializeCleanUpLoop.bind(this);

  // This must be set in derived classes
  this.listeningSelectors = listeningSelectors;
}
MonitorBase.run = function (listeningSelectors, settings, modClasses) {
  var collection = new ModCollection();
  var monitor = new MonitorBase(listeningSelectors, settings, modClasses, collection);
  monitor.initializeWaiter();
  monitor.initializeCleanUpLoop();
  return monitor;
};
MonitorBase.prototype.initializeWaiter = function () {
  var settings = this._settings;
  var modFactories = this._modClasses.map(function (modClass) {
    return ModFactory.create(settings, modClass);
  });
  // Listen to the following areas for change

  var waiter = ElementWaiter.start(this.listeningSelectors, settings.processedClass, modFactories);
  waiter.on('created-mods', this.addMods);
  waiter.on('removed-mods', this.removeMods);

  // Do an initial call on the mutation handler
  setTimeout(function () {
    waiter.handleMutation($(document).children(), []);
  }, 1000);
  this.waiter = waiter;
};
MonitorBase.prototype.initializeCleanUpLoop = function () {
  this._scheduleCleanUp(true);
  // On user click reinitialize the clean up loop
  $(document.body).one('mousedown', this.initializeCleanUpLoop);
};
MonitorBase.prototype.addMods = function (modsLoc) {
  this._collection.extend(modsLoc);
};
MonitorBase.prototype.removeMods = function () {
  this.initializeCleanUpLoop();
};
MonitorBase.prototype.cleanUp = function () {
  this._collection.clean();
  this._scheduleCleanUp(false);
};
MonitorBase.prototype._scheduleCleanUp = function (reset) {
  reset = reset || false;
  if (reset) {
    clearTimeout(this._currentTimeout);
    this._cleanUpTimeout = this._initialCleanUpTimeout;
  } else {
    this._cleanUpTimeout += this._cleanUpTimeout;
    if (this._cleanUpTimeout > this._maximumCleanUpTimeout) {
      this._cleanUpTimeout = this._maximumCleanUpTimeout;
    }
  }
  this._currentTimeout = setTimeout(this.cleanUp, this._cleanUpTimeout);
};
MonitorBase.prototype.updateSettings = function (settings) {
  this._collection.updateSettings(settings);
};
exports.MonitorBase = MonitorBase;

/***/ }),

/***/ 25026:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ACTIVATION_BUTTON_ACTIVATE":"Activate {{currentUser}}","ACTIVATION_BUTTON_REACTIVATE":"Reactivate {{currentUser}}","ACTIVATION_FAILED":"Activation failed","ACTIVATION_FAILED_GENERAL_BODY":"We were unable to activate Virtru protection. Please wait a moment and try again or contact your administrator.","ACTIVATION_HEADER_USER_NOT_ACTIVATED":"{{currentUser}} is not activated to use Virtru","ACTIVATION_LINK":"How it works","ACTIVATION_MESSAGE_DELEGATION_LINK":"Activate","ACTIVATION_SUBTEXT":"To protect your privacy, we periodically need to verify your identity. It just takes a minute, just click to reactivate.","ACTIVATION_TEXT_ACTIVATE":"ACTIVATE VIRTRU TO<br>COMPOSE SECURE EMAILS","ACTIVATION_TEXT_REACTIVATE":"REACTIVATE VIRTRU TO CONTINUE","ACTIVATION_WAIT_CANCELED":"Virtru was unable to authenticate your email account because the authentication tab was closed.<br/><br/>Click the \'Try Again\' link below to restart the process","ACTIVATION_WAIT_ERROR":"Virtru - Could Not Authenticate","ACTIVATION_WAIT_FAILED":"Virtru was unable to authenticate your email account because your current browser settings do not allow cookies to be created, or because you denied Virtru\'s request to verify your email address.</br><br/>The authentication process requires cookies. If you have changed your browser\'s default cookie settings, please configure your browser to allow all cookies, then click the \\"Try Again\\" button. When your account has been authenticated, you may reactivate the cookie restrictions and continue to use Virtru.</br><br/>Virtru requests the \\"See your email address\\" permission from your webmail provider to verify that you own the account you are activating. For more information about how we use your email address, please see our <a href=\\"https://www.virtru.com/terms-of-service\\" target=\\"_blank\\">Terms of Service<a/> and <a href=\\"https://www.virtru.com/privacy-policy\\" target=\\"_blank\\">Privacy Policy</a>. Please click the \\"Try Again\\" button to grant this permission.","ACTIVATION_WAIT_HEADER":"Virtru - Authenticating...","ACTIVATION_WAIT_IN_PRIVATE":"Virtru was unable to authenticate your email account because your browser is in private mode, also known as \\"incognito\\" or \\"InPrivate\\" mode. The authentication process requires cookies, which are restricted in private mode.</br><br/>To continue, please disable private mode and return to your webmail window or tab to restart the authentication process.</br><br/>When your account has been authenticated, you may re-enable private mode and continue to use Virtru.","ACTIVATION_WAIT_MESSAGE":"Virtru is still authenticating your email account on this browser. Until you complete authentication, you will not be able to send or read secure messages.","ANIMATION_WIDGET_LOADING_TEXT":"Decrypting Email...","ATTACHMENTS_UPLOADING_NO_SEND":"Uploading attachments must complete before being able to send.","ATTACHMENT_APPID_ERROR_HEADER":"Activation expired","ATTACHMENT_APPID_ERROR_TEXT":"Your attachments cannot be uploaded because your activation has expired. Please reactivate and try again.","ATTACHMENT_CONNECTION_ERROR_HEADER":"Network error","ATTACHMENT_CONNECTION_ERROR_TEXT":"There was a problem uploading your attachments. Please check your connection and try again.","ATTACHMENT_CONTENT":"Attachment Content","ATTACHMENT_ERROR_CORRUPT":"The attachment is corrupt and cannot be decrypted. Please ask the sender to resend the attachment.","ATTACHMENT_ERROR_UNAUTHORIZED":"You are not authorized to have access to this file.","ATTACHMENT_ERROR_UNKNOWN":"An error has occurred and Virtru is unable to download or decrypt this file. Please try again later.","ATTACHMENT_GENERIC_ERROR_BUTTON":"Dismiss","ATTACHMENT_GENERIC_ERROR_HEADER":"Attachment error","ATTACHMENT_GENERIC_ERROR_TEXT":"There was a problem uploading your attachments. Please check your files, browser, and plugin before trying again.","ATTACHMENT_INTEGRITY_COMPROMISED":"Virtru cannot decrypt this attachment.\\n\\nThis situation usually occurs when a message\'s ciphertext has been modified, thus making the encryption unreadable.","ATTACHMENT_ERROR_CLOSE_BUTTON":"Close","ATTACHMENT_NOT_READY_ERROR":"Attachment not ready","ATTACHMENT_OPTIONS":"Attachment Options","ATTACHMENT_PFP_ERROR_HEADER":"Attachment Error","ATTACHMENT_REVOKED_HEADER":"Access Revoked","ATTACHMENT_REVOKED_TEXT":"You no longer have permission to view this file","ATTACHMENT_TOO_LARGE_HEADER":"Attachment too large","ATTACHMENT_TOO_LARGE_TEXT":"One or more of your attachments was too large to be encrypted. Please attach files that are under {{maxSizeMb}} MB.","ATTACHMENT_TOO_LARGE_SUGGEST_SECURE_SHARE_TEXT":"One or more of your attachments exceeds size limit for email encryption. Please attach files under {{maxSizeMb}} MB, or use Virtru Secure Share to send files up to {{secureShareMaxSize}} GB to your recipients securely.","CANNOT_DECRYPT_GET_HELP":"Learn more about this in Virtru\'s FAQ.","CANNOT_DECRYPT_HEADER":"Possibly Altered Message","CANNOT_DECRYPT_MESSAGE_CKS":"The {{ownerName}} encryption server is unreachable.<br/>For help, <a href=\\"{{ownerSupportUrl}}\\">contact the<br/>{{ownerName}} support desk</a>.","CANNOT_DECRYPT_MESSAGE_CKS_TROUBLE_READING_EMAIL":"We\'re having trouble reading your email. Try again later!","CANNOT_DECRYPT_MESSAGE_INTEGRITY_COMPROMISED":"Virtru has detected that this message may have been tampered with. Try asking <span class=\\"vic-message-bold\\">{{sender}}</span> to resend the message.","CHROME_POPUP_ABOUT_VIRTRU_BUTTON":"About Virtru","CHROME_POPUP_ACTIVATION_BUTTON":"Activate Virtru for {{userId}}","CHROME_POPUP_ACTIVATION_LABEL":"Virtru Email Protection","CHROME_POPUP_SIGN_OUT_BUTTON":"Sign Out","CHROME_POPUP_VIRTRU_CONTROL_CENTER_BUTTON":"Control Center","CHROME_POPUP_SUPPORT_BUTTON":"Support","CHROME_POPUP_UNINSTALL_BUTTON":"Uninstall","CHROME_POPUP_DRIVE_CROSS_SELL":"Get Virtru for Drive","CHROME_POPUP_SECURE_SHARE_CROSS_SELL":"Get Virtru Secure Share for Drive","COMMON_RETRY_SECURE_SEND":"Retry Secure Send","COMMON_CANCEL":"Cancel","COMMON_CLOSE":"Close","COMMON_OK":"OK","COMMON_SEND":"Send","COMMON_SEND_SECURE":"Secure Send","COMMON_SEND_SECURE_TOOLTIP_OFFLINE":"Protected message cannot be sent because Virtru is offline","COMMON_TRY_AGAIN":"Try Again","COMMON_REFRESH":"refresh","COMMON_REFRESH_PAGE":"Refresh Page","COMPOSE_ACTIVATION_REQUIRED":"Virtru requires activation","COMPOSE_ATTACHMENTS_UPLOADING_WARN":"Secure mode cannot be toggled while attachments are uploading.  Please wait until attachments are finished uploading and then toggle secure mode.","COMPOSE_DRIVE_ATTACHMENTS_UNSUPPORTED":"Virtru does not currently support Drive attachments. Would you like to remove them?","COMPOSE_EXPIRES":"Expires {{timeRemaining}}","COMPOSE_INSERT_DRIVE_INSERT_FILE":"Inserting files from Google Drive is not supported in secure mode.","COMPOSE_INSERT_PHOTOS_INLINE_IMAGES":"Currently, Virtru does not support inline images.","COMPOSE_OFF_CONFIRM_REMOVE":"If secure mode is turned off all secure attachments will be removed.  Are you sure you want to do this?","CONTENT_IS_MANAGED":"The sender has disabled download for this file.","CONTEXTUAL_ACTIVATE_INFO":"The account {{currentUser}} has not been activated with Virtru.  Once activated, your identity is verified and Virtru sends you the keys to decrypt your secure messages.  Virtru never has access to any of your content.","DISMISS_POPOVER_DEFAULT_OPTIONS_TEXT":"Ok, got it.","DOWNLOAD_ATTACHMENT_DECRYPTING":"Decrypting","EMAIL_BODY_CONTENT":"Email Body Content","EMAIL_ERROR_EMAIL_CORRUPT":"The message is corrupt and cannot be decrypted. Please ask the sender to resend the message.","EMAIL_ERROR_EMAIL_CORRUPT_HEADER":"Email Corrupt","EMAIL_ERROR_INTERNAL_SERVER_ERROR":"Virtru\'s servers did not respond. Please wait a few minutes and try again.","EMAIL_ERROR_INTERNAL_SERVER_ERROR_HEADER":"Server Error","EMAIL_ERROR_NETWORK_LOST":"Virtru could not connect to the internet. Please check your internet connection and try again.","EMAIL_ERROR_NETWORK_LOST_HEADER":"Network Connection Error","EMAIL_ERROR_READ":"The message could not be decrypted. Please check your internet connection and try again.","EMAIL_ERROR_SEND":"An error occurred and the message could not be sent. Please check your internet connection and try again.","EMAIL_ERROR_SMART_SEND_SECURE":"An error occurred when attempting to send your message. Please contact Virtru if the problem persists.","EMAIL_ERROR_SMART_SEND_SECURE_HEADER":"Error Sending","EMAIL_ERROR_TEMPLATE_SUPPORT_LINK":"Virtru Support","EMAIL_ERROR_UNKNOWN":"Virtru has encountered an error and is unable to send this message. Please refresh this page and try again.","EMAIL_ERROR_UNKNOWN_HEADER":"Unknown Error","EMAIL_ERROR_YOURE_ON_STAGING":"Whoa there cowboy... looks like you\'re trying to get tricky and read an e-mail from the wrong server (staging/production). Check the options page to see which server you\'re pointing to.. you might just be pointing to the wrong one.","EMAIL_ERROR_YOURE_ON_STAGING_HEADER":"Whoa there cowboy... looks like you\'re trying to get tricky and read an e-mail from the ","EMAIL_ERROR_SEND_UNKNOWN":"Virtru has encountered an error and is unable to send this message. Click the button below to try sending again.","EMAIL_ERROR_SEND_UNKNOWN_HEADER":"Unknown error","EMAIL_ERROR_SEND_REACTIVATION":"Activation expired, please reactivate to send your message.","EMAIL_ERROR_SEND_REACTIVATION_HEADER":"Error Sending","EMAIL_ERROR_SEND_REACTIVATION_RETRY_BUTTON":"Reactivate and Send","EMAIL_ERROR_READ_SECURE_READER_LABEL":"Click here to view the message in Virtru\'s Secure Reader","EMAIL_EXPIRATION":"Expiration Date","SMS_REQUIRE":"Require SMS","SMS_PHONE_INPUT_LABEL":"Input phone number","SMS_ERROR_WRONG_NUMBER":"Wrong or empty phone number","SMS_NO_RECIPIENTS":"No recipients","POLICY_MENU_ERROR":"Wrong or empty phone number for SMS two-factor authentication option","EMAIL_INVALID_ADDRESS":"The address \\"{{invalidAddress}}\\" was not recognized. Please make sure that all addresses are properly formed.","EMAIL_INVALID_ADDRESS_GENERIC":"One or more email addresses were not recognized. Please make sure that all addresses are properly formed.","EMAIL_ADDRESS_NOT_FOUND":"Please specify at least one recipient.","EMAIL_TEMPLATE_FOOTER":"Secured by Virtru","EMAIL_TEMPLATE_SENDER_HEADER":"Your message, protected by Virtru","ENCRYPTED_SEARCH_REMINDER_HEADER":"Encrypted Search will not appear in your search results.","ENCRYPTED_SEARCH_REMINDER_SUBTEXT":"Searching of Virtru-encrypted message bodies is not currently enabled. Click here to learn how to enable Encrypted Search.","ENHANCEDPDF_DL_DISABLED_TOOLTIP":"The sender has disabled download for this file. Click below to view it in Virtru\'s Secure Reader.","ENHANCEDPDF_DL_DISABLED_TOOLTIP_TITLE":"Enhanced PDF Protection","EXPANDED_WATERMARKING_DL_DISABLED_TOOLTIP_TITLE":"Enhanced Protection","FAQ":"FAQ","FEATURE_CHIP_TEXT":"New Feature","FEATURE_ENCRYPTED_SEARCH_FAQ":"Learn more in our FAQ","FEATURE_ENCRYPTED_SEARCH_POPUP_DESCRIPTION":"To enable search for your Virtru-encrypted emails, click below to go to the \'Features\' tab of your Virtru Control Center.","FEATURE_ENCRYPTED_SEARCH_BUTTON":"Go To Control Center","FEATURE_ENCRYPTED_SEARCH_CANCEL":"Later","FEATURE_ENCRYPTED_SEARCH_DESCRIPTION":["In Control Center, go to Features tab and enable search.","Or, go to our FAQ to learn more."],"FEATURE_ENCRYPTED_SEARCH_TITLE_TEXT":"Search Your Encrypted Emails","FEATURE_ENCRYPTED_SEARCH_SUB_TITLE_TEXT":"Enable search for your Virtru-encrypted emails","FEATURE_VAULT_BUTTON":"Get Started","FEATURE_VAULT_CANCEL":"No Thanks","FEATURE_VAULT_DESCRIPTION":["Search encrypted emails and decrypt them directly","Maintain sensitivity with Virtru encryption","Easily discoverable by authorized parties","Integrated into your existing Google interface","Contact a Virtru representative for more information."],"FEATURE_VAULT_SUB_TITLE_TEXT":"Add the Google Vault package to your Virtru end-to-end encryption","FEATURE_VAULT_TITLE_TEXT":"Search Virtru Emails in Google Vault","FILE_SIZES":{"BYTES":"b","UNITS":["Kb","Mb","Gb","Tb","Pb","Eb","Zb","Yb"]},"DELIMITERS":{"DECIMAL":"."},"FIRST_TIME_ONBOARD_LINK_ACTIVATE":"Activate","FOOTER_POPOVER_BODY":"Let your friends and colleagues know they can email you securely with Virtru.","FOOTER_POPOVER_HEADER":"Communicate Privately","FOOTER_POPOVER_REMOVE_SIGNATURE":" Remove from my email signature ","FOOTER_PROMO":"Need to send me private email? I use","FOOTER_PROMO_USE":"Virtru","FORWARDING_RESTRICTED":"- Forwarding Restricted","GMAIL_BASIC_MODE_UNSUPPORTED_MAIN":"Gmail\'s basic HTML view not supported","GMAIL_BASIC_MODE_UNSUPPORTED_SUB":"Please switch to standard view to use Virtru.","GO_TO_SECURE_SHARE":"Go to Secure Share","INTRO_MESSAGE_FOOTER_TEXT":"Text above this line will not be encrypted.","INVITATION_EMAIL_REPLACE_TEXT_DEFAULT":"This is a secure message chain, protected by Virtru.","LEARN_MORE":"Learn More","LIMITED_ENCRYPTION_BUTTON_CANCEL":"Cancel","LIMITED_ENCRYPTION_BUTTON_OK":"Continue","LIMITED_ENCRYPTION_CHECKBOX":"Don\'t show me again","LIMITED_ENCRYPTION_HEADER":"Limited Protection","LIMITED_ENCRYPTION_TEXT":"Additional security features such as Persistent Protection and Watermarking will not be applied to the following attachments because the file types are either unsupported or have security settings managed separately from this message:","MESSAGE_OPTIONS":"Message Options","MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE":{"lastDay":"[Yesterday @] LT","lastWeek":"[Last] dddd [@] LT","nextDay":"[Tomorrow @] LT","nextWeek":"dddd [@] LT","sameDay":"[Today @] LT","sameElse":"dddd[,] MMM Do[,] YYYY [@] LT"},"MOMENT_CALENDAR_RECIPIENT_EXPIRATION":{"lastDay":"[at] LT [yesterday]","lastWeek":"[at] LT [last] dddd","nextDay":"[at] LT [tomorrow]","nextWeek":"[at] LT [on] dddd","sameDay":"[at] LT [today]","sameElse":"[at] LT [on] dddd[,] MMM Do[,] YYYY"},"MOMENT_CALENDAR_SENDER_EXPIRED":{"lastDay":"[yesterday at] LT","lastWeek":"[last] dddd [at] LT","nextDay":"[tomorrow at] LT","nextWeek":"[on] dddd [at] LT","sameDay":"[today at] LT","sameElse":"[on] dddd[,] MMM Do[,] YYYY [at] LT"},"MOMENT_CALENDAR_SENDER_EXPIRING_SOON":{"lastDay":"LT [yesterday]","lastWeek":"LT [last] dddd","nextDay":"LT [tomorrow]","nextWeek":"LT [on] dddd","sameDay":"LT [today]","sameElse":"LT [on] dddd[,] MMM Do[,] YYYY"},"NESTED_MESSAGE_PLACEHOLDER_TEXT_DEFAULT":"Show last secure message","NESTED_MESSAGE_PLACEHOLDER_TEXT_LOADING":"Loading secure message...","NEW_COMPOSE_ARCHIVE_SEND":"Send +","NEW_COMPOSE_ARCHIVE_SEND_SECURE":"Secure Send +","NEW_COMPOSE_DISABLED_WHILE_SECURING":"Disabled while securing message (and attachments)","NEW_MESSAGE_NOT_SECURE":"New Message","NEW_FEATURE_POPOVER_PP_BODY":"Virtru can now keep your file attachments secured after they have been shared and downloaded.<br><br><a href=\'https://support.virtru.com/hc/en-us/articles/360022693153\'>Learn more</a> about this feature, including the recipient experience.","NEW_FEATURE_POPOVER_PP_BUTTON":"Dismiss","NEW_FEATURE_POPOVER_PP_LABEL":"New! Persistent Protection","NEW_MESSAGE_SECURE":"New Secure Message","OFFLINE_MODE_MODAL":{"PROTECTION_OFF":{"ACTION":"Close","BODY":"Virtru protection is currently disabled because your network connection is offline.","TITLE":"No network detected"},"PROTECTION_ON":{"ACTION":"Close","BODY":"Virtru protection is currently disabled because your network connection is offline. Any revisions while offline will not be saved.","TITLE":"No network detected"}},"OKGOTIT":"OK, GOT IT!","ONBOARDING_POPOVER_1_CONFIRM":"Activate","ONBOARDING_POPOVER_1_ENTERPRISE_BODY":"Your company uses Virtru to protect email and keep its\' data private. To start sending secure messages, activate your email account.","ONBOARDING_POPOVER_1_HEADER":"Welcome to Virtru","ONBOARDING_POPOVER_1_INDIVIDUAL_BODY":"Protecting email and keeping your data private is easy with Virtru. To start sending secure messages, activate your email account.","ONBOARDING_POPOVER_2_BODY":"You\'re now ready to send secure messages from {{currentUser}} using Virtru.","ONBOARDING_POPOVER_2_CONFIRM":"Next","ONBOARDING_POPOVER_2_HEADER":"Your email address is activated","ONBOARDING_POPOVER_2_SKIP_CHECKBOX_LABEL":"Dont show again","ONBOARDING_POPOVER_3_BODY":"Changed your mind? Revoke access or update controls from your Gmail Sent Folder or your <a href=\'https://secure.virtru.com/control-center\'>Virtru Control Center</a>.","ONBOARDING_POPOVER_3_CONFIRM":"Done","ONBOARDING_POPOVER_3_HEADER":"You sent your first secure message!","ONBOARDING_RESTART_4_BODY":"Virtru protects your messages and attachments. To learn more about how Virtru protects you, please visit us at <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>.","ONBOARDING_RESTART_4_ORG_BODY":"Virtru protection has been set to \\"On\\" by your Administrator, and will protect your messages and attachments.<br><br>To learn more about how Virtru protects you, please visit us at <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>.","ONBOARDING_RESTART_4_ORG_HEADING":"Virtru Protection","ONBOARDING_RESTART_CONFIRM":"Take the tour","ONBOARDING_SEND_VERIFICATION":"Send Activation Email","ONBOARDING_TOUR_1_BODY":"When you\'re ready to send a secure message, select <span class=\\"bold\\">Compose</span> to begin.","ONBOARDING_TOUR_1_HEADER":"Start composing a message","ONBOARDING_TOUR_2_BODY":"Any time you need to send a secure message, turn on Virtru at the top right of the compose window. Drafts are also protected, even before you send.","ONBOARDING_TOUR_2_HEADER":"Turn on Virtru protection","ONBOARDING_TOUR_3_BODY":"Control access to your secure message: set an expiration date, disable forwarding, or watermark attachments.","ONBOARDING_TOUR_3_HEADER":"Add Security Options","ONBOARDING_TOUR_4_BODY":"Secure messages can include introduction text that the recipient can see without decrypting the whole message. You can customize that introduction by selecting <span class=\\"bold\\">Personal Introduction</span>.","ONBOARDING_TOUR_4_HEADER":"Personal Introduction","ONBOARDING_TOUR_CONFIRM":"OK","ONE_CLICK_OPTION":"Require Authentication","PAGE_ACTIONS_FORMAT_NON_PROD_MESSAGE":"This message was sent using {{acmUrl}}","PERSONAL_INTRO_ADD":"Personal Introduction","ARIA_PERSONAL_INTRO":"Personal Introduction","PERSONAL_INTRO_ONBOARD":"Add an unencrypted personal introduction to your private email.  This lets recipients know that your message is genuine and not spam.","PERSONAL_INTRO_PLACEHOLDER_TEXT":"[Enter your intro message here. Include information that only your recipient would know, or write it in such a way that they know it\'s really you.]","PLAINTEXT_NOT_SUPPORTED_HEADER":"Plain text mode is not supported","PLAINTEXT_NOT_SUPPORTED_TEXT":"Please turn off plaintext mode before continuing.","PLAINTEXT_NOT_SUPPORTED_TITLE":"Send Failed","POLICY_MENU_DISABLE_FORWARDING":"Disable Forwarding","POLICY_MENU_EXPANDED_WATERMARKING":"Watermarking","POLICY_MENU_PERSISTENT_PROTECTION":"Persistent Protection","POLICY_MENU_WATERMARKING":"PDF Watermarking","POLICY_MENU_SUPPORTED_FILES_INFO_TITLE":"Supported Formats","REQUIRE_AUTH_FOR_MORE_OPTIONS":"Require Authentication for more options","PROTECTION_REQUIRED":"Protection required","PROTECT_AND_SEND":"Protect & Send","READ_RECEIPT_FORWARD_COUNT_DETAILS":"(click for more details)","RECIPIENT":"Recipient Field","RECIPIENT_WIDGET_EXPIRATION_DATE":"Expires {{datetime}}","RECIPIENT_WIDGET_EXPIRED":"This message has expired","RECIPIENT_WIDGET_EXPIRED_BODY":"ACCESS EXPIRED","RECIPIENT_WIDGET_EXPIRED_DATE":"This message expired {{datetime}}","RECIPIENT_WIDGET_HEADER":"You are reading a secure message, protected by Virtru","RECIPIENT_WIDGET_NO_EXPIRATION":"No expiration date","RECIPIENT_WIDGET_OFFLINE_BODY":"LOST INTERNET CONNECTION","RECIPIENT_WIDGET_OFFLINE_HEADER":"Access to secure messages is not allowed without an internet connection.","RECIPIENT_WIDGET_REVOKED_BODY":"ACCESS REVOKED","RECIPIENT_WIDGET_REVOKED_HEADER":"The author has removed your access","RECIPIENT_WIDGET_UNAUTHORIZED_BODY":"THIS EMAIL ADDRESS IS NOT AUTHORIZED TO VIEW THIS EMAIL","RECIPIENT_WIDGET_UNAUTHORIZED_HEADER":"This email address is not authorized to read this email","RESTORE_DRAFT_FAILED":"There was a problem restoring this draft. Please check your network connection and try again.","SCREENREADER_VIRTRU_INFO":"More information about Virtru Email Protection","SCREENREADER_CLOSED_POLICY_MENU":"Closed policy menu","SCREENREADER_DISABLED_EXPIRATION":"Disabled expiration","SCREENREADER_DISABLED_FORWARDING":"Disabled forwarding","SCREENREADER_DISABLED_ONECLICK":"Disabled One-Click Access","SCREENREADER_DISABLED_WATERMARK":"Disabled watermark","SCREENREADER_DISABLED_WATERMARK_PDF":"Disabled watermark PDF","SCREENREADER_DISABLED_PFP":"Disabled persistent protection","SCREENREADER_DISABLE_FORWARDING":"Disable forwarding","SCREENREADER_ENABLED_EXPIRATION":"Enabled expiration","SCREENREADER_ENABLED_FORWARDING":"Enabled forwarding","SCREENREADER_ENABLED_ONECLICK":"Enabled One-Click Access","SCREENREADER_ENABLED_WATERMARK":"Enabled watermark","SCREENREADER_ENABLED_WATERMARK_PDF":"Enabled watermark PDF","SCREENREADER_ENABLED_PFP":"Enabled persistent protection","SCREENREADER_EXPIRATION":"Expiration set","SCREENREADER_ONECLICK":"Enable One-Click Access","SCREENREADER_OPENED_POLICY_MENU":"Opened policy menu","SCREENREADER_VIRTRU_POLICY_MENU":"Virtru Security Options","SCREENREADER_VIRTRU_SECURE_TOGGLE":"Virtru secure toggle","SCREENREADER_WATERMARK_PDF":"Watermark PDF","SCREENREADER_WATERMARK":"Watermark","SCREENREADER_PFP":"Persistent protection","SCREENREADER_SMS_ENABLED":"Enabled SMS two-factor authentication","SCREENREADER_SMS_DISABLED":"Disabled SMS two-factor authentication","SECURE_EMAIL_COMPOSER_PLACEHOLDER_HTML":"The email chain has been secured by Virtru.","SECURE_EMAIL_COMPOSER_POLICY_OPTIONS_DEFAULT":"(No Subject)","SECURE_MESSAGE_CONTROL_ENABLE":"Enable","SECURE_MESSAGE_CONTROL_REVOKE":"Revoke","SECURE_MESSAGE_LABEL":"You are reading a secured message","SECURE_MESSAGE_SENT_NOTIFICATION":"Secure message sent.","SECURED_ATTACHMENTS_HEADER":"{{count}} SECURED ATTACHMENT","SECURED_ATTACHMENTS_HEADER_plural":"{{count}} SECURED ATTACHMENTS","SENDER_WIDGET_ERROR_ENABLE_MESSAGE":"There was an error processing enabling this message.","SENDER_WIDGET_ERROR_REVOCATION":"There was an error processing the revocation.","SENDER_WIDGET_ERROR_UPDATE_POLICY":"There was an error updating the policy.","SENDER_WIDGET_EXPIRED_DATE":"Expired {{datetime}}","SENDER_WIDGET_EXPIRES_DATE":"Expires {{datetime}}","SENDER_WIDGET_MESSAGE_REVOKED":"This message has been revoked","SENDER_WIDGET_NO_EXPIRATION":"No expiration date","SENDER_WIDGET_REVOKED_DATE":"Revoked {{datetime}}","SEND_ANIMATION_LOADING_TEXT":"Encrypting Email...","SEND_ANYWAY":"Send Anyway","SEND_ANYWAY_OFFLINE":"Queue Anyway","SCHEDULE_SEND":"Schedule Send","GO_BACK":"Go Back","SEND_BLOCK_HEADER":"Email cannot be sent","SEND_BLOCK_SUBTEXT":"According to your organization\'s content security policy, this email contains sensitive information and cannot be sent without Virtru Protection.","SEND_BLOCK_BOLDTEXT":"Please remove any sensitive data, and try again.","SEND_WARNING_BUTTON_SEND":"SEND","SEND_WARNING_BUTTON_SEND_SECURE":"SEND SECURE","SEND_WARNING_BUTTON_SEND_SECURE_IMMEDIATELY":"Send Secure Now","SEND_WARNING_WARNING_SEND_SCHEDULED_LABEL":"However, schedule send is not currently supported with Virtru protection. Please either Send Secure Now or remove the sensitive information to Schedule Send.","SEND_WARNING_SCHEDULE_SEND_NOT_SUPPORTED":"Schedule send is not currently supported. Please either Send Secure Now or send schedule with no Virtru protection.","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE":"Scheduled send unavailable","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE_TOOLTIP":"Schedule send is not currently supported with Virtru protection","SENSITIVE_DATA_FOUND":"Sensitive data found","WARN_SENSITIVE_DATA_FOUND_BODY":"The message you\'re sending contains sensitive information. Your organization recommends that you turn on Virtru protection before sending this email.","WARN_SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE":"You can protect and send this draft when you have regained network connectivity, or queue this email in your Outbox without Virtru protection.","WARN_SENSITIVE_DATA_FOUND_BODY_OFFLINE":"The message you\'re sending contains sensitive information.","WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE":"However, Virtru protection is not compatible with Mail Merge in Gmail. Please select {{button}} on this screen and turn off Mail Merge to proceed.","SENSITIVE_DATA_FOUND_BODY":"The message you\'re sending contains sensitive information and your organization has automatically applied Virtru protection.","SENSITIVE_DATA_FOUND_BODY_OFFLINE":"The message you\'re sending contains sensitive information.","SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE":"You can protect and send this draft when you have regained network connectivity, or remove the sensitive information to queue this email in your Outbox without Virtru protection.","WARN_ATTACHMENTS_LIMIT_REACHED":"Attachment limit reached","ATTACHMENTS_LIMIT_REACHED_BODY":"You have attached [ATTACHMENTS_COUNT] files to this message. Virtru protection supports up to [ATTACHMENTS_LIMIT] attachments per secure message. Please remove [ATTACHMENTS_REMOVE_COUNT] files from this secure message and try again.","SMART_SEND_SECURE_STACK_ERROR_HEADER":"Message cannot be sent","SMART_SEND_SECURE_STACK_ERROR_BODY":"This message exceeds the maximum size for encryption, typically due to the number of replies, forwards, or amount of content. Please reduce your message size, or start a new conversation.\\n\\nVisit <a href=\\"https://support.virtru.com/hc/en-us\\" target=\\"blank\\">Virtru Support</a> for more information.","TOOLTIP_DISABLE_FORWARDING":"Disable Forwarding","TOOLTIP_EXPIRATION":"Expiration Date","TOOLTIP_EXPIRES":"Expires: {{date}}","TOOLTIP_FORWARDING_RESTRICTED":"Forwarding Restricted","TOOLTIP_FORWARDING_RESTRICTED_CONTENT":"Forwarding has been restricted on a secure message in the chain.  Recipients added to your message may not be able to access the forwarded message.  The owner of the secure message must allow access to new recipients.","TOOLTIP_ONE_CLICK":"One-Click Access","TOOLTIP_REAUTHORIZE_BUTTON_CONTENT":"This message was revoked previously. Reauthorizing it will let people see it again.","TOOLTIP_REAUTHORIZE_BUTTON_TITLE":"Reauthorize Message","TOOLTIP_RECIPIENT_DISABLE_FORWARDING":"This Virtru-secured message has been restricted from forwarding by its sender.","TOOLTIP_ENABLE_SMS":"SMS two-factor authentication","TOOLTIP_RECIPIENT_SMS":"This Virtru-secured message require sms authentication.","TOOLTIP_RECIPIENT_EXPIRATION":"This Virtru-secured message expires {{date}}. To view this message after it expires, contact the sender.","TOOLTIP_RECIPIENT_ONE_CLICK":"This Virtru-secured message does not require authorization to read.","TOOLTIP_RECIPIENT_UNAUTHORIZED_INFO":"The original author of this email has restricted access to this message. Therefore, if you did not directly receive this message from the original author, you may not view its contents.<br><br>To get access, contact the original author.","TOOLTIP_REVOKE_BUTTON_CONTENT":"Disables access to your message. Other than you, no one will be able to see this message.","TOOLTIP_REVOKE_BUTTON_TITLE":"Revoke Message","TOOLTIP_SECURE_ATTACHMENT_CONTENT":"{{filename}} has been secured by Virtru","TOOLTIP_SECURE_ATTACHMENT_DOWNLOAD":"Decrypt & Download","TOOLTIP_SECURE_ATTACHMENT_DRIVE":"Save to Google Drive\\nnot Virtru supported","TOOLTIP_SECURE_ATTACHMENT_TITLE":"Virtru Secure Attachment","TOOLTIP_SENDER_DISABLE_FORWARDING_CONTENT":"This setting makes your message unreadable if it\'s been forwarded","TOOLTIP_SENDER_ENABLE_SMS2FA":"Access to this message will require SMS verification","TOOLTIP_SENDER_EXPIRATION_CONTENT":"After your specified time, your recipients will no longer have access to this message","TOOLTIP_SENDER_ONE_CLICK_CONTENT":"Turning this off makes authentication not required to view your encrypted message","TOOLTIP_TOGGLE_DISABLED":"You are not authorized to send securely.  Please contact your administrator if you have any questions.","TOOLTIP_TOGGLE_ON":"Virtru protection is enabled","TOOLTIP_TOGGLE_ON_ORG":"Virtru protection is enabled by default. You can disable if not required.","TOOLTIP_SENDER_WATERMARK":"Watermarking","TOOLTIP_SENDER_WATERMARK_CONTENT":"Supported attachments will be watermarked in Secure Reader","TOOLTIP_SENDER_PFP":"Persistent Protection","TOOLTIP_SENDER_PFP_CONTENT":"This setting protects files by requiring authentication even if it\'s shared or downloaded to a computer","TOOLTIP_TOGGLE_OFF":"Protect your message with Virtru","TOOLTIP_TOGGLE_OFF_OFFLINE":"Virtru protection cannot be enabled while offline","TOOLTIP_UPSELL_POSTFIX":"<br/><br/>This feature is available in the Pro version of Virtru.","TOOLTIP_VIRTRU_OPTIONS":"Security Options","TWO_FACTOR_AUTH_ERROR":"This sender has added extra security options.\\nYou must decrypt this message outside of Gmail.","UNLOCK_MESSAGE_BUTTON":"Unlock Message","UNSECURE_ATTACHMENTS_EXIST_HEADER":"Unsecure attachments exist","UNSECURE_ATTACHMENTS_EXIST_TEXT":"Unable to send secure while attachments detected.","UNSECURE_ATTACHMENTS_EXIST_TITLE":"Send Failed","UPDATE_MODAL_HEADER":"Virtru has been updated.","UPDATE_MODAL_REFRESH_BUTTON":"Click here to refresh","UPDATE_MODAL_SUBHEADER":"Please refresh this page to make sure <br>you\'re using the latest version.","VIRTRU_ATTACHMENT_DECRYPTING":"Decrypting","VIRTRU_ATTACHMENT_DOWNLOAD":"Download","VIRTRU_ATTACHMENT_VIEW":"View","VIRTRU_ATTACHMENT_REMOVE":"Remove","VIRTRU_AUTH_LINK":"Activate Virtru","VIRTRU_AUTH_LINK_REACTIVATE":"Reactivate Virtru","VIRTRU_CONTACT_US":"Please contact your IT administrator","VIRTRU_DISABLED_ON_DOMAIN":"Virtru has been disabled for your domain","VIRTRU_PROTECTION_NOT_AUTH":"Virtru must be activated to enable protection.","VIRTRU_PROTECTION_NOT_AUTH_OFFLINE":"Network connection required for Virtru activation.","VIRTRU_PROTECTION_NOT_AUTH_SHORT":"Please activate Virtru.","VIRTRU_PROTECTION_ON":"Virtru Protection ON","VIRTRU_PROTECTION_OFF":"Virtru Protection OFF","VIRTRU_PROTECTION_OFFLINE":"Virtru protection is offline","VIRTRU_SECURE_DRAFT_PREFIX":"This is a draft secured by Virtru","WEBMAIL_PLUGIN_ACTIVATION_LINK_RETRY":"Send again","WEBMAIL_PLUGIN_ACTIVATION_TEXT":"Verification email sent.<br>Check this inbox shortly.","WEBMAIL_PLUGIN_INIT_ERROR":"Virtru was unable to successfully initialize. This may be due to network connectivity errors or a broken user configuration. Please try refreshing again in a few moments, or contact Virtru customer support at <a href=\\"https://support.virtru.com/hc/en-us/\\">https://support.virtru.com/hc/en-us/</a>","WEBMAIL_PLUGIN_INIT_ERROR_HEADER":"Virtru plugin failed to initialize","WIDGET_BASE_BODY_REVOKED":"ACCESS DENIED","WIDGET_BASE_EXPIRATION_OPTIONS_CUSTOM":"Add custom date/time","WIDGET_BASE_FOOTER":"Secured by Virtru technology","WIDGET_BASE_HEADER_MESSAGE_RECIPIENT":"You are reading a secure message, protected by Virtru","WIDGET_BASE_HEADER_MESSAGE_SENDER":"Your message, protected by Virtru","WIDGET_BASE_MENU_OPTION_EXPIRES":"Add Expiration","WIDGET_BASE_MENU_OPTION_FORWARDING":"Disable Forwarding","EXPIRATION_UNIT_DAYS":"day","EXPIRATION_UNIT_DAYS_plural":"days","EXPIRATION_UNIT_HOURS":"hour","EXPIRATION_UNIT_HOURS_plural":"hours","EXPIRATION_UNIT_MINS":"minute","EXPIRATION_UNIT_MINS_plural":"minutes","EXPIRATION_UNIT_MONTHS":"month","EXPIRATION_UNIT_MONTHS_plural":"months","EXPIRATION_UNIT_WEEKS":"week","EXPIRATION_UNIT_WEEKS_plural":"weeks","EXPIRATION_UNIT_YEARS":"year","EXPIRATION_UNIT_YEARS_plural":"years","READ_RECEIPT_READBY_COUNT":"Read by {{accessors}} of {{count}} recipient","READ_RECEIPT_READBY_COUNT_plural":"Read by {{accessors}} of {{count}} recipients","READ_RECEIPT_FORWARD_COUNT":"<div style=\\"text-align:center;\\">Forwarded {{count}} time<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","READ_RECEIPT_FORWARD_COUNT_plural":"<div style=\\"text-align:center;\\">Forwarded {{count}} times<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","ATTACHMENTS_TOOLTIP_CONTENT":{"RECIPIENT":{"SUPPORTED_FILE":{"NONE_SECURE":"This file is encrypted with no additional security options enabled.","EXPANDED_WATERMARKING":"This file will be watermarked when viewed in Virtru Secure Reader.","IS_MANAGED":"This file will be watermarked when viewed in Virtru Secure Reader.","EXPANDED_IS_MANAGED":"This file has additional security options enabled, and will be watermarked and remain protected when downloaded or shared.","PERSISTENT_PROTECTION":"This file has Persistent Protection enabled, and will remain secure when downloaded or shared.","EXPANDED_PROTECTION":"This file has additional security options enabled, and will be watermarked and remain protected when downloaded or shared."},"UNSUPPORTED_FILE":{"NONE_SECURE":"This file is encrypted with no additional security options enabled.","EXPANDED_WATERMARKING":"No additional protection enabled due to unsupported file format.","IS_MANAGED":"No additional protection enabled due to unsupported file format.","EXPANDED_IS_MANAGED":"No additional protection enabled due to unsupported file format.","PERSISTENT_PROTECTION":"No additional protection enabled due to unsupported file format.","EXPANDED_PROTECTION":"No additional protection enabled due to unsupported file format."},"STEPCHILD":"This attachment has security settings that are managed separately from this message."},"SENDER":{"SUPPORTED_FILE":{"NONE_SECURE":"This file is encrypted with no additional security options enabled.","EXPANDED_WATERMARKING":"<p>Additional Security Options:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Watermarking</p>","IS_MANAGED":"<p>Additional Security Options:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>PDF Watermarking</p>","EXPANDED_IS_MANAGED":"<p>Additional Security Options:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>PDF Watermarking</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Persistent Protection</p>","PERSISTENT_PROTECTION":"<p>Additional Security Options:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Persistent Protection</p>","EXPANDED_PROTECTION":"<p>Additional Security Options:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Watermarking</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Persistent Protection</p>"},"UNSUPPORTED_FILE":{"NONE_SECURE":"This file is encrypted with no additional security options enabled.","EXPANDED_WATERMARKING":"No additional protection enabled due to unsupported file format.","IS_MANAGED":"No additional protection enabled due to unsupported file format.","EXPANDED_IS_MANAGED":"No additional protection enabled due to unsupported file format.","PERSISTENT_PROTECTION":"No additional protection enabled due to unsupported file format.","EXPANDED_PROTECTION":"No additional protection enabled due to unsupported file format."},"STEPCHILD":"This attachment has security settings that are managed separately from this message."}},"ATTACHMENT_SECTION_TOOLTIP_TITLE":"Secured Attachments","ATTACHMENT_SECTION_TOOLTIP_CONTENT":"The attachments below are encrypted by Virtru. Files with the lock icon have Persistent Protection enabled, and will still be protected after being shared or downloaded.","ERROR_REFRESH_TOAST_MESSAGE":"Virtru has encountered an error and may not function properly. Please refresh this page to continue.","REATTACH_FILE_WARNING_MESSAGE_POP_IN":"You will have to reattach your file. Pop-in anyway?","REATTACH_FILE_WARNING_MESSAGE_POP_OUT":"You will have to reattach your file. Tear off anyway?","PROTECTION_OVERVIEW_POPUP":"Virtru protection overview popup","PROTECTION_OVERVIEW_POPUP_CLOSE":"Close popup, button","SECURE_ATTACHMENT_INFO":"Secure attachment info","CKS_INDICATOR_TITLE":"Identity Verified","CKS_INDICATOR_BODY":"Sender identity verified by Virtru to prevent fraud.","CKS_INDICATOR_LINK":"Learn more here","MAIL_MERGE_CONFLICT_MODAL_TITLE":"Mail Merge Conflict","MAIL_MERGE_CONFLICT_MODAL_BODY":"Virtru Protection is not compatible with Mail Merge in Gmail. Please turn off Mail Merge before enabling Virtru Protection.","MAIL_MERGE_CONFLICT_TOOLTIP":"Mail Merge is not supported with Virtru Protection"}');

/***/ }),

/***/ 25119:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var i18n = __webpack_require__(2622);
function isElementASecureEmail(element, selectors) {
  return element.find(selectors.TDF_SELECTOR).length !== 0;
}

/**
 * There have been instances of Outlook (+Proofpoint?) clients mucking with our HTML structure
 * when sending unsecure replies back to secure messages. This is a heuristic to
 * determine when this occurs so we can reconstruct the propera and expected Virtru
 * HTML structure and prevent the unsecure response from being accidentally destroyed or hidden.
 *
 * @param {$Element} messageElem - The secure message/TDF element
 * @returns {$Element} - An element containing the secure message content
 */
function getMessageContainer(messageElem) {
  var grandfatherElem = messageElem.parent().parent();

  // Only Outlook adds extra elements and applies the classname "MsoNormal"
  if (grandfatherElem.children().length > 4 && grandfatherElem.find('> .MsoNormal').length) {
    // Take each element containing Virtru content and append them to a new container element.
    // This ensures that we have a single element containing all Virtru secure content and nothing else.
    var newVirtruContainer = $('<div></div>');
    grandfatherElem.children().each((i, childElem) => {
      childElem = $(childElem);
      if (containsVirtruSecureContent(childElem)) {
        childElem.appendTo(newVirtruContainer);
      }
    });

    // Add the container element back to the original email content and return it.
    newVirtruContainer.appendTo(grandfatherElem);
    return newVirtruContainer;
  }

  // Returnt the grandfather element if no Outlook fuckery is detected
  return grandfatherElem;
}

/**
 * Check for remnants of Virtru secure content in an attempt to reconstruct it.
 * @param {$Element} elem - Element to check for Virtru content
 * @returns {Boolean} - Result
 */
function containsVirtruSecureContent(elem) {
  return elem.find('a[href*="virtru.com/start"]').length || elem.find('a[href*="virtru.com_start"]').length || elem.find('pre:contains(START PROTECTED MESSAGE TDF)').length || elem.find('pre:contains(VIRTRU SEARCH TOKENS)').length || elem.find('pre:contains(Virtru Metadata)').length;
}

/**
 * Formats the file size
 * @param  {number} bytes number of byes
 * @return {string}       the formatted file size
 */
function formatFileSize(_bytes) {
  let bytes = _bytes;
  var thresh = 1000;
  if (bytes < thresh) {
    return bytes !== 0 ? `${bytes} ${i18n.t('FILE_SIZES.BYTES')}` : '';
  }
  var units = i18n.t('FILE_SIZES.UNITS', {
    joinArrays: ','
  }).split(',');
  var u = -1;
  do {
    bytes /= thresh;
    ++u;
  } while (bytes >= thresh);
  if (isNaN(bytes)) {
    return _bytes;
  }
  var correctSize = bytes !== 0 ? `${bytes.toFixed(1)} ${units[u]}` : '';
  /**
   * Change separator from '.' to custom localization separator
   */
  return correctSize.replace('.', i18n.t('DELIMITERS.DECIMAL'));
}
module.exports = {
  isElementASecureEmail,
  getMessageContainer,
  formatFileSize
};

/***/ }),

/***/ 25235:
/***/ ((module, exports, __webpack_require__) => {

var blobUri = __webpack_require__(14483);
module.exports = exports = blobUri;

/***/ }),

/***/ 25281:
/***/ ((module) => {

module.exports = {
  key: 'advertiseEncryptedSearch',
  seenFlag: 'preferences.featureIntros.hasSeenEncryptedSearch',
  permission: 'permissions.canSearchEncryptedEmails',
  releaseDate: new Date('2016-09-28'),
  shouldShow(user) {
    const hasFeature = user.settings().hasSearchKey;
    const hasSeenFeatureIntro = user.setting(this.seenFlag);
    const hasPermission = user.setting(this.permission);
    return !hasSeenFeatureIntro && !hasFeature && hasPermission;
  }
};

/***/ }),

/***/ 25939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var base = __webpack_require__(81147);
var collection = __webpack_require__(9531);
var factory = __webpack_require__(75769);
Object.assign(module.exports, base);
Object.assign(module.exports, collection);
Object.assign(module.exports, factory);
module.exports.MessageManager = __webpack_require__(19806);

/***/ }),

/***/ 26847:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  RenderAttachmentTooltip: () => (/* binding */ RenderAttachmentTooltip),
  RenderPCMInfoTooltip: () => (/* binding */ RenderPCMInfoTooltip),
  RenderRevokedTooltip: () => (/* binding */ RenderRevokedTooltip),
  RenderSectionTooltip: () => (/* binding */ RenderSectionTooltip)
});

// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(64078);
// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(87568);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(33632);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./node_modules/react-dom/index.js
var react_dom = __webpack_require__(20213);
;// ./compatibility/BaseTooltip/TooltipPortal.js



const TooltipPortal = ({
  children
}) => {
  const el = (0,react.useRef)(document.createElement('div'));
  (0,react.useEffect)(() => {
    const currentEl = el.current;
    document.body.appendChild(currentEl);
    return () => {
      document.body.removeChild(currentEl);
    };
  }, []);
  return /*#__PURE__*/(0,react_dom.createPortal)(children, el.current);
};
TooltipPortal.propTypes = {
  children: (prop_types_default()).node
};
/* harmony default export */ const BaseTooltip_TooltipPortal = (TooltipPortal);
// EXTERNAL MODULE: ./node_modules/react-redux/es/index.js + 21 modules
var es = __webpack_require__(13255);
// EXTERNAL MODULE: ./lib/email/lib/attachment-utils.js
var attachment_utils = __webpack_require__(62769);
;// ./compatibility/BaseTooltip/constants.js
const TOOLTIP_TYPES = {
  ATTACHMENT: 'attachment',
  SECTION: 'section',
  REVOKED: 'revoked',
  PCM_EXTENSIONS: 'pcm-extensions'
};
const TOOLTIP_TYPES_CLASSES = {
  [TOOLTIP_TYPES.ATTACHMENT]: 'virtru-attachment-tooltip',
  [TOOLTIP_TYPES.SECTION]: 'virtru-section-tooltip',
  [TOOLTIP_TYPES.REVOKED]: 'virtru-attachment-revoked-tooltip',
  [TOOLTIP_TYPES.PCM_EXTENSIONS]: 'virtru-pcm-extensions-tooltip'
};
;// ./compatibility/BaseTooltip/components.js



const {
  AUTHORIZATION_PERSISTENT_PROTECTION,
  AUTHORIZATION_WATERMARK
} = (__webpack_require__(42769).PolicyModel);
const getTitle = ({
  title,
  attachment,
  isTdf3Html
}) => {
  if (!attachment) {
    return title;
  }
  if (isTdf3Html) {
    return `${title}.html`;
  }
  const {
    authorizations,
    isSupportedFile,
    isReattachedPFPFile
  } = attachment;
  const isPersistentProtection = (authorizations === null || authorizations === void 0 ? void 0 : authorizations.includes(AUTHORIZATION_PERSISTENT_PROTECTION)) && isSupportedFile;
  if (isPersistentProtection || isReattachedPFPFile) {
    return `${title}.tdf.html`;
  }
  return `${title}.tdf`;
};
const ChipTitle = ({
  type,
  title,
  attachment,
  isTdf3Html
}) => {
  if (type !== TOOLTIP_TYPES.ATTACHMENT) {
    return title;
  }
  const chipTitle = getTitle({
    title,
    attachment,
    isTdf3Html
  });
  return chipTitle.split('.').map((text, index) => {
    if (index === 0) {
      return text.split('').map((letter, lIndex) => /*#__PURE__*/react.createElement("span", {
        className: "virtru-tooltip-non-dot",
        key: `${index}${lIndex}`
      }, letter));
    }
    return /*#__PURE__*/react.createElement("span", {
      key: index
    }, text);
  });
};
const WarningIcon = ({
  attachment,
  dangerIcon
}) => {
  if (!attachment || dangerIcon) {
    return null;
  }
  const {
    authorizations,
    isSender,
    isSupportedFile,
    isReattachedPFPFile
  } = attachment;
  const isExpandedProtection = (authorizations === null || authorizations === void 0 ? void 0 : authorizations.includes(AUTHORIZATION_PERSISTENT_PROTECTION)) || (authorizations === null || authorizations === void 0 ? void 0 : authorizations.includes(AUTHORIZATION_WATERMARK));
  const showWarningIcon = Boolean(isSender && (!isSupportedFile && isExpandedProtection || isReattachedPFPFile));
  if (!showWarningIcon) {
    return null;
  }
  return /*#__PURE__*/react.createElement("span", {
    className: "virtru-tooltip-non-dot virtru-tooltip-warning-icon"
  });
};
WarningIcon.propTypes = {
  attachment: prop_types_default().shape({
    authorizations: (prop_types_default()).array,
    isSender: (prop_types_default()).bool,
    isSupportedFile: (prop_types_default()).bool,
    isReattachedPFPFile: (prop_types_default()).bool
  }),
  dangerIcon: (prop_types_default()).bool
};
const PortalContent = ({
  tooltipVisible,
  tooltipType,
  tooltipPosition,
  attachment,
  dangerIcon,
  isTdf3Html,
  tooltipContent,
  title
}) => {
  if (!tooltipVisible) {
    return null;
  }
  return /*#__PURE__*/react.createElement("div", {
    className: `${tooltipType} virtru-base-tooltip`,
    style: tooltipPosition,
    "aria-modal": "true",
    role: "dialog",
    tabIndex: "-1"
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-tooltip-arrow"
  }), /*#__PURE__*/react.createElement("div", {
    className: "virtru-tooltip-container",
    role: "dialog",
    "aria-live": "polite"
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-tooltip-header"
  }, /*#__PURE__*/react.createElement(WarningIcon, {
    attachment: attachment,
    dangerIcon: dangerIcon
  }), dangerIcon && /*#__PURE__*/react.createElement("span", {
    className: "virtru-tooltip-non-dot virtru-tooltip-danger-icon"
  }), /*#__PURE__*/react.createElement(ChipTitle, {
    title: title,
    attachment: attachment,
    isTdf3Html: isTdf3Html
  })), /*#__PURE__*/react.createElement("div", {
    className: "virtru-tooltip-content",
    dangerouslySetInnerHTML: {
      __html: tooltipContent
    }
  })));
};
PortalContent.propTypes = {
  tooltipVisible: (prop_types_default()).bool,
  tooltipType: (prop_types_default()).string,
  tooltipPosition: prop_types_default().shape({
    left: (prop_types_default()).number,
    top: (prop_types_default()).number
  }),
  attachment: prop_types_default().shape({
    authorizations: (prop_types_default()).array,
    isSender: (prop_types_default()).bool,
    isSupportedFile: (prop_types_default()).bool,
    isReattachedPFPFile: (prop_types_default()).bool
  }),
  dangerIcon: (prop_types_default()).bool,
  isTdf3Html: (prop_types_default()).bool,
  tooltipContent: (prop_types_default()).string,
  title: (prop_types_default()).string
};
;// ./compatibility/BaseTooltip/BaseTooltip.js







const getContent = ({
  attachment,
  type,
  content
}) => {
  if (!attachment || type === TOOLTIP_TYPES.REVOKED) {
    return content;
  }
  const {
    authorizations,
    isSender,
    isSupportedFile,
    isReattachedPFPFile,
    isManaged
  } = attachment;
  return (0,attachment_utils/* getAttachmentTooltipContent */.se)(authorizations, isSender, isSupportedFile, isReattachedPFPFile, isManaged) || content;
};
const BaseTooltip = ({
  anchor,
  attachment,
  type,
  title,
  content,
  dangerIcon,
  isTdf3Html
}) => {
  const [tooltipVisible, setTooltipVisible] = (0,react.useState)(false);
  const [tooltipPosition, setTooltipPosition] = (0,react.useState)({
    top: 0,
    left: 0
  });
  const tooltipWrapper = (0,react.useRef)(null);
  (0,react.useEffect)(() => {
    if (tooltipWrapper.current) {
      tooltipWrapper.current.append(anchor);
    }
  }, []);
  const showTooltip = () => {
    const {
      top,
      left
    } = anchor.getBoundingClientRect();
    setTooltipPosition({
      top,
      left
    });
    setTooltipVisible(true);
  };
  const hideTooltip = () => {
    setTooltipVisible(false);
  };
  const tooltipType = TOOLTIP_TYPES_CLASSES[type];
  const tooltipContent = getContent({
    attachment,
    type,
    content
  });
  return /*#__PURE__*/react.createElement("div", {
    "data-testid": "base-tooltip-container",
    onMouseEnter: showTooltip,
    onMouseLeave: hideTooltip,
    onFocus: showTooltip,
    onBlur: hideTooltip
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-tooltip-wrapper",
    ref: tooltipWrapper
  }), /*#__PURE__*/react.createElement("div", {
    onMouseEnter: showTooltip,
    onMouseLeave: hideTooltip,
    onFocus: showTooltip,
    onBlur: hideTooltip,
    className: "virtru-info-mouse-area"
  }), /*#__PURE__*/react.createElement(BaseTooltip_TooltipPortal, null, /*#__PURE__*/react.createElement(PortalContent, {
    tooltipVisible: tooltipVisible,
    tooltipPosition: tooltipPosition,
    tooltipContent: tooltipContent,
    tooltipType: tooltipType,
    attachment: attachment,
    title: title,
    dangerIcon: dangerIcon,
    isTdf3Html: isTdf3Html
  })));
};
BaseTooltip.propTypes = {
  anchor: prop_types_default().shape({
    id: (prop_types_default()).string.isRequired,
    getBoundingClientRect: (prop_types_default()).func
  }).isRequired,
  title: (prop_types_default()).string,
  content: (prop_types_default()).string,
  type: (prop_types_default()).string,
  attachmentId: (prop_types_default()).string,
  attachment: (prop_types_default()).object,
  dangerIcon: (prop_types_default()).bool,
  isTdf3Html: (prop_types_default()).bool
};
const mapStateToProps = function (state, ownProps) {
  return {
    attachment: state.attachments[ownProps.attachmentId]
  };
};
/* harmony default export */ const BaseTooltip_BaseTooltip = ((0,es/* connect */.Ng)(mapStateToProps)(BaseTooltip));
;// ./lib/email/lib/react-render.js





const globalStore = __webpack_require__(71139);
function RenderAttachmentTooltip(tooltipWrapper, renderData) {
  const {
    anchor,
    title,
    warningIcon,
    attachmentId,
    isTdf3Html
  } = renderData;
  const root = (0,client/* createRoot */.H)(tooltipWrapper);
  root.render(/*#__PURE__*/react.createElement(es/* Provider */.Kq, {
    store: globalStore
  }, /*#__PURE__*/react.createElement(BaseTooltip_BaseTooltip, {
    isTdf3Html: isTdf3Html,
    anchor: anchor,
    title: title,
    warningIcon: warningIcon,
    type: 'attachment',
    attachmentId: attachmentId
  })));
}
function RenderRevokedTooltip(tooltipWrapper, renderData) {
  const {
    anchor,
    title,
    content,
    attachmentId
  } = renderData;
  const root = (0,client/* createRoot */.H)(tooltipWrapper);
  root.render(/*#__PURE__*/react.createElement(es/* Provider */.Kq, {
    store: globalStore
  }, /*#__PURE__*/react.createElement(BaseTooltip_BaseTooltip, {
    anchor: anchor,
    title: title,
    type: 'revoked',
    dangerIcon: true,
    attachmentId: attachmentId,
    content: content
  })));
}
function RenderSectionTooltip(tooltipID, renderData) {
  const {
    anchor,
    title,
    content
  } = renderData;
  const container = document.getElementById(tooltipID);
  if (container) {
    const root = (0,client/* createRoot */.H)(container);
    root.render(/*#__PURE__*/react.createElement(es/* Provider */.Kq, {
      store: globalStore
    }, /*#__PURE__*/react.createElement(BaseTooltip_BaseTooltip, {
      anchor: anchor,
      title: title,
      type: 'section',
      content: content
    })));
  }
}
function RenderPCMInfoTooltip({
  anchor,
  title,
  content
}) {
  return /*#__PURE__*/react.createElement(es/* Provider */.Kq, {
    store: globalStore
  }, /*#__PURE__*/react.createElement(BaseTooltip_BaseTooltip, {
    anchor: anchor,
    title: title,
    type: 'pcm-extensions',
    content: content
  }));
}
RenderPCMInfoTooltip.propTypes = {
  anchor: prop_types_default().shape({
    id: (prop_types_default()).string.isRequired,
    getBoundingClientRect: (prop_types_default()).func
  }).isRequired,
  title: (prop_types_default()).string,
  content: (prop_types_default()).string
};

/***/ }),

/***/ 28654:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Virtru Email Template for Receiver
 */
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var Popover = __webpack_require__(55929);
var i18n = __webpack_require__(2622);
var moment = __webpack_require__(13985);
var Templates = __webpack_require__(5749);
var emailUtils = __webpack_require__(25119);
var {
  NestedMessagePlaceholder
} = __webpack_require__(82890);
const {
  _bindAllMethods
} = __webpack_require__(4424);
var STATUSES = {
  active: 'active',
  revoked: 'deactivated',
  expired: 'expired',
  unauthorized: 'unauthorized',
  offline: 'offline'
};
var defaultOptions = {};
function EmailTemplateReceiver(element, settings) {
  this._element = element;
  this._settings = settings;
  _bindAllMethods(this);
}

// Add events to this class
Emitter(EmailTemplateReceiver.prototype);
EmailTemplateReceiver.create = function (options, settings) {
  options = Object.assign({}, defaultOptions, options);
  var element = $(Templates.emailTemplateReceiver());
  var receiver = new EmailTemplateReceiver(element, settings);
  moment.updateLocale(moment.locale(), {
    calendar: i18n.t('MOMENT_CALENDAR_RECIPIENT_EXPIRATION', {
      returnObjects: true
    })
  });
  receiver.setOptions(options);
  receiver.initEvents();
  receiver.initTooltips();

  // Replace the chained messages with our own html
  var nestedMessages = element.find('div[data-message-id]');
  nestedMessages.each(function (_, nestedMessage) {
    nestedMessage = $(nestedMessage);
    var messageId = nestedMessage.data('message-id');
    NestedMessagePlaceholder.render(nestedMessage[0], {
      messageId
    });
  });
  return receiver;
};
EmailTemplateReceiver.prototype.setOptions = function (options) {
  var element = this._element;
  this._analyticsService = options.analyticsService;
  this.setId(options.id);
  this.setBodyHtml(options.bodyHtml);
  this.setExpirationDate(options.expirationDate);
  this.setExpires(options.expires);
  this.setStatus(options.status);
  this.setData(options.remoteContentLink);
  var renderedAttachments = element.find('.virtru-attachment');
  var attachments = renderedAttachments ? renderedAttachments.length : 0;
  for (let i = 0; i < attachments; i++) {
    const attachment = $(renderedAttachments[i]);
    const fileSize = attachment.data('size');
    if (fileSize) {
      const correctFileSize = emailUtils.formatFileSize(attachment.data('size'));
      attachment.find('.virtru-attachment-file-size').text(correctFileSize);
    }
  }

  // sets visibility of each status icon based on the policy
  $(element.find('.virtru-forwarding-icon')[0]).css('display', options.disableForwarding && options.status === STATUSES.active ? 'inline' : 'none');
  const sms2faNotEmpty = !!options.sms2faMap && Object.keys(options.sms2faMap).length > 0;
  $(element.find('.virtru-sms-icon')[0]).css('display', sms2faNotEmpty && options.status === STATUSES.active ? 'inline' : 'none');
  $(element.find('.virtru-noauth-icon')[0]).css('display', options.enableNoauth && options.status === STATUSES.active ? 'inline' : 'none');
  $(element.find('.virtru-pfp-icon')[0]).css('display', options.persistentProtection && options.status === STATUSES.active ? 'inline' : 'none');
  $(element.find('.virtru-expiration-icon')[0]).css('display', options.expires && options.status === STATUSES.active ? 'inline' : 'none');
  $(element.find('.virtru-email-template-receiver-header-message')[0]).text(i18n.t('RECIPIENT_WIDGET_HEADER'));
};
EmailTemplateReceiver.prototype.initEvents = function () {
  if (this._status === STATUSES.active && this._expires) {
    this.refreshExpirationTimer();
    this._expirationInterval = setInterval(this.updateExpirationText, 30000);
  } else if (this._status === STATUSES.expired || this._status === STATUSES.revoked) {
    this._expirationInterval = setInterval(this.updateExpirationText, 30000);
  }
};
function _createPopover($icon, content, title) {
  const popover = new Popover(content, title);
  popover.classname += ' virtru-popover-dark';
  popover.position('north');
  popover.setShowTimer();
  popover.attach($icon);
}
EmailTemplateReceiver.prototype.initTooltips = function () {
  var element = this._element;
  var formattedDate = moment(this._expirationDate).format('dddd, MMM Do, YYYY [@] h:mm a');
  _createPopover(element.find('.virtru-forwarding-icon'), i18n.t('TOOLTIP_RECIPIENT_DISABLE_FORWARDING'), i18n.t('TOOLTIP_DISABLE_FORWARDING'));
  _createPopover(element.find('.virtru-sms-icon'), i18n.t('TOOLTIP_RECIPIENT_SMS'), i18n.t('TOOLTIP_ENABLE_SMS'));
  _createPopover(element.find('.virtru-noauth-icon'), i18n.t('TOOLTIP_RECIPIENT_ONE_CLICK'), i18n.t('TOOLTIP_ONE_CLICK'));
  _createPopover(element.find('.virtru-expiration-icon'), i18n.t('TOOLTIP_RECIPIENT_EXPIRATION', {
    date: formattedDate
  }), i18n.t('TOOLTIP_EXPIRATION'));
  _createPopover(element.find('.virtru-email-template-receiver-info-icon'), i18n.t('TOOLTIP_RECIPIENT_UNAUTHORIZED_INFO'));
};

// sets up the expiration timer and forces a refresh if the value is too far in the future
EmailTemplateReceiver.prototype.refreshExpirationTimer = function () {
  var now = moment();
  var expiration = moment(this._expirationDate);
  var differenceMs = Math.max(expiration.diff(now), 0);
  if (this._expirationTimer) {
    clearTimeout(this._expirationTimer);
  }
  if (differenceMs >= 0x7FFFFFFF) {
    // setTimeout limit is MAX_INT32=(2^31-1)
    var self = this;
    this._expirationTimer = setTimeout(function () {
      self.refreshExpirationTimer();
    }, 0x7FFFFFFF);
  } else {
    this._expirationTimer = setTimeout(this.handleExpiration, differenceMs);
  }
};
EmailTemplateReceiver.prototype.setId = function (id) {
  this._id = id;
};
EmailTemplateReceiver.prototype.setStatus = function (value, isLive) {
  var element = this._element;
  var bodyContainer = element.find('.virtru-email-template-receiver-body-enabled');

  // default to revoked if there's no policy
  if (!value) {
    value = STATUSES.revoked;
  }

  // If we're offline and now are active restore the body text
  if (value === STATUSES.active && this._status === STATUSES.offline && this._offlineBodyHtml) {
    this._bodyText = this._offlineBodyHtml;
  }
  this._status = value;
  bodyContainer.empty();
  element.removeClass();
  element.addClass('virtru-email-decrypted');
  var noAccess = false;
  switch (value) {
    // eslint-disable-line
    case STATUSES.active:
      element.addClass('virtru-email-template-receiver-enabled');
      bodyContainer.append(this._bodyHtml);
      break;
    case STATUSES.revoked:
      element.addClass('virtru-email-template-receiver-revoked');
      this.setBodyHtml('');
      noAccess = 'revoked';
      break;
    case STATUSES.unauthorized:
      element.addClass('virtru-email-template-receiver-revoked');
      this.setBodyHtml('');
      noAccess = 'unauthorized';
      break;
    case STATUSES.expired:
      element.addClass('virtru-email-template-receiver-expired');
      this.setBodyHtml('');
      noAccess = 'expired';
      break;
    case STATUSES.offline:
      element.addClass('virtru-email-template-receiver-revoked');

      // If we're online and now we're offline then store the body html
      // in memory so we can restore it if we get our connection back
      this._offlineBodyHtml = this._bodyHtml;
      break;
  }
  if (noAccess !== false) {
    this._analyticsService.track('View Access Denied', {
      'event.version': '1.0.0',
      type: noAccess,
      'policy.Id': this._id,
      live: typeof isLive !== 'undefined' ? isLive : false
    });
  }
  this.updateExpirationText();
};
EmailTemplateReceiver.prototype.setExpires = function (value) {
  var element = this._element;
  var expiration = element.find('.virtru-email-template-receiver-header-expiration-date');
  expiration.removeClass();
  expiration.addClass('virtru-email-template-receiver-header-expiration-date');
  if (value) {
    expiration.addClass('virtru-email-template-receiver-header-active-expiration-date');
  } else {
    expiration.addClass('virtru-email-template-receiver-header-no-expiration-date');
  }
  this._expires = value;
};
EmailTemplateReceiver.prototype.setBodyHtml = function (bodyHtml) {
  this._bodyHtml = bodyHtml;
};
EmailTemplateReceiver.prototype.setExpirationDate = function (date) {
  this._expirationDate = date;
};
EmailTemplateReceiver.prototype.setData = function (remoteContentLink) {
  this._element.data('remoteContentLink', remoteContentLink);
};
EmailTemplateReceiver.prototype.updateExpirationText = function () {
  var element = this._element;
  var dateString = '';
  var start = moment();
  var end = moment(this._expirationDate);
  var headerElement = $(element.find('.virtru-email-template-receiver-header-message')[0]);
  var infoIcon = $(element.find('.virtru-email-template-receiver-info-icon')[0]);

  // using opacity here because we still want the element taking up space
  headerElement.css('opacity', 1);
  infoIcon.css('display', 'none');
  var revokedIcon = $(element.find('.virtru-email-template-receiver-body-revoked-icon')[0]);
  var textElement = $(element.find('.virtru-email-template-receiver-body-revoked-text')[0]);
  switch (this._status) {
    // eslint-disable-line
    case STATUSES.active:
      if (this._expires) {
        dateString = i18n.t('RECIPIENT_WIDGET_EXPIRATION_DATE', {
          datetime: end.from(start)
        });
      } else {
        dateString = i18n.t('RECIPIENT_WIDGET_NO_EXPIRATION');
      }
      break;
    case STATUSES.revoked:
      headerElement.css('opacity', 0);
      dateString = i18n.t('RECIPIENT_WIDGET_REVOKED_HEADER');
      revokedIcon.removeClass('virtru-email-template-receiver-body-expired-icon');
      revokedIcon.removeClass('virtru-email-template-receiver-body-unauthorized-icon');
      textElement.text(i18n.t('RECIPIENT_WIDGET_REVOKED_BODY'));
      break;
    case STATUSES.unauthorized:
      infoIcon.css('display', 'inline-block');
      headerElement.css('opacity', 0);
      dateString = i18n.t('RECIPIENT_WIDGET_UNAUTHORIZED_HEADER');
      revokedIcon.removeClass('virtru-email-template-receiver-body-expired-icon');
      revokedIcon.addClass('virtru-email-template-receiver-body-unauthorized-icon');
      textElement.text(i18n.t('RECIPIENT_WIDGET_UNAUTHORIZED_BODY'));
      break;
    case STATUSES.offline:
      headerElement.css('opacity', 0);
      dateString = i18n.t('RECIPIENT_WIDGET_OFFLINE_HEADER');
      revokedIcon.removeClass('virtru-email-template-receiver-body-expired-icon');
      revokedIcon.removeClass('virtru-email-template-receiver-body-unauthorized-icon');
      textElement.text(i18n.t('RECIPIENT_WIDGET_OFFLINE_BODY'));
      break;
    case STATUSES.expired:
      if (this._expirationDate) {
        dateString = i18n.t('RECIPIENT_WIDGET_EXPIRED_DATE', {
          datetime: end.from(start)
        });
      } else {
        dateString = i18n.t('RECIPIENT_WIDGET_EXPIRED');
      }
      revokedIcon.addClass('virtru-email-template-receiver-body-expired-icon');
      revokedIcon.removeClass('virtru-email-template-receiver-body-unauthorized-icon');
      textElement.text(i18n.t('RECIPIENT_WIDGET_EXPIRED_BODY'));
      break;
  }
  $(element.find('.virtru-email-template-receiver-header-expiration-date')[0]).text(dateString);
};
EmailTemplateReceiver.prototype.appendTo = function (el) {
  $(el).append(this._element);
  $(el).closest('.gmail_extra').addClass('gmail_extra-borders-removed');
};

/* PUBLIC METHODS */

/**
 * Cleanup function
 */
EmailTemplateReceiver.prototype.teardown = function () {
  if (this._expirationTimer) {
    clearTimeout(this._expirationTimer);
  }
  if (this._expirationInterval) {
    clearInterval(this._expirationInterval);
  }
};

/* Enables access to the message, with an optional expiration date. Body text must be set here */
EmailTemplateReceiver.prototype.enable = function (bodyHtml, expirationDate) {
  this.setBodyHtml(bodyHtml);
  this.setExpirationDate(expirationDate);
  if (expirationDate) {
    this.setExpires(true);
  } else {
    this.setExpires(false);
  }
  this.setStatus(STATUSES.active);
};

/* Forces the message to be revoked. Removes body text completely */
EmailTemplateReceiver.prototype.revoke = function () {
  this.setStatus(STATUSES.revoked, true);
};

/* Forces the message to be revoked. Removes body text completely */
EmailTemplateReceiver.prototype.enable = function () {
  this.setStatus(STATUSES.active);
};

/* Forces the message to expire, with an optional expiration date. Removes body text completely */
EmailTemplateReceiver.prototype.expire = function (expirationDate) {
  if (expirationDate) {
    this.setExpirationDate(expirationDate);
  }
  this.setStatus(STATUSES.expired, true);
};

/**
 * Handles a revocation event
 */
EmailTemplateReceiver.prototype.handleRevocation = function () {
  this.revoke();
};
EmailTemplateReceiver.prototype.handleExpiration = function () {
  clearTimeout(this._expirationTimer);
  this.expire();
};
EmailTemplateReceiver.prototype.hideFooter = function () {
  this._element.find('.virtru-email-template-receiver-footer').hide();
  this._element.css('padding-bottom', '0');
};

/**
 * Event handler for when we're back online.
 */
EmailTemplateReceiver.prototype.onOnline = function () {
  if (this._status !== STATUSES.expired) {
    this.enable('online');
  }
};

/**
 * Event handler for offline.
 */
EmailTemplateReceiver.prototype.onOffline = function () {};
EmailTemplateReceiver.prototype.onOfflineLeaseStarted = function () {};

/**
 * Revokes the message if the lease has expired
 */
EmailTemplateReceiver.prototype.onOfflineLeaseExpired = function () {
  this.setStatus(STATUSES.offline);
};
exports.EmailTemplateReceiver = EmailTemplateReceiver;

/***/ }),

/***/ 29182:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports.routers = __webpack_require__(12367);
module.exports.request = __webpack_require__(50344);
module.exports.transports = __webpack_require__(58533);

/***/ }),

/***/ 30878:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

__webpack_require__(65413);

/***/ }),

/***/ 30893:
/***/ ((module) => {

const constants = {
  TDF3_HTML_MANIFEST_ID: 'data-manifest',
  get TDF3_HTML_MANIFEST_SELECTOR() {
    return `#${this.TDF3_HTML_MANIFEST_ID}`;
  },
  TDF3_EMAIL_MANIFEST_ID: 'virtru-data-manifest',
  get TDF3_EMAIL_MANIFEST_SELECTOR() {
    return `#${this.TDF3_EMAIL_MANIFEST_ID}`;
  },
  TDF3_TRANSFER_URL_ID: 'virtru-transfer-url',
  get TDF3_TRANSFER_URL_SELECTOR() {
    return `#${this.TDF3_TRANSFER_URL_ID}`;
  },
  TDF3_HTML_PAYLOAD_ID: 'data-input',
  get TDF3_HTML_PAYLOAD_SELECTOR() {
    return `#${this.TDF3_HTML_PAYLOAD_ID}`;
  }
};
module.exports = constants;

/***/ }),

/***/ 31027:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Utils = __webpack_require__(55675);
const precond = __webpack_require__(57128);
const renderModal = (__webpack_require__(58665)/* ["default"] */ .A);
const AnalyticsService = (__webpack_require__(1246).instance)();
const LimitedEncryptionWarning = (__webpack_require__(83681)/* ["default"] */ .A);
const mime = (__webpack_require__(63985)/* ["default"] */ .A);
const MB = 1024 << 10;
const MB_150 = 150 * MB;
const fipsSize = 80 * MB;
const showAttachmentsTooLargeModal = async (user, transports) => {
  const {
    suggestSecureShareForLargeAttachments
  } = user.permissions;
  if (suggestSecureShareForLargeAttachments) {
    renderModal.suggestSecureShare(user, transports);
    return;
  }
  renderModal.attachmentTooLarge(user);
};
module.exports.validateFileSize = async function (fileList, user, transports) {
  precond.checkIsDefAndNotNull(fileList, 'fileList');

  // This doesn't work. This guard fails way too much. It's probably just being used wrong, but I've literally spent hours
  // debugging issues related to it, so for now I'm commenting it out.
  // Guard.checkArgument(fileList instanceof FileList, 'Argument is not a FileList.');
  const {
    enforceFips
  } = user.permissions;
  let shown = false;
  const files = fileList.map(item => item);
  let validatedFiles = files.slice();
  const size = enforceFips ? fipsSize : MB_150;
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    if (file.size >= size) {
      validatedFiles = validatedFiles.filter(f => f.name !== file.name && f.size !== file.size);
      if (!shown) {
        await showAttachmentsTooLargeModal(user, transports);
        shown = true;
      }
    }
  }
  return validatedFiles;
};
module.exports.canProceedLimitedEncryption = function (allFiles, authorizations) {
  const unsupportedFiles = this.validateExpandedWatermarkingSupport(allFiles);
  return this.displayLimitedEncryptionWarning(unsupportedFiles, allFiles, authorizations);
};

// Displays warning with names of the files which don't support extended watermarking
// @returns flag to block or proceed downloading
module.exports.displayLimitedEncryptionWarning = function (unsupportedFiles, allFiles, authorizations) {
  return new Promise(resolve => {
    if (unsupportedFiles.length > 0) {
      AnalyticsService.unsupportedFileFormat({
        attachmentsCount: allFiles.length,
        unsupportedCount: unsupportedFiles.length,
        authorizations
      });
      const skipWarning = localStorage.getItem('skipLimitedEncryptionWarning') === 'true';
      if (!skipWarning) {
        const modal = new LimitedEncryptionWarning({
          filesList: unsupportedFiles,
          emitResult: resolve
        });
        modal.openModal();
        // do not resolve
        return;
      }
    }
    resolve(true);
  });
};
module.exports.validateExpandedWatermarkingSupport = function (fileList) {
  precond.checkIsDefAndNotNull(fileList, 'fileList');
  return fileList.filter(item => !Utils.hasPfpFileExtensions(item.name) && !Utils.supportsExpandedWatermarking(item.name));
};

/**
 * Update mime type for file if it does not exist.
 *
 * Note: in Chrome OS you have no type of files on upload.
 *
 * @param {File[]} eventFiles - uploaded/dnd files
 * @return {File[]} new array of files
 */
module.exports.processFilesMimeType = function (eventFiles) {
  return Array.from(eventFiles).map(file => {
    // Looking for file type if it does not present in file
    const type = file.type || mime.getType(file.name) || 'application/octet-stream';

    // Create a new file, because "type" property is read-only in original file
    return new File([file], file.name, {
      type
    });
  });
};

/***/ }),

/***/ 31795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var {
  Toggle
} = __webpack_require__(40163);
var {
  DismissPopover
} = __webpack_require__(80539);
var PolicyConfig = __webpack_require__(73405);
var {
  PolicyModel
} = __webpack_require__(74029);
var {
  EmailTemplateSender
} = __webpack_require__(75794);
var {
  EmailTemplateReceiver
} = __webpack_require__(28654);
var {
  EmailError
} = __webpack_require__(73668);
var {
  HighlightOverlay
} = __webpack_require__(19950);
var {
  PromoFooter
} = __webpack_require__(91738);
module.exports = {
  Toggle,
  DismissPopover,
  PolicyConfig,
  PolicyModel,
  EmailTemplateSender,
  EmailTemplateReceiver,
  EmailError,
  HighlightOverlay,
  PromoFooter,
  CksError: (__webpack_require__(9135)/* .CksError */ .G),
  MessageIntegrityError: (__webpack_require__(59441)/* .MessageIntegrityError */ .p)
};

/***/ }),

/***/ 32841:
/***/ ((module, exports, __webpack_require__) => {

const i18nUtils = __webpack_require__(8341);
const locales = __webpack_require__(64474);
const {
  getCrossWindowStore
} = __webpack_require__(37060);
const isPopout = () => !window.GLOBALS;
const localeStore = getCrossWindowStore('locale');
const i18n = {
  queryLocale: null,
  /**
   * Sets query locale from query string
   */
  setQueryLocale: () => {
    const locale = new URLSearchParams(window.location.search).get('virtru-locale');
    i18n.queryLocale = locales[locale] ? locale : null;
  },
  /**
   * Detect language with new available locales list
   * @returns {string}
   */
  detectLocale: clientLocale => i18n.getCurrentLanguage() || i18nUtils.getLanguage({}, clientLocale || 'en'),
  /**
   * Sets new language
   * @param language
   */
  updateLanguage: language => {
    i18nUtils.setLanguage(language, () => {
      if (!isPopout()) {
        localeStore.userLocale = language;
      }
    });
  },
  /**
   * For sync between all instances of i18next
   * @returns {string}
   */
  getCurrentLanguage: () => i18n.queryLocale,
  getActualLanguage: () => isPopout() ? localeStore.userLocale : document.documentElement.lang,
  detectActualLocale: () => i18n.detectLocale(i18n.getActualLanguage()),
  /**
   * Sync current language between 2 instances of i18next
   * created by content and gmail scripts
   */
  syncCurrentLanguage: () => {
    const currentRealLanguage = i18n.detectActualLocale();
    i18n.updateLanguage(currentRealLanguage);
  },
  init: () => {
    i18n.setQueryLocale();
    i18nUtils.updateLocales(locales);
    const locale = i18n.detectActualLocale();
    if (!document.documentElement.lang) {
      document.documentElement.lang = locale; // set HTML.lang attribute for popout window if needed
    }
    return i18nUtils.init(locales, locale, {});
  }
};

// Remove casted 't' function to avoid infinite loops
// eslint-disable-next-line no-unused-vars
const {
  t,
  ...cleanUtils
} = i18nUtils;
const i18nInstance = i18n.init();
module.exports = exports = Object.assign(i18nInstance, cleanUtils, i18n);

/***/ }),

/***/ 33560:
/***/ ((module) => {

module.exports = {
  key: 'advertiseVault',
  seenFlag: 'preferences.featureIntros.hasSeenVault',
  permission: 'permissions.canUseVault',
  releaseDate: new Date('2016-10-12'),
  shouldShow(user) {
    const hasSeenFeatureIntro = user.setting(this.seenFlag);
    const hasPermission = user.setting(this.permission);
    return !hasSeenFeatureIntro && !hasPermission;
  }
};

/***/ }),

/***/ 33621:
/***/ ((module) => {

module.exports = {
  DATES: '.g3',
  TOPLEVEL: '.nH.if',
  POPOVERS: '.ajA.SK',
  POPOVER_FOR_DATE: '.gI:contains',
  EMAILS_IN_POPOVER: '.ajv:not(.UszGxc) [email]',
  MESSAGE_HEADER_EMAILS: '[email]:not(.gD)',
  MESSAGE_HEADER_POPOVER: '.ajz'
};

/***/ }),

/***/ 33921:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var mods = __webpack_require__(25939);
var {
  GmailElementWaiter
} = __webpack_require__(18629);
var {
  ModFactory
} = mods;
var {
  ModCollection
} = mods;

/**
 * Gmail DOM Monitor
 *
 * This manages a set of mods using waiters and timers.
 */
function GmailMonitor(settings, modClasses, collection) {
  this._settings = settings;
  this._modClasses = modClasses;
  this._collection = collection;
  this.addMods = this.addMods.bind(this);
  this.removedElement = this.removedElement.bind(this);
}
GmailMonitor.run = function (settings, modClasses) {
  var collection = new ModCollection();
  var monitor = new GmailMonitor(settings, modClasses, collection);
  monitor.initializeWaiter();
  return monitor;
};
GmailMonitor.prototype.initializeWaiter = function () {
  var settings = this._settings;
  var modFactories = this._modClasses.map(function (modClass) {
    return ModFactory.create(settings, modClass);
  });
  // Listen to the following areas for change
  var listeningSelectors = [document.body];
  var waiter = GmailElementWaiter.start(listeningSelectors, settings.processedClass, modFactories);
  waiter.on('created-mods', this.addMods);
  waiter.on('removed-element', this.removedElement);
  this.waiter = waiter;
};
GmailMonitor.prototype.addMods = function (mods) {
  this._collection.extend(mods);
};
GmailMonitor.prototype.removedElement = function (element) {
  for (var i = 0; i < this._collection._mods.length; i++) {
    var mod = this._collection._mods[i];
    if (mod._addedElement === element) {
      mod.teardownAll();
      this._collection._mods.splice(i, 1);
    }
  }
};
GmailMonitor.prototype.updateSettings = function (settings) {
  this._collection.updateSettings(settings);
};
exports.GmailMonitor = GmailMonitor;

/***/ }),

/***/ 34316:
/***/ ((module) => {

"use strict";
module.exports = "<div class=\"virtru-onboarding-modal-v2\">\n  <div class=\"tourv2 tourv2--normal org-enforced\">\n    <h1 class=\"onboardv2__heading\"></h1>\n    <p class=\"onboardv2__body\"></p>\n    <div class=\"onboardv2__actions\">\n      <button class=\"onboardv2__close\"></button>\n      <button class=\"onboardv2__okay\"></button>\n    </div>\n  </div>\n  \n  </div>";

/***/ }),

/***/ 35648:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customEscape: () => (/* binding */ customEscape)
/* harmony export */ });
// Converts the characters "&", "<", ">", '"', and "'" in string to their corresponding HTML entities. Note: No other characters are escaped.

const map = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;',
  '\'': '&#39;'
};
const customEscape = str => str.replace(/[&<>"']/g, m => map[m]);

/***/ }),

/***/ 36469:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// TODO: Check if this code is still used
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
function ElementWaiter(listeningSelectors, processedClass, modFactoriesMap) {
  this._listeningSelectors = listeningSelectors;
  this._processedClass = processedClass;
  this._modFactoriesMap = modFactoriesMap;
  this.handleMutation = this.handleMutation.bind(this);
}
Emitter(ElementWaiter.prototype);
ElementWaiter.start = function (listeningSelectors, processedClass, modFactories) {
  var modFactoriesMap = {};
  modFactories.forEach(function (modFactory) {
    modFactoriesMap[modFactory.mainSelector] = modFactory;
  });
  var waiter = new ElementWaiter(listeningSelectors, processedClass, modFactoriesMap);
  waiter.startWaiter();
  return waiter;
};
ElementWaiter.prototype.startWaiter = function () {
  var options = {
    continuous: true,
    includeAdded: true,
    includeRemoved: true
  };
  var self = this;
  this._listeningSelectors.forEach(function (selector) {
    $(selector).wait('on', null, options, self.handleMutation);
  });
};
ElementWaiter.prototype.handleMutation = function (added, removed) {
  var self = this;
  added.forEach(function (element) {
    // If it isn't one of the mods then don't process
    self._callHandlingFactory(element);
  });
  if (removed.length > 0) {
    this.emit('removed-mods');
  }
};
ElementWaiter.prototype._callHandlingFactory = function (element) {
  element = $(element);
  var self = this;
  this._modFactoriesMap.forEach(function (factory, selector) {
    var mainSelector = `${selector}:not(.${self._processedClass})`;
    var inclusiveSelector = `${mainSelector}, :has(${mainSelector})`;
    if (element.is(inclusiveSelector)) {
      var target = element.find(mainSelector);
      if (target.length === 0) {
        target = element;
      }
      self.emit('created-mods', factory.process(target));
    }
  });
};
exports.ElementWaiter = ElementWaiter;

/***/ }),

/***/ 37060:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getCrossWindowStore: () => (/* binding */ getCrossWindowStore),
/* harmony export */   getWindowOpener: () => (/* binding */ getWindowOpener)
/* harmony export */ });
// Return correct window object
// depending of how we open compose.
// For shift + click it opens new window
// so we have to operate with window.opener
const getWindowOpener = () => {
  const getUrl = target => target.location.origin + target.location.pathname;
  let result = window;
  while (result.opener) {
    try {
      // We have to make sure that we use the correct
      // window in order to not break the other user
      // profile tab functionality
      const popoutUrl = getUrl(window);
      const openerUrl = getUrl(result.opener);
      if (popoutUrl !== openerUrl && !popoutUrl.includes(openerUrl)) {
        break;
      }

      // inspired by https://github.com/virtru/browser-extension/pull/1039
      result.opener.isAnyPropertyAccessible = 1;
      result = result.opener;
    } catch (error) {
      break;
    }
  }
  return result;
};
const getCrossWindowStore = storeKey => {
  const globalStoreKey = '_cross_window_store_';
  const store = getWindowOpener();
  if (!Object.hasOwn(store, globalStoreKey)) {
    store[globalStoreKey] = {};
  }
  if (!store[globalStoreKey][storeKey]) {
    store[globalStoreKey][storeKey] = {};
  }
  return store[globalStoreKey][storeKey];
};

/***/ }),

/***/ 37450:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DR: () => (/* binding */ assignValue),
/* harmony export */   Gv: () => (/* binding */ isObject),
/* harmony export */   fw: () => (/* binding */ toKey),
/* harmony export */   nw: () => (/* binding */ isIndex),
/* harmony export */   r9: () => (/* binding */ castPath)
/* harmony export */ });
/* unused harmony exports reIsDeepProp, reIsPlainProp, charCodeOfDot, reEscapeChar, rePropName, reIsUint, MAX_SAFE_INTEGER, stringToPath, getTag, isSymbol, isKey, eq */
const reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
const reIsPlainProp = /^\w*$/;
const charCodeOfDot = '.'.charCodeAt(0);
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp(
// Match anything that isn't a dot or bracket.
'[^.[\\]]+' + '|' +
// Or match property names within brackets.
'\\[(?:' +
// Match a non-string expression.
'([^"\'][^[]*)' + '|' +
// Or match strings (supports escaping characters).
'(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' + ')\\]' + '|' +
// Or match "" as the space between consecutive dots or empty brackets.
'(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))', 'g');
const reIsUint = /^(?:0|[1-9]\d*)$/;
const MAX_SAFE_INTEGER = 9007199254740991;
const stringToPath = string => {
  const result = [];
  if (string.charCodeAt(0) === charCodeOfDot) {
    result.push('');
  }
  string.replace(rePropName, (match, expression, quote, subString) => {
    let key = match;
    if (quote) {
      key = subString.replace(reEscapeChar, '$1');
    } else if (expression) {
      key = expression.trim();
    }
    result.push(key);
  });
  return result;
};
function getTag(value) {
  if (value == null) {
    return value === undefined ? '[object Undefined]' : '[object Null]';
  }
  return toString.call(value);
}
function isSymbol(value) {
  const type = typeof value;
  return type === 'symbol' || type === 'object' && value != null && getTag(value) === '[object Symbol]';
}
function isKey(value, object) {
  if (Array.isArray(value)) {
    return false;
  }
  const type = typeof value;
  if (type === 'number' || type === 'boolean' || value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
}
function isObject(value) {
  const type = typeof value;
  return value != null && (type === 'object' || type === 'function');
}
function castPath(value, object) {
  if (Array.isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(value);
}
function toKey(value) {
  const INFINITY = 1 / 0;
  if (typeof value === 'string' || isSymbol(value)) {
    return value;
  }
  const result = `${value}`;
  return result === '0' && 1 / value === -INFINITY ? '-0' : result;
}
function isIndex(value, length) {
  const type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length && (type === 'number' || type !== 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 === 0 && value < length;
}
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
function assignValue(object, key, value) {
  const objValue = object[key];
  function baseAssignValue(object, key, value) {
    if (key === '__proto__') {
      Object.defineProperty(object, key, {
        'configurable': true,
        'enumerable': true,
        value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }
  if (!(Object.prototype.hasOwnProperty.hasOwnProperty.call(object, key) && eq(objValue, value))) {
    if (value !== 0 || 1 / value === 1 / objValue) {
      baseAssignValue(object, key, value);
    }
  } else if (value === undefined && !(key in object)) {
    baseAssignValue(object, key, value);
  }
}

/***/ }),

/***/ 37600:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(721);

/***/ }),

/***/ 37605:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _bindAllMethods: () => (/* binding */ _bindAllMethods)
/* harmony export */ });
/**
 * Replacing lodash/underscore functionality: _.bindAll(this, _.functions(this));
 * @param {this} obj
 */

function _bindAllMethods(obj) {
  const propertyNames = getAllProperties(obj);
  propertyNames.forEach(propertyName => {
    const descriptor = Object.getOwnPropertyDescriptor(obj, propertyName);
    if (descriptor && (descriptor.get || descriptor.set)) {
      Object.defineProperty(obj, propertyName, {
        get: descriptor.get ? descriptor.get.bind(obj) : undefined,
        set: descriptor.set ? descriptor.set.bind(obj) : undefined,
        configurable: true
      });
    } else if (typeof obj[propertyName] === 'function') {
      obj[propertyName] = obj[propertyName].bind(obj);
    }
  });
}
function getAllProperties(obj) {
  const propertyNames = new Set();
  let currentPrototype = Object.getPrototypeOf(obj);
  while (currentPrototype) {
    const ownPropertyNames = Object.getOwnPropertyNames(currentPrototype);
    ownPropertyNames.forEach(propertyName => {
      propertyNames.add(propertyName);
    });
    currentPrototype = Object.getPrototypeOf(currentPrototype);
  }
  return Array.from(propertyNames);
}

/***/ }),

/***/ 38282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @file Loads all 'lib/sites' components.
 */
var Templates = __webpack_require__(5749);
var emailMetadata = __webpack_require__(93882);
var baseModalPage = __webpack_require__(86345);
var downloadVirtruAttachment = __webpack_require__(5421);
var addAttachmentButton = __webpack_require__(4288);
var settings = __webpack_require__(81177);
var settingsService = __webpack_require__(54231);
var userProfile = __webpack_require__(87618);
var policyAttributes = __webpack_require__(81722);
var webmailPlugin = __webpack_require__(55647);
var MonitorBase = __webpack_require__(24427);
var ElementWaiter = __webpack_require__(36469);
var AttachmentDropZone = __webpack_require__(86294);
var AttachmentService = __webpack_require__(95727);
var RemoteContentAttachment = __webpack_require__(45754);
var FeatureModals = __webpack_require__(52067);
var OnboardingV2Modal = __webpack_require__(67262);
Object.assign(module.exports, OnboardingV2Modal);
Object.assign(module.exports, emailMetadata);
Object.assign(module.exports, baseModalPage);
Object.assign(module.exports, downloadVirtruAttachment);
Object.assign(module.exports, addAttachmentButton);
Object.assign(module.exports, settings);
Object.assign(module.exports, settingsService);
Object.assign(module.exports, userProfile);
Object.assign(module.exports, policyAttributes);
Object.assign(module.exports, webmailPlugin);
Object.assign(module.exports, MonitorBase);
Object.assign(module.exports, ElementWaiter);
module.exports.InvitationEmailReplacement = {
  html: Templates.invitationEmailReplace(),
  selector: 'input[name="virtru-nested-secure-message"]'
};
module.exports.AttachmentDropZone = AttachmentDropZone;
module.exports.AttachmentService = AttachmentService;
module.exports.RemoteContentAttachment = RemoteContentAttachment;
module.exports.ComposeBase = __webpack_require__(68014);
module.exports.FeatureModals = FeatureModals;

/***/ }),

/***/ 39283:
/***/ ((module) => {

/** Javascript escape attribute strings. How is this not part of the lib?.
 * https://stackoverflow.com/a/30970751
 */
function escHtml(plainString) {
  return plainString.replace(/["'&<]/g, c => `&#${c.charCodeAt(0)};`);
}
function escJavaScript(plainString) {
  return plainString.replace(/["'\\<]/g, c => `\\${c === '<' ? '074' : c}`);
}
module.exports = {
  escHtml,
  escJavaScript
};

/***/ }),

/***/ 40163:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Virtru Toggle Widget (On/Off Switch)
 */
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var html = __webpack_require__(9463);
var utils = __webpack_require__(55675);
var i18n = __webpack_require__(2622);
var OPPOSITE_STATE = {
  on: 'off',
  off: 'on'
};
var defaultOptions = {
  state: 'off'
};
function Toggle(element) {
  this._element = element;
  this._touched = false;
}

// Add events to this class
Emitter(Toggle.prototype);
Toggle.prototype.cancelableEmit = utils.cancelableEmit;
Toggle.create = function (options) {
  options = Object.assign({}, defaultOptions, options);
  var element = $(html);
  var toggle = new Toggle(element);
  toggle.initEvents();
  toggle.setState(options.state);
  return toggle;
};
Toggle.load = function (localElement, options) {
  options = Object.assign({}, defaultOptions, options);
  var element = $(localElement);
  var toggle = new Toggle(element);
  toggle.emailMode = options.emailMode;
  toggle.initEvents();
  toggle.setState(options.state);
  return toggle;
};
Toggle.prototype.initEvents = function () {
  var element = this._element;
  this.toggle = this.toggle.bind(this);
  utils.onA11yClick(element, this.toggle);
};
Toggle.prototype.updateStatus = function (txt) {
  this._element.closest('.virtru-new-compose-editor-banner').find('.virtru-announce-status').text(txt);
};
Toggle.prototype.setState = function (state) {
  if (['on', 'off'].indexOf(state) === -1) {
    throw Error(`Invalid Toggle State "${state}"`);
  }
  this.removeState();
  this._element.addClass(`virtru-${state}`);
  this._element.closest('.virtru_new_compose').addClass(`virtru-compose-${state}`);
  this._element.attr('aria-pressed', state === 'on');
  this.updateStatus(state === 'on' ? i18n.t('VIRTRU_PROTECTION_ON') : i18n.t('VIRTRU_PROTECTION_OFF'));
  this._state = state;
};
Toggle.prototype.getState = function () {
  return this._state;
};
Toggle.prototype.isTouched = function () {
  return this._touched;
};
Toggle.prototype.removeState = function () {
  this._element.closest('.virtru_new_compose').removeClass('virtru-compose-on');
  this._element.closest('.virtru_new_compose').removeClass('virtru-compose-off');
  this._element.removeClass('virtru-on');
  this._element.removeClass('virtru-off');
};
Toggle.prototype.toggle = function () {
  var state = this.getState();
  var newState = OPPOSITE_STATE[state];
  this._touched = true;
  // Signal the event and give the opportunity to cancel it
  if (!this.cancelableEmit(`before${newState}`)) {
    return;
  }
  this.setState(newState);
  this.emit(newState);
};
Toggle.prototype.appendTo = function (el) {
  el.append(this._element);
};
exports.Toggle = Toggle;

/***/ }),

/***/ 40503:
/***/ ((module) => {

const ACTION_CONSTANTS = {
  warn: 'virtru:warn',
  block: 'virtru:block',
  encrypt: 'virtru:encrypt',
  addTo: 'virtru:addTo',
  addCc: 'virtru:addCc',
  addBcc: 'virtru:addBcc',
  addContent: 'virtru:addContent',
  stripAttachments: 'virtru:stripAttachments',
  disableForwarding: 'virtru:disableForwarding',
  setExpiration: 'virtru:expire',
  noAuth: 'virtru:noAuth',
  // oneclick
  isManaged: 'virtru:isManaged',
  // watermarking
  watermark: 'virtru:watermark',
  preventDownload: 'virtru:preventDownload',
  persistentProtection: 'virtru:persistentProtection'
};
const ACTIONS_ORDER = [ACTION_CONSTANTS.stripAttachments, ACTION_CONSTANTS.warn, ACTION_CONSTANTS.block, ACTION_CONSTANTS.encrypt, ACTION_CONSTANTS.addTo, ACTION_CONSTANTS.addCc, ACTION_CONSTANTS.addBcc, ACTION_CONSTANTS.addContent, ACTION_CONSTANTS.disableForwarding, ACTION_CONSTANTS.setExpiration, ACTION_CONSTANTS.noAuth, ACTION_CONSTANTS.isManaged, ACTION_CONSTANTS.watermark, ACTION_CONSTANTS.preventDownload, ACTION_CONSTANTS.persistentProtection];
module.exports = {
  ACTIONS_ORDER,
  ACTION_CONSTANTS
};

/***/ }),

/***/ 42634:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 42825:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   limitedEncryptionPopover: () => (/* binding */ limitedEncryptionPopover)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const limitedEncryptionPopover = () => `
  <div class="popup-overlay limited-encryption-warning-overlay" >
    <div class="limited-encryption-warning-popup">
      <div class="popup-header">
        <div class="popup-icon"></div>
        <div class="popup-header-text">
          ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('LIMITED_ENCRYPTION_HEADER')}
        </div>
      </div>
      <div class="popup-description">
        ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('LIMITED_ENCRYPTION_TEXT')}
      </div>
      <div class="popup-files-list">
        <ul></ul>
      </div>
      <div class="popup-footer">
        <div class="popup-checkbox">
          <input type="checkbox" name="limited-encryption-disable-warning" id="limited-encryption-disable-warning" />
          <label for="limited-encryption-disable-warning">
            ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('LIMITED_ENCRYPTION_CHECKBOX')}
          </label>
        </div>
        <div class="popup-button ok">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('LIMITED_ENCRYPTION_BUTTON_OK')}</div>
        <div class="popup-button cancel">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('LIMITED_ENCRYPTION_BUTTON_CANCEL')}</div>
      </div>
    </div>
  </div>
`;

/***/ }),

/***/ 44644:
/***/ ((module, exports, __webpack_require__) => {

// NOTE: TweenMax library tells us to create this exact object in order to prevent all of the library
// functions from being stored on the window. As a result, all of the classes, such as TweenMax et al,
// need to be accessed via this object.
window.GreenSockGlobals = {};
module.exports = exports = __webpack_require__(20813);

/***/ }),

/***/ 44883:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OnboardingTourMod: () => (/* binding */ OnboardingTourMod)
/* harmony export */ });
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4424);
/* provided dependency */ var console = __webpack_require__(31799);

const mods = __webpack_require__(25939);
const contexts = __webpack_require__(47446);
const $ = __webpack_require__(55401);
const i18n = __webpack_require__(2622);
const Popover = __webpack_require__(55929);
const widgets = __webpack_require__(31795);
const {
  HighlightOverlay
} = widgets;
const AnalyticsService = (__webpack_require__(1246).instance)();
const {
  TweenMax
} = window.GreenSockGlobals;
const {
  Back
} = window.GreenSockGlobals;
const {
  transports
} = __webpack_require__(29182);
const Templates = __webpack_require__(5749);
const VirtruOfflineMode = (__webpack_require__(2883)/* ["default"] */ .A);
const ONBOARDING_V2_HTML = __webpack_require__(34316);
const TOUR_MODAL_RESTART_HTML = Templates.virtruTourRestart();
const TOUR_MODAL_HTML = Templates.virtruTourV2();

/**
 * The onboarding popover mod
 */
class OnboardingTourMod extends mods.Mod {
  constructor(settings) {
    super(settings);
    this._settings = settings;
    this._isAlive = true;
    this._virtruOfflineMode = new VirtruOfflineMode(this._settings.user._profile);
    (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__._bindAllMethods)(this);
    window.addEventListener('resize', this.resizeHandler);
  }
  openTourStepOne() {
    this.onCloseOnboardingPopover();
    const target = $(this._settings.dom.COMPOSE_BUTTON);
    this._onboardingOverlay = HighlightOverlay.create(target);
    const popover = new Popover();
    popover.classname = 'virtru-onboarding-popover';
    popover.inner.empty().append(TOUR_MODAL_HTML);

    // set up text
    $('.onboardv2__heading', popover.inner).text(i18n.t('ONBOARDING_TOUR_1_HEADER'));
    $('.onboardv2__body', popover.inner).html(i18n.t('ONBOARDING_TOUR_1_BODY'));
    $('.onboardv2__okay', popover.inner).text(i18n.t('ONBOARDING_TOUR_CONFIRM'));

    // set up events
    popover.inner.on('click', '.tour-x-button', () => {
      this.cancelOnboardingTour('Start composing a message');
    });
    popover.inner.on('click', '.onboardv2__okay', () => {
      this.onCloseOnboardingPopover();
    });
    target.on('click', () => {
      this.onCloseOnboardingPopover();
    });

    // show popover and set flag
    this._settings.user.setting('onboarding.tour1', true);
    if (this.isOnboardingActive()) {
      try {
        popover.position('westAlignTop').show(target[0]).focus();
        this._onboardingOverlay.show();
        this._fadeAndScaleElementIn(popover.el);
        this._activeOnboardingPopover = popover;
      } catch (err) {
        AnalyticsService.popoverDisplayError({
          message: err.message
        });
      }
    }
  }
  openTourStepTwo(el) {
    this.onCloseOnboardingPopover();
    let target;
    if (el) {
      target = el;
    } else {
      target = $('.virtru-new-compose-editor-banner');
    }
    const overlay = HighlightOverlay.create(target);
    this._onboardingOverlay = overlay;
    const popover = new Popover();
    popover.classname = 'virtru-onboarding-popover';
    popover.inner.empty().append(TOUR_MODAL_HTML);

    // set up text
    $('.onboardv2__heading', popover.inner).text(i18n.t('ONBOARDING_TOUR_2_HEADER'));
    $('.onboardv2__body', popover.inner).text(i18n.t('ONBOARDING_TOUR_2_BODY'));
    $('.onboardv2__okay', popover.inner).text(i18n.t('ONBOARDING_TOUR_CONFIRM'));

    // set up events
    popover.inner.on('click', '.tour-x-button', () => {
      this.cancelOnboardingTour('Turn on Virtru protection');
    });
    popover.inner.on('click', '.onboardv2__okay', () => {
      this.onCloseOnboardingPopover();
    });
    target.on('click', '.virtru-slider', () => {
      popover.hide();
      overlay.hide();
      if (!this._settings.user.setting('onboarding.tour3')) {
        this.openTourStepThree();
      }
    });

    // show popover and set flag
    this._settings.user.setting('onboarding.tour2', true);
    if (this.isOnboardingActive()) {
      try {
        this._formElement = $('.virtru_new_compose').find('form');
        this._composeId = this._formElement.find('input[name="composeid"]').attr('value');
        window.VIRTRU_COMPOSE_MANAGER.composeMods[this._composeId]._toggle.emit('off');
        popover.position('southAlignRight').show(target[0]).focus();
        this._onboardingOverlay.show();
        this._fadeAndScaleElementIn(popover.el);
        this._activeOnboardingPopover = popover;
      } catch (err) {
        AnalyticsService.popoverDisplayError({
          message: err.message
        });
      }
    }
  }
  openTourStepThree(el) {
    this.onCloseOnboardingPopover();
    let target;
    if (el) {
      target = $(el).find('.virtru-pcm-container');
    } else {
      target = $('.virtru-pcm-container');
    }
    this._onboardingOverlay = HighlightOverlay.create(target);
    const popover = new Popover();
    popover.classname = 'virtru-onboarding-popover';
    popover.inner.empty().append(TOUR_MODAL_HTML);

    // set up text
    $('.onboardv2__heading', popover.inner).text(i18n.t('ONBOARDING_TOUR_3_HEADER'));
    $('.onboardv2__body', popover.inner).text(i18n.t('ONBOARDING_TOUR_3_BODY'));
    $('.onboardv2__okay', popover.inner).text(i18n.t('ONBOARDING_TOUR_CONFIRM'));

    // set up events
    popover.inner.on('click', '.tour-x-button', () => {
      this.cancelOnboardingTour('Add security options');
    });
    popover.inner.on('click', '.onboardv2__okay', () => {
      this.onCloseOnboardingPopover();
      if (!this._settings.user.setting('onboarding.tour4')) {
        this.openTourStepFour();
      }
    });
    target.on('click', () => {
      popover.hide();
      this._isAlive = false;
      if (this._onboardingOverlay) {
        this._onboardingOverlay.hide();
        this._onboardingOverlay = null;
      }
      // if the policy menu is closed and they havent seen the personal intro modal
      if ($('.virtru-pcm-container-closed')[0] && !this._settings.user.setting('onboarding.tour4')) {
        this.openTourStepFour();
      }
    });

    // show popover and set flag
    this._settings.user.setting('onboarding.tour3', true);
    if (this.isOnboardingActive()) {
      try {
        popover.position('west').show(target[0]).focus();
        this._onboardingOverlay.show();
        this._fadeAndScaleElementIn(popover.el);
        this._activeOnboardingPopover = popover;
      } catch (err) {
        AnalyticsService.popoverDisplayError({
          message: err.message
        });
      }
    }
  }
  openTourStepFour() {
    this.onCloseOnboardingPopover();
    const target = $('.virtru-intro-message-toggle-button');
    this._onboardingOverlay = HighlightOverlay.create(target);
    const popover = new Popover();
    popover.classname = 'virtru-onboarding-popover';
    popover.inner.empty().append(TOUR_MODAL_HTML);

    // set up text
    $('.onboardv2__heading', popover.inner).text(i18n.t('ONBOARDING_TOUR_4_HEADER'));
    $('.onboardv2__body', popover.inner).html(i18n.t('ONBOARDING_TOUR_4_BODY'));
    $('.onboardv2__okay', popover.inner).text(i18n.t('ONBOARDING_TOUR_CONFIRM'));

    // set up events
    popover.inner.on('click', '.tour-x-button', () => {
      this.cancelOnboardingTour('Personal Introduction');
    });
    popover.inner.on('click', '.onboardv2__okay', () => {
      AnalyticsService.onboardingTourCompleted({});
      this._settings.user.setting('onboarding.tour1', true);
      this._settings.user.setting('onboarding.tour2', true);
      this._settings.user.setting('onboarding.tour3', true);
      this.onCloseOnboardingPopover();
    });
    target.on('click', () => {
      popover.hide();
      this._isAlive = false;
      if (this._onboardingOverlay) {
        this._onboardingOverlay.hide();
        this._onboardingOverlay = null;
      }
    });

    // show popover and set flag
    this._settings.user.setting('onboarding.tour4', true);
    if (this.isOnboardingActive()) {
      try {
        popover.position('southAlignRight').show(target[0]).focus();
        this._onboardingOverlay.show();
        this._fadeAndScaleElementIn(popover.el);
        this._activeOnboardingPopover = popover;
        this._settings.user.setting('preferences.showOnboardingTour', false);
        this.sendSettingsToServer();
      } catch (err) {
        AnalyticsService.popoverDisplayError({
          message: err.message
        });
      }
    }
  }
  showRestartBanner() {
    this._gmailBanner = $(this._settings.dom.GMAIL_COMPOSE_BANNER);
    this._authLabel = $('.virtru-auth-label');
    this._activateLabel = $('.virtru-auth-link');
    const margin = 40;
    var authPopover = this._authLabelPopover;
    // default auth banner to the longer text and popover disabled
    $('.virtru-not-authenticated').css('display', 'flex');
    this._authLabel.find('.virtru-label').text(i18n.t('VIRTRU_PROTECTION_NOT_AUTH'));
    if (authPopover) {
      authPopover.disable();
    }
    /* check if the long auth banner text and the activate button together are wider than the window
    *  if yes switch to smaller text and create popover with longer text
    * */
    if (this._gmailBanner.width() < this._authLabel.width() + this._activateLabel.width() + margin) {
      this._authLabel.find('.virtru-label').text(i18n.t('VIRTRU_PROTECTION_NOT_AUTH_SHORT'));
      if (authPopover) {
        authPopover.enable();
      } else {
        authPopover = new Popover(i18n.t('VIRTRU_PROTECTION_NOT_AUTH'));
        authPopover.classname += ' virtru-popover-dark';
        authPopover.position('south');
        authPopover.attach($('.virtru-auth-label'));
        this._authLabelPopover = authPopover;
      }
    }
    $('.virtru-secure-mode-toggle').hide();
  }
  hideRestartBanner() {
    $('.virtru-not-authenticated').hide();
    $('.virtru-secure-mode-toggle').show();
  }
  bindInfoIconLinks(bannerEl, orgOverride, toggle) {
    this.bannerEl = bannerEl;
    const target = $(this.bannerEl).find('.virtru-show-info-btn');
    const popover = new Popover();
    const setContent = () => {
      // set up text & events
      if (orgOverride && toggle.getState() === 'on' && !toggle.isTouched()) {
        popover.inner.empty().append(ONBOARDING_V2_HTML);
        popover.classname = 'virtru-onboarding-popover org-enforced';
        $('.onboardv2__heading', popover.inner).html(i18n.t('ONBOARDING_RESTART_4_ORG_HEADING'));
        $('.onboardv2__body', popover.inner).html(i18n.t('ONBOARDING_RESTART_4_ORG_BODY'));
        $('.onboardv2__okay', popover.inner).text(i18n.t('ONBOARDING_RESTART_CONFIRM'));
        $('.onboardv2__close', popover.inner).text(i18n.t('COMMON_CLOSE'));
        // do not close popover if clicked inside for SSS tooltip
        popover.inner.on('click', e => e.stopPropagation());
      } else {
        popover.classname = 'virtru-onboarding-popover-small';
        popover.inner.empty().append(TOUR_MODAL_RESTART_HTML);
        $('.onboardv2__body', popover.inner).html(i18n.t('ONBOARDING_RESTART_4_BODY'));
        $('.onboardv2__okay', popover.inner).text(i18n.t('ONBOARDING_RESTART_CONFIRM'));
        popover.inner.off('click');
      }
    };
    const setupEvents = () => {
      // set up events
      popover.inner.on('click', '.tour-x-button, .onboardv2__close', () => {
        $(window).off('click', this.checkClick);
        this.onCloseOnboardingPopover();
      });
      popover.inner.on('click', '.onboardv2__okay', () => {
        $(window).off('click', this.checkClick);
        AnalyticsService.onboardingTourRestarted({});
        // Take the tour
        this.onCloseOnboardingPopover();
        if (this._settings.user.auth('status') !== 'active') {
          this._settings.user.emit('restartTourNoAuth');
        } else {
          // reset all flags so user will see popovers again
          this._settings.user.setting('onboarding.isActive', true);
          this._settings.user.setting('onboarding.tour2', false);
          this._settings.user.setting('onboarding.tour3', false);
          this._settings.user.setting('onboarding.tour4', false);
          this.openTourStepTwo(this.bannerEl);
        }
      });
    };
    const updatePopover = () => {
      setContent();
      setupEvents();
    };
    target.on('online_click', e => {
      updatePopover();
      if (this._onboardingOverlay) {
        return;
      }
      if (e.target !== e.currentTarget) {
        return;
      }
      popover.hide();
      this._isAlive = false;

      // show popover and set flag
      popover.position(orgOverride ? 'northMiddleWest' : 'northwest').show(e.target).focus();
      this._fadeAndScaleElementIn(popover.el);
      this._activeOnboardingPopover = popover;
      $(window).on('click', this.checkClick);
    });
  }
  bindActivateLink(isReactivation = false) {
    const $activateLink = $('.virtru-auth-link');
    $activateLink.text(i18n.t(isReactivation ? 'VIRTRU_AUTH_LINK_REACTIVATE' : 'VIRTRU_AUTH_LINK'));
    $activateLink.on('click', () => {
      if (this._virtruOfflineMode.isOnline()) {
        $activateLink.off('click');
        this._settings.requestActivation({
          requestedFrom: 'onboarding',
          isReactivation
        });
      }
    });
  }
  _fadeAndScaleElementIn(el) {
    TweenMax.set(el, {
      opacity: 0,
      scaleX: 0.95,
      scaleY: 0.95
    });
    TweenMax.to(el, 0.15, {
      opacity: 1
    });
    TweenMax.to(el, 0.15, {
      scaleX: 1,
      scaleY: 1,
      ease: Back.easeOut
    });
  }
  _fadeAndScaleElementOut(el, callback) {
    TweenMax.to(el, 0.15, {
      opacity: 0,
      scaleX: 0.95,
      scaleY: 0.95,
      onComplete() {
        if (callback) {
          callback();
        }
      }
    });
  }
  cancelOnboardingTour(modal) {
    this._settings.user.setting('preferences.showOnboardingTour', false);
    this._settings.user.setting('onboarding.isActive', false);
    this._settings.user.setting('onboarding.tour1', true);
    this._settings.user.setting('onboarding.tour2', true);
    this._settings.user.setting('onboarding.tour3', true);
    this._settings.user.setting('onboarding.tour4', true);
    AnalyticsService.onboardingTourCanceled({
      atModal: modal
    });
    this.sendSettingsToServer();
    this.onCloseOnboardingPopover();
  }
  onCloseOnboardingPopover() {
    if (this._onboardingOverlay) {
      this._onboardingOverlay.hide();
      this._onboardingOverlay = null;
    }
    if (this._activeOnboardingPopover) {
      const popover = this._activeOnboardingPopover;
      this._fadeAndScaleElementOut(popover.el, () => {
        popover.hide();
        if (popover.disabledTooltip) {
          popover.disabledTooltip.enable();
        }
      });
      if (popover.target) {
        popover.target.off('click.onboarding-close');
      }
      this._activeOnboardingPopover = null;
    }
  }
  resizeHandler() {
    if (this._activeOnboardingPopover) {
      this._activeOnboardingPopover.reposition();
    }
    if (this._onboardingOverlay) {
      this._onboardingOverlay.reposition();
    }
  }
  checkClick(event) {
    const onboardingTakeTourPopover = document.querySelector('.tourv2--restart');
    const $showTourButton = $('.virtru-show-info-btn');

    // if the user clicks on the info icon do not close the modal
    // there are three instances of the info icon check for all three cases.
    //    1. Virtru protection on
    //    2. Virtru protection off
    //    3. Virtru not activated
    if ($showTourButton.toArray().some(ele => event.originalEvent.path.includes(ele))) {
      return;
    }
    // if the user clicks anywhere in the window that is not within
    // the popover modal close the popover
    if (!event.originalEvent.path.includes(onboardingTakeTourPopover)) {
      if (this._activeOnboardingPopover) {
        this._activeOnboardingPopover.hide();
      }
      $(window).off('click', this.checkClick);
    }
  }
  isOnboardingActive() {
    return this._settings.user.setting('onboarding.isActive');
  }
  sendSettingsToServer() {
    // Save to server that the user has seen this modal.
    const params = {
      userId: this._settings.currentUser()
    };
    transports.call('content', 'saveUserSettingsToServer', params).catch(err => {
      console.error('Error on saving the user-settings', err);
    });
  }
}
Object.assign(OnboardingTourMod.prototype, mods.ModWaiterPromises);
contexts.addOpen(OnboardingTourMod);

/***/ }),

/***/ 45055:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   set: () => (/* binding */ set)
/* harmony export */ });
/* harmony import */ var _get_set_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37450);

function baseSet(object, path, value, customizer) {
  if (!(0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(object)) {
    return object;
  }
  path = (0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .castPath */ .r9)(path, object);
  const {
    length
  } = path;
  const lastIndex = length - 1;
  let index = -1;
  let nested = object;
  while (nested != null && ++index < length) {
    const key = (0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .toKey */ .fw)(path[index]);
    let newValue = value;
    if (index !== lastIndex) {
      const objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = (0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .isObject */ .Gv)(objValue) ? objValue : (0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .isIndex */ .nw)(path[index + 1]) ? [] : {};
      }
    }
    (0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .assignValue */ .DR)(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}
function set(object, path, value) {
  return object == null ? object : baseSet(object, path, value);
}

/***/ }),

/***/ 45754:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const globalStore = __webpack_require__(71139);
const $ = __webpack_require__(55401);
const i18n = __webpack_require__(2622);
const Utils = __webpack_require__(55675);
const Emitter = __webpack_require__(16502);
const AnalyticsService = (__webpack_require__(1246).instance)();
const emailUtils = __webpack_require__(25119);
const attachmentsUtils = (__webpack_require__(62769)/* ["default"] */ .Ay);
const InlineElement = __webpack_require__(60684);
const {
  TDF3_EMAIL_MANIFEST_ID,
  TDF3_TRANSFER_URL_ID
} = __webpack_require__(30893);
const {
  PFP_PARSE_ERROR,
  NO_APP_ID_FOR_DOMAIN,
  INVALID_APP_ID,
  NETWORK_CONNECTION_ERROR
} = __webpack_require__(22592);
const {
  getAttachmentImage
} = (__webpack_require__(82672).modules);
const {
  AttachmentImages
} = (__webpack_require__(82672).modules);
const attachmentHtml = __webpack_require__(23774);
const renderModal = (__webpack_require__(58665)/* ["default"] */ .A);

/**
 * Creates new Remote Content Attachment in the compose window
 * @param {fileData} fileData Contains size, name, and type.
 * @param composeMod Contains size, name, and type.
 * @param {promise} deferred The promise for the uploading attachment which is kicked off in attachment-service.js
 */
class RemoteContentAttachment extends InlineElement {
  constructor(fileData, composeMod, deferred) {
    super(fileData, composeMod, deferred);
    this._deferred = deferred;
  }
  static showErrorModal(files, emitResult) {
    const erroredFiles = [];
    const errorNames = [];
    let pfpErrorMessage = '';
    files.forEach(file => {
      const {
        error
      } = file;
      if (error) {
        AnalyticsService.clientError({
          context: 'Remote content attachment failure',
          name: error.name,
          message: error.message
        });
        erroredFiles.push(file);
        if (!errorNames.includes(error.name)) {
          errorNames.push(error.name);
        }
        if (error.name === PFP_PARSE_ERROR) {
          pfpErrorMessage = error.message;
        }
      }
    });
    function errorModalOnClose() {
      if (emitResult !== undefined) {
        emitResult(files);
      }
      setTimeout(function () {
        erroredFiles.forEach(file => file.self.remove());
      }, 1000);
    }

    // NetworkConnectionError has a top priority
    // It should be displayed in a modal if met at least once
    if (errorNames.includes(NETWORK_CONNECTION_ERROR)) {
      return renderModal.attachmentNetworkConnectionError(errorModalOnClose);
    }
    if (errorNames.includes(INVALID_APP_ID) || errorNames.includes(NO_APP_ID_FOR_DOMAIN)) {
      return renderModal.attachmentAppIdError(errorModalOnClose);
    }
    if (errorNames.includes(PFP_PARSE_ERROR)) {
      return renderModal.attachmentPfpError(pfpErrorMessage, errorModalOnClose);
    }
    return renderModal.attachmentGenericError({
      handleClose: errorModalOnClose
    });
  }

  /**
   * Update rendering of the file's metadata, which can change when more info is received.
   */
  updateElementFileInfo() {
    // @SECURITY: Because we are inserting user defined data (attachment metadata)
    //            into an HTML template, do NOT use jQuery's html()! It WILL open
    //            an XSS vulnerability by not html encoding the user input!!
    this._element.find('.virtru-attachment-file-name').text(this.fileData.name);
    this._element.find('.virtru-attachment-file-size').text(emailUtils.formatFileSize(this.fileData.size));
    this._element.find('.virtru-attachment-delete').text(i18n.t('VIRTRU_ATTACHMENT_REMOVE'));

    // tdf3html doesnt have necessary tdf middle extension
    if (this.isTdf3Html) {
      this._element.find('.virtru-attachment-tdf-extension').text('');
    }
    this._element.attr('data-name', this.fileData.name);
    this._element.attr('data-size', this.fileData.size);
    if (this.fileData.size === 0) {
      this._element.find('.virtru-attachment-file-size').css('display', 'none');
    } else {
      this._element.find('.virtru-attachment-file-size').css('display', 'unset');
    }
  }

  /**
   * Add and animate the initial attachment chip. Later we'll do more with it, like attach events.
   */
  addHtml() {
    this._element = $($(attachmentHtml)[0]);
    const userProfile = this._settings.user._profile;
    if (Utils.isFeatureEnabled(userProfile, 'useAttachmentChipsV2')) {
      this._element.addClass('virtru-attachment-v2');
    }
    this._element.addClass('virtru-attachment-is-uploading');
    const shield = this._element.find('.virtru-attachment-shield');
    shield.css('background-image', '');
    shield.removeClass('virtru-attachment-shield');
    shield.addClass('virtru-attachment-uploading');
    const $appendElem = $(this._element);
    this.addElementToCompose($appendElem);

    // This stupid hack is to get fadeIn to work properly in outlook.
    this._element.hide();
    setTimeout(function () {
      this._element.fadeIn(200);
    }.bind(this), 25);

    // Make sure the file data is displayed
    this.updateElementFileInfo();
  }

  /**
   * Get the file icon for the file type. Can get base64, or remote url versions.
   * @param  {type} type Type to get, can be base64, or s3. s3 being the remote version
   * @return {string}      Returns either a base64 image, or an s3 URL pointing to an image.
   */
  _getFileImage(type) {
    return getAttachmentImage(this.fileData.mimeType || this.fileData.type, type);
  }

  /**
   * Sets up the various events for the attachment chip, like the delete mouse over, click events,
   * and attaches some required data to fthe chip.
   *
   *
   */
  setupDataAndEvents() {
    const self = this;
    const deleteButton = $('.virtru-attachment-delete', this._element);
    const link = $('.virtru-attachment-link', this._element);
    if (this.tdfData.tdo.id) {
      link.attr('id', this.tdfData.tdo.id);
    }
    this._element.attr('data-policy-uuid', this.tdfData.policyUuid);
    this._element.attr('data-tdo-id', this.tdfData.tdo.id);
    this._element.attr('id', this.tdfData.tdo.id);
    const data = {
      'policy-uuid': this.tdfData.policyUuid,
      'tdo-id': this.tdfData.tdo.id,
      'name': this.fileData.name,
      'size': this.fileData.size
    };
    this._element.append($('<input type="hidden" class="virtru-attachment-data" />').val(JSON.stringify(data)));

    // If we are provided a preview link, this must be a reattached TDF.html file
    if (this.tdfData.previewLink) {
      this._element.append($(`<div class='virtru-reattached-preview-link' style="display:none;">${this.tdfData.previewLink}</div>`));
    }
    if (!this.isV2Attachment() && Utils.isFeatureEnabled(this._settings.user._profile, 'useAttachmentChipsV2')) {
      this._element.addClass('virtru-attachment-v2');
    }
    if (this.tdfData.isTdf3Html) {
      this._element.append($(`<input id="${TDF3_EMAIL_MANIFEST_ID}" type="hidden" value="${this.tdfData.originalFile.manifestBase64}">`));
      this._element.append($(`<input id="${TDF3_TRANSFER_URL_ID}" type="hidden" value="${this.tdfData.originalFile.transferUrl}">`));
    }
    const policyModel = this._composeMod._policyConfigMenu.getModel();
    const pfpEnabled = policyModel.persistentProtection;
    const isReattachedFile = Boolean(this.tdfData.previewLink) || this.tdfData.isTdf3Html;
    if (this.isV2Attachment()) {
      var _this$tdfData, _this$tdfData$policy, _this$tdfData$policy$;
      const cssClassName = attachmentsUtils.attachmentExtensionClassName(this.fileData.name, isReattachedFile, pfpEnabled, true, this.tdfData.isTdf3Html);
      this._element.addClass(cssClassName);
      const authorizations = this.tdfData.policy && this.tdfData.policy.simplePolicy.authorizations.slice(0);
      const isSender = true;
      attachmentsUtils.createChipTooltip({
        $anchor: this._element,
        fileName: this.fileData.name,
        isReattachedPFPFile: isReattachedFile,
        attachmentId: this.tdfData.tdo.id,
        isManaged: ((_this$tdfData = this.tdfData) === null || _this$tdfData === void 0 ? void 0 : (_this$tdfData$policy = _this$tdfData.policy) === null || _this$tdfData$policy === void 0 ? void 0 : (_this$tdfData$policy$ = _this$tdfData$policy.simplePolicy) === null || _this$tdfData$policy$ === void 0 ? void 0 : _this$tdfData$policy$.isManaged) || false,
        isTdf3Html: this.tdfData.isTdf3Html,
        authorizations,
        isSender
      });
    }

    // Delete handler
    deleteButton[0].addEventListener('click', function (e) {
      e.stopPropagation();
      self._element.animate({
        opacity: 0,
        height: 0
      }, 150, function () {
        if (Utils.isFeatureEnabled(self._settings.user._profile, 'useAttachmentChipsV2')) {
          // Unmount React Tooltip component at DOM
          const $tooltipWrapper = self._element.parents('.virtru-attachment-wrapper');
          globalStore.dispatch({
            type: 'REMOVE_ATTACHMENT_DATA',
            id: self.tdfData.tdo.id
          });
          $tooltipWrapper.remove();
        }
        self._element.remove();
        self.emit('attachment-deleted');
        AnalyticsService.attachmentRemoved({
          'policy.Id': self.tdfData.policyUuid
        });
      });
    }, false);
    addElementHoverEvents(this._element);
    this._element.animate({
      opacity: 1
    }, 150);
  }

  /**
   * Removes the chip from the compose window
   */
  remove() {
    const self = this;
    this._element.animate({
      opacity: 0,
      height: 0
    }, 150, function () {
      self._element.remove();
      self.emit('attachment-deleted');
    });
  }
  isV2Attachment() {
    return this._element.hasClass('virtru-attachment-v2');
  }

  /**
   * restores the attachment from a draft
   * @param  element    The attachment chip in the draft
   * @param  {string} tdoId
   * @param  {string} policyUuid
   * @param  {string} (*optional) previewLink - reattached preview link
   */
  restoreDraftAttachment(element, tdoId, policyUuid, previewLink) {
    this._element = element;

    // This line allows us to replace attachments that are stripped out of drafts
    // by gmail's zealous onpaste sanitizer
    this._sendHtml = this._element.get(0).outerHTML;
    this.tdfData = {
      policyUuid,
      tdo: {
        id: tdoId
      },
      previewLink
    };
    this.setupDataAndEvents();
  }

  /**
   * Gets the send safe HTML of the chip. We set opacity to 1, because it could be in the
   * middle of an animation. This needs to be called once the attachment chip is fully constructed,
   * with all the required data.
   * @return {string} HTML of the chip
   */
  getSendHtml() {
    return this._element.clone().css('opacity', 1)[0].outerHTML;
  }

  /**
   * This is called by the compose mod, right before the email is sent.
   * It takes the send safe HTML that was stored earlier with the getSendHtml function,
   * and replaces the chips in the email body.
   */
  prepareForSend() {
    const {
      id
    } = this._element[0];

    // Double-check the attachment for gmail sanitization due to copy-pasting
    // It's possible even the ID can be prepended with `gmail-`
    let $attachmentElem = this._editor.find(`#${id}`);
    if ($attachmentElem.length < 1) {
      $attachmentElem = this._editor.find(`#gmail-${id}`);
    }
    $attachmentElem.replaceWith(this._sendHtml);
  }

  /**
   * Finds and returns the delete button so it can be triggered
   * in the case the compose mod needs to delete it.
   * @return {Element} The delete button
   */
  getClonedDeleteButton() {
    return this._element.firstChild().children().last();
  }

  /**
   * Kicks off the whole process. Error handling here too.
   * @return {Promise} The promise for the attachment
   */
  init() {
    const self = this;
    return new Promise(resolve => {
      this._deferred.then(function (resolved) {
        // Check if gmail has screwed with our attachment HTML from copy+paste
        // sanitization. If it has, remove the soiled elem and replace it with our working copy.
        if (!$.contains(document.body, self._element[0])) {
          $(`.virtru-attachment.virtru-attachment-is-uploading,
                .gmail-virtru-attachment.gmail-virtru-attachment-is-uploading`).first().replaceWith(self._element);
        }
        // Update the file metadata from the attachment's XHR request headers
        if (resolved.originalFile) {
          self.fileData.mimeType = resolved.originalFile.mimeType || self.fileData.mimeType;
          self.fileData.size = resolved.originalFile.size || self.fileData.size || 0;
          self.fileData.name = resolved.originalFile.name || self.fileData.name;
          self.isTdf3Html = resolved.isTdf3Html;
        }

        // Render any updates of the file metadata
        self.updateElementFileInfo();
        self.tdfData = resolved;
        self.setupDataAndEvents(resolved);
        const icon = self._element.find('.virtru-attachment-uploading');
        icon.removeClass('virtru-attachment-uploading');
        icon.addClass('virtru-attachment-file-image');
        self._element.removeClass('virtru-attachment-is-uploading');
        icon.css('background-image', `url(${self._getFileImage('base64')})`);

        // This code below handles maintaining the UI of the chip if a paste operation
        // happens.  GMail sanitizes the HTML on paste and strips out things that
        // we rely on in the HTML.  So once we create the attachment chip, save a copy
        // of its HTML so we can reinstate it on Send.
        //
        // The order is important here, this getSendHtml must be called before the jquery stuff below.
        self._sendHtml = self.getSendHtml();
        icon.css('background-image', '');
        const img = $('<img>');
        img.attr('src', self._getFileImage('s3'));
        img.css({
          display: 'inline-block',
          verticalAlign: 'top',
          marginTop: '-1px',
          width: '18px',
          height: '16px'
        });
        icon.append(img);
        resolve(self);
      })
      // todo: this part of code is not executed and should be rethought
      // .progress(function(progress) {
      //   console.log(progress);
      //   self.emit('progress', progress);
      //   var bar = $('.virtru-attachment-progress-bar', self._element);
      //   bar.css('width', `${Math.floor(progress.percent) }%`);
      //   if (!self._hasRemovedProgressBar && progress.percent >= 98) {
      //     self._hasRemovedProgressBar = true;
      //     bar.fadeOut(200, function() {
      //       bar.remove();
      //     });
      //   }
      // })
      .catch(function (error) {
        // Create fake policy for record keeping in the compose mods.
        self.tdfData = {
          policyUuid: window.crypto.randomUUID()
        };
        $('.virtru-attachment-content', self._element).addClass('error');
        resolve({
          error,
          self
        });
      });
    });
  }

  /**
   * Set watermark authorization on an attachment
   * @param {Boolean} isExpandedWatermarked True/False to add the authorization or not
   */
  setExpandedWatermarking(isExpandedWatermarked) {
    if (typeof isExpandedWatermarked !== 'boolean') {
      throw new Error('Wrong type for isExpandedWatermarked');
    }

    // Only apply for supported file types
    // NOTE: reattached PFP files will not have a unique policy of their own
    if (Utils.supportsExpandedWatermarking(this.fileData.name) && this.tdfData.policy) {
      // Toggle the existence of the 'watermark' authorization
      const authorizations = this.tdfData.policy.simplePolicy.authorizations.slice(0);
      const hasWatermark = authorizations.includes('watermark');
      if (isExpandedWatermarked && !hasWatermark) {
        authorizations.push('watermark');
      } else if (!isExpandedWatermarked && hasWatermark) {
        authorizations.splice(authorizations.indexOf('watermark'), 1);
      }
      this._attachmentService.updateAttachmentPolicy(this.tdfData.policyUuid, {
        simplePolicy: {
          authorizations
        }
      });
    }
  }

  /**
   * Set isManaged flag on an attachment
   * @param {Boolean} value True/False for isManaged
   */
  setIsManaged(isManaged) {
    if (typeof isManaged !== 'boolean') {
      throw new Error('Wrong type for isManaged');
    }

    // Currently we only want this to happen for PDFs
    // NOTE: reattached PFP files will not have a unique policy of their own
    if (Utils.supportsLegacyWatermarking(this.fileData.name) && this.tdfData.policy) {
      this._attachmentService.updateAttachmentPolicy(this.tdfData.policyUuid, {
        simplePolicy: {
          isManaged
        }
      });
    }
  }
}
Emitter(RemoteContentAttachment.prototype);
function addElementHoverEvents(element) {
  if (!element.hasClass('virtru-attachment-v2')) {
    // Handles mouseover for the delete button
    // The reason the selector for delete button is awful is b/c we can't rely on
    // our class names or attributes existing on the chip b/c GMail sanitizes them
    // out on paste.
    element.on('mouseover', function () {
      element.find('*').css('pointer-events', 'none');
      const dButton = element.firstChild().children().last(); // I hate this.
      dButton.css('background-image', `url(${AttachmentImages.delete_button.base64})`);
      dButton.css('pointer-events', 'auto');
      dButton.show();
    });

    // Handles mouseout for the delete button
    element.on('mouseout', function () {
      const dButton = element.firstChild().children().last(); // I hate this.
      dButton.hide();
    });
  }
}
module.exports = RemoteContentAttachment;

/***/ }),

/***/ 47206:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   callContentScript: () => (/* binding */ callContentScript),
/* harmony export */   cancelableEmit: () => (/* reexport safe */ _emitter__WEBPACK_IMPORTED_MODULE_4__.Q),
/* harmony export */   formatForTransport: () => (/* binding */ formatForTransport),
/* harmony export */   getAttachmentData: () => (/* binding */ getAttachmentData),
/* harmony export */   getFileExtension: () => (/* binding */ getFileExtension),
/* harmony export */   getFileType: () => (/* binding */ getFileType),
/* harmony export */   hasPfpFileExtensions: () => (/* binding */ hasPfpFileExtensions),
/* harmony export */   isFeatureEnabled: () => (/* binding */ isFeatureEnabled),
/* harmony export */   isPfpFile: () => (/* binding */ isPfpFile),
/* harmony export */   isTdf3Html: () => (/* binding */ isTdf3Html),
/* harmony export */   isUid: () => (/* binding */ isUid),
/* harmony export */   mergeSelectors: () => (/* binding */ mergeSelectors),
/* harmony export */   onA11yClick: () => (/* binding */ onA11yClick),
/* harmony export */   pdftronFileTypes: () => (/* binding */ pdftronFileTypes),
/* harmony export */   processError: () => (/* binding */ processError),
/* harmony export */   supportsExpandedWatermarking: () => (/* binding */ supportsExpandedWatermarking),
/* harmony export */   supportsLegacyWatermarking: () => (/* binding */ supportsLegacyWatermarking)
/* harmony export */ });
/* harmony import */ var mime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(63985);
/* harmony import */ var _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(52938);
/* harmony import */ var _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var superagent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(75522);
/* harmony import */ var superagent__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(superagent__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lib_email_lib_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76223);
/* harmony import */ var _lib_email_lib_constants__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lib_email_lib_constants__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _emitter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8561);
/* provided dependency */ var console = __webpack_require__(31799);





// MIME types supported by the PDFTron WebViewer renderer
const pdftronFileTypes = ['pdf', 'docx', 'xlsx', 'pptx', 'jpeg', 'jpg', 'png'];

// Attach a click listener that also triggers on space + enter to better support screenreaders
function onA11yClick(element, callback) {
  const $ = __webpack_require__(91089);
  $(element).on('click keypress', e => {
    if (isA11yClick(e)) {
      callback(e);
    }
  });
}

// Determine if an event is either a click or a screenreader simulated click (with ENTER or SPACE key codes)
function isA11yClick(event) {
  return event.type === 'click' || event.type === 'keypress' && (event.charCode === 32 || event.charCode === 13);
}

// Serialize an error message so that it can be transferred in between extension scripts
function formatForTransport(obj) {
  var type = toString.call(obj);
  if (type === '[object Error]' || type === '[object DOMException]') {
    return processError(obj);
  }
  if (typeof obj === 'object' && obj !== null && !Array.isArray(obj)) {
    // We need to make a copy for cases when obj property has only a getter
    const objectCopy = {};
    Object.entries(obj).forEach(([key, value]) => {
      objectCopy[key] = formatForTransport(value);
    });
    return objectCopy;
  }
  return obj;
}
const ERROR_PROPERTIES = ['name', 'message', 'type', 'status', 'stack', 'arguments', 'reason'];
function processError(err) {
  var info = {};
  ERROR_PROPERTIES.forEach(function (name) {
    if (err[name] !== null) {
      info[name] = err[name];
    }
  });
  return info;
}

/**
 * Check for feature enablement. If the feature has a GA_date specified, check if the current date exceeds it yet.
 *
 * @param featureName
 * @returns {*}
 */
function isFeatureEnabled(profile, featureName) {
  var _profile$settings, _profile$settings$cli, _profile$settings2;
  // Allow for feature flag OR user permission to enable the functionality.
  const featureObj = (profile === null || profile === void 0 ? void 0 : (_profile$settings = profile.settings) === null || _profile$settings === void 0 ? void 0 : (_profile$settings$cli = _profile$settings.clientConfig) === null || _profile$settings$cli === void 0 ? void 0 : _profile$settings$cli.features[featureName]) || (profile === null || profile === void 0 ? void 0 : (_profile$settings2 = profile.settings) === null || _profile$settings2 === void 0 ? void 0 : _profile$settings2.permissions[featureName]) || false;
  if (typeof featureObj === 'object' && typeof featureObj.GA_date === 'string') {
    return Date.now() >= new Date(featureObj.GA_date).getTime();
  }
  return !!featureObj;
}

/**
 * Helper function to merge selectors by iterating through the selectors in newest
 * to oldest order and build up our merged selectors as we go
 *
 * @param {Object} selectors - Selectors to merge
 * @param {String} gmailVersion - Gmail Version
 */
function mergeSelectors(selectors, gmailVersion) {
  let mergedSelectors;
  const versions = Object.keys(selectors).filter(Number) // filter out non BP selectors
  .sort((a, b) => b - a);
  for (const version of versions) {
    if (Number(gmailVersion) >= Number(version)) {
      mergedSelectors = {
        ...selectors[version],
        ...mergedSelectors
      };
    }
  }
  return mergedSelectors;
}

/**
 * Determine if a filename is a TDF.html file, i.e. a PFP file
 *
 * @param {String} filename - the filename of a Virtru attachment
 */
function isPfpFile(filename) {
  const lowerCaseFileName = filename.toLowerCase();
  return filename.indexOf('tdf') >= 0 && (lowerCaseFileName.endsWith('.htm') || lowerCaseFileName.endsWith('.html'));
}

/**
 * Determine if a file is a tdf3 html file
 *
 * @param {String} filename - the filename of a Virtru attachment
 */
function isTdf3Html(filename, html) {
  const $ = __webpack_require__(91089);
  const lowerCaseFileName = filename.toLowerCase();
  const isHtml = /\.html?$/.test(lowerCaseFileName);
  if (!isHtml) {
    return false;
  }
  const iframeSrc = $('<div></div>').append(html).find('iframe').attr('src') || '';
  return iframeSrc.includes('virtru.com/start?htmlProtocol=1');
}
const isUid = str => /[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}/.test(str);

/**
 * Determine if a filename is a TDF.html file, i.e. a PFP file
 *
 * [IMPORTANT]
 * The only safe way to check if file is PFP is `previewLink` extraction
 * Use this check only if its not possible: e.g. before the file is uploaded
 *
 * This check may return incorrect `true` result for file names like XXX.tdfXXX.html
 *
 * We don't check if it ends with `.tdf.hmtl` because file copy may look like `.tdf (1).hmtl`
 * We don't use regular expression because we don't know all the possible cases of how do
 * the copies' names look like: it depends on OS, number of times file has been copied, etc.
 *
 * @param {String} fileName - the filename of a Virtru attachment
 * @return {Boolean} - whether the file is PFP file
 */
function hasPfpFileExtensions(fileName) {
  if (typeof fileName === 'string') {
    const lowerCaseFileName = fileName.toLowerCase();
    const filenameParts = lowerCaseFileName.split('.');
    if (filenameParts.length > 2 && filenameParts[0]) {
      const extension = filenameParts[filenameParts.length - 1];
      const subExtension = filenameParts[filenameParts.length - 2];
      return (extension === 'htm' || extension === 'html') && subExtension.startsWith('tdf');
    }
  }
  return false;
}

/**
 * Simply checks a filename to determine whether it's a PDF media type.
 *
 * @param {String} filename - the filename of an attachment
 * @return {Boolean} - whether the file is supported
 */
function supportsLegacyWatermarking(filename) {
  return filenameIsSupportedType(filename, ['pdf']);
}

/**
 * Simply checks a filename to determine whether it's a PFP-supported media type.
 *
 * @param {String} filename - the filename of an attachment
 * @return {Boolean} - whether the file is supported
 */
function supportsExpandedWatermarking(filename) {
  return filenameIsSupportedType(filename, ['pdf', 'docx', 'xlsx', 'pptx', 'jpg', 'jpeg', 'png']);
}

/**
 * Checks a filename to determine whether it has an extension in the provided list.
 *
 * @param {String} filename - the filename of an attachment
 * @param {Array[String]} supportedFileTypes - array of extensions to check
 * @return {Boolean} - whether the file is supported
 */
function filenameIsSupportedType(filename, supportedFileTypes) {
  return supportedFileTypes.indexOf(getFileExtension(filename)) >= 0;
}

/**
 * Function for get file extension from its name
 * @param fileName - name ex. file.ext
 * @return {String} file extension
 */
function getFileExtension(fileName) {
  if (typeof fileName === 'string') {
    const filenameParts = fileName.toLowerCase().split('.');
    if (filenameParts.length > 1 && filenameParts[0]) {
      return filenameParts.pop();
    }
  }
  return false;
}
function getAttachmentData(_attachment) {
  var attachment = {
    file: {
      type: 'regular',
      name: _attachment.name,
      binary: _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_1__.Binary.fromString('')
    }
  };

  // no need to fetch inline image content
  if (_attachment.url && !_attachment.inlineImageUuid) {
    if (_attachment.binary) {
      return Promise.resolve({
        file: {
          ..._attachment
        }
      });
    }
    return superagent__WEBPACK_IMPORTED_MODULE_2___default().get(_attachment.url).responseType('arraybuffer').retry(25).then(resp => {
      attachment.file.type = 'broken';
      if (resp.status === 404) {
        console.error('File not found:', attachment);
        return resolve(attachment); // eslint-disable-line
      }
      if (resp.status < 200 || resp.status > 299) {
        console.error('Request failed:', attachment);
        return resolve(attachment); // eslint-disable-line
      }
      var binary = _virtru_private_binaryjs__WEBPACK_IMPORTED_MODULE_1__.Binary.fromArrayBuffer(resp.body);
      attachment.file.binary = binary;
      attachment.file.type = resp.type;
      return attachment;
    });
  }
  return attachment;
}

/**
 * Allows the popup & background to communicate to the content script.
 *
 * This is a similar idea to the transports object available on the sdk.
 * However, the sdk is not yet available to the popup. It may not ever be
 * available.
 *
 * @param {String} command The name of the command to call on the content
 *                         script
 * @param {Object} params The parameters to the command
 * @returns {Any} Response from the content script
 *
 * @deferred
 */
const callContentScript = function (command, params) {
  return new Promise((resolve, reject) => {
    const envelope = {
      uniqueExtensionKey: _lib_email_lib_constants__WEBPACK_IMPORTED_MODULE_3__.EXTENSION_KEY,
      type: 'command',
      action: command,
      target: 'content',
      data: params
    };
    chrome.tabs.query({
      currentWindow: true,
      active: true
    }, function (tabs) {
      if (tabs.length > 0) {
        const tab = tabs[0];
        chrome.tabs.sendMessage(tab.id, envelope, function (response) {
          if (typeof response === 'undefined') {
            reject(new Error('No response'));
          } else if (response.error) {
            reject(response.error);
          } else {
            resolve(response.data);
          }
        });
      } else {
        reject(new Error('No active tabs found'));
      }
    });
  });
};
const getFileType = function (name) {
  // Determine the file extension in order to lookup the mime type
  const displayNameParts = typeof name === 'string' ? name.split('.') : [];
  const fileExtension = displayNameParts.length > 1 ? displayNameParts.pop() : '';
  return mime__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A.getType(fileExtension) || 'application/octet-stream';
};


/***/ }),

/***/ 47446:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var base = __webpack_require__(7709);
var common = __webpack_require__(95961);
Object.assign(module.exports, base);
Object.assign(module.exports, common);

/***/ }),

/***/ 47790:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 48864:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sendAnimation: () => (/* binding */ sendAnimation)
/* harmony export */ });
const sendAnimation = () => `<table class="virtru-send-animation-widget">
    <tr>
      <td></td>
    </tr>
  </table>`;

/***/ }),

/***/ 49706:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ACTIVATION_BUTTON_ACTIVATE":"{{currentUser}} ","ACTIVATION_BUTTON_REACTIVATE":"{{currentUser}} ","ACTIVATION_FAILED":"","ACTIVATION_FAILED_GENERAL_BODY":"Virtru ","ACTIVATION_HEADER_USER_NOT_ACTIVATED":"{{currentUser}}  Virtru ","ACTIVATION_LINK":"","ACTIVATION_MESSAGE_DELEGATION_LINK":"","ACTIVATION_SUBTEXT":" 1 ","ACTIVATION_TEXT_ACTIVATE":"Virtru <br>","ACTIVATION_TEXT_REACTIVATE":"Virtru ","ACTIVATION_WAIT_CANCELED":"Virtru  <br/><br/> [] ","ACTIVATION_WAIT_ERROR":"Virtru - ","ACTIVATION_WAIT_FAILED":" Cookie   Virtru Virtru  </br><br/> Cookie  Cookie  Cookie  [] Cookie  Virtru </br><br/>Virtru   [ ] Virtru  <a href=\\"https://www.virtru.com/terms-of-service\\" target=\\"_blank\\"><a/><a href=\\"https://www.virtru.com/privacy-policy\\" target=\\"_blank\\"> </a>[] ","ACTIVATION_WAIT_HEADER":"Virtru - ...","ACTIVATION_WAIT_IN_PRIVATE":" Virtru    [incognito]  [InPrivate]  Cookie  </br><br/>  </br><br/>  Virtru ","ACTIVATION_WAIT_MESSAGE":"Virtru  ","ANIMATION_WIDGET_LOADING_TEXT":"...","ATTACHMENTS_UPLOADING_NO_SEND":"","ATTACHMENT_APPID_ERROR_HEADER":"","ATTACHMENT_APPID_ERROR_TEXT":"","ATTACHMENT_CONNECTION_ERROR_HEADER":"","ATTACHMENT_CONNECTION_ERROR_TEXT":"","ATTACHMENT_CONTENT":"","ATTACHMENT_ERROR_CORRUPT":"","ATTACHMENT_ERROR_UNAUTHORIZED":"","ATTACHMENT_ERROR_UNKNOWN":"Virtru ","ATTACHMENT_GENERIC_ERROR_BUTTON":"","ATTACHMENT_GENERIC_ERROR_HEADER":" ","ATTACHMENT_GENERIC_ERROR_TEXT":"","ATTACHMENT_INTEGRITY_COMPROMISED":"Virtru ","ATTACHMENT_ERROR_CLOSE_BUTTON":"","ATTACHMENT_NOT_READY_ERROR":"","ATTACHMENT_OPTIONS":"","ATTACHMENT_PFP_ERROR_HEADER":" ","ATTACHMENT_REVOKED_HEADER":"","ATTACHMENT_REVOKED_TEXT":"","ATTACHMENT_TOO_LARGE_HEADER":"","ATTACHMENT_TOO_LARGE_TEXT":" {{maxSizeMb}} MB ","ATTACHMENT_TOO_LARGE_SUGGEST_SECURE_SHARE_TEXT":"1  {{maxSizeMb}} MB  Virtru Secure Share  {{secureShareMaxSize}} GB ","CANNOT_DECRYPT_GET_HELP":"Virtru ","CANNOT_DECRYPT_HEADER":"","CANNOT_DECRYPT_MESSAGE_CKS":"{{ownerName}} <br/><a href=\\"{{ownerSupportUrl}}\\"><br/>{{ownerName}}  </a>","CANNOT_DECRYPT_MESSAGE_CKS_TROUBLE_READING_EMAIL":"","CANNOT_DECRYPT_MESSAGE_INTEGRITY_COMPROMISED":"Virtru <span class=\\"vic-message-bold\\">{{sender}}</span> ","CHROME_POPUP_ABOUT_VIRTRU_BUTTON":"Virtru ","CHROME_POPUP_ACTIVATION_BUTTON":"{{userId}}  Virtru ","CHROME_POPUP_ACTIVATION_LABEL":"Virtru ","CHROME_POPUP_SIGN_OUT_BUTTON":"","CHROME_POPUP_VIRTRU_DASHBOARD_BUTTON":"Virtru ","CHROME_POPUP_SUPPORT_BUTTON":"","CHROME_POPUP_UNINSTALL_BUTTON":"","CHROME_POPUP_DRIVE_CROSS_SELL":"Virtru for Drive ","CHROME_POPUP_SECURE_SHARE_CROSS_SELL":"Virtru Secure Share for Drive ","COMMON_CANCEL":"","COMMON_OK":"OK","COMMON_REFRESH":"","COMMON_SEND":"","COMMON_SEND_SECURE":"","COMMON_TRY_AGAIN":"","COMPOSE_ACTIVATION_REQUIRED":"Virtru ","COMPOSE_ATTACHMENTS_UPLOADING_WARN":"  ","COMPOSE_DRIVE_ATTACHMENTS_UNSUPPORTED":"Virtru ?","COMPOSE_EXPIRES":"{{timeRemaining}} ","COMPOSE_INSERT_DRIVE_INSERT_FILE":"  Google ","COMPOSE_INSERT_PHOTOS_INLINE_IMAGES":"Virtru ","COMPOSE_OFF_CONFIRM_REMOVE":" ?","CONTENT_IS_MANAGED":"","CONTEXTUAL_ACTIVATE_INFO":" {{currentUser}}  Virtru Virtru Virtru ","DISMISS_POPOVER_DEFAULT_OPTIONS_TEXT":"","DOWNLOAD_ATTACHMENT_DECRYPTING":"","EMAIL_BODY_CONTENT":"","EMAIL_ERROR_EMAIL_CORRUPT":"","EMAIL_ERROR_EMAIL_CORRUPT_HEADER":"","EMAIL_ERROR_INTERNAL_SERVER_ERROR":"Virtru ","EMAIL_ERROR_INTERNAL_SERVER_ERROR_HEADER":" ","EMAIL_ERROR_NETWORK_LOST":"Virtru ","EMAIL_ERROR_NETWORK_LOST_HEADER":"","EMAIL_ERROR_READ":"","EMAIL_ERROR_SEND":"","EMAIL_ERROR_SMART_SEND_SECURE":"Virtru ","EMAIL_ERROR_SMART_SEND_SECURE_HEADER":"","EMAIL_ERROR_TEMPLATE_SUPPORT_LINK":"Virtru ","EMAIL_ERROR_UNKNOWN":"","EMAIL_ERROR_UNKNOWN_HEADER":"","EMAIL_ERROR_YOURE_ON_STAGING":"... (/)  ...","EMAIL_ERROR_YOURE_ON_STAGING_HEADER":"... ","EMAIL_ERROR_SEND_REACTIVATION":"","EMAIL_ERROR_SEND_REACTIVATION_HEADER":"","EMAIL_ERROR_SEND_REACTIVATION_RETRY_BUTTON":"","EMAIL_ERROR_READ_SECURE_READER_LABEL":"Virtru  Secure Reader ","EMAIL_EXPIRATION":"","EMAIL_INVALID_ADDRESS":"{{invalidAddress}}","EMAIL_INVALID_ADDRESS_GENERIC":"1  ","EMAIL_TEMPLATE_FOOTER":"Virtru ","EMAIL_TEMPLATE_SENDER_HEADER":" Virtru ","ENCRYPTED_SEARCH_REMINDER_HEADER":"","ENCRYPTED_SEARCH_REMINDER_SUBTEXT":"Virtru ","ENHANCEDPDF_DL_DISABLED_TOOLTIP":"Virtru  ","ENHANCEDPDF_DL_DISABLED_TOOLTIP_TITLE":" PDF ","EXPANDED_WATERMARKING_DL_DISABLED_TOOLTIP_TITLE":"","FAQ":"FAQ","FEATURE_CHIP_TEXT":"","FEATURE_ENCRYPTED_SEARCH_FAQ":"","FEATURE_ENCRYPTED_SEARCH_POPUP_DESCRIPTION":"Virtru  Virtru  [] ","FEATURE_ENCRYPTED_SEARCH_BUTTON":"","FEATURE_ENCRYPTED_SEARCH_CANCEL":"","FEATURE_ENCRYPTED_SEARCH_DESCRIPTION":[""," FAQ "],"FEATURE_ENCRYPTED_SEARCH_TITLE_TEXT":"","FEATURE_ENCRYPTED_SEARCH_SUB_TITLE_TEXT":"Virtru ","FEATURE_VAULT_BUTTON":"","FEATURE_VAULT_CANCEL":"","FEATURE_VAULT_DESCRIPTION":["","Virtru",""," Google ","Virtru "],"FEATURE_VAULT_TITLE_TEXT":"Google Vault  Virtru ","FEATURE_VAULT_SUB_TITLE_TEXT":"Google Vault  Virtru ","FILE_SIZES":{"BYTES":"b","UNITS":["Kb","Mb","Gb","Tb","Pb","Eb","Zb","Yb"]},"DELIMITERS":{"DECIMAL":"."},"FIRST_TIME_ONBOARD_LINK_ACTIVATE":"","FOOTER_POPOVER_BODY":"Virtru ","FOOTER_POPOVER_HEADER":"","FOOTER_POPOVER_REMOVE_SIGNATURE":"  ","FOOTER_PROMO":"?","FOOTER_PROMO_USE":"Virtru","FORWARDING_RESTRICTED":"- ","GMAIL_BASIC_MODE_UNSUPPORTED_MAIN":"Gmail  HTML ","GMAIL_BASIC_MODE_UNSUPPORTED_SUB":"Virtru ","GO_TO_SECURE_SHARE":"Secure Share","INTRO_MESSAGE_FOOTER_TEXT":"","INVITATION_EMAIL_REPLACE_TEXT_DEFAULT":"Virtru  ","LEARN_MORE":"","LIMITED_ENCRYPTION_BUTTON_CANCEL":"","LIMITED_ENCRYPTION_BUTTON_OK":"","LIMITED_ENCRYPTION_CHECKBOX":"","LIMITED_ENCRYPTION_HEADER":"","LIMITED_ENCRYPTION_TEXT":":","MESSAGE_OPTIONS":" ","MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE":{"lastDay":"[] LT","lastWeek":"[] dddd LT","nextDay":"[] LT","nextWeek":"ddddLT","sameDay":"[] LT","sameElse":"YYYY  MMM (dddd)LT"},"MOMENT_CALENDAR_RECIPIENT_EXPIRATION":{"lastDay":"[] LT","lastWeek":"[] ddddLT","nextDay":"[] LT","nextWeek":"[] ddddLT","sameDay":"[] LT","sameElse":"YYYY  MMM  dddd[,]LT"},"MOMENT_CALENDAR_SENDER_EXPIRED":{"lastDay":"[] LT","lastWeek":"[] dddd LT","nextDay":"[] LT","nextWeek":"[] dddd LT","sameDay":"[] LT","sameElse":"YYYY  MMM (dddd)LT"},"MOMENT_CALENDAR_SENDER_EXPIRING_SOON":{"lastDay":"[] LT","lastWeek":"[] ddddLT","nextDay":"[] LT","nextWeek":"[] ddddLT","sameDay":"[] LT","sameElse":"YYYY  MMM (dddd)LT"},"NESTED_MESSAGE_PLACEHOLDER_TEXT_DEFAULT":"","NESTED_MESSAGE_PLACEHOLDER_TEXT_LOADING":"...","NEW_COMPOSE_ARCHIVE_SEND":" +","NEW_COMPOSE_ARCHIVE_SEND_SECURE":" +","NEW_COMPOSE_DISABLED_WHILE_SECURING":" () ","NEW_MESSAGE_NOT_SECURE":"","NEW_FEATURE_POPOVER_PP_BODY":"Virtru <br><br><a href=\'https://support.virtru.com/hc/en-us/articles/360022693153\'></a>","NEW_FEATURE_POPOVER_PP_BUTTON":"","NEW_FEATURE_POPOVER_PP_LABEL":"","NEW_MESSAGE_SECURE":"","OKGOTIT":"","ONBOARDING_POPOVER_1_CONFIRM":"","ONBOARDING_POPOVER_1_ENTERPRISE_BODY":" Virtru ","ONBOARDING_POPOVER_1_HEADER":"Virtru ","ONBOARDING_POPOVER_1_INDIVIDUAL_BODY":"Virtru ","ONBOARDING_POPOVER_2_BODY":"{{currentUser}} Virtru ","ONBOARDING_POPOVER_2_CONFIRM":"","ONBOARDING_POPOVER_2_HEADER":"","ONBOARDING_POPOVER_2_SKIP_CHECKBOX_LABEL":"","ONBOARDING_POPOVER_3_BODY":"Gmail <a href=\'https://secure.virtru.com/control-center\'>Virtru </a>","ONBOARDING_POPOVER_3_CONFIRM":"","ONBOARDING_POPOVER_3_HEADER":"","ONBOARDING_RESTART_4_BODY":"Virtru Virtru <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>","ONBOARDING_RESTART_CONFIRM":"","ONBOARDING_SEND_VERIFICATION":" ","ONBOARDING_TOUR_1_BODY":"<span class=\\"bold\\"></span>","ONBOARDING_TOUR_1_HEADER":"","ONBOARDING_TOUR_2_BODY":" Virtru ","ONBOARDING_TOUR_2_HEADER":"Virtru ","ONBOARDING_TOUR_3_BODY":"","ONBOARDING_TOUR_3_HEADER":"","ONBOARDING_TOUR_4_BODY":"<span class=\\"bold\\"></span>","ONBOARDING_TOUR_4_HEADER":"","ONBOARDING_TOUR_CONFIRM":"OK","ONE_CLICK_OPTION":"","PAGE_ACTIONS_FORMAT_NON_PROD_MESSAGE":"{{acmUrl}}","PERSONAL_INTRO_ADD":"","PERSONAL_INTRO_ONBOARD":"","PERSONAL_INTRO_PLACEHOLDER_TEXT":"[]","PLAINTEXT_NOT_SUPPORTED_HEADER":" ","PLAINTEXT_NOT_SUPPORTED_TEXT":" ","PLAINTEXT_NOT_SUPPORTED_TITLE":"","POLICY_MENU_DISABLE_FORWARDING":"","POLICY_MENU_EXPANDED_WATERMARKING":"","POLICY_MENU_PERSISTENT_PROTECTION":"","POLICY_MENU_WATERMARKING":"PDF ","POLICY_MENU_SUPPORTED_FILES_INFO_TITLE":"","PROTECTION_REQUIRED":"","PROTECT_AND_SEND":"","READ_RECEIPT_FORWARD_COUNT_DETAILS":"()","RECIPIENT":"","RECIPIENT_WIDGET_EXPIRATION_DATE":"{{datetime}} ","RECIPIENT_WIDGET_EXPIRED":"","RECIPIENT_WIDGET_EXPIRED_BODY":"","RECIPIENT_WIDGET_EXPIRED_DATE":" {{datetime}} ","RECIPIENT_WIDGET_HEADER":"Virtru ","RECIPIENT_WIDGET_NO_EXPIRATION":"","RECIPIENT_WIDGET_OFFLINE_BODY":"","RECIPIENT_WIDGET_OFFLINE_HEADER":"","RECIPIENT_WIDGET_REVOKED_BODY":"","RECIPIENT_WIDGET_REVOKED_HEADER":"","RECIPIENT_WIDGET_UNAUTHORIZED_BODY":" ","RECIPIENT_WIDGET_UNAUTHORIZED_HEADER":" ","RESTORE_DRAFT_FAILED":"","SCREENREADER_CLOSED_POLICY_MENU":" ","SCREENREADER_DISABLED_EXPIRATION":"","SCREENREADER_DISABLED_FORWARDING":"","SCREENREADER_DISABLED_ONECLICK":"","SCREENREADER_DISABLED_WATERMARK":"","SCREENREADER_DISABLED_WATERMARK_PDF":"PDF ","SCREENREADER_DISABLED_PFP":"","SCREENREADER_DISABLE_FORWARDING":"","SCREENREADER_ENABLED_EXPIRATION":"","SCREENREADER_ENABLED_FORWARDING":"","SCREENREADER_ENABLED_ONECLICK":"","SCREENREADER_ENABLED_WATERMARK":"","SCREENREADER_ENABLED_WATERMARK_PDF":"PDF ","SCREENREADER_ENABLED_PFP":"","SCREENREADER_EXPIRATION":"","SCREENREADER_ONECLICK":"","SCREENREADER_OPENED_POLICY_MENU":"","SCREENREADER_VIRTRU_POLICY_MENU":"Virtru  ","SCREENREADER_VIRTRU_SECURE_TOGGLE":"Virtru ","SCREENREADER_WATERMARK_PDF":"PDF ","SCREENREADER_WATERMARK":"","SCREENREADER_PFP":"","SECURE_EMAIL_COMPOSER_PLACEHOLDER_HTML":"  Virtru ","SECURE_EMAIL_COMPOSER_POLICY_OPTIONS_DEFAULT":"()","SECURE_MESSAGE_CONTROL_ENABLE":"","SECURE_MESSAGE_CONTROL_REVOKE":"","SECURE_MESSAGE_LABEL":"","SECURE_MESSAGE_SENT_NOTIFICATION":"","SECURED_ATTACHMENTS_HEADER":": {{count}}","SECURED_ATTACHMENTS_HEADER_plural":": {{count}}","SENDER_WIDGET_ERROR_ENABLE_MESSAGE":"","SENDER_WIDGET_ERROR_REVOCATION":"","SENDER_WIDGET_ERROR_UPDATE_POLICY":"","SENDER_WIDGET_EXPIRED_DATE":"{{datetime}} ","SENDER_WIDGET_EXPIRES_DATE":"{{datetime}} ","SENDER_WIDGET_MESSAGE_REVOKED":"","SENDER_WIDGET_NO_EXPIRATION":"","SENDER_WIDGET_REVOKED_DATE":"{{datetime}} ","SEND_ANIMATION_LOADING_TEXT":"...","SEND_ANYWAY":"","SCHEDULE_SEND":"","GO_BACK":"","SEND_BLOCK_HEADER":"","SEND_BLOCK_SUBTEXT":"  Virtru Protection ","SEND_WARNING_BUTTON_SEND":"","SEND_WARNING_BUTTON_SEND_SECURE":"","SEND_WARNING_BUTTON_SEND_SECURE_IMMEDIATELY":"","SEND_WARNING_WARNING_SEND_SCHEDULED_LABEL":" Virtru ","SEND_WARNING_SCHEDULE_SEND_NOT_SUPPORTED":" Virtru ","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE":"","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE_TOOLTIP":" Virtru ","SENSITIVE_DATA_FOUND":"","WARN_SENSITIVE_DATA_FOUND_BODY":" Virtru ","WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE":"Virtru  Gmail {{button}}","SENSITIVE_DATA_FOUND_BODY":" Virtru ","WARN_ATTACHMENTS_LIMIT_REACHED":"","ATTACHMENTS_LIMIT_REACHED_BODY":" [ATTACHMENTS_COUNT]  Virtru  [ATTACHMENTS_LIMIT]  [ATTACHMENTS_REMOVE_COUNT] ","TOOLTIP_DISABLE_FORWARDING":"","TOOLTIP_EXPIRATION":"","TOOLTIP_FORWARDING_RESTRICTED":"","TOOLTIP_FORWARDING_RESTRICTED_CONTENT":"","TOOLTIP_ONE_CLICK":"","TOOLTIP_REAUTHORIZE_BUTTON_CONTENT":"","TOOLTIP_REAUTHORIZE_BUTTON_TITLE":"","TOOLTIP_RECIPIENT_DISABLE_COPY_PASTE":" Virtru /","TOOLTIP_RECIPIENT_DISABLE_FORWARDING":" Virtru ","TOOLTIP_RECIPIENT_DISABLE_PRINT":" Virtru ","TOOLTIP_RECIPIENT_EXPIRATION":" Virtru  {{date}} ","TOOLTIP_RECIPIENT_ONE_CLICK":" Virtru ","TOOLTIP_RECIPIENT_UNAUTHORIZED_INFO":"<br><br>","TOOLTIP_REVOKE_BUTTON_CONTENT":"","TOOLTIP_REVOKE_BUTTON_TITLE":"","TOOLTIP_SECURE_ATTACHMENT_CONTENT":"{{filename}}  Virtru ","TOOLTIP_SECURE_ATTACHMENT_DOWNLOAD":"","TOOLTIP_SECURE_ATTACHMENT_DRIVE":"Google  Virtru ","TOOLTIP_SECURE_ATTACHMENT_TITLE":"Virtru ","TOOLTIP_SENDER_DISABLE_FORWARDING_CONTENT":"","TOOLTIP_SENDER_ENABLE_SMS2FA":" SMS ","TOOLTIP_SENDER_EXPIRATION_CONTENT":"{{date}} ","TOOLTIP_SENDER_ONE_CLICK_CONTENT":"","TOOLTIP_TOGGLE_DISABLED":"","TOOLTIP_SENDER_WATERMARK":"","TOOLTIP_SENDER_WATERMARK_CONTENT":" ","TOOLTIP_SENDER_PFP":"","TOOLTIP_SENDER_PFP_CONTENT":"","TOOLTIP_TOGGLE_OFF":"Virtru ","TOOLTIP_UPSELL_POSTFIX":"<br/><br/>Pro  Virtru ","TOOLTIP_VIRTRU_OPTIONS":"","UNSECURE_ATTACHMENTS_EXIST_HEADER":"","UNSECURE_ATTACHMENTS_EXIST_TEXT":"","UNSECURE_ATTACHMENTS_EXIST_TITLE":"","UPDATE_MODAL_HEADER":"Virtru ","UPDATE_MODAL_REFRESH_BUTTON":"","UPDATE_MODAL_SUBHEADER":"<br>","VIRTRU_ATTACHMENT_DECRYPTING":"","VIRTRU_ATTACHMENT_DOWNLOAD":"","VIRTRU_ATTACHMENT_VIEW":"","VIRTRU_ATTACHMENT_REMOVE":"","VIRTRU_AUTH_LINK":"Virtru ","VIRTRU_AUTH_LINK_REACTIVATE":"Virtru ","VIRTRU_CONTACT_US":"IT ","VIRTRU_DISABLED_ON_DOMAIN":" Virtru ","VIRTRU_PROTECTION_NOT_AUTH":" Virtru ","VIRTRU_PROTECTION_NOT_AUTH_SHORT":"Virtru ","VIRTRU_PROTECTION_OFF":"Virtru ","VIRTRU_PROTECTION_ON":"Virtru ","VIRTRU_SECURE_DRAFT_PREFIX":" Virtru ","WEBMAIL_PLUGIN_ACTIVATION_LINK_RETRY":"","WEBMAIL_PLUGIN_ACTIVATION_TEXT":"<br>","WEBMAIL_PLUGIN_INIT_ERROR":"Virtru <a href=\\"https://www.virtru.com/contact-us/\\">https://www.virtru.com/contact-us/</a>  Virtru  ","WEBMAIL_PLUGIN_INIT_ERROR_HEADER":"Virtru ","WIDGET_BASE_BODY_REVOKED":"","WIDGET_BASE_EXPIRATION_OPTIONS_CUSTOM":"","WIDGET_BASE_FOOTER":"Virtru ","WIDGET_BASE_HEADER_MESSAGE_RECIPIENT":"Virtru ","WIDGET_BASE_HEADER_MESSAGE_SENDER":" Virtru ","WIDGET_BASE_MENU_OPTION_EXPIRES":"","WIDGET_BASE_MENU_OPTION_FORWARDING":"","EXPIRATION_UNIT_DAYS":"","EXPIRATION_UNIT_DAYS_plural":"","EXPIRATION_UNIT_HOURS":"","EXPIRATION_UNIT_HOURS_plural":"","EXPIRATION_UNIT_MINS":"","EXPIRATION_UNIT_MINS_plural":"","EXPIRATION_UNIT_MONTHS":"","EXPIRATION_UNIT_MONTHS_plural":"","EXPIRATION_UNIT_WEEKS":"","EXPIRATION_UNIT_WEEKS_plural":"","EXPIRATION_UNIT_YEARS":"","EXPIRATION_UNIT_YEARS_plural":"","READ_RECEIPT_FORWARD_COUNT":"<div style=\\"text-align:center;\\">{{count}}<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","READ_RECEIPT_FORWARD_COUNT_plural":"<div style=\\"text-align:center;\\">{{count}}<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","ATTACHMENTS_TOOLTIP_CONTENT":{"RECIPIENT":{"SUPPORTED_FILE":{"NONE_SECURE":"","EXPANDED_WATERMARKING":"Virtru  ","IS_MANAGED":"Virtru  ","EXPANDED_IS_MANAGED":"","PERSISTENT_PROTECTION":"","EXPANDED_PROTECTION":""},"UNSUPPORTED_FILE":{"NONE_SECURE":"","EXPANDED_WATERMARKING":"","IS_MANAGED":"","EXPANDED_IS_MANAGED":"","PERSISTENT_PROTECTION":"","EXPANDED_PROTECTION":""},"STEPCHILD":""},"SENDER":{"SUPPORTED_FILE":{"NONE_SECURE":"","EXPANDED_WATERMARKING":"<p></p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span></p>","IS_MANAGED":"<p></p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>PDF </p>","EXPANDED_IS_MANAGED":"<p></p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>PDF </p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span></p>","PERSISTENT_PROTECTION":"<p></p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span></p>","EXPANDED_PROTECTION":"<p></p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span></p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span></p>"},"UNSUPPORTED_FILE":{"NONE_SECURE":"","EXPANDED_WATERMARKING":"","IS_MANAGED":"","EXPANDED_IS_MANAGED":"","PERSISTENT_PROTECTION":"","EXPANDED_PROTECTION":""},"STEPCHILD":""}},"ATTACHMENT_SECTION_TOOLTIP_TITLE":"","ATTACHMENT_SECTION_TOOLTIP_CONTENT":" Virtru ","ERROR_REFRESH_TOAST_MESSAGE":"Virtru ","CKS_INDICATOR_TITLE":"","CKS_INDICATOR_BODY":"Virtru ","CKS_INDICATOR_LINK":"","MAIL_MERGE_CONFLICT_MODAL_TITLE":"","MAIL_MERGE_CONFLICT_MODAL_BODY":"VirtruGmail","MAIL_MERGE_CONFLICT_TOOLTIP":"Virtru"}');

/***/ }),

/***/ 50154:
/***/ ((module, exports, __webpack_require__) => {

var moment = __webpack_require__(13985);
var i18n = __webpack_require__(32841);

// Add fake locale for date&time testing purposes
moment.defineLocale('dev', {
  parentLocale: 'fr'
});
moment.locale(i18n.language);
i18n.on('languageChanged', lang => moment.locale(lang));
module.exports = exports = moment;

/***/ }),

/***/ 50310:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 50344:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var request = __webpack_require__(75522);

// Provide setXHRAdapter as a method on request
request.setXHRAdapter = function (xhrAdapter) {
  request.getXHR = xhrAdapter;
};

// Pass the custom superagent as the request
module.exports = request;

/***/ }),

/***/ 51041:
/***/ ((module) => {

module.exports = function attachmentsReducer(originalState = {}, action) {
  const {
    id
  } = action;
  const state = {
    ...originalState
  };
  switch (action.type) {
    case 'REMOVE_ATTACHMENT':
      delete state[id];
      return state;
    case 'ADD_ATTACHMENT_DATA':
      state[id] = {
        ...action.data
      };
      return state;
    case 'REMOVE_ATTACHMENT_DATA':
      delete state[id];
      return state;
    case 'SECURE_ATTACHMENT_DETECTED':
    case 'ADD_SECURE_ATTACHMENT':
      return {
        ...state,
        [id]: action.contract
      };
    case 'UPDATE_ATTACHMENT_SECURITY_OPTION':
      if (state[id] && state[id].authorizations) {
        if (action.data.value) {
          if (!state[id].authorizations.includes(action.data.securityOption)) {
            state[id].authorizations.push(action.data.securityOption);
          }
        } else if (state[id].authorizations.includes(action.data.securityOption)) {
          state[id].authorizations.splice(state[id].authorizations.indexOf(action.data.securityOption), 1);
        }
      }
      return state;
    case 'UPDATE_ATTACHMENT_IS_MANAGED_OPTION':
      if (state[id]) {
        return state;
      }
      return {
        ...state,
        [id]: {
          ...state[id],
          isManaged: action.data
        }
      };
    default:
      return originalState;
  }
};

/***/ }),

/***/ 51069:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 51671:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ErrorRefreshPageToast),
/* harmony export */   renderErrorRefreshPageToast: () => (/* binding */ renderErrorRefreshPageToast),
/* harmony export */   toastDuration: () => (/* binding */ toastDuration)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87568);
/* harmony import */ var _virtru_private_design_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(80001);
/* harmony import */ var _virtru_private_design_system__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10855);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _createReactRoot__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(72213);




const toastDuration = 20000; // 20 seconds

function ErrorRefreshPageToast({
  handleClose
}) {
  const refreshText = _lib_i18n__WEBPACK_IMPORTED_MODULE_1___default().t('COMMON_REFRESH');
  const [textStart, textEnd] = _lib_i18n__WEBPACK_IMPORTED_MODULE_1___default().t('ERROR_REFRESH_TOAST_MESSAGE').split(refreshText);
  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
    const timer = setTimeout(() => {
      handleClose();
    }, toastDuration);
    return () => clearTimeout(timer);
  }, []);
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_virtru_private_design_system__WEBPACK_IMPORTED_MODULE_3__/* ["default"] */ .A, {
    icon: false,
    variant: "filled",
    severity: "error",
    className: "error-refresh-page-toast"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("span", {
    className: "error-refresh-page-toast-text"
  }, textStart, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(_virtru_private_design_system__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A, {
    className: "error-refresh-toast-link",
    onClick: () => window.location.reload()
  }, refreshText), textEnd));
}
const ROOT_ID = 'virtru-error-refresh-toast-root';
function renderErrorRefreshPageToast() {
  const root = (0,_createReactRoot__WEBPACK_IMPORTED_MODULE_2__/* ["default"] */ .A)({
    rootId: ROOT_ID
  });
  const handleClose = () => root.render(null);
  root.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(ErrorRefreshPageToast, {
    handleClose: handleClose
  }));
}

/***/ }),

/***/ 51694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
/* istanbul ignore file */
// TODO: decompose for unit testing
const $ = __webpack_require__(55401);
const Emitter = __webpack_require__(16502);
const {
  RulesEngine
} = __webpack_require__(57009);
const {
  DlpRulesModel
} = __webpack_require__(42769);
const i18n = __webpack_require__(2622);
const moment = __webpack_require__(13985);
const blobUtils = __webpack_require__(25235);
const {
  Queue
} = __webpack_require__(2755);
const {
  ACTION_CONSTANTS,
  ACTIONS_ORDER
} = __webpack_require__(40503);
const {
  getAttachmentData
} = __webpack_require__(55675);
const {
  showAttachmentsLimitModal,
  showMailMergeModal
} = __webpack_require__(52561);
const WarningPopoverModal = (__webpack_require__(12221)/* ["default"] */ .A);
const VirtruOfflineMode = (__webpack_require__(2883)/* ["default"] */ .A);
const sanitizeAnalyticsError = (__webpack_require__(81442)/* ["default"] */ .A);
const MAX_CONCURRENT_REQUEST = 5;
const MIN_GAP_BETWEEN_REQUEST = 100;
const attachmentFetchingRequestQueue = new Queue(MAX_CONCURRENT_REQUEST, MIN_GAP_BETWEEN_REQUEST);
const {
  ATTACHMENTS_LIMIT
} = __webpack_require__(76223);
const {
  _bindAllMethods
} = __webpack_require__(4424);
const {
  ATTACHMENT_LIMIT_ERROR
} = __webpack_require__(22592);
const AnalyticsService = (__webpack_require__(1246).instance)();
Emitter(SmartSendSecure.prototype);
const INCIDENT_WARN = 'warn';
const INCIDENT_ENCRYPT = 'encrypt';
const INCIDENT_BLOCK = 'block';
// initialized as constant because this text should not be internationalized (not implemented for DLP rules)
const INCIDENT_BLOCK_STRING_CLEANUP = 'Encrypt with Virtru to protect your content.';
function SmartSendSecure(context, transports) {
  // Import specific properties from context
  this._context = context;
  Object.assign(this, {
    _settings: context._settings,
    _editor: context._editor,
    _fadeAndScaleElementIn: context._fadeAndScaleElementIn,
    _sendButtonsMod: context._sendButtonsMod
  });
  this.initRules();
  this._transports = transports;
  this._sendActions = [];
  this.attachmentAcknowledgementSet = new Set();
  this._virtruOfflineMode = new VirtruOfflineMode(this._settings.user._profile);
  _bindAllMethods(this);
}
SmartSendSecure.prototype.initRules = function () {
  this._rules = this._settings.user.setting('dlp.rules');
  if (this._rules) {
    this._rules = this._rules.map(function (rule) {
      try {
        return DlpRulesModel.create(rule);
      } catch (err) {
        return console.log('There was an error creating a rules model');
      }
    });
    this._rulesEngine = new RulesEngine(this._rules);
  }
};

/**
 * Setup function - Starts keypress listener for instance
 */
SmartSendSecure.prototype.setup = function () {
  var trash = this._settings.dom.NEW_COMPOSE_TRASH;
  var titlebar = this._settings.dom.NEW_COMPOSE_TITLEBAR;
  var composeWindow = this._settings.dom.NEW_COMPOSE;
  composeWindow = this._context._element.closest(composeWindow);

  // Remove residual popovers if trash, minimize, etc are clicked.
  // Necessary because new-compose teardown is not fast enough.
  $([trash, titlebar].join(), composeWindow).on('mousedown', this.remove);

  // this._context._settings.user.on('profile-refreshed', function() { this.check.bind(this, false, true));
};
SmartSendSecure.prototype.notifyAboutAttachment = function (attachmentLink) {
  //eslint-disable-line

  if (this.attachmentAcknowledgementSet.has(attachmentLink)) {
    return;
  }
  this.attachmentAcknowledgementSet.add(attachmentLink);
};
SmartSendSecure.prototype.cacheAttachments = async function () {
  try {
    const attachments = await this.detectAttachments();
    attachments.forEach(attachment => {
      if (this._rulesEngine) {
        this._rulesEngine._attachmentsCacher.buildSingleAttachmentCache.call(this._rulesEngine._attachmentsCacher, attachment);
      }
    });
  } catch (e) {
    if (e !== ATTACHMENT_LIMIT_ERROR) {
      throw e;
    }
  }
};

// TODO: Make this NOT gmail specific
/**
 * Detects any attachments encrypted or not - ONLY GMAIL
 * @return {array} Array of the attachments data {name, type} - Type can be regular or encrypted
 */
SmartSendSecure.prototype.detectAttachments = async function () {
  const context = this._context;
  this.attachments = await context.awaitUnsecureAttachments();
  const isSecureSend = this._context.isSecureMode();
  if (!this.containsAttachmentRules()) {
    return Promise.resolve([]); // If the policy doesn't contain attachment rules, then we should just skip all this
  }

  // @NOTE: WS-4927 If you click send too soon getUnsecureAttachments throws an error
  // rather than trying to convert getUnsecureAttachments to use a promise I opted to isolate the fix to here,
  // as getUnsecureAttachments is used in two places with one of them already accounting for a thrown error
  // @NOTE: WS-5803 replaced the previous fix by creating a new function that does return a promise

  const securedAttacments = this._context.attachmentsHelper._tdfAttachmentMods.length;
  if (this.attachments.length > ATTACHMENTS_LIMIT && isSecureSend || securedAttacments > ATTACHMENTS_LIMIT) {
    showAttachmentsLimitModal(this.attachments.length + securedAttacments);
    return Promise.reject(ATTACHMENT_LIMIT_ERROR);
  }

  // unencrypted drive attachments
  // NOTE:  unsecure drive -> secure attachment workflow does not exist anywhere
  //        yet!!
  // attachments = attachments.concat(this._context.getDriveAttachments());

  // unsecure attachments GET
  // map promises to unencrypted drive and non-drive files

  const downloadAttachmentData = async () => {
    const requestQueue = [];
    for (const arg of this.attachments) {
      /**
       * The sixth call will wait for the previous five to complete
       * plus the time needed to make this at least 100ms
       * after the fifth call
       */
      requestQueue.push(attachmentFetchingRequestQueue.run(() => getAttachmentData(arg)));
    }
    return Promise.all(requestQueue);
  };
  const attachmentDataPromises = await downloadAttachmentData();

  // map of secured file related promises
  var promises2 = Object.values(this._context.attachmentsHelper._tdfAttachmentMods)
  // don't consider stepchild attachments
  .filter(_attachment => !_attachment.tdfData.previewLink).map(function (_attachment) {
    var {
      id
    } = _attachment.tdfData.tdo;
    return this._context._secureService.readFile(id).then(async function (_file) {
      const binary = await blobUtils.blobUriToBinary(_file.tdf.payload);
      const attachment = {
        file: {
          type: _file.tdf.tdo.payload.mediaType,
          name: _file.tdf.tdo.payload.filename.replace('.tdf', ''),
          binary
        }
      };
      // if (attachment.file.name.split('.').pop() === 'pdf') {
      //  attachment.file.type = 'application/pdf';
      // }
      return attachment;
    }.bind(this)); // eslint-disable-line
  }.bind(this));
  return Promise.all(attachmentDataPromises.concat(promises2)).catch(err => {
    console.error('awaitUnsecureAttachments failed:', err);
    return Promise.reject(err);
  });
};

/**
 * This detects whether or not there are rules in the policy that require our parsing of
 * attachments. We want to know this to save us from scanning attachments unnecessarily.
 * @return {boolean} True if we should parse attachments, false if not.
 */
SmartSendSecure.prototype.containsAttachmentRules = function () {
  var rules = this._rules || [];
  for (var i = 0, len = rules.length; i < len; ++i) {
    if (rules[i].hasAttachmentRule()) {
      return true;
    }
  }
  return false;
};

/**
 * Sort actions by descending to avoid triggering logOnly
 * before all triggered actions
 *
 * @readonly https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
 *
 * @param {Object} violation1 - action 1 to sort
 * @param {Object} violation2 - action 2 to sort
 * @return {number} number to compare in sorting
 */
function sortViolationsDescending(violation1, violation2) {
  const violation1Order = ACTIONS_ORDER.indexOf(violation1.key);
  const violation2Order = ACTIONS_ORDER.indexOf(violation2.key);
  return (violation1Order > violation2Order) - (violation2Order > violation1Order);
}

/**
 * Checks an email for violations
 * @param  {boolean}   onSend - If true, this check operation was triggered by a
 *                              user attempting to send
 * @param  {boolean}   blockSend -- I don't know (cbaron)
 * @param  {boolean}   isArchive -- If true, the user wants to archive the message after sending.
 * @param  {boolean}   isScheduledSend -- scheduled send selected
 * @return {violations}         Either a list of violations or false.
 */
SmartSendSecure.prototype.check = function (onSend, blockSend, isArchive, isScheduledSend) {
  var isActivated = this._context._settings.user.auth('status') === 'active';
  // make sure we have an updated copy of tha rules
  this.initRules();
  if (typeof this._rules === 'undefined' || !isActivated) {
    // bail because the user is not activated yet
    return Promise.resolve(false);
  }
  AnalyticsService.sssBegin({});
  var processingStarted = Date.now();
  var violations = false;
  if (!this._context._settings.user.permissions.canCreatePolicies) {
    return Promise.resolve(violations);
  }
  this.isSecureSend = this._context.isSecureMode();
  this._blockSend = blockSend || false;
  this._sendActions = [];
  var emailFields = this._context.emailUsers();
  var email = {
    body: this._editor.html(),
    subject: this._context.subject(),
    sender: {
      email: this._context._settings.currentUser(),
      memberships: this._context._settings.user.memberships()
    },
    to: emailFields.tos,
    cc: emailFields.ccs,
    bcc: emailFields.bccs,
    attachments: []
  };
  if (onSend) {
    this._context._sendButtonsMod.disableSendButton();
    if (this._context._sendArchiveButtonMod) {
      this._context._sendArchiveButtonMod.disable();
    }
  }
  return this.detectAttachments().then(function (attachments) {
    email.attachments = attachments;
    return this._rulesEngine.go(email, {
      willEncrypt: this.isSecureSend
    });
  }.bind(this)).then(function (report) {
    this._report = report;
    this._dlpAuditRecord = this._report.dlpAuditRecord;
    var types = [INCIDENT_WARN, INCIDENT_ENCRYPT, INCIDENT_BLOCK];
    var names = function (type) {
      return `virtru:${type}`;
    };
    var actions = function (action) {
      return action.key;
    };

    // Use .map() to create an array of action names based upon 'report'
    // i.e. [{'action':['virtru:warn']},{'action':['virtru:encrypt']}]
    //      becomes ['virtru:warn', 'virtru:encrypt', et al]
    // These are the actions SSS engine has reported
    var actionReportExpanded = this._report.actions.map(actions);

    // Use .map() to create an array of action names based upon 'types'
    // i.e. ['warn'] becomes ['virtru:warn']
    // These are the actions BP can accommodate
    var actionTypesExpanded = types.map(names);

    // Check the intersection of the two arrays above for actions that
    // intersect. These are the returned actions that BP can accommodate
    // i.e. ['virtru:warn'] given examples above
    const commonActions = actionReportExpanded.filter(action => actionTypesExpanded.includes(action));
    if (commonActions.length) {
      violations = true;
    }
    const hasEncryptAction = this._report.actions.some(action => action.key === 'virtru:encrypt');
    if (hasEncryptAction && this.attachments.length > ATTACHMENTS_LIMIT) {
      showAttachmentsLimitModal(this.attachments.length);
      return Promise.reject(ATTACHMENT_LIMIT_ERROR);
    }
    const [secureSendAction] = this._report.actions.sort(sortViolationsDescending).map(action => this.actionsRouter({
      report: report.dlpAuditRecord,
      isScheduledSend,
      action,
      isArchive
    })).filter(encryptionPromise => encryptionPromise); // filter out undefined-s

    const sendAnalytics = dlpReport => {
      AnalyticsService.sssProcessed({
        actions: dlpReport.actions,
        numberOfViolations: dlpReport.violations.length,
        duration: {
          total: Date.now() - processingStarted,
          sssEngine: dlpReport.durationData
        }
      });
    };
    const processSendActions = sendActions => {
      sendActions.forEach(sendAction => {
        if (onSend && (!violations || this.isSecureSend)) {
          this.sendActionRouter(sendAction);
        }
      });
      sendAnalytics(report);
    };
    this.showTrimmedContent();
    processSendActions(this._sendActions);
    if (typeof secureSendAction === 'function') {
      secureSendAction().then(() => AnalyticsService.dlpSendSecureSuccess({})).catch(error => {
        this._context.handleSendError(error);
        AnalyticsService.dlpSendSecureFailed({
          error
        });
      });
    }
    return Promise.resolve({
      check: violations,
      blockSend: actionReportExpanded.includes(ACTION_CONSTANTS.block)
    });
  }.bind(this));
};
SmartSendSecure.prototype.applyPreSendActions = function () {
  return this._sendActions.forEach(actionObj => {
    this.sendActionRouter(actionObj);
  });
};

/**
 * Router function for all the actions that come from the rules engine
 * @param  {object} report The report object, it contains the action, and the FULL violation report
 *
 * @returns {Function} that executes secure send if it specified by rules
 * or undefined in case of secure send not allowed or not specified by rules
 */
SmartSendSecure.prototype.actionsRouter = function (report) {
  const action = report.action.key;
  const context = this._context;
  const isOffline = this._virtruOfflineMode.isOffline();

  // Emit metric representing the action to apply
  AnalyticsService.dlpRuleTriggered({
    action
  });
  const mapRouterActions = {
    [ACTION_CONSTANTS.warn]: () => {
      if (!context.isSecureMode() && !this._blockSend) {
        this.createWarningPopover(INCIDENT_WARN, report.isArchive, report.isScheduledSend);
      }
    },
    [ACTION_CONSTANTS.block]: () => {
      if (!this._blockSend) {
        this.createWarningPopover(INCIDENT_BLOCK, report.isArchive, report.isScheduledSend);
      }
    },
    [ACTION_CONSTANTS.encrypt]: () => {
      if (report.isScheduledSend || isOffline) {
        this.createWarningPopover(INCIDENT_ENCRYPT, report.isArchive, report.isScheduledSend);
        return;
      }
      if (this._blockSend || this.isSecureSend) {
        return;
      }
      if (this.isMailMergeMode()) {
        showMailMergeModal(`${i18n.t('SEND_BLOCK_SUBTEXT')}<br><br>${i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE', {
          button: i18n.t('COMMON_OK')
        })}`);
        return;
      }
      this.isSecureSend = true;
      AnalyticsService.sssAutoEncrypt({});
      return this.createSendSecure(this._context, false, undefined, report.isScheduledSend);
    },
    [ACTION_CONSTANTS.setExpiration]: () => {
      this.patchPolicyExpiration(report.action);
    },
    [ACTION_CONSTANTS.noAuth]: () => {
      context.turnOnNoAuthEmails();
    }
  };
  const routerSendActionList = [ACTION_CONSTANTS.addTo, ACTION_CONSTANTS.addCc, ACTION_CONSTANTS.addBcc, ACTION_CONSTANTS.addContent, ACTION_CONSTANTS.stripAttachments];
  if (routerSendActionList.includes(action)) {
    this._sendActions.push(report);
    return;
  }
  const routerPatchPolicyList = [ACTION_CONSTANTS.disableForwarding, ACTION_CONSTANTS.isManaged, ACTION_CONSTANTS.watermark, ACTION_CONSTANTS.preventDownload, ACTION_CONSTANTS.persistentProtection];
  if (routerPatchPolicyList.includes(action)) {
    const policyPatchPropertyMap = {
      [ACTION_CONSTANTS.disableForwarding]: 'disableForwarding',
      [ACTION_CONSTANTS.isManaged]: 'isManaged',
      [ACTION_CONSTANTS.watermark]: 'expandedWatermarking',
      [ACTION_CONSTANTS.preventDownload]: 'preventDownload',
      [ACTION_CONSTANTS.persistentProtection]: 'persistentProtection'
    };
    context.patchPolicyConfig({
      [policyPatchPropertyMap[action]]: true
    });
    return;
  }
  const mappedActionFunc = mapRouterActions[action];
  if (mappedActionFunc) {
    return mappedActionFunc();
  }
};
SmartSendSecure.prototype.sendTriggeredDlpRules = async function (auditType) {
  const {
    violations
  } = this._report;
  const violatedRuleIds = [];
  const violatedRuleNames = [];
  violations.forEach(violation => {
    violatedRuleIds.push(violation.id);
    violatedRuleNames.push(violation.displayName);
  });
  const auditRecord = {
    type: auditType,
    action: 'create',
    details: {
      violatedRuleIds,
      violatedRuleNames,
      orgId: this._settings.user.setting('org.id'),
      userId: this._settings.currentUser()
    }
  };
  try {
    await this._transports.call('content', 'sendAuditRecord', {
      auditRecord
    });
  } catch (err) {
    AnalyticsService.clientError({
      context: auditType,
      name: 'smart-send-secure',
      error_obj: sanitizeAnalyticsError(err)
    }, true);
  }
};

/**
 * This function takes an action of 'virtru:expire' type and
 * updates policy config in NewComposerMode correspondingly.
 *
 * @param {object} action Actions to take from sss-engine (from report)
 * @returns {boolean} whether policy was patched.
 */
SmartSendSecure.prototype.patchPolicyExpiration = function (action) {
  if (!action.value || !action.value.autoExpireDuration) {
    return false;
  }
  const expires = action.value.autoExpireDuration;
  const expirationMoment = moment.duration(expires);
  const expirationProps = {
    expires: true,
    expirationUnit: 'minutes',
    expirationNum: expirationMoment.asMinutes(),
    expirationDate: moment().add(expirationMoment).toDate()
  };
  this._context.patchPolicyConfig(expirationProps);
  return true;
};
SmartSendSecure.prototype.addContent = function (action) {
  if (action.value && action.value.content) {
    var ele = $('<div>').text(action.value.content);
    this._editor.append(ele);
  }
};

/**
 * Similar to the actions router above, but this handles just the actions
 * that are to take place when the email finally sends.
 * @param  {[type]} actionObj [description]
 */
SmartSendSecure.prototype.sendActionRouter = function (report) {
  var action = report.action.key;
  switch (action) {
    case ACTION_CONSTANTS.addTo:
      this._context._recipientsMod.add('to', report.action);
      break;
    case ACTION_CONSTANTS.addCc:
      this._context._recipientsMod.add('cc', report.action);
      break;
    case ACTION_CONSTANTS.addBcc:
      this._context._recipientsMod.add('bcc', report.action);
      break;
    case ACTION_CONSTANTS.addContent:
      this.addContent(report.action);
      break;
    case ACTION_CONSTANTS.stripAttachments:
      this._context.removeAllAttachments();
      break;
    default:
  }
};
SmartSendSecure.prototype.sendUnsecure = function (isArchive, isSendUnsecureButtonPressed, isScheduledSend) {
  if (isSendUnsecureButtonPressed) {
    this.applyPreSendActions();
  }

  // This unhides the compose mod trimmed content that is 'covertly' unhidden
  // if a warning modal is shown.
  try {
    this._context._element.find(this._settings.dom.NEW_COMPOSE_TRIMMED_CONTENT).first().show();
  } catch (err) {
    /* Ignore errors, being extra careful this succeeds */
  }
  if (isArchive) {
    this._context._sendArchiveButtonMod.triggerGmailSendArchive();
  } else if (isScheduledSend) {
    this._context._scheduledSendButtonsMod.triggerScheduledSend();
  } else {
    this._context._sendButtonsMod.triggerGmailSend();
  }
};
SmartSendSecure.prototype.createWarningPopover = function (type, isArchive, isScheduledSend) {
  const sendSecure = () => {
    this.sendTriggeredDlpRules('dlpEncryptAndSend');
    this._context._sendButtonsMod.enableSendButton();
    AnalyticsService.sssSentSecure({});
    AnalyticsService.dlpSendSecureAttempt({});
    this.sendSecure(this._context, isArchive, () => this.applyPreSendActions(), isScheduledSend).then(() => {
      AnalyticsService.dlpSendSecureSuccess({});
    }).catch(error => {
      this._context.handleSendError(error);
      AnalyticsService.dlpSendSecureFailed({
        error
      });
    });
  };
  const cancelOnClick = () => {
    if (type === INCIDENT_BLOCK) {
      this.sendTriggeredDlpRules('dlpBlock');
    } else {
      this.sendTriggeredDlpRules('dlpCancelAndEdit');
    }
    AnalyticsService.sssCancelSend({});
    this._context._sendButtonsMod.enableSendButton();
    if (this._context._sendArchiveButtonMod) {
      this._context._sendArchiveButtonMod.enable();
    }
    // Show trimmed content if we've hidden it
    this.showTrimmedContent();
  };
  const sendUnsecure = () => {
    this.sendTriggeredDlpRules('dlpOverride');
    AnalyticsService.sssSentUnsecure({});
    this._context._sendButtonsMod.enableSendButton();
    this.sendUnsecure(isArchive, true, isScheduledSend);
  };
  let headingText = '';
  let bodyText = '';
  let bodyAdditionalText = '';
  let bodyAdditionalBoldText = '';
  let blueButtonText = '';
  let whiteButtonText = '';
  let showWhiteButton = true;
  let showBlueButton = !this.isMailMergeMode(); // Mail merge mode doesn't support secure send so we hide the button
  let showCancel = true;
  let cancelText;
  let blueButtonOnClick = sendSecure;
  const activeList = [];
  const isOffline = this._virtruOfflineMode.isOffline();
  switch (type) {
    case INCIDENT_WARN:
      headingText = i18n.t('SENSITIVE_DATA_FOUND');
      bodyText = i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY');
      blueButtonText = i18n.t('PROTECT_AND_SEND');
      whiteButtonText = i18n.t('SEND_ANYWAY');
      if (isOffline) {
        showWhiteButton = false;
        blueButtonText = i18n.t('SEND_ANYWAY_OFFLINE');
        bodyText = i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY_OFFLINE');
        bodyAdditionalText = i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE');
        blueButtonOnClick = sendUnsecure;
      } else if (isScheduledSend) {
        whiteButtonText = i18n.t('SCHEDULE_SEND');
        bodyText += `<br><br>${i18n.t('SEND_WARNING_SCHEDULE_SEND_NOT_SUPPORTED')}`;
        blueButtonText = i18n.t('SEND_WARNING_BUTTON_SEND_SECURE_IMMEDIATELY');
      }
      if (this.isMailMergeMode()) {
        bodyText += `<br><br>${i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE', {
          button: i18n.t('COMMON_CANCEL')
        })}`;
      }
      break;
    case INCIDENT_ENCRYPT:
      headingText = i18n.t('PROTECTION_REQUIRED');
      bodyText = i18n.t('SENSITIVE_DATA_FOUND_BODY');
      blueButtonText = i18n.t('PROTECT_AND_SEND');
      if (isOffline) {
        showWhiteButton = false;
        showCancel = false;
        blueButtonText = i18n.t('COMMON_CLOSE');
        bodyText = i18n.t('SENSITIVE_DATA_FOUND_BODY_OFFLINE');
        bodyAdditionalText = i18n.t('SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE');
        blueButtonOnClick = cancelOnClick;
      } else if (isScheduledSend) {
        headingText = i18n.t('SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE');
        bodyText += `<br><br>${i18n.t('SEND_WARNING_WARNING_SEND_SCHEDULED_LABEL')}`;
        blueButtonText = i18n.t('SEND_WARNING_BUTTON_SEND_SECURE_IMMEDIATELY');
        whiteButtonText = i18n.t('GO_BACK');
      }
      if (this.isMailMergeMode()) {
        bodyText += `<br><br>${i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE', {
          button: i18n.t('COMMON_CANCEL')
        })}`;
      }
      break;
    case INCIDENT_BLOCK:
      headingText = i18n.t('SEND_BLOCK_HEADER');
      bodyText = i18n.t('SEND_BLOCK_SUBTEXT');
      bodyAdditionalBoldText = i18n.t('SEND_BLOCK_BOLDTEXT');
      cancelText = i18n.t('COMMON_OK');
      showBlueButton = false;
      showWhiteButton = false;
      if (this.isMailMergeMode()) {
        bodyText += `<br><br>${i18n.t('WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE', {
          button: i18n.t('COMMON_OK')
        })}`;
      }
      break;
    default:
      return;
  }

  /**
   * create the active list of violations for the popover
   * any recipient violations with the given type (warn, or encrypt)
   * add in any subject violations with the given type
   * then any body content violations to the list of active violations
   * check violations list for any missed violations
   */
  this._report.violationDisplayList.forEach(violation => {
    if (violation.action.includes(`virtru:${type}`)) {
      let itemText = violation.ruleDetails;
      violation.violationDetails.forEach(text => {
        let violatedText = text;
        if (text === 'Subject Field') {
          violatedText = this._context.subject();
        }
        if (text === violation.name) {
          if (this._report.recipientViolations.some(item => item.email === text)) {
            violation.name = i18n.t('RECIPIENT');
          } else {
            violation.name = i18n.t('EMAIL_BODY_CONTENT');
          }
        }

        // Remove 'Encrypt with Virtru to protect your content.' for block action
        if (violation.action.includes(`virtru:${INCIDENT_BLOCK}`)) {
          itemText = itemText.replace(INCIDENT_BLOCK_STRING_CLEANUP, '');
        }
        activeList.push({
          name: violation.name,
          desc: violatedText,
          ruleDetails: itemText
        });
      });
      if (violation.violationDetails.length === 0) {
        activeList.push({
          name: violation.name,
          desc: i18n.t('ATTACHMENT_CONTENT'),
          ruleDetails: itemText
        });
      }
    }
  });
  const modal = new WarningPopoverModal({
    headingText,
    bodyText,
    bodyAdditionalText,
    bodyAdditionalBoldText,
    whiteButtonText,
    blueButtonText,
    cancelOnClick,
    showCancel,
    cancelText,
    showWhiteButton,
    showBlueButton,
    issuesList: activeList,
    isScheduledSend,
    blueButtonOnClick,
    whiteButtonOnClick: isScheduledSend && type === INCIDENT_ENCRYPT ? cancelOnClick : sendUnsecure
  });
  modal.openModal();
  AnalyticsService.dlpModalOpened({
    ruleType: type
  });
  modal.element.parents('.simplemodal-wrap').attr('tabindex', 1).attr('role', 'dialog').attr('aria-modal', 'true');
  modal.element.parents('.simplemodal-container').addClass('warning-modal-container');
  modal.element.find('.popup-button.popup-button-blue').addClass('secure-send-button');
  modal.element.find('.popup-button.popup-button-white').addClass('unsecure-send-button');
  if (isScheduledSend && type === INCIDENT_ENCRYPT) {
    const cancelButton = modal.element.find('.popup-button.popup-button-borderless')[0];
    if (cancelButton) {
      cancelButton.style.display = 'none';
    }
  }
};
SmartSendSecure.prototype.remove = function () {
  this._context._sendButtonsMod.enableSendButton();
  if (this._context._sendArchiveButtonMod) {
    this._context._sendArchiveButtonMod.enable();
  }
  // Show trimmed content if we've hidden it
  this.showTrimmedContent();
};
SmartSendSecure.prototype.showTrimmedContent = function () {
  try {
    this._context._element.find(this._settings.dom.NEW_COMPOSE_TRIMMED_CONTENT).first().show();
  } catch (err) {
    /* Ignore errors, being extra careful this succeeds */
  }
};
SmartSendSecure.prototype.teardown = function () {
  $(document).off('mouseup', this.docListener);
  this._virtruOfflineMode.teardown();
};
SmartSendSecure.prototype.sendSecure = function (context, isArchive, applyPresendActions, isScheduledSend) {
  const encryptionPromise = context.encryptAttachmentsAndSendSecure(isArchive, applyPresendActions, isScheduledSend);
  return context.promiseWithEncryptionAnimation(encryptionPromise);
};
SmartSendSecure.prototype.createSendSecure = function (context, isArchive, applyPresendActions, isScheduledSend) {
  return () => this.sendSecure(context, isArchive, applyPresendActions, isScheduledSend);
};
SmartSendSecure.prototype.isMailMergeMode = function () {
  return this._context._element.parents(this._settings.dom.MAIL_MERGE_COMPOSE_BODY).length > 0;
};
module.exports = SmartSendSecure;

/***/ }),

/***/ 52067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const features = __webpack_require__(7020);
const renderModal = (__webpack_require__(58665)/* ["default"] */ .A);

/**
 * Check through feature configurations and introduce new features to admins via modals.
 *
 * @param {Object} settings   Settings object.
 * @returns
 */
function checkNewFeatures(settings, settingsService) {
  const {
    user
  } = settings;
  if (!user) {
    return;
  }
  const isActive = user.auth('status') === 'active';
  const {
    isAdmin
  } = user.setting('org');
  const createdOn = new Date(user.setting('created'));

  // Only introduce features to activated admins
  if (!isAdmin || !isActive) {
    return;
  }
  features.forEach(function checkFeature(feature) {
    // Only want to show modals to old users
    if (createdOn >= feature.releaseDate || Date.now() < feature.releaseDate.getTime()) {
      return;
    }

    // Escape if user has seen this intro before or has the feature turned on already
    if (!feature.shouldShow(user)) {
      return;
    }

    // Flag this feature intro so it doesn't appear again
    user.setting(feature.seenFlag, true);

    // Save the feature modal flag back to the db so we don't pop it again
    settingsService.saveUserSettingsToServer();
    renderModal[feature.key]({
      user
    });
  });
}
module.exports = {
  checkNewFeatures
};

/***/ }),

/***/ 52561:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   showAttachmentsLimitModal: () => (/* binding */ showAttachmentsLimitModal),
/* harmony export */   showMailMergeModal: () => (/* binding */ showMailMergeModal)
/* harmony export */ });
/* harmony import */ var _widgets_WarningPopoverModal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12221);
const i18n = __webpack_require__(2622);

const {
  ATTACHMENTS_LIMIT
} = __webpack_require__(76223);

/**
 * Shows warning popup when attachments limit is reached
 * @param {Number} attachmentsCount
 * */
function showAttachmentsLimitModal(attachmentsCount) {
  const modal = new _widgets_WarningPopoverModal__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A({
    headingText: i18n.t('WARN_ATTACHMENTS_LIMIT_REACHED'),
    bodyText: i18n.t('ATTACHMENTS_LIMIT_REACHED_BODY').replace('[ATTACHMENTS_COUNT]', attachmentsCount).replace('[ATTACHMENTS_LIMIT]', ATTACHMENTS_LIMIT).replace('[ATTACHMENTS_REMOVE_COUNT]', attachmentsCount - ATTACHMENTS_LIMIT),
    blueButtonText: 'OK',
    showBlueButton: true,
    showWhiteButton: false,
    showCancel: false,
    issuesList: []
  });
  const list = modal.element.find('.popup-list-border-box');
  list.css('display', 'none');
  modal.openModal();
  modal.updateDialog(modal.options);
}

/**
 * Shows warning popup when mail merge is enabled
 * */
function showMailMergeModal(bodyText) {
  const modal = new _widgets_WarningPopoverModal__WEBPACK_IMPORTED_MODULE_0__/* ["default"] */ .A({
    headingText: i18n.t('MAIL_MERGE_CONFLICT_MODAL_TITLE'),
    bodyText: bodyText || i18n.t('MAIL_MERGE_CONFLICT_MODAL_BODY'),
    blueButtonText: 'OK',
    showBlueButton: true,
    showWhiteButton: false,
    showCancel: false,
    issuesList: []
  });
  const list = modal.element.find('.popup-list-border-box');
  list.css('display', 'none');
  modal.openModal();
  modal.updateDialog(modal.options);
}

/***/ }),

/***/ 52635:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   get: () => (/* binding */ get)
/* harmony export */ });
/* harmony import */ var _get_set_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(37450);

function baseGet(object, path) {
  path = (0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .castPath */ .r9)(path, object);
  let index = 0;
  const {
    length
  } = path;
  while (object != null && index < length) {
    object = object[(0,_get_set_utils__WEBPACK_IMPORTED_MODULE_0__/* .toKey */ .fw)(path[index++])];
  }
  return index && index === length ? object : undefined;
}
function get(object, path, defaultValue) {
  const result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/***/ }),

/***/ 53054:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  renderCKSIndicator: () => (/* binding */ renderCKSIndicator)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(87568);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(64078);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(33632);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
// EXTERNAL MODULE: ./lib/i18n/index.js
var i18n = __webpack_require__(2622);
var i18n_default = /*#__PURE__*/__webpack_require__.n(i18n);
// EXTERNAL MODULE: ./lib/analytics/index.js
var analytics = __webpack_require__(1246);
;// ./images/icon-key.svg
var _path;
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }

var SvgIconKey = function SvgIconKey(props) {
  return /*#__PURE__*/react.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 12,
    height: 12,
    fill: "#004987"
  }, props), _path || (_path = /*#__PURE__*/react.createElement("path", {
    fillRule: "evenodd",
    d: "M3.699 0c2.154 0 3.73 1.597 3.73 3.677 0 .581-.164.968-.164.968L12 9.29v2.516l-.32.194H9.346l-.327-1.01v-.925l-.452-.332-1.168.332-.39-.505V8.01l-.194-.075-1.781.075s.243-.746-.068-1.054L3.7 7.355C1.557 7.355 0 5.806 0 3.677 0 1.581 1.557 0 3.699 0M3 3v1h1V3z",
    opacity: 0.85
  })));
};
/* harmony default export */ const icon_key = (SvgIconKey);
;// ./images/icon-hint.svg
var _defs, _g;
function icon_hint_extends() { return icon_hint_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, icon_hint_extends.apply(null, arguments); }

var SvgIconHint = function SvgIconHint(props) {
  return /*#__PURE__*/react.createElement("svg", icon_hint_extends({
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    width: 12,
    height: 12,
    fill: "#B0B3B8"
  }, props), _defs || (_defs = /*#__PURE__*/react.createElement("defs", null, /*#__PURE__*/react.createElement("path", {
    id: "icon-hint_svg__a",
    d: "M5.15 7.25a2.15 2.15 0 0 1 .15-.9 1.7 1.7 0 0 1 .55-.65l.25-.2.25-.2.15-.2a.5.5 0 0 0 .05-.25.5.5 0 0 0-.25-.45 1 1 0 0 0-.55-.15H5.5l-.35.15-.3.2-.2.2-.8-.85.3-.3.45-.3.6-.25L6 3l.8.1a1.9 1.9 0 0 1 .65.35 1.6 1.6 0 0 1 .4.55c.1.22.152.459.15.7a1.8 1.8 0 0 1-.05.5l-.15.35-.25.3-.3.25-.3.25-.25.25-.15.25a1 1 0 0 0-.05.35v.1H5.15zm-.1.7H6.5V9.4H5.05zM2.438 0a.5.5 0 0 1 .024 1A1.5 1.5 0 0 0 1 2.5v7A1.5 1.5 0 0 0 2.462 11a.5.5 0 1 1-.024 1A2.5 2.5 0 0 1 0 9.5v-7A2.5 2.5 0 0 1 2.438 0m7.124 12a.5.5 0 1 1-.024-1A1.5 1.5 0 0 0 11 9.5v-7A1.5 1.5 0 0 0 9.538 1a.5.5 0 0 1 .024-1A2.5 2.5 0 0 1 12 2.5v7A2.5 2.5 0 0 1 9.562 12"
  }))), _g || (_g = /*#__PURE__*/react.createElement("g", {
    fillRule: "evenodd"
  }, /*#__PURE__*/react.createElement("mask", {
    id: "icon-hint_svg__b"
  }, /*#__PURE__*/react.createElement("use", {
    xlinkHref: "#icon-hint_svg__a"
  })), /*#__PURE__*/react.createElement("use", {
    xlinkHref: "#icon-hint_svg__a",
    fillRule: "nonzero"
  }), /*#__PURE__*/react.createElement("g", {
    mask: "url(#icon-hint_svg__b)"
  }, /*#__PURE__*/react.createElement("path", {
    d: "M0 0h12v12H0z"
  })))));
};
/* harmony default export */ const icon_hint = (SvgIconHint);
;// ./lib/widgets/cks-indicator.js







const virtruCKSUrl = 'https://support.virtru.com/hc/en-us/articles/115004566453';
const AnalyticsService = (0,analytics.instance)();
function CKSIndicatorTooltip({
  open,
  position
}) {
  const onLinkClick = () => {
    window.open(virtruCKSUrl);
    AnalyticsService.cksMoreInfoDisplayed({});
  };
  if (open) {
    return /*#__PURE__*/react.createElement("div", {
      className: "cks-tooltip",
      style: position
    }, /*#__PURE__*/react.createElement("p", {
      className: "cks-tooltip-item"
    }, i18n_default().t('CKS_INDICATOR_BODY')), /*#__PURE__*/react.createElement("div", {
      className: "cks-tooltip-link",
      onClick: onLinkClick
    }, i18n_default().t('CKS_INDICATOR_LINK')));
  }
  return null;
}
CKSIndicatorTooltip.propTypes = {
  open: (prop_types_default()).bool.isRequired,
  position: prop_types_default().shape({
    top: (prop_types_default()).number
  })
};
function CKSIndicator() {
  const indicatorRef = (0,react.useRef)();
  const [isTooltipOpen, setIsTooltipOpen] = (0,react.useState)(false);
  const [currentPosition, setCurrentPosition] = (0,react.useState)({
    top: 0
  });
  const hideTooltip = () => setIsTooltipOpen(false);
  const toggleTooltip = () => setIsTooltipOpen(prev => !prev);
  const updatePosition = () => {
    const position = indicatorRef.current.getBoundingClientRect();
    setCurrentPosition({
      top: position.top + 25
    });
  };
  const updatePositionAndShowTooltip = e => {
    e.stopPropagation();
    updatePosition();
    toggleTooltip();
  };
  (0,react.useEffect)(() => {
    if (isTooltipOpen) {
      AnalyticsService.cksInfoDisplayed({});
    }
  }, [isTooltipOpen]);
  (0,react.useEffect)(() => {
    window.addEventListener('click', hideTooltip, false);
    window.addEventListener('scroll', hideTooltip, true);
    return () => {
      window.removeEventListener('click', hideTooltip, false);
      window.removeEventListener('scroll', hideTooltip, true);
    };
  }, []);
  return /*#__PURE__*/react.createElement("div", {
    className: "cks-indicator"
  }, /*#__PURE__*/react.createElement("div", {
    ref: indicatorRef,
    onClick: updatePositionAndShowTooltip
  }, /*#__PURE__*/react.createElement(icon_key, {
    className: "cks-icon-key"
  }), /*#__PURE__*/react.createElement("span", null, "\xA0"), /*#__PURE__*/react.createElement("span", null, i18n_default().t('CKS_INDICATOR_TITLE')), /*#__PURE__*/react.createElement("span", null, "\xA0"), /*#__PURE__*/react.createElement(icon_hint, null)), /*#__PURE__*/react.createElement("div", {
    className: "cks-tooltip-container"
  }, /*#__PURE__*/react.createElement(CKSIndicatorTooltip, {
    open: isTooltipOpen,
    position: currentPosition
  })));
}
function renderCKSIndicator(element) {
  const root = (0,client/* createRoot */.H)(element);
  root.render(/*#__PURE__*/react.createElement(CKSIndicator, null));
}

/***/ }),

/***/ 53749:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnimationWidget: () => (/* binding */ AnimationWidget)
/* harmony export */ });
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64078);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(87568);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5749);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_templates__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _compatibility_tweenmax__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(44644);
/* harmony import */ var _compatibility_tweenmax__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_compatibility_tweenmax__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _virtru_private_design_system__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(70150);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(76223);
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_constants__WEBPACK_IMPORTED_MODULE_6__);








const {
  TimelineLite,
  Sine
} = window.GreenSockGlobals;

/**
 * Widget that handles the encryption and decryption animation
 */
class AnimationWidget {
  constructor(element, settings) {
    this._messageElement = element;
    this._element = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2___default()(_templates__WEBPACK_IMPORTED_MODULE_3___default().animationWidget());
    this._timeline = null;

    // Get the ui area to replace clipped messages with the animation
    const messageContainers = this._messageElement.find(settings.dom.TDF_SELECTOR);
    this._topMessageContainer = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2___default()(messageContainers[0]).parent().parent();
  }
  static create(...args) {
    return new this(...args);
  }
  static removeFromDOM(element) {
    const animationWidgetElement = element.siblings('.virtru-animation-widget');
    if (animationWidgetElement.length) {
      animationWidgetElement.remove();
    }
  }

  /**
   * Replaces the email with the decryption animation if it's a secure message
   */
  async beginAnimation({
    isMessageClipped = false
  }) {
    performance.mark(_constants__WEBPACK_IMPORTED_MODULE_6__.DECRYPTION_ANIMATION_START);
    const messageWidth = isMessageClipped ? this._topMessageContainer.outerWidth() : this._messageElement.outerWidth();
    const messageHeight = isMessageClipped ? this._topMessageContainer.outerHeight() : this._messageElement.outerHeight();
    const GROW_TIME = 0.15;
    this._renderSpinner();

    // if we already created an animation widget, the content might have been re-rendered unexpectedly.
    // remove any older animation widgets to avoid duplicate animation elements appearing.
    this._messageElement.siblings('.virtru-animation-widget').remove();

    // make the animation element cover the message
    this._element.css('width', messageWidth);
    this._element.css('height', 0);
    if (isMessageClipped) {
      this._topMessageContainer.css('position', 'absolute');
      this._topMessageContainer.css('z-index', '-999');
      this._topMessageContainer.after(this._element);
    } else {
      // make the message not take up space on the page
      this._messageElement.css('position', 'absolute');
      this._messageElement.css('z-index', '-999');
      this._messageElement.after(this._element);
    }
    this._timeline = new TimelineLite();
    this._timeline.to(this._element, GROW_TIME, {
      height: messageHeight,
      ease: Sine.easeInOut,
      delay: 0.35
    });
    return new Promise(resolve => {
      this._timeline.call(resolve);
    });
  }
  async endAnimation() {
    const decryptedMessage = this._messageElement.siblings('.virtru-email-decrypted');
    const height = decryptedMessage.outerHeight();
    const GROW_TIME = 0.15;
    const FADE_TIME = 0.15;
    await this._animationComplete;
    this._timeline.clear();

    // prevent decrypted message from taking up space on the page
    decryptedMessage.css('z-index', '-999');
    decryptedMessage.css('position', 'absolute');

    // phase 1 grows the height of the placeholder to match the height of the message
    // then makes the message take up space but stay invisible.
    this._timeline.to(this._element, GROW_TIME, {
      height,
      ease: Sine.easeInOut
    });
    this._timeline.call(() => {
      // make the message / decrypted message finally take up space on the page
      this._topMessageContainer.css('position', '');
      this._topMessageContainer.css('z-index', '');
      this._messageElement.css('position', '');
      this._messageElement.css('z-index', '');
      decryptedMessage.css('position', '');
      decryptedMessage.css('z-index', '');

      // make the animation appear over top of the message
      this._element.css('position', 'absolute');
    });

    // phase 2 fades the animation div out and the message in
    this._timeline.to(this._element, FADE_TIME, {
      opacity: 0,
      ease: Sine.easeInOut
    });
    return new Promise(resolve => {
      // phase 3 removes the animation div
      this._timeline.call(() => {
        this._element.remove();
        performance.mark(_constants__WEBPACK_IMPORTED_MODULE_6__.DECRYPTION_ANIMATION_END);
        resolve();
      });
    });
  }
  _renderSpinner() {
    const Scene = () => {
      let resolveAnimationComplete;
      this._animationComplete = new Promise(resolve => {
        resolveAnimationComplete = resolve;
        setTimeout(resolveAnimationComplete, 500);
      });
      return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(_virtru_private_design_system__WEBPACK_IMPORTED_MODULE_7__/* ["default"] */ .A, {
        className: "virtru-animation-widget-spinner",
        text: _lib_i18n__WEBPACK_IMPORTED_MODULE_5___default().t('ANIMATION_WIDGET_LOADING_TEXT'),
        variant: "page"
      });
    };
    const container = this._element.get(0);
    (0,react_dom_client__WEBPACK_IMPORTED_MODULE_0__/* .createRoot */ .H)(container).render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1__.createElement(Scene, null));
  }
}

/***/ }),

/***/ 54026:
/***/ ((module) => {

/**
 * @module utils/cks
 */

/**
 * Get the org public key PEM payload from a userSettings object.
 *
 * @param  {Object} userSettings
 * @return {String|undefined}
 */
module.exports.getOrgPublicKey = function (userSettings) {
  if (!userSettings || !userSettings.orgPublicKey) {
    return undefined;
  }
  return userSettings.orgPublicKey.payload;
};

/***/ }),

/***/ 54231:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
/**
 * @file Provides the settings-service (SettingsService) object.
 */

let transports = null;
const {
  UserProfileProxy
} = __webpack_require__(87618);
const Emitter = __webpack_require__(16502);
const gmailUtil = __webpack_require__(2090);

/**
 * Retrieves settings from the background script
 * @constructor
 * @param {Object} settings - the application 'Settings' object
 */
function SettingsService(settings) {
  this._settings = settings;
  this._window = settings.window;
  // get 'transports' from settings
  transports = settings.getTransports();
  // bind methods as needed
  this.updateUserProfileSettings = this.updateUserProfileSettings.bind(this);
}
Emitter(SettingsService.prototype);

/**
 * Static method initializer and calls setupListeners()
 * @constructs
 * @param {Object} settings - the application 'Settings' object
 */
SettingsService.setup = function (settings) {
  const service = new SettingsService(settings);
  service.setupListeners();
  return service;
};

/**
 * Setup 'Settings' events listeners, and event-worker method
 * @method
 */
SettingsService.prototype.setupListeners = function () {
  const settings = this._settings;
  settings.on('update:user:settings', this.updateUserProfileSettings);
  settings.on('load:user:profile', this.loadUserProfile.bind(this));
};

/**
 * Load DOM settings
 * @method
 */
SettingsService.prototype.loadDomSettings = function () {
  const self = this;
  const GMAIL_GLOBALS = gmailUtil.getWindowGlobals();
  return transports.call('content', 'returnSelectors', {
    gmailVersion: GMAIL_GLOBALS[2]
  }).then(function success(selectors) {
    const dom = selectors;
    self._settings.setDomDictionary(dom);
  });
};

/**
 * Load the user-profile
 * @method
 */
SettingsService.prototype.loadUserProfile = function () {
  const self = this;
  const params = {
    userId: this._currentUser()
  };
  return transports.call('content', 'loadUserProfile', params).then(function success(userProfileData) {
    if (!userProfileData) {
      throw new Error('loadUserProfileError');
    }
    // enable overriding feature flags and user permissions via query param
    // or by supplying them in localStorage
    // just append a query string with 'features' and/or 'permissions'
    // with a string of feature names separated by commas
    // (i.e. ?features=specialFeature,extraSpecialFeature)
    const queryObj = Object.fromEntries(new URLSearchParams(window.location.search)) || {};
    const savedMockFeatures = localStorage.getItem('mockFeatures') || '';
    const mockFeatures = (queryObj.features || '').split(',').concat(savedMockFeatures.split(',')).filter(Boolean);
    mockFeatures.forEach(key => {
      try {
        userProfileData.settings.clientConfig.features[key] = true;
      } catch (e) {
        console.warn(`Unable to set mockFeature "${key}" for user profile`);
      }
    });
    const savedMockPermissions = localStorage.getItem('mockPermissions') || '';
    const mockPermissions = (queryObj.permissions || '').split(',').concat(savedMockPermissions.split(','));
    mockPermissions.forEach(key => {
      try {
        userProfileData.settings.permissions[key] = true;
      } catch (e) {
        console.error('Unable to set mockPermission', key);
      }
    });
    const savedMockUserSettings = localStorage.getItem('mockUserSettings');
    if (savedMockUserSettings) {
      try {
        const settings = JSON.parse(savedMockUserSettings);
        userProfileData.settings = {
          ...userProfileData.settings,
          ...settings
        };
      } catch (e) {
        console.error('Unable to set mockUserSettings', savedMockUserSettings);
      }
    }
    const userProfile = UserProfileProxy.create(userProfileData);
    self._settings.setUserProfile(userProfile);
    return userProfile;
  });
};

/**
 * Refresh the user-profile
 * @method
 */
SettingsService.prototype.refreshUserProfile = function () {
  const params = {
    userId: this._currentUser(),
    refreshing: true
  };
  return transports.call('content', 'loadUserProfile', params).then(function success(userProfileData) {
    return this._settings.user.refreshProfile(userProfileData, true);
  }.bind(this));
};

/**
 * Load the user-profile
 * @method
 */
SettingsService.prototype.refreshProfile = function (profile) {
  this._settings.user.refreshProfile(profile);
};

/**
 * update user-profile-settings
 * @method
 */
SettingsService.prototype.updateUserProfileSettings = function () {
  const params = {
    userId: this._currentUser(),
    settings: this._settings.user.settings()
  };
  transports.call('content', 'updateUserProfileSettings', params).catch(error => {
    console.error('Error on updating the user-profile-settings', error);
  });
};

/**
 * Save the user settings to the server
 * @method
 */
SettingsService.prototype.saveUserSettingsToServer = function () {
  const params = {
    userId: this._currentUser()
  };
  transports.call('content', 'saveUserSettingsToServer', params).catch(function (err) {
    console.error('Error on saving the user-settings', err);
  });
};

/**
 * Get the current mail-user
 * @method
 * @returns {String} - the full email-address
 */
SettingsService.prototype._currentUser = function () {
  return this._settings.currentUser();
};
exports.SettingsService = SettingsService;

/***/ }),

/***/ 54654:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var i18n = __webpack_require__(2622);
var Emitter = __webpack_require__(16502);
var utils = __webpack_require__(25119);
var Popover = __webpack_require__(55929);
var Templates = __webpack_require__(5749);
const {
  _bindAllMethods
} = __webpack_require__(4424);

/**
 * The generic activation interface to be used throughout the browser extension
 *
 * Instances of this will trigger a single event 'activationRequested' when the
 * user clicks on the activation button.
 *
 * @param {HTMLElement/jQueryElement} element - The container of the secure email
 * @param {Object} selectors - Gmail Selectors
 */
function ActivationInterface(element, selectors) {
  this._element = $(element);
  this._selectors = selectors;
  _bindAllMethods(this);
}
Emitter(ActivationInterface.prototype);

/**
 * Static method that will automatically setup the element
 */
ActivationInterface.create = function (element, currentUser, activationStatus, selectors) {
  var activationInterface = new ActivationInterface(element, selectors);
  activationInterface.setup(currentUser, activationStatus);
  return activationInterface;
};
ActivationInterface.prototype.setup = function (currentUser, activationStatus) {
  // Ignore if this is not actually a tdf email
  if (!utils.isElementASecureEmail(this._element, this._selectors)) {
    return;
  }

  // Replace the invitation template with the activation interface... which
  // right now is nearly identical to the invitation template
  var messageContainers = this._element.find(this._selectors.TDF_SELECTOR);

  // Get the ui area to replace
  var topMessageContainer = $(messageContainers[0]).parent().parent();

  // Remove all of the children except those with secure messages
  topMessageContainer.children().each(function (_, childLoc) {
    var child = $(childLoc);
    const text = child.text();
    if ((text.includes('--- START PROTECTED MESSAGE') || text.includes('Message ID:')) && !child.is($('div[class*=\'virtru-invitation\']'))) {
      return;
    }
    child.remove();
  });
  var activationInterfaceEle = $(Templates.readActivation({
    expired: activationStatus === 'expired',
    currentUser
  }));
  topMessageContainer.prepend(activationInterfaceEle);
  activationInterfaceEle.on('click', 'a.virtru-reactivation-button', {}, this._reactivationRequested);
  activationInterfaceEle.on('click', 'a.virtru-firsttime-activation-button', {}, this._activationRequested);
  var icon = $(activationInterfaceEle.find('.virtru-receiver-inactive-header-info-link')[0]);
  var popover = new Popover(i18n.t('CONTEXTUAL_ACTIVATE_INFO', {
    currentUser
  }), '');
  popover.classname += ' virtru-popover-dark';
  popover.position('north');
  popover.setShowTimer(250);
  popover.attach(icon);
};
ActivationInterface.prototype._activationRequested = function () {
  this.emit('activationRequested', false);
};
ActivationInterface.prototype._reactivationRequested = function () {
  this.emit('activationRequested', true);
};
exports.ActivationInterface = ActivationInterface;

/***/ }),

/***/ 55258:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   footerPopover: () => (/* binding */ footerPopover)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const footerPopover = () => `
  <div class="virtru-footer">
    <div class="virtru-footer-header">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('FOOTER_POPOVER_HEADER')}</div>
    <div class="virtru-footer-body">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('FOOTER_POPOVER_BODY')}</div>
    <div class="virtru-confirm-button">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('COMMON_OK')}</div>
    <a href="https://secure.virtru.com/control-center/settings" target="_blank" rel="noopener noreferrer">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('FOOTER_POPOVER_REMOVE_SIGNATURE')}</a>
  </div>
`;

/***/ }),

/***/ 55302:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   newComposeEditor: () => (/* binding */ newComposeEditor)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const newComposeEditor = () => `
  <div class="virtru-new-compose-editor-banner">
    <div role="status" class="virtru-announce-status visually-hidden" aria-live="polite"></div>
    <div class="virtru-secure-mode-on no-outline" tabIndex="1">
      <div class="virtru-pcm-options-enabled-icons">

        <div class="virtru-new-compose-icon virtru-noauth-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_ONECLICK')}">&nbsp;</div>
        <div class="virtru-new-compose-icon virtru-forwarding-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_DISABLE_FORWARDING')}">&nbsp;</div>
        <div class="virtru-new-compose-icon virtru-sms-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_SMS_ENABLED')}">&nbsp;</div>
        <div class="virtru-new-compose-icon virtru-expiration-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_EXPIRATION')}">&nbsp;</div>
        <div class="virtru-new-compose-icon virtru-is-managed-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_WATERMARK_PDF')}">&nbsp;</div>
        <div class="virtru-new-compose-icon virtru-watermark-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_WATERMARK')}">&nbsp;</div>
        <div class="virtru-new-compose-icon virtru-pfp-icon no-outline" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_PFP')}">&nbsp;</div>

      </div>
      <div class="virtru-label"></div>
      <a class="virtru-show-info-btn" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_VIRTRU_INFO')}" role="button" tabIndex="1" href="javascript: void(0);">i</a>
      <div class="virtru-forward-warning" style="display: none"></div>
      <div class="virtru-forward-warning-icon" style="display: none"></div>
    </div>
    <div class="virtru-secure-mode-off no-outline" tabIndex="1">
      <div class="virtru-label"></div>
      <a class="virtru-show-info-btn" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_VIRTRU_INFO')}" role="button" tabIndex="1" href="javascript: void(0);">i</a>
    </div>
    <div class="virtru-not-authenticated">
      <div class="virtru-auth-label no-outline">
        <div class="virtru-label"></div>
        <a class="virtru-show-info-btn" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_VIRTRU_INFO')}" role="button" tabIndex="1" href="javascript: void(0);">i</a>
      </div>
      <button class="virtru-auth-link no-outline" tabIndex="1">
        ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('VIRTRU_AUTH_LINK')}
      </button>
    </div>

    <div class="virtru-secure-mode-toggle">
      <div class="virtru-policy-config">&nbsp;</div>
      <div class="virtru-toggle no-outline" tabIndex="1" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('SCREENREADER_VIRTRU_SECURE_TOGGLE')}" role="button">
        <div class="virtru-slider">
          <div class="virtru-slider-handle">&nbsp;</div>
        </div>
        <div class="virtru-overlay">&nbsp;</div>
      </div>
    </div>
  </div>
`;

/***/ }),

/***/ 55401:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Require all of the plugins
var jQuery = __webpack_require__(91089);
__webpack_require__(37600);
__webpack_require__(2913);
__webpack_require__(30878);
__webpack_require__(282);

// Export jquery
module.exports = jQuery;

/***/ }),

/***/ 55647:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
var $ = __webpack_require__(55401);
var i18n = __webpack_require__(2622);
var Emitter = __webpack_require__(16502);
var {
  SettingsService
} = __webpack_require__(54231);
var AnalyticsService = (__webpack_require__(1246).instance)();
var refreshingProfile = false;
const WarningPopoverModal = (__webpack_require__(12221)/* ["default"] */ .A);
const {
  parseConfig,
  parseBySelector,
  parseByUrl,
  parseByExactSelector
} = __webpack_require__(61873);
const {
  transports,
  routers
} = __webpack_require__(29182);
const {
  checkNewFeatures
} = __webpack_require__(52067);
const {
  renderErrorRefreshPageToast
} = __webpack_require__(51671);
const renderModal = (__webpack_require__(58665)/* ["default"] */ .A);
const sanitizeAnalyticsError = (__webpack_require__(81442)/* ["default"] */ .A);

// If this is a delegated account, we need to activate differently
var {
  pathname
} = window.location;
var delegated = pathname.includes('/b/') || pathname.includes('/d/');

// 3 hours
var USER_PROFILE_REFRESH_INTERVAL_MS = 180 * 60000;
function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function WebmailPlugin({
  secureServiceProxy,
  settings,
  secureEmail,
  GmailMonitor,
  gmailMods,
  settingsService,
  xhrIntercepts
}) {
  this.routers = routers;
  this.secureEmail = secureEmail;
  this.settings = settings;
  this.transports = transports;
  this._secureService = secureServiceProxy;
  this._settingsService = settingsService;
  this._isActivationInProgress = false;
  this.GmailMonitor = GmailMonitor;
  this.gmailMods = gmailMods;
  this.xhrIntercepts = xhrIntercepts;
}
WebmailPlugin.run = function ({
  gmailGlobals,
  GmailSettings,
  ...rest
}) {
  var processedClassLoc = `virtru-processed-${random(0, 10000)}`;
  var settings = new GmailSettings(gmailGlobals);
  settings.processedClass = processedClassLoc;
  var settingsService = SettingsService.setup(settings);
  var plugin = new WebmailPlugin({
    settings,
    settingsService,
    ...rest
  });

  // Start the plugin listening
  plugin.start();
  return plugin;
};

/**
 * Starts the plugin when the document is ready
 */
WebmailPlugin.prototype.start = function () {
  const isHtmlMode = document.doctype === null;
  if (isHtmlMode) {
    if (localStorage.getItem('basicUnsupportedSeenGmail') !== 'true') {
      localStorage.setItem('basicUnsupportedSeenGmail', 'true');
      renderModal.basicModeNotSupported();
    }
    return;
  }
  $(document).ready(this.initialize.bind(this));
};
WebmailPlugin.prototype.initialize = function () {
  // Setup to listen for an activation request from the settings object
  this.settings.on('activationRequested', this.activationRequested.bind(this));
  this.setupTransportErrorHook();
  this.setupCommandListener();

  // The order of initialization is as follows:
  // 1) Load the user profile from the background script
  // 2) Setup a refresh interval so that the profile is refreshed frequently while the page is open
  // 3) Fetch the external selectors and load them into the user settings
  // 4) Initialize the page mods (i.e. start to hook elements)
  // 5) Report the client status. and if part of setup fails display a warning modal to the user
  return this.loadUserProfile()
  // Refresh the profile every X milliseconds
  .then(() => setTimeout(this.refreshProfile, this.settings.user.setting('userSettingsRefreshInterval') || USER_PROFILE_REFRESH_INTERVAL_MS)).then(() => this.transports.call('content', 'fetchExternalSelectors', {}).then(() => {
    console.debug('Successfully loaded external selectors.');
  }).catch(e => {
    AnalyticsService.clientError({
      name: 'Failure to load external selectors',
      userId: this.settings.currentUser(),
      error_obj: sanitizeAnalyticsError(e)
    });
  }))
  // Load selectors into user settings.
  .then(() => this._settingsService.loadDomSettings())
  // Init the element registry listeners
  .then(this.initializeMonitor.bind(this)).then(() => {
    this.setupHideObserver(this.settings.dom);
    AnalyticsService.identify({
      userId: this.settings.currentUser(),
      isUsingMaterialDesign: true,
      isUsingMaterialBackend: true
    });

    // If any Virtru errors were stored in localStorage, fire them now
    const previousVirtruError = localStorage.getItem('previousVirtruError');
    if (previousVirtruError) {
      const parsedPreviousError = JSON.parse(previousVirtruError);
      parsedPreviousError.emittedOnNextRun = true;
      AnalyticsService.clientError(parsedPreviousError);
      localStorage.removeItem('previousVirtruError');
    }
    return Promise.resolve();
  }).then(() => {
    this.xhrIntercepts.init(this.settings);
    checkNewFeatures(this.settings, this._settingsService);
  }).catch(err => {
    if ((err === null || err === void 0 ? void 0 : err.message) === 'loadUserProfileError') {
      return;
    }
    console.error(err);
    AnalyticsService.clientError({
      name: 'WebmailPlugin Initialization Error',
      path: window.location.pathname,
      userId: this.settings.currentUser(),
      webmail_provider: this.settings.site(),
      webmail_version: this.settings.currentVersion(),
      error_obj: sanitizeAnalyticsError(err)
    });
    // Make sure the user knows the plugin is in a broken state
    // but only if they're actually using the plugin
    if (err.doShowErrorMessageModal) {
      renderModal.webmailPluginInitError();
    }
  });
};

/**
 * Observe elements which should be hidden and hide them(came from external-selectors)
 */
WebmailPlugin.prototype.setupHideObserver = function (selectors) {
  if (selectors.ALWAYS_HIDE) {
    const hideElements = () => $(document.body).find(selectors.ALWAYS_HIDE).hide();
    this.hideObserver = new MutationObserver(() => {
      hideElements();
    });
    this.hideObserver.observe(document.body, {
      childList: true,
      subtree: true
    });
    hideElements();
  }
};

/**
 * Handles setting up hooks to catch extension communication errors which can
 * cause decryption to spin forever when the extension is updated,
 * disabled/enabled, or network errors occur.
 */
WebmailPlugin.prototype.setupTransportErrorHook = function () {
  var self = this;
  var originalTransportCall = this.transports.call;
  this.transports.call = function () {
    return originalTransportCall.apply(self.transports, arguments).catch(function (err) {
      throw err;
    });
  };
};

/**
 * Sets up the listening for commands from the content script
 */
WebmailPlugin.prototype.setupCommandListener = function () {
  // Secure Service
  var self = this;
  // Start command listener
  var contentRouter = this.routers.router('content');
  this.secureEmail.setRouter(contentRouter);

  // If activation is completed by the content script (probably via the
  // toolbar) then this is called
  contentRouter.register('activationCompleted', function (params, res) {
    self.activationCompleted(params.activationData);
    res.send(null);
  });

  // Handle revocations and emit the events on the secure service
  contentRouter.register('revoke', function (params, res) {
    self._secureService.emitRevocation(params);
    res.send(null);
  });
  contentRouter.register('refresh-settings-page', function (params, res) {
    self._settingsService.refreshProfile(params);
    self.settings.emit('profile-refreshed');
    res.send(null);
  });
  contentRouter.register('showErrorRefreshPageToast', function (params, res) {
    renderErrorRefreshPageToast();
    res.send(null);
  });
};

/**
 * Refreshes the user profile. After getting a response, it tries again 5 minutes later.
 */
WebmailPlugin.prototype.refreshProfile = function () {
  // Make sure we aren't already running this
  if (refreshingProfile) {
    return;
  }
  refreshingProfile = true;
  this._settingsService.refreshUserProfile().then(function initTimeout() {
    var userSettingsRefreshInterval = this.settings.user.setting('userSettingsRefreshInterval') || USER_PROFILE_REFRESH_INTERVAL_MS;
    setTimeout(function callRefreshAgain() {
      refreshingProfile = false;
      this.refreshProfile();
    }.bind(this), userSettingsRefreshInterval);
  }.bind(this));
};
WebmailPlugin.prototype.getDelegatee = function () {
  // Get last non-empty item in pathname. it is the gmail account index value, works only if /b/ present in url
  const parsedPathName = pathname.split('/').filter(x => x !== '');
  const dIndex = parsedPathName.indexOf('d'); // for newer gmail behavior we can get account index prior to /d/
  const account = dIndex > -1 ? parsedPathName[dIndex - 1] : parsedPathName.pop();
  const strategies = [parseConfig, parseByUrl, parseBySelector, parseByExactSelector];
  let delegateeEmail = null;
  for (let i = 0; i < strategies.length; ++i) {
    const strategy = strategies[i];
    const delegateeEmailMaybe = strategy.call(this, account);
    if (delegateeEmailMaybe) {
      delegateeEmail = delegateeEmailMaybe;
      break;
    }
  }
  if (!delegateeEmail) {
    AnalyticsService.clientError({
      context: 'delegatee_activation',
      name: 'activation_failed',
      webmail_provider: this.settings.site(),
      webmail_version: this.settings.currentVersion()
    });
    throw new Error('Delegatee not found');
  }
  return delegateeEmail;
};

/*
 * The requestedFrom argument is for analytics purposes, it allows us to see from where
 * the user requested to activate.
 *    i.e.
 *       Dropdown (browser action)
 *       Compose window
 *       Read window
 *       Popup modal
 */
WebmailPlugin.prototype.activationRequested = function (activationData) {
  var self = this;
  if (this._isActivationInProgress) {
    return;
  }
  var requestedFrom = typeof activationData.requestedFrom !== 'undefined' ? activationData.requestedFrom : 'unknown';
  var isReactivation = typeof activationData.isReactivation !== 'undefined' ? activationData.isReactivation : false;
  AnalyticsService.activationAttempt({
    userId: this.settings.currentUser(),
    type: requestedFrom,
    isReactivation
  });
  this._isActivationInProgress = true;

  // Delegated emails should not attempt to prevent user interaction with gmail
  if (!delegated) {
    // Clean up if wait screen already has been shown
    if (this.waitScreen) {
      this.waitScreen.closeDialog();
      this.waitScreen.off('activation-requested', this.activationRequested.bind(this));
      this.waitScreen = null;
    }
    this.waitScreen = new WarningPopoverModal({
      headingText: i18n.t('ACTIVATION_WAIT_HEADER'),
      bodyText: i18n.t('ACTIVATION_WAIT_MESSAGE'),
      blueButtonText: i18n.t('COMMON_OK'),
      issuesList: [],
      showWhiteButton: false,
      showBlueButton: true,
      showCancel: false
    });
    this.waitScreen.on('activation-requested', this.activationRequested.bind(this));
    this.waitScreen.openModal();
  }
  var params = {
    userId: this.settings.currentUser(),
    provider: this.settings._provider
  };
  this.settings.user.auth('status', 'pending');
  if (delegated) {
    params.delegatee = this.getDelegatee();
  }
  const getDelegateeSamlAppIdBundle = () => this.transports.call('content', 'getUserSettings', {
    userId: params.delegatee
  }).then(delegateeUserSettings => {
    const delegateeSamlAppIdBundle = delegateeUserSettings.appIdBundles.find(appIdBundle => appIdBundle.mostRecentLogin && appIdBundle.isSaml && appIdBundle.state === 'active');
    if (!delegateeSamlAppIdBundle) {
      throw new Error('Delegatee SAML app id not found');
    }
  });
  this.transports.call('content', 'isSaml', {
    userId: params.userId
  }).then(({
    isSaml
  }) => {
    if (!isSaml) {
      return this.transports.call('content', 'federatedActivate', params);
    }
    if (!delegated) {
      return this.transports.call('content', 'samlActivate', params);
    }
    return getDelegateeSamlAppIdBundle().catch(() => this.transports.call('content', 'samlActivate', {
      provider: params.provider,
      userId: params.delegatee
    })).then(() => this.transports.call('content', 'emailActivate', params));
  }).then(function (activationDataLoc) {
    return Object.assign(activationDataLoc, {
      requestedFrom,
      isReactivation
    });
  }).then(this.activationCompleted.bind(this)).catch(function (err) {
    var _self$waitScreen;
    (_self$waitScreen = self.waitScreen) === null || _self$waitScreen === void 0 ? void 0 : _self$waitScreen.closeDialog();
    self.waitScreen = new WarningPopoverModal(self.getErrorModalOptions(err));
    self.waitScreen.on('activation-requested', self.activationRequested);
    self.waitScreen.openModal();
    self._isActivationInProgress = false;
    AnalyticsService.clientError({
      // Track the error name
      context: err.name ? err.name : 'unknown',
      name: 'activation_failed',
      // Only log if there's not a name that describes the error
      error_obj: err.name ? '' : err,
      webmail_provider: self.settings.site(),
      webmail_version: self.settings.currentVersion()
    });
  });
};

/**
 * Handles the completion of the activation
 *
 * This will be executed from any of the scenarios in which activation is completed
 *
 * @deferred
 */
WebmailPlugin.prototype.activationCompleted = async function (activationData) {
  this._isActivationInProgress = false;
  if (this.waitScreen) {
    this.waitScreen.closeDialog();
  }
  if (activationData.status !== 'success') {
    console.log('activation failed....', activationData);
    AnalyticsService.clientError({
      context: 'activation_attempt',
      name: 'activation_failed',
      error_obj: sanitizeAnalyticsError(activationData),
      webmail_provider: this.settings.site(),
      webmail_version: this.settings.currentVersion()
    });
    return;
  }
  $('.virtru-activation-wait-dialog').removeClass('virtru-activation-failed');
  if (delegated) {
    // Hide activation button
    const $btn = $('.virtru-reactivation-button, .virtru-activation-button');
    $btn.off().attr('style', 'display:none !important');

    // Notify user to stand by
    const $text = $('.virtru-receiver-body-inactive-text');
    $text.html(i18n.t('WEBMAIL_PLUGIN_ACTIVATION_TEXT'));

    // Change first link to re-try logic
    $('.virtru-receiver-link:nth-child(1)').removeAttr('href').text(i18n.t('WEBMAIL_PLUGIN_ACTIVATION_LINK_RETRY')).on('click', () => this.activationRequested({
      requestedFrom: 'try_again_link',
      isReactivation: false
    }));
  }
  AnalyticsService.activationSuccess({
    userId: this.settings.currentUser(),
    type: activationData.requestedFrom,
    isReactivation: activationData.isReactivation
  });
  this.settings.user.setting('firstTime', false);
  if (delegated) {
    this.settings.emit('delegateActivationCompleted');
  }
  const userProfile = await this.loadUserProfile();
  if (activationData.isReactivation) {
    this.settings.emit('reactivation-completed');
  } else {
    // key pair generation only necessary on first activation
    await this.transports.call('content', 'generateAndCacheKeyPair', {});
  }
  return userProfile;
};

/**
 * Load the user profile
 */
WebmailPlugin.prototype.loadUserProfile = function () {
  return this._settingsService.loadUserProfile();
};
/**
 * Handle Activation Errors by updating the wait modal
 */
WebmailPlugin.prototype.getErrorModalOptions = function (err) {
  // Set Modal to be a generic Error Message
  var options = {
    headingText: i18n.t('ACTIVATION_FAILED'),
    bodyText: i18n.t('ACTIVATION_FAILED_GENERAL_BODY'),
    blueButtonText: i18n.t('COMMON_TRY_AGAIN'),
    blueButtonOnClick: () => {
      this.waitScreen.emit('activation-requested', {
        requestedFrom: 'try_again_link',
        isReactivation: false
      });
    },
    issuesList: [],
    showWhiteButton: false,
    showBlueButton: true,
    showCancel: true
  };

  // If the error name is specific adjust Text and button actions based on the error
  if (err.name === 'ActivationTabClosed') {
    options.bodyText = i18n.t('ACTIVATION_WAIT_CANCELED');
  }
  if (err.name === 'PrivateBrowsingModeNotSupported') {
    options.bodyText = i18n.t('ACTIVATION_WAIT_IN_PRIVATE');
  }
  return options;
};

/**
 * Initialize the GmailMonitor
 */
WebmailPlugin.prototype.initializeMonitor = function () {
  this.monitor = window.VIRTRU_MONITOR = this.GmailMonitor.run(this.settings, this.gmailMods.main);
};

/**
 * Implement events for the BaseSettings object.
 */
Emitter(WebmailPlugin.prototype);
exports.WebmailPlugin = WebmailPlugin;

/***/ }),

/***/ 55675:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(47206);

/***/ }),

/***/ 55929:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var Tip = __webpack_require__(8904);
var $ = __webpack_require__(91089);

// default delay for showing the tooltip on mouseover
var DEFAULT_SHOW_DELAY = 500;

/**
 * Initialize a `Popover` with the given `content`
 * and optional `title`.
 *
 * @param {Mixed} content
 * @param {Mixed} title
 * @api public
 */

class Popover extends Tip {
  constructor(content, title) {
    const popover = $(__webpack_require__(64115));
    super(popover);
    this.popover = popover;
    this.classname = 'virtru-popover';
    $(this.el).addClass('popover');
    $(document).on('keydown', event => {
      if (event.key === 'Escape') {
        $(document).off('keydown');
        this.hide();
      }
    });
    if (title) {
      this.title(title);
    } else {
      this.hideTitle();
    }
    this.content(content);
    if (Popover.effect) {
      this.effect(Popover.effect);
    }
    this.enable();
  }

  /**
   * Replace `content`.
   *
   * @param {Mixed} content
   * @return {Popover}
   * @api public
   */
  content(content) {
    this.popover.find('.virtru-popover-content').empty().append(content);
    return this;
  }

  /**
   * Change `title`.
   *
   * @param {String} title
   * @return {Popover}
   * @api public
   */
  title(title) {
    this.popover.find('.virtru-popover-title').empty().append(title);
    return this;
  }

  /**
   * Hide the title.
   *
   * @return {Popover}
   * @api private
   */
  hideTitle() {
    this.popover.find('.virtru-popover-title').remove();
    return this;
  }

  /**
   * Sets a delay for showing tooltips
   *
   * @param {Number} ms (optional)
   * @return {Tip}
   * @api public
   */
  setShowTimer(ms) {
    if (!ms && ms !== 0) {
      ms = DEFAULT_SHOW_DELAY;
    }
    this.showDelay = ms;
    return this;
  }

  /**
   * Hide the tip with optional `ms` delay.
   *
   * Emits "hide" event.
   *
   * @param {Number} ms
   * @return {Tip}
   * @api public
   */
  hide(ms) {
    // clear the show timer
    if (this._showTimer) {
      clearTimeout(this._showTimer);
    }

    // continue normally
    Tip.prototype.hide.call(this, ms);
    return this;
  }

  /**
   * Sets up a delay before actually showing the tooltip
   *
   * @param {String|Element|Number} el or x
   * @param {Number} [y]
   * @return {Tip}
   * @api public
   */
  show(el) {
    if (!this.enabled) {
      return;
    }
    if (this.showDelay) {
      // if timer already exists, get rid of it
      if (this._showTimer) {
        clearTimeout(this._showTimer);
      }

      // set a delay for showing the popover
      var self = this;
      this._showTimer = setTimeout(function () {
        Tip.prototype.show.call(self, el);
      }, this.showDelay);
      return this;
    }

    // show the popover
    Tip.prototype.show.call(this, el);
    return this;
  }

  // enables the popover
  enable() {
    this.enabled = true;
    return this;
  }
  focus() {
    this.el.trigger('focus');
    return this;
  }

  // disables the popover
  disable() {
    this.enabled = false;
    return this;
  }
}

/**
 * Expose `Popover`.
 */

module.exports = Popover;

/***/ }),

/***/ 56062:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   virtruOnboardingV2: () => (/* binding */ virtruOnboardingV2)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const virtruOnboardingV2 = () => `
  <div aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('PROTECTION_OVERVIEW_POPUP')}" class="virtru-onboarding-modal-v2">
    <div class="onboardv2 onboardv2--normal">
      <div class="tour-popover-close">
        <button aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('PROTECTION_OVERVIEW_POPUP_CLOSE')}" class="tour-x-button" tabIndex="1" role="button"></button>
      </div>
      <div class="onboardv2__hero"></div>
      <h1 class="onboardv2__heading"></h1>
      <p class="onboardv2__body"></p>
      <div class="onboardv2__actions onboardv2__column-actions">
        <button class="onboardv2__confirm" tabindex="1" role="button"></button>
        <label class="onboardv2__checkbox">
          <input type="checkbox" tabindex="1" role="checkbox" />
          <span class="onboardv2__checkbox-alias"></span>
          <span class="onboardv2__checkbox-label"></span>
        </label>
      </div>
    </div>
  </div>
`;

/***/ }),

/***/ 56119:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Generate fake locale for i18n testing purposes using dictionary
 */
const originalLocale = __webpack_require__(25026);
const brackets = {
  '{': '}',
  '<': '>'
};
const dictionary = {
  a: '',
  b: '',
  c: '',
  d: '',
  e: '',
  f: '',
  g: '',
  h: '',
  i: '',
  j: '',
  k: '',
  l: '',
  m: '',
  n: '',
  o: '',
  p: '',
  q: '',
  r: '',
  s: '',
  t: '',
  u: '',
  w: '',
  v: '',
  x: '',
  y: '',
  z: '',
  A: '',
  B: '',
  C: '',
  D: '',
  E: '',
  F: '',
  G: '',
  H: '',
  I: '',
  J: '',
  K: '',
  L: '',
  M: '',
  N: '',
  O: '',
  P: '',
  Q: '',
  R: '',
  S: '',
  T: '',
  U: '',
  W: '',
  V: '',
  X: '',
  Y: '',
  Z: ''
};

/**
 * Replace characters in string using dictionary. Keeps original data between brackets and in HTML tags
 * @param {string} input - The string from original locale
 * @returns {string} - The string with replaced characters
 */
const replaceInString = input => {
  const preserve = [];
  let output = '';
  for (let i = 0; i < input.length; i++) {
    if (Object.keys(brackets).includes(input[i])) {
      preserve.push(brackets[input[i]]);
    } else if (input[i] === preserve[preserve.length - 1]) {
      preserve.pop();
    }
    output += !preserve.length && dictionary[input[i]] || input[i];
  }
  return output;
};

/**
 * Replace characters in array
 * @param {Array} input - The array of original strings
 * @returns {Array} - The array of modified strings
 */
const replaceInArray = input => input.map(value => replaceInString(value));

/**
 * Recursive loop for embedded objects
 * @param {string} key - The key of character to replace
 * @param {string} value - The character to replace
 * @returns {string} - The string with replaced characters
 */
const replacer = (key, value) => {
  if (Array.isArray(value)) {
    return replaceInArray(value);
  } else if (typeof value === 'object') {
    const obj = {};
    Object.keys(value).forEach(prop => {
      obj[prop] = replacer(prop, value[prop]);
    });
    return obj;
  } else if (value) {
    return replaceInString(value);
  }
  throw new Error('Incorrect value format');
};

// TO DO: fine tuning
// Removing full strings raises a bug reproduced only in testing phase
// (words 'Today' and 'Tomorrow' displayed in English)
const datetimePropsList = ['MOMENT_CALENDAR_RECIPIENT_EXPIRATION', 'MOMENT_CALENDAR_SENDER_EXPIRED', 'MOMENT_CALENDAR_SENDER_EXPIRING_SOON', 'MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE'];
const datetimeProps = datetimePropsList.reduce((obj, prop) => {
  obj[prop] = originalLocale[prop];
  return obj;
}, {});
const filteredLocale = datetimePropsList.reduce((obj, prop) => {
  delete obj[prop];
  return obj;
}, originalLocale);

/**
 * Custom JSON parser
 * @type {Object}
 */
const locale = Object.assign(JSON.parse(JSON.stringify(filteredLocale), (key, value) => {
  if (key && value) {
    value = replacer(key, value);
  }
  return value;
}), datetimeProps);
module.exports = exports = locale;

/***/ }),

/***/ 56183:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 56282:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NewComposeInsertPhotosMod: () => (/* binding */ NewComposeInsertPhotosMod)
/* harmony export */ });
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4424);

var $ = __webpack_require__(55401);
var contexts = __webpack_require__(47446);
var mods = __webpack_require__(25939);
var Emitter = __webpack_require__(16502);
var i18n = __webpack_require__(2622);

/**
 * The attach button mod
 */
class NewComposeInsertPhotosMod extends mods.Mod {
  static mainDomKey = 'NEW_COMPOSE_INSERT_PHOTOS_DIALOG';
  constructor(settings, element) {
    super(settings, element);
    this._settings = settings;
    this._element = $(element);
    (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__._bindAllMethods)(this);
  }
  setup() {
    var composeId = this._settings.user.setting('insert:photos:composeid');
    this._settings.user.setting('insert:photos:composeid', '');
    if (!composeId) {
      return;
    }
    var {
      dom
    } = this._settings;
    this.selectExternal($(dom.NEW_COMPOSE_INSERT_PHOTOS_EXTERNAL));
    this.cloneExisting($(dom.NEW_COMPOSE_INSERT_PHOTOS_YOUR_IMAGES));
    this.showWarning();
    this.disableLocal($(dom.NEW_COMPOSE_INSERT_PHOTOS_LOCAL));
  }
  isAlive() {
    return $.contains(document.documentElement, this._element[0]);
  }
  teardown() {}
  cloneExisting($div) {
    // Clone and style the container div
    var $clone = $div.clone();
    $clone.addClass('virtru-disabled-photos-your');
    $clone.insertBefore($div);
    $div.hide();

    // Override the styling on the text
    var $text = $('.Lw-Kx-KU-J9', $clone);
    $text.removeClass('Lw-Kx-KU-J9');
    $text.addClass('virtru-disabled-photos-your-text');

    // Add a warning icon after the text
    var $warn = $('<td>', {
      'class': 'virtru-disabled-photos-warn-image',
      'style': 'padding-top: 12px;'
    });
    $warn.insertAfter($text);
  }
  showWarning() {
    var $warn = $('<div>', {
      'class': 'virtru-disabled-photos-warn-parent'
    });
    $warn.append($('<div>', {
      'class': 'virtru-disabled-photos-warn-image'
    }));
    $warn.append($('<div>', {
      'class': 'virtru-disabled-photos-warn-text',
      text: i18n.t('COMPOSE_INSERT_PHOTOS_INLINE_IMAGES')
    }));
    var $cancel = $('button[name="cancel"]');
    $warn.insertAfter($cancel);
  }
  disableLocal($local) {
    $local.removeAttr('checked');
    $local.attr('disabled', 'disabled');
  }
  selectExternal($external) {
    $external.attr('checked', 'checked');
    $external.triggerNative('click');
  }
}
Emitter(NewComposeInsertPhotosMod.prototype);
Object.assign(NewComposeInsertPhotosMod.prototype, mods.ModWaiterPromises);
Object.assign(NewComposeInsertPhotosMod.prototype, mods.ModElementShortcut);
Object.assign(NewComposeInsertPhotosMod.prototype, mods.ModEventListenerShortcut);
contexts.addOpen(NewComposeInsertPhotosMod);

/***/ }),

/***/ 57500:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const contexts = __webpack_require__(47446);
const $ = __webpack_require__(55401);
const printUtils = __webpack_require__(91090);
const linkEls = document.querySelectorAll('link');
const printStylesEl = Array.from(linkEls).find(linkEl => linkEl.href.endsWith('css/print.css'));
module.exports = PrintAll;

/**
 * Sets up printing a thread
 *
 * @param {GmailSettings} settings
 * @param {HTMLElement} element - DOM element
 */
function PrintAll(settings, element) {
  this.settings = settings;
  this.element = element;
  this.setup(settings, element);
}
PrintAll.mainDomKey = 'PRINT_ALL';

/**
 * Sets up the print button on top of thread.
 * We only use the first opened message to determine if the thread is encrypted.
 *
 * @param {GmailSettings} settings
 * @param {HTMLElement} element
 */
PrintAll.prototype.setup = function (settings, element) {
  element.classList.add(settings.processedClass);

  // Print container might have previous messages, so need to scope this
  const $messagesToPrint = $(settings.dom.READ_CONTAINER).find(settings.dom.MESSAGES);
  if (!printUtils.hasEncryptedContent($messagesToPrint, settings.dom)) {
    this.teardownAll();
    return;
  }
  printStylesEl.disabled = false;
  const clone = element.cloneNode(true);
  clone.id = 'virtru-print-all';
  clone.onclick = function (e) {
    e.preventDefault();
    e.stopPropagation();
    const colapsedMessages = $(settings.dom.READ_CONTAINER).find(settings.dom.COLLAPSED_MESSAGE);
    const expandAllButton = $(settings.dom.EXPAND_ALL);
    if (colapsedMessages.length && expandAllButton.length) {
      // We let Gmail open up all messages, so that we can decrypt them
      expandAllButton.click();
    }

    // We keep checking during each animation frame to see if all messages have been decrypted
    window.requestAnimationFrame(function loop() {
      const animations = document.getElementsByClassName('virtru-animation-widget');
      if (animations.length) {
        window.requestAnimationFrame(loop);
      } else {
        printUtils.print(settings);
      }
    });
  };
  printUtils.addHover(clone, 'T-I-JW');
  element.parentNode.replaceChild(clone, element);
};

// @NOTE: This sometimes does not fire as expected, so we also fire it for non-encrypted chains
PrintAll.prototype.teardownAll = function () {
  printStylesEl.disabled = true;
};
PrintAll.prototype.setupAll = function () {};

// Alive while looking at a thread
PrintAll.prototype.isAlive = function () {
  return $(this.settings.dom.PRINT_ALL).length;
};
contexts.addOpen(PrintAll);

/***/ }),

/***/ 58533:
/***/ ((module, exports, __webpack_require__) => {

const Utils = __webpack_require__(55675);

/**
 * Handles transports between script layers
 */
function ScriptTransport(options) {
  this._requestAdapter = options.requestAdapter;
}

/**
 * @static
 *
 * Create a new script transport
 *
 * @param {Object} options The options for the transport
 * @param {Function} options.requestAdapter The adapter used to communicate
 *                                          across transport layers. This is
 *                                          meant to be defined per browser.
 *
 * @returns {ScriptTransport} The new script transport
 */
ScriptTransport.setup = function (options) {
  return new ScriptTransport(options);
};

/**
 * Calls the script with a given command
 *
 * @param {String} command The command to call at the other script
 * @param {Object} params An object containing the command parameters
 */
ScriptTransport.prototype.call = function (command, params) {
  return new Promise((resolve, reject) => {
    const responder = function (err, responseMessage) {
      if (err) {
        reject(Utils.formatForTransport(err));
      } else {
        resolve(responseMessage);
      }
    };
    const progressUpdater = function () {
      /* noop */
    };
    this._requestAdapter(command, params, responder, progressUpdater, false);
  });
};

/**
 * Calls the script with a given command
 *
 * @param {String} command The command to call at the other script
 * @param {Object} params An object containing the command parameters
 */
ScriptTransport.prototype.broadcast = function (command, params) {
  return new Promise((resolve, reject) => {
    const responder = function (err, responseMessage) {
      if (err) {
        reject(Utils.formatForTransport(err));
      } else {
        resolve(responseMessage);
      }
    };
    const progressUpdater = function () {
      /* noop */
    };
    this._requestAdapter(command, params, responder, progressUpdater, true);
  });
};

/**
 * A registry of script transports
 */
function ScriptTransportRegistry() {
  this._registry = {};
}

/**
 * @static
 *
 * Setup a registry
 *
 * @returns {ScriptTransportRegistry} The new registry
 */
ScriptTransportRegistry.setup = function () {
  return new ScriptTransportRegistry();
};

/**
 * Register a new script transport
 *
 * @param {String} scriptType The name of the script transport
 * @param {ScriptTransport} transport The script transport to register
 */
ScriptTransportRegistry.prototype.registerTransport = function (scriptType, transport) {
  this._registry[scriptType] = transport;
};

/**
 * Call a script transport of a particular name
 *
 * @param {String} scriptType The name of the script transport to call
 * @param {String} command The command to call
 * @param {Object} params Parameters for command. Optional
 */
ScriptTransportRegistry.prototype.call = function (scriptType, command, params) {
  const transport = this._registry[scriptType];
  if (transport === undefined) {
    throw new Error(`Transport ${scriptType} does not exist`);
  }
  return transport.call(command, params);
};

/**
 * Call a script transport of a particular name
 *
 * @param {String} scriptType The name of the script transport to call
 * @param {String} command The command to call
 * @param {Object} params Parameters for command. Optional
 */
ScriptTransportRegistry.prototype.broadcast = function (scriptType, command, params) {
  const transport = this._registry[scriptType];
  if (transport === undefined) {
    throw new Error(`Transport ${scriptType} does not exist`);
  }
  return transport.broadcast(command, params);
};

// Make a singleton script transport registry
exports = module.exports = ScriptTransportRegistry.setup();
// Also expose the ScriptTransport classes
exports.ScriptTransport = ScriptTransport;
exports.ScriptTransportRegistry = ScriptTransportRegistry;

/***/ }),

/***/ 58665:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  A: () => (/* binding */ modals_renderModal)
});

// UNUSED EXPORTS: renderer

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(87568);
// EXTERNAL MODULE: ./components/createReactRoot.js
var createReactRoot = __webpack_require__(72213);
// EXTERNAL MODULE: ./node_modules/@virtru-private/design-system/dist/node_modules/@mui/material/Typography/Typography.js
var Typography = __webpack_require__(16422);
// EXTERNAL MODULE: ./lib/i18n/index.js
var i18n = __webpack_require__(2622);
var i18n_default = /*#__PURE__*/__webpack_require__.n(i18n);
;// ./images/encrypted-lock.svg
var _path;
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }

var SvgEncryptedLock = function SvgEncryptedLock(props) {
  return /*#__PURE__*/react.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 74,
    height: 91,
    fill: "none"
  }, props), _path || (_path = /*#__PURE__*/react.createElement("path", {
    fill: "#004987",
    d: "M30.188 59.125h13.625L41.2 44.478a8.6 8.6 0 0 0 3.577-3.293q1.305-2.157 1.305-4.768 0-3.747-2.668-6.416-2.668-2.667-6.415-2.668-3.747 0-6.415 2.669-2.668 2.667-2.668 6.415 0 2.61 1.305 4.768a8.6 8.6 0 0 0 3.577 3.293zM37 90.917q-15.782-3.974-26.058-18.11T.667 41.413V13.708L37 .083l36.333 13.625v27.705q0 17.258-10.275 31.394T37 90.917m0-9.538q11.808-3.747 19.53-14.987 7.72-11.24 7.72-24.98V19.954L37 9.734 9.75 19.954v21.459q0 13.738 7.72 24.979Q25.193 77.632 37 81.379"
  })));
};
/* harmony default export */ const encrypted_lock = (SvgEncryptedLock);
// EXTERNAL MODULE: ./node_modules/@virtru-private/design-system/dist/node_modules/@mui/material/Modal/Modal.js
var Modal = __webpack_require__(57642);
// EXTERNAL MODULE: ./node_modules/@virtru-private/design-system/dist/node_modules/@mui/material/Box/Box.js + 2 modules
var Box = __webpack_require__(58402);
// EXTERNAL MODULE: ./node_modules/@virtru-private/design-system/dist/node_modules/@mui/material/Button/Button.js + 1 modules
var Button = __webpack_require__(38696);
;// ./components/modals/new-feature-adv/NewFeatureModal.js
function NewFeatureModal_extends() { return NewFeatureModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, NewFeatureModal_extends.apply(null, arguments); }



function NewFeatureModal({
  heading,
  subHeading,
  children,
  iconComponent,
  actionText,
  cancelText,
  handleClose,
  handleAction,
  ...restProps
}) {
  const actionHandler = () => {
    handleAction();
    handleClose();
  };
  const chipText = i18n_default().t('FEATURE_CHIP_TEXT');
  const slotProps = {
    backdrop: {
      className: 'virtru-new-feature-adv-modal-backdrop'
    }
  };
  return /*#__PURE__*/react.createElement(Modal/* default */.A, NewFeatureModal_extends({}, restProps, {
    onClose: handleClose,
    slotProps: slotProps,
    className: "virtru-new-feature-adv-modal",
    "aria-labelledby": "virtru-new-feature-proposition",
    "aria-describedby": "virtru-new-feature-proposition",
    disableAutoFocus: true
  }), /*#__PURE__*/react.createElement(Box/* default */.A, {
    className: "virtru-new-feature-adv-modal-box"
  }, /*#__PURE__*/react.createElement(Typography/* default */.A, {
    variant: "button",
    className: "virtru-new-feature-adv-modal-chip"
  }, chipText), iconComponent, /*#__PURE__*/react.createElement(Typography/* default */.A, {
    variant: "h4"
  }, heading), /*#__PURE__*/react.createElement(Typography/* default */.A, {
    variant: "subtitle1",
    className: "virtru-new-feature-adv-modal-sub-heading"
  }, subHeading), children, /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "contained",
    className: "virtru-new-feature-adv-modal-action-button",
    onClick: actionHandler
  }, actionText), /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "text",
    onClick: handleClose
  }, cancelText)));
}
;// ./components/modals/new-feature-adv/NewFeatureVault.js
function NewFeatureVault_extends() { return NewFeatureVault_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, NewFeatureVault_extends.apply(null, arguments); }





const supportTicketUrl = 'https://support.virtru.com/hc/en-us/requests/new?ticket_form_id=666907';
function NewFeatureVault(props) {
  const handleAction = () => {
    window.open(supportTicketUrl, '_blank', 'noopener,noreferrer');
    props.handleClose();
  };
  const heading = i18n_default().t('FEATURE_VAULT_TITLE_TEXT');
  const subHeading = i18n_default().t('FEATURE_VAULT_SUB_TITLE_TEXT');
  const actionText = i18n_default().t('FEATURE_VAULT_BUTTON');
  const cancelText = i18n_default().t('FEATURE_VAULT_CANCEL');
  const description = i18n_default().t('FEATURE_VAULT_DESCRIPTION', {
    returnObjects: true
  });
  const contactVirtru = description.pop();
  const renderDescriptionListItem = (text, idx) => /*#__PURE__*/react.createElement("li", {
    key: idx
  }, /*#__PURE__*/react.createElement(Typography/* default */.A, {
    variant: "body1"
  }, text));
  return /*#__PURE__*/react.createElement(NewFeatureModal, NewFeatureVault_extends({
    heading: heading,
    subHeading: subHeading,
    actionText: actionText,
    cancelText: cancelText,
    iconComponent: /*#__PURE__*/react.createElement(encrypted_lock, null),
    handleAction: handleAction
  }, props), /*#__PURE__*/react.createElement("ul", null, description.map(renderDescriptionListItem)), /*#__PURE__*/react.createElement(Typography/* default */.A, {
    variant: "subtitle1"
  }, contactVirtru));
}
// EXTERNAL MODULE: ./node_modules/@virtru-private/design-system/dist/node_modules/@mui/material/Link/Link.js + 2 modules
var Link = __webpack_require__(10855);
;// ./images/search-magnifying-glass.svg
var search_magnifying_glass_path;
function search_magnifying_glass_extends() { return search_magnifying_glass_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, search_magnifying_glass_extends.apply(null, arguments); }

var SvgSearchMagnifyingGlass = function SvgSearchMagnifyingGlass(props) {
  return /*#__PURE__*/react.createElement("svg", search_magnifying_glass_extends({
    xmlns: "http://www.w3.org/2000/svg",
    width: 82,
    height: 83,
    fill: "none"
  }, props), search_magnifying_glass_path || (search_magnifying_glass_path = /*#__PURE__*/react.createElement("path", {
    fill: "#004987",
    d: "M75.517 82.375 46.904 53.763q-3.405 2.724-7.834 4.314-4.428 1.59-9.424 1.59-12.376 0-20.949-8.573Q.125 42.522.125 30.146T8.697 9.197 29.646.625t20.948 8.572 8.573 20.949q0 4.996-1.59 9.424t-4.314 7.834l28.612 28.613zM29.646 50.583q8.515 0 14.476-5.96 5.961-5.962 5.961-14.477t-5.96-14.477Q38.16 9.71 29.645 9.71t-14.477 5.96Q9.21 21.63 9.21 30.146t5.96 14.476 14.477 5.961"
  })));
};
/* harmony default export */ const search_magnifying_glass = (SvgSearchMagnifyingGlass);
;// ./components/modals/new-feature-adv/NewFeatureEncryptedSearch.js
function NewFeatureEncryptedSearch_extends() { return NewFeatureEncryptedSearch_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, NewFeatureEncryptedSearch_extends.apply(null, arguments); }





const controlCenterOrgSettingsUrl = 'https://secure.virtru.com/control-center/org-settings';
const whatIsSecureSearchUrl = 'https://support.virtru.com/hc/en-us/articles/360039151953-What-is-Encrypted-Search';
function NewFeatureEncryptedSearch(props) {
  const handleAction = () => {
    window.open(controlCenterOrgSettingsUrl, '_blank', 'noopener,noreferrer');
    props.handleClose();
  };
  const handleFaqClick = () => {
    window.open(whatIsSecureSearchUrl, '_blank', 'noopener,noreferrer');
    props.handleClose();
  };
  const heading = i18n_default().t('FEATURE_ENCRYPTED_SEARCH_TITLE_TEXT');
  const subHeading = i18n_default().t('FEATURE_ENCRYPTED_SEARCH_SUB_TITLE_TEXT');
  const actionText = i18n_default().t('FEATURE_ENCRYPTED_SEARCH_BUTTON');
  const cancelText = i18n_default().t('FEATURE_ENCRYPTED_SEARCH_CANCEL');
  const [line1, line2] = i18n_default().t('FEATURE_ENCRYPTED_SEARCH_DESCRIPTION', {
    returnObjects: true
  });
  const linkText = i18n_default().t('FAQ');
  const [textStart, textEnd] = line2.split(linkText);
  return /*#__PURE__*/react.createElement(NewFeatureModal, NewFeatureEncryptedSearch_extends({
    heading: heading,
    subHeading: subHeading,
    actionText: actionText,
    cancelText: cancelText,
    iconComponent: /*#__PURE__*/react.createElement(search_magnifying_glass, null),
    handleAction: handleAction
  }, props), /*#__PURE__*/react.createElement(Typography/* default */.A, {
    variant: "body1",
    className: "virtru-new-feature-adv-modal-es-body"
  }, line1, /*#__PURE__*/react.createElement("br", null), textStart, /*#__PURE__*/react.createElement(Link/* default */.A, {
    href: whatIsSecureSearchUrl,
    onClick: handleFaqClick,
    target: "_blank",
    rel: "noopener noreferrer",
    "data-testid": "encrypted-search-modal-faq-link"
  }, linkText), textEnd));
}
;// ./components/modals/BaseModal.js
function BaseModal_extends() { return BaseModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, BaseModal_extends.apply(null, arguments); }


function BaseModal({
  title,
  description,
  iconComponent,
  actionText,
  cancelText,
  handleClose,
  handleAction,
  ...restProps
}) {
  const actionHandler = () => {
    handleAction();
    if (handleClose) {
      handleClose();
    }
  };
  const slotProps = {
    backdrop: {
      className: 'virtru-mui-modal-backdrop'
    }
  };
  return /*#__PURE__*/react.createElement(Modal/* default */.A, BaseModal_extends({}, restProps, {
    onClose: handleClose,
    slotProps: slotProps,
    className: "virtru-mui-modal",
    disableAutoFocus: true
  }), /*#__PURE__*/react.createElement(Box/* default */.A, {
    className: "virtru-mui-modal-container"
  }, /*#__PURE__*/react.createElement(Box/* default */.A, {
    className: "virtru-mui-modal-title-container"
  }, iconComponent, /*#__PURE__*/react.createElement(Typography/* default */.A, {
    className: "virtru-mui-modal-title",
    variant: "h6"
  }, title)), description && /*#__PURE__*/react.createElement(Typography/* default */.A, {
    className: "virtru-mui-modal-description",
    variant: "body1"
  }, description), /*#__PURE__*/react.createElement(Box/* default */.A, {
    className: "virtru-mui-modal-button-container"
  }, cancelText && /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "text",
    onClick: handleClose
  }, cancelText), /*#__PURE__*/react.createElement(Button/* default */.A, {
    variant: "contained",
    className: "virtru-mui-modal-action-button",
    onClick: actionHandler
  }, actionText))));
}
// EXTERNAL MODULE: ./lib/analytics/index.js
var analytics = __webpack_require__(1246);
// EXTERNAL MODULE: ./lib/utils/sanitizeAnalyticsError.js
var sanitizeAnalyticsError = __webpack_require__(81442);
;// ./components/modals/action/utils.js


const analyticsService = analytics.instance();
const getAuditRecord = (type, details) => ({
  auditRecord: {
    action: 'create',
    details,
    type
  }
});
const logAuditEvent = async ({
  event,
  transports,
  logData,
  callback
}) => {
  try {
    await transports.call('content', 'sendAuditRecord', getAuditRecord(event, logData));
  } catch (err) {
    analyticsService.clientError({
      context: event,
      name: 'bp-invite-to-ss',
      error_obj: (0,sanitizeAnalyticsError/* default */.A)(err)
    }, true);
  } finally {
    if (callback) {
      callback();
    }
  }
};
function getLogger({
  user,
  transports,
  handleClose
}) {
  const {
    userId,
    org
  } = user._profile.settings;
  const logData = {
    userId,
    orgId: org.id
  };
  return {
    async modalShown() {
      analyticsService.suggestSecureShareModalShown(logData);
      await logAuditEvent({
        event: 'bpGoToSsShown',
        transports,
        logData
      });
    },
    async wentToSecureShare() {
      analyticsService.accessedSecureShareFromBP(logData);
      await logAuditEvent({
        event: 'bpUserNavToSs',
        transports,
        logData,
        callback: handleClose
      });
    }
  };
}
;// ./components/modals/action/constants.js
const domainDisabledUrl = 'https://www.virtru.com/domain-disabled';
const secureShareUrl = 'https://secure.virtru.com/secure-share';
const virtruSecureShare = 'Virtru Secure Share';
;// ./components/modals/utils.js
const secureShareMaxSize = 5; // 5 GB
const friendlySize = 150; // MB
const fipsFriendlySize = 80;
function attachmentTooLargeMaxSizes(user = {}) {
  const {
    permissions
  } = user || {};
  const {
    enforceFips
  } = permissions || {};
  const maxSizeMb = enforceFips ? fipsFriendlySize : friendlySize;
  return {
    maxSizeMb,
    secureShareMaxSize
  };
}
;// ./components/modals/action/SuggestSecureShare.js






function SuggestSecureShare(props) {
  const {
    user
  } = props;
  const description = i18n_default().t('ATTACHMENT_TOO_LARGE_SUGGEST_SECURE_SHARE_TEXT', attachmentTooLargeMaxSizes(user));
  const [textStart, textEnd] = description.split(virtruSecureShare);
  const log = getLogger(props);
  (0,react.useEffect)(() => {
    async function logModalShown() {
      await log.modalShown();
    }
    logModalShown();
  }, []);
  async function onClick() {
    await log.wentToSecureShare();
  }
  return /*#__PURE__*/react.createElement(react.Fragment, null, textStart, /*#__PURE__*/react.createElement(Link/* default */.A, {
    onClick: onClick,
    href: secureShareUrl,
    target: "_blank",
    rel: "noopener noreferrer"
  }, virtruSecureShare), textEnd);
}
;// ./components/modals/action/modalTypes.js
function modalTypes_extends() { return modalTypes_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, modalTypes_extends.apply(null, arguments); }





const modalTypes = {
  virtruDisabledOnDomain: {
    title: i18n_default().t('VIRTRU_DISABLED_ON_DOMAIN'),
    description: i18n_default().t('VIRTRU_CONTACT_US'),
    actionText: i18n_default().t('LEARN_MORE'),
    cancelText: i18n_default().t('ATTACHMENT_GENERIC_ERROR_BUTTON'),
    handleAction() {
      window.open(domainDisabledUrl, '_blank', 'noopener,noreferrer');
    }
  },
  suggestSecureShare: (props = {}) => {
    const log = getLogger(props);
    const handleAction = () => {
      window.open(secureShareUrl, '_blank', 'noopener,noreferrer');
      return log.wentToSecureShare();
    };
    return {
      title: i18n_default().t('ATTACHMENT_TOO_LARGE_HEADER'),
      description: /*#__PURE__*/react.createElement(SuggestSecureShare, modalTypes_extends({}, props, {
        handleAction: handleAction
      })),
      actionText: i18n_default().t('GO_TO_SECURE_SHARE'),
      cancelText: i18n_default().t('COMMON_CLOSE'),
      handleAction
    };
  }
};
/* harmony default export */ const action_modalTypes = (modalTypes);
;// ./components/modals/action/ActionModal.js
function ActionModal_extends() { return ActionModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, ActionModal_extends.apply(null, arguments); }



function ActionModal(props) {
  const {
    open,
    type,
    handleAction,
    handleClose
  } = props;
  const mappedProps = action_modalTypes[type];
  const typeProps = typeof mappedProps === 'function' ? mappedProps(props) : {
    ...mappedProps
  };
  return /*#__PURE__*/react.createElement(BaseModal, ActionModal_extends({
    open: open,
    handleAction: handleAction,
    handleClose: handleClose
  }, typeProps));
}
;// ./images/warn_24_a70a0d.svg
var _g;
function warn_24_a70a0d_extends() { return warn_24_a70a0d_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, warn_24_a70a0d_extends.apply(null, arguments); }

var SvgWarn24A70A0D = function SvgWarn24A70A0D(props) {
  return /*#__PURE__*/react.createElement("svg", warn_24_a70a0d_extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, props), _g || (_g = /*#__PURE__*/react.createElement("g", {
    "data-name": "Layer 2"
  }, /*#__PURE__*/react.createElement("path", {
    fill: "none",
    d: "M0 0h24v24H0z",
    "data-name": "under square"
  }), /*#__PURE__*/react.createElement("g", {
    "data-name": "Layer 1"
  }, /*#__PURE__*/react.createElement("path", {
    fill: "none",
    stroke: "#a70a0d",
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M1 21 12 3l11 18zM12 10.1V14"
  }), /*#__PURE__*/react.createElement("circle", {
    cx: 12,
    cy: 17,
    r: 1,
    fill: "#a70a0d"
  })))));
};
/* harmony default export */ const warn_24_a70a0d = (SvgWarn24A70A0D);
;// ./components/modals/error/modalTypes.js


const modalTypes_modalTypes = {
  attachmentTooLarge: ({
    user
  } = {}) => ({
    title: i18n_default().t('ATTACHMENT_TOO_LARGE_HEADER'),
    description: i18n_default().t('ATTACHMENT_TOO_LARGE_TEXT', attachmentTooLargeMaxSizes(user)),
    noIcon: true
  }),
  plainTextNotSupported: {
    title: i18n_default().t('PLAINTEXT_NOT_SUPPORTED_HEADER'),
    description: i18n_default().t('PLAINTEXT_NOT_SUPPORTED_TEXT'),
    noIcon: true
  },
  unsecureAttachmentsPresent: {
    title: i18n_default().t('UNSECURE_ATTACHMENTS_EXIST_HEADER'),
    description: i18n_default().t('UNSECURE_ATTACHMENTS_EXIST_TEXT')
  },
  webmailPluginInitError: {
    title: i18n_default().t('WEBMAIL_PLUGIN_INIT_ERROR_HEADER'),
    description: i18n_default().t('WEBMAIL_PLUGIN_INIT_ERROR')
  },
  attachmentPfpError: ({
    description
  }) => ({
    title: i18n_default().t('ATTACHMENT_PFP_ERROR_HEADER'),
    description
  }),
  attachmentGenericError: ({
    description
  }) => ({
    title: i18n_default().t('ATTACHMENT_GENERIC_ERROR_HEADER'),
    description: description || i18n_default().t('ATTACHMENT_GENERIC_ERROR_TEXT')
  }),
  attachmentNetworkConnectionError: {
    title: i18n_default().t('ATTACHMENT_CONNECTION_ERROR_HEADER'),
    description: i18n_default().t('ATTACHMENT_CONNECTION_ERROR_TEXT')
  },
  attachmentAppIdError: {
    title: i18n_default().t('ATTACHMENT_APPID_ERROR_HEADER'),
    description: i18n_default().t('ATTACHMENT_APPID_ERROR_TEXT')
  },
  offline: ({
    secureMode
  }) => {
    const mode = secureMode ? 'ON' : 'OFF';
    return {
      title: i18n_default().t(`OFFLINE_MODE_MODAL.PROTECTION_${mode}.TITLE`),
      description: i18n_default().t(`OFFLINE_MODE_MODAL.PROTECTION_${mode}.BODY`),
      noIcon: true
    };
  },
  basicModeNotSupported: {
    title: i18n_default().t('GMAIL_BASIC_MODE_UNSUPPORTED_MAIN'),
    description: i18n_default().t('GMAIL_BASIC_MODE_UNSUPPORTED_SUB')
  }
};
/* harmony default export */ const error_modalTypes = (modalTypes_modalTypes);
;// ./components/modals/error/ErrorModal.js
function ErrorModal_extends() { return ErrorModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, ErrorModal_extends.apply(null, arguments); }





function ErrorModal(props) {
  const {
    type,
    handleClose,
    open
  } = props;
  const mappedProps = error_modalTypes[type];
  const {
    noIcon,
    ...typeProps
  } = typeof mappedProps === 'function' ? mappedProps(props) : {
    ...mappedProps
  };
  return /*#__PURE__*/react.createElement(BaseModal, ErrorModal_extends({
    open: open,
    handleAction: handleClose,
    actionText: i18n_default().t('COMMON_OK'),
    iconComponent: noIcon ? null : /*#__PURE__*/react.createElement(warn_24_a70a0d, {
      style: {
        width: 24
      }
    })
  }, typeProps));
}
;// ./components/modals/renderModal.js
function renderModal_extends() { return renderModal_extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, renderModal_extends.apply(null, arguments); }






const ROOT_ID = 'virtru-modal-react-root';
function renderer(Modal, props = {}) {
  const reactRoot = (0,createReactRoot/* default */.A)({
    rootId: ROOT_ID
  });
  function handleClose() {
    if (props.handleClose) {
      props.handleClose();
    }
    reactRoot.render(null);
  }
  reactRoot.render(/*#__PURE__*/react.createElement(Modal, renderModal_extends({}, props, {
    handleClose: handleClose,
    open: true
  })));
}
const renderModal = {
  // New Feature modals
  advertiseVault(user) {
    renderer(NewFeatureVault, {
      user
    });
  },
  advertiseEncryptedSearch() {
    renderer(NewFeatureEncryptedSearch);
  },
  // Actions
  virtruDisabledOnDomain() {
    renderer(ActionModal, {
      type: 'virtruDisabledOnDomain'
    });
  },
  suggestSecureShare(user, transports) {
    renderer(ActionModal, {
      type: 'suggestSecureShare',
      user,
      transports
    });
  },
  // Errors
  attachmentTooLarge(user) {
    renderer(ErrorModal, {
      type: 'attachmentTooLarge',
      user
    });
  },
  plainTextNotSupported() {
    renderer(ErrorModal, {
      type: 'plainTextNotSupported'
    });
  },
  unsecureAttachmentsPresent() {
    renderer(ErrorModal, {
      type: 'unsecureAttachmentsPresent'
    });
  },
  webmailPluginInitError() {
    renderer(ErrorModal, {
      type: 'webmailPluginInitError'
    });
  },
  attachmentPfpError(description, handleClose) {
    renderer(ErrorModal, {
      type: 'attachmentPfpError',
      description,
      handleClose
    });
  },
  attachmentGenericError(props = {}) {
    renderer(ErrorModal, {
      type: 'attachmentGenericError',
      ...props
    });
  },
  attachmentNetworkConnectionError(handleClose) {
    renderer(ErrorModal, {
      type: 'attachmentNetworkConnectionError',
      handleClose
    });
  },
  attachmentAppIdError(handleClose) {
    renderer(ErrorModal, {
      type: 'attachmentAppIdError',
      handleClose
    });
  },
  offline(secureMode) {
    renderer(ErrorModal, {
      type: 'offline',
      secureMode
    });
  },
  basicModeNotSupported() {
    renderer(ErrorModal, {
      type: 'basicModeNotSupported'
    });
  }
};
/* harmony default export */ const modals_renderModal = (renderModal);

/***/ }),

/***/ 58922:
/***/ ((module, exports, __webpack_require__) => {

var {
  SecureEmailComposer
} = __webpack_require__(575);
var {
  SecureEmailWidget
} = __webpack_require__(72665);
var {
  SecureEmailReader
} = __webpack_require__(96638);
var {
  AnimationWidget
} = __webpack_require__(53749);
var {
  ActivationInterface
} = __webpack_require__(54654);
var {
  ConnectionEventRouter
} = __webpack_require__(6699);
var Guard = __webpack_require__(57128);
var TemplateService = (__webpack_require__(82672).templates);

/**
 * SecureEmailService provides an api for reading and composing Virtru Secure
 * Emails. These emails, by default, are rendered using the Virtru Secure Email
 * Format.
 *
 * This singleton is used as an IoC-like container.
 */
function SecureEmailService() {
  this._options = {
    secureService: null,
    composerRenderer: new TemplateService()
  };
  this.SecureEmailComposer = SecureEmailComposer;
  this.SecureEmailWidget = SecureEmailWidget;
  this.SecureEmailReader = SecureEmailReader;
  this.AnimationWidget = AnimationWidget;
  this.ActivationInterface = ActivationInterface;
}
SecureEmailService.prototype.configure = function (options) {
  this._options = Object.assign({}, this._options, options);
};
SecureEmailService.prototype.createComposer = function (options) {
  return this.SecureEmailComposer.create({
    secureService: this._options.secureService,
    renderer: this._options.composerRenderer,
    settings: options.settings
  });
};

/**
 *
 * @param element
 * @param settings
 * @param [options]
 * @param {String} [options.sender] - The sender of the email, used for message integrity verification
 * @returns {element}
 */
SecureEmailService.prototype.createWidget = function (element, settings, options) {
  Guard.checkIsDefAndNotNull(element, 'SecureEmailService.emailElement');
  Guard.checkIsDefAndNotNull(settings, 'SecureEmailService.settings');
  var defaultOptions = {
    secureService: this._options.secureService,
    SecureEmailReader: this.SecureEmailReader,
    AnimationWidget: this.AnimationWidget,
    renderer: info => info.message.body,
    connectionEventRouter: this._connectionEventRouter,
    doAnimation: true
  };
  options = Object.assign({}, defaultOptions, options);
  return this.SecureEmailWidget.create(element, settings, options);
};
SecureEmailService.prototype.showActivationInterface = function (element, currentUser, activationStatus, selectors) {
  return ActivationInterface.create(element, currentUser, activationStatus, selectors);
};
SecureEmailService.prototype.setRouter = function (router) {
  this._connectionEventRouter = new ConnectionEventRouter(router);
};
module.exports = exports = new SecureEmailService();
exports.utils = __webpack_require__(74838);
exports.Constants = __webpack_require__(76223);

/***/ }),

/***/ 58927:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   virtruTourV2: () => (/* binding */ virtruTourV2)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const virtruTourV2 = () => `
  <div aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('PROTECTION_OVERVIEW_POPUP')}" class="virtru-onboarding-modal-v2">
    <div class="tourv2 tourv2--normal">
      <div class="tour-popover-close">
        <button aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('PROTECTION_OVERVIEW_POPUP_CLOSE')}" class="tour-x-button" tabIndex="1" role="button"></button>
      </div>
      <h1 class="onboardv2__heading"></h1>
      <p class="onboardv2__body"></p>
      <div class="onboardv2__actions">
        <button class="onboardv2__okay" tabIndex="1" role="button"></button>
      </div>
    </div>

  </div>
`;

/***/ }),

/***/ 59195:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * The send + archive button mod.
 * A ripoff of the send button mod, ./new-compose-send-archive-button.js
 * Exports a JSON object to be used as the object prototype on instatiation
 * Used in the 'new-compose' mod as NewComposeSendArchiveButtonMod:
 *
 * this._sendArchiveButtonMod =
 *  Object.create( NewComposeSendArchiveButtonMod, {
 *   _settings: { value: this._settings },
 *   _element: { value: $(button) }
 *  } )
 *  .constructor(this)
 *  .on(NewComposeSendArchiveButtonMod.SendEmail, () => this.sendInitiated(true));
 .
 */

var mods = __webpack_require__(25939);
var i18n = __webpack_require__(2622);
module.exports = {
  ...(__webpack_require__(16502).prototype),
  ...mods.Mod.prototype,
  ...mods.ModElementShortcut,
  // event name emitted upon button click
  SendEmail: 'send-email-archive',
  $: __webpack_require__(55401),
  /**
   * constructor - should be called upon instantiation. stores context information,
   * calls setup to mirror send button mod
   * @constructor
   */
  constructor(context) {
    return Object.assign(this, {
      getToggleState: context.getToggleState,
      _sendSecureMod: context._sendSecureMod,
      _hasBeenSent: context._hasBeenSent,
      setupSendEmailError: context.setupSendEmailError,
      animationHelper: context.animationHelper
    }).setup();
  },
  disable() {
    this.animationHelper.disableSendButtonAnimate(this._sendArchiveButton);
  },
  enable() {
    if (this._settings.user.permissions.canCreatePolicies) {
      this._sendArchiveButton.addClass('virtru-send-secure');
      this.animationHelper.enableSendButtonAnimate(this._sendArchiveButton);
    }
  },
  /**
   * setup - called at the end of the constructor
   * clones gmail's send+archive button, inserts into the DOM
   * handles events, does stuff from the Mod base class
   */
  setup() {
    var cloneButton;
    this._element.hide().addClass('virtru-modded');
    cloneButton = this._element.clone();
    this.attachElement({
      element: cloneButton
    });
    this._element.before(cloneButton);
    this._sendArchiveButton = cloneButton;
    this.reinitializeButton(cloneButton);
    cloneButton.on('click', this.buttonClicked.bind(this));
    this._settings.on('load:user', this.userProfileUpdated.bind(this));
    return this;
  },
  /**
   * reinitializeButton
   * @param  {Element} sendSecureArchiveButton
   * if button is already in the DOM, just rename return
   * if not, show the button and enable it
   */
  reinitializeButton(sendSecureArchiveButton) {
    var eject = !sendSecureArchiveButton;
    sendSecureArchiveButton = sendSecureArchiveButton || this._sendArchiveButton;
    if (this.getToggleState() === 'on') {
      sendSecureArchiveButton.get(0).firstChild.nodeValue = i18n.t('NEW_COMPOSE_ARCHIVE_SEND_SECURE');
    }

    // If reinitializing an existing button set, we can stop here.
    if (eject) {
      return;
    }
    sendSecureArchiveButton.removeAttr('id').show();
    this.enable();
  },
  /**
   * teardown
   * "the user does not want to be secure, tear down this Mod" (Reagan)
   */
  teardown() {
    this._element.removeClass('virtru-modded');

    // Replace send button text

    this._sendArchiveButton.get(0).firstChild.nodeValue = i18n.t('NEW_COMPOSE_ARCHIVE_SEND');
  },
  /**
   * triggerGmailSendArchive
   * copied from send button mod
   */
  triggerGmailSendArchive() {
    this._element.triggerNative('mouseover');
    this._element.triggerNative('mousedown');
    this._element.triggerNative('mouseup');
    this._element.triggerNative('mouseout');
    this._element.triggerNative('click');
  },
  /**
   * buttonClicked
   * tell the world
   */
  buttonClicked() {
    this.emit(this.SendEmail);
  },
  /**
   * buttonClicked
   * copied from send button mod
   */
  userProfileUpdated() {
    this.reinitializeButton(this._sendArchiveButton);
  }
};

/***/ }),

/***/ 59345:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ components_EncryptedSearchReminder),
  renderEncryptedSearchReminder: () => (/* binding */ renderEncryptedSearchReminder),
  whatIsEncryptedSearch: () => (/* binding */ whatIsEncryptedSearch)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(87568);
// EXTERNAL MODULE: ./lib/i18n/index.js
var i18n = __webpack_require__(2622);
var i18n_default = /*#__PURE__*/__webpack_require__.n(i18n);
;// ./images/logo_search_reminder.svg
var _path, _path2;
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }

var SvgLogoSearchReminder = function SvgLogoSearchReminder(props) {
  return /*#__PURE__*/react.createElement("svg", _extends({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24"
  }, props), _path || (_path = /*#__PURE__*/react.createElement("path", {
    fill: "none",
    d: "M0 0h24v24H0z"
  })), _path2 || (_path2 = /*#__PURE__*/react.createElement("path", {
    fill: "#004987",
    d: "M12 0a12 12 0 1 0 12 12A12 12 0 0 0 12 0M9.8 18.3l-1.8.4V8h3v6.6a6.2 6.2 0 0 0 4-6.2 1.5 1.5 0 0 1 3 0c0 6.6-5.4 9.3-8.2 9.9"
  })));
};
/* harmony default export */ const logo_search_reminder = (SvgLogoSearchReminder);
// EXTERNAL MODULE: ./components/createReactRoot.js
var createReactRoot = __webpack_require__(72213);
;// ./components/EncryptedSearchReminder.js




const whatIsEncryptedSearch = 'https://support.virtru.com/hc/en-us/articles/360039151953-What-is-Encrypted-Search';
const onMouseDown = () => window.open(whatIsEncryptedSearch, '_blank', 'noopener,noreferrer');
const Spacer = () => /*#__PURE__*/react.createElement("td", {
  className: "gssb_n"
});
const Reminder = () => /*#__PURE__*/react.createElement("td", {
  className: "gssb_a gsfs reminder-cell",
  role: "presentation",
  dir: "ltr",
  onMouseDown: onMouseDown
}, /*#__PURE__*/react.createElement("div", {
  className: "gsas_c asor_v",
  id: "gs_asls50_4"
}, /*#__PURE__*/react.createElement("table", {
  cellSpacing: "0",
  cellPadding: "0"
}, /*#__PURE__*/react.createElement("tbody", null, /*#__PURE__*/react.createElement("tr", null, /*#__PURE__*/react.createElement("td", {
  className: "icon-container"
}, /*#__PURE__*/react.createElement(logo_search_reminder, {
  className: "icon"
})), /*#__PURE__*/react.createElement("td", {
  className: "text-container"
}, /*#__PURE__*/react.createElement("div", {
  className: "header",
  dir: "ltr"
}, i18n_default().t('ENCRYPTED_SEARCH_REMINDER_HEADER')), /*#__PURE__*/react.createElement("div", {
  className: "subtext"
}, /*#__PURE__*/react.createElement("span", null, i18n_default().t('ENCRYPTED_SEARCH_REMINDER_SUBTEXT')))))))));
const EncryptedSearchReminder = () => /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(Spacer, null), /*#__PURE__*/react.createElement(Reminder, null));
const ROOT_ID = 'virtru-encrypted-search-reminder';
function renderEncryptedSearchReminder(element) {
  const root = (0,createReactRoot/* default */.A)({
    element,
    rootId: ROOT_ID,
    tagName: 'tr'
  });
  root.render(/*#__PURE__*/react.createElement(EncryptedSearchReminder, null));
  return () => root.render(null);
}
/* harmony default export */ const components_EncryptedSearchReminder = (EncryptedSearchReminder);

/***/ }),

/***/ 59441:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Virtru Email Template for a Metadata Integrity Error
 */
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var i18n = __webpack_require__(2622);
var Templates = __webpack_require__(5749);
const {
  _bindAllMethods
} = __webpack_require__(4424);

/**
 * Creates an email error widget.  If the operation is able to be retried
 * it will show a 'Try again' and 'Cancel' buttons, otherwise it only
 * shows an 'Ok' button.
 *
 * Events:
 *
 * @param element
 * @constructor
 */
function MessageIntegrityError(element) {
  this._element = element;
  _bindAllMethods(this);
}

// Add events to this class
Emitter(MessageIntegrityError.prototype);
MessageIntegrityError.create = function (opts) {
  var html = Templates.messageIntegrityError({
    header: i18n.t('CANNOT_DECRYPT_HEADER'),
    message: i18n.t('CANNOT_DECRYPT_MESSAGE_INTEGRITY_COMPROMISED', opts),
    help: i18n.t('CANNOT_DECRYPT_GET_HELP')
  });
  var element = $(html);
  var widget = new MessageIntegrityError(element);
  return widget;
};
MessageIntegrityError.prototype.initEvents = function () {
  this._element.find('.vic-show-details').on('click', this.showDetails);
};
MessageIntegrityError.prototype.showDetails = function () {
  this._element.find('.vic-details').show();
  this._element.find('.vic-show-details').hide();
};
MessageIntegrityError.prototype.teardown = function () {
  this._element.find('.vic-show-details').off('click', this.showDetails);
  this._element.remove();
};
MessageIntegrityError.prototype.htmlElement = function () {
  return this._element;
};
MessageIntegrityError.prototype.appendTo = function (el) {
  $(el).append(this._element);
};
exports.p = MessageIntegrityError;

/***/ }),

/***/ 60162:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const encryptedSearch = __webpack_require__(82519);
const newDraftIntercept = __webpack_require__(68819);
module.exports = {
  init: settings => {
    encryptedSearch.initSearchXhr(settings);
    newDraftIntercept(settings);
  }
};

/***/ }),

/***/ 60355:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const $ = __webpack_require__(91089);
var i18n = __webpack_require__(2622);
const PREFIX = `${'<div>' + '<input name="virtru-secure-draft" type="hidden"/>' + '<div>'}${i18n.t('VIRTRU_SECURE_DRAFT_PREFIX')}</div>` + '<div style="font-size:0em;display:none;">' + '--- START PROTECTED MESSAGE TDF 0 ---\n ';
const POSTFIX = '\n--- END PROTECTED MESSAGE ---</div></div>';
function isSender(settings) {
  const subscriptions = settings.user.auth('subscriptions');
  if (subscriptions !== undefined && !subscriptions.canCreatePolicies) {
    return false;
  }
  return true;
}

/**
 * Format the draft in the TDF text format
 *
 * @param secureMessage
 * @returns {{message: string, length: number}}
 */
function formatDraft(secureMessage, encode) {
  const message = `${PREFIX}${secureMessage}${POSTFIX}`;
  return {
    message: encode ? encodeURIComponent(message) : message,
    length: PREFIX.length + secureMessage.length + POSTFIX.length
  };
}
function getAllWindows() {
  const iframes = $('iframe, frame');
  const windows = [];
  iframes.each((index, iframe) => {
    windows.push(iframe.contentWindow);
  });
  windows.push(window);
  return windows;
}

/**
 * Temporary content manager for the draft message
 */
const TemporaryDraftContent = {
  /**
   * Wrap the content in the Temporary Content string
   * @param content
   * @returns {string|undefined}
   */
  make: content => content && `--- START TEMPORARY DRAFT CONTENT --- ${`${content}`} --- END TEMPORARY DRAFT CONTENT ---`,
  /**
   * Extract the Temporary Content
   * @param content
   * @returns {string|undefined}
   */
  clear: content => content && content.replace(new RegExp(TemporaryDraftContent.make('(.*)'), 'g'), '')
};
module.exports = {
  isSender,
  formatDraft,
  getAllWindows,
  TemporaryDraftContent
};

/***/ }),

/***/ 60578:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NewFeatureNotification: () => (/* binding */ NewFeatureNotification)
/* harmony export */ });
const $ = __webpack_require__(91089);
const Popover = __webpack_require__(55929);
class NewFeatureNotification {
  /**
   * Class to show new features popover
   * @param options.position {string} 'north, south, east, west' default 'north'
   * @param options.attachToElement {string} selector of element to attach
   * @param options.popoverClassName {string} popover class name
   * @param options.dismissCallback {function} callback to execute on button click
   */
  constructor(options = {}) {
    Object.assign(this, options);
    this.attach();
  }
  attach() {
    const $el = $(this.attachToElement);
    this.popover = new Popover();
    this.popover.setShowTimer(1000);
    this.popover.classname = this.popoverClassName || 'virtru-new-feature-tip';
    this.popover.inner.empty().append(this.template);

    // set up events
    this.popover.inner.on('click', () => {
      this.dismiss();
    });
    this.popover.position(this.position || 'north').show($el[0]);
  }
  updatePosition() {
    try {
      this.popover.reposition();
    } catch (e) {} // eslint-disable-line
  }
  dismiss() {
    this.popover.hide();
    if (this.dismissCallback) {
      this.dismissCallback();
    }
  }
}

/***/ }),

/***/ 60684:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const $ = __webpack_require__(55401);
const Utils = __webpack_require__(55675);
const Emitter = __webpack_require__(16502);

/**
 * Base class for an Inline element in the compose window
 * @param {fileData} fileData Contains size, name, and type.
 * @param composeMod Contains size, name, and type.
 */
function InlineElement(fileData, composeMod) {
  this.fileData = fileData;
  this._editor = composeMod._editor;
  this._composeMod = composeMod;
  this.tdfData = null;
  this._attachmentService = composeMod._attachmentService;
  this._settings = this._composeMod._settings;
}
Emitter(InlineElement.prototype);

/**
 * Return a set of elements inside of a container that pass a hit test against given coords.
 * @param {Number} clickX The horizontal x position to hit test
 * @param {Number} clickY The horizontal x position to hit test
 * @param {DOMElement} container Return all elements in this container.
 * @return {Array<DOMElement>} List of elements that pass the hit test.
 */
function _getElementsUnderPoint(clickX, clickY, container) {
  return $(container || document.body).find('*').filter(function () {
    var offset = $(this).offset();
    var range = {
      x: [offset.left, offset.left + $(this).outerWidth()],
      y: [offset.top, offset.top + $(this).outerHeight()]
    };
    return clickX >= range.x[0] && clickX <= range.x[1] && clickY >= range.y[0] && clickY <= range.y[1];
  }).toArray();
}

// Add a blank line return above and/or below the added element so the text cursor doesn't get stuck
InlineElement.prototype._addSpaceAroundElementIfNeeded = function ($el) {
  const userProfile = this._settings.user._profile;
  // v2 attachment chips are put into the attachment section, so no need to add the spacer
  if ($el.is('img') || !Utils.isFeatureEnabled(userProfile, 'useAttachmentChipsV2')) {
    if ($el.prev('br').length === 0) {
      $el.before('<br class="virtru-spacer"/>');
    }
    if ($el.next('br').length === 0) {
      $el.after('<br class="virtru-spacer"/>');
    }
  }
};

/**
 * Insert this mod's HTML element into the compose box at the desired location.
 */
InlineElement.prototype.addElementToCompose = function ($appendElem) {
  // The contenteditable editor is sometimes presented inside of an iframe (such as with outlook)
  var $editorBody = this._editor.is('iframe') ? this._editor.contents().find('body') : this._editor;
  var editorBody = $editorBody.get(0);

  // If this attachment represents an inline image to be replaced, replace it inline
  var inlineImageUuid = this.fileData && this.fileData.inlineImageUuid;
  var $inlineImageToReplace = $editorBody.find(`[data-virtru-inline-image-uuid="${inlineImageUuid}"]`);
  if (inlineImageUuid && $inlineImageToReplace.length) {
    $inlineImageToReplace.replaceWith($appendElem);
    this._addSpaceAroundElementIfNeeded($appendElem);
  } else {
    // For all other attachments, try to infer where they should be placed
    var didInsert = false;
    var dropPos = this.fileData && this.fileData.dropPos;

    // If the element was dropped, approximate where the user might have dropped it
    if (dropPos) {
      // Get all elements under the drop position eligible for dropping next to
      var elementsUnderMouse = _getElementsUnderPoint(dropPos.x, dropPos.y, editorBody).filter(function (element) {
        // Prevent dropping attachments onto other attachments
        return $(element).closest('.virtru-attachment,.virtru-attachment-section').length === 0;
      });
      if (elementsUnderMouse.length > 0) {
        var elementUnderMouse = elementsUnderMouse[elementsUnderMouse.length - 1];
        $appendElem.insertBefore(elementUnderMouse);
        this._addSpaceAroundElementIfNeeded($appendElem);
        didInsert = true;
      }
    }

    // If the drop failed, see if we can put it at the last known cursor position
    if (!didInsert) {
      var nodeAtCursor = this._composeMod.lastSelectedElement;
      if (this.fileData && this.fileData.doInsertAtCursorPosition && editorBody.contains(nodeAtCursor)) {
        if (nodeAtCursor === editorBody) {
          $editorBody.append($appendElem);
          this._addSpaceAroundElementIfNeeded($appendElem);
        } else {
          // Insert as a direct child of the editor body
          while (nodeAtCursor.parentElement !== editorBody) {
            nodeAtCursor = nodeAtCursor.parentElement;
          }
          $appendElem.insertAfter(nodeAtCursor);
          this._addSpaceAroundElementIfNeeded($appendElem);
        }
      } else if ($editorBody.find('.virtru-attachment-section').length > 0) {
        // Put us before the attachment section, if it exists
        $appendElem.insertBefore($editorBody.find('.virtru-attachment-section'));
        this._addSpaceAroundElementIfNeeded($appendElem);
      } else {
        // If all else fails, just put us at the bottom
        $editorBody.append($appendElem);
        this._addSpaceAroundElementIfNeeded($appendElem);
      }
      try {
        // Make sure we can actually see the element
        $appendElem.get(0).scrollIntoView(true);
        // eslint-disable-next-line
      } catch (e) {} // No worries if we can't scroll to the element
    }
  }
  // Just in case we have a lingering inline image, remove it from the DOM
  $inlineImageToReplace.remove();
};
InlineElement.prototype.getAnalyticsObject = function () {
  var _this$tdfData;
  return {
    fileSize: this.fileData ? this.fileData.size : 0,
    fileType: this.fileData ? Utils.getFileType(this.fileData.name) : '',
    'policy.Id': (this === null || this === void 0 ? void 0 : (_this$tdfData = this.tdfData) === null || _this$tdfData === void 0 ? void 0 : _this$tdfData.policyUuid) || 'unknown'
  };
};
module.exports = InlineElement;

/***/ }),

/***/ 61526:
/***/ ((__unused_webpack_module, exports) => {

/**
 * @class RoutingError
 *
 * Error for routing errors
 */
class RoutingError extends Error {
  constructor(message) {
    super(message);
    this.name = 'RoutingError';
  }
}
exports.RoutingError = RoutingError;

/**
 * Routes actions to specific handlers. This is a very general router it is
 * meant to be wrapped in something that adapts the communication for both
 * sides of the router.
 */
function Router() {
  this._actions = {};
}

/**
 * Registers a handler to an action
 *
 * @param {String} action The action name
 * @param {Function} handler Handler for the action
 */
Router.prototype.register = function (action, handler) {
  this._actions[action] = handler;
};

/**
 * Route an action
 *
 * @param {String} action The action name
 * @param {Object} params The parameters
 * @param {Function} sendResponse The response callback
 * @param {Function} sendProgress The progress callback
 */
Router.prototype.route = function (action, params, sendResponse, sendProgress) {
  var handler = this._actions[action];
  if (handler === undefined) {
    throw new RoutingError(`Action ${action} does not exist.`);
  }
  var response = {
    send: sendResponse,
    progress: sendProgress
  };
  handler.apply(null, [params, response]);
};

// Add to the namespace
exports.Router = Router;

/***/ }),

/***/ 61873:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   makeUrlValidatorRegExp: () => (/* binding */ makeUrlValidatorRegExp),
/* harmony export */   parseByExactSelector: () => (/* binding */ parseByExactSelector),
/* harmony export */   parseBySelector: () => (/* binding */ parseBySelector),
/* harmony export */   parseByUrl: () => (/* binding */ parseByUrl),
/* harmony export */   parseConfig: () => (/* binding */ parseConfig)
/* harmony export */ });
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__);

const makeUrlValidatorRegExp = accountNumber => new RegExp(`/mail(/data)?/u/${accountNumber}/?$`);
const parseByUrl = accountNumber => {
  const urlRegExp = makeUrlValidatorRegExp(accountNumber);
  const possibleDelegateeLinks = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(`[href*="/${accountNumber}"]`);
  const delegateeLink = Array.from(possibleDelegateeLinks).find(node => urlRegExp.test(node.getAttribute('href')));
  const childNodes = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(delegateeLink).find('*').contents();
  const textNodes = Array.from(childNodes).filter(node => node.nodeType === Node.TEXT_NODE);
  const values = textNodes.map(node => node.nodeValue);
  return values.find(value => value.includes('@'));
};
function parseBySelector(accountNumber) {
  const urlRegExp = makeUrlValidatorRegExp(accountNumber);
  const {
    dom
  } = this.settings;
  const delegatees = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(dom.ACCOUNT_LIST).filter(function isNonDelegatedGmailAccount() {
    // Ignore DOM nodes with non-gmail or other account links
    return urlRegExp.test(this.href);
  }).map(function getEmail() {
    // For each DOM node returned, remove any extraneous info.
    // i.e. 'account1 (default)' becomes 'account1'
    const splits = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(this).find(dom.ACCOUNT_ENTRY).text().split(' ');
    if (splits.length === 1) {
      return splits[0];
    }
    for (let i = 0, len = splits.length; i < len; ++i) {
      const split = splits[i];
      if (split.indexOf('@') > 0) {
        return split.trim();
      }
    }
    return null;
  });
  return delegatees[0];
}
function parseByExactSelector() {
  const {
    dom
  } = this.settings;
  return _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(dom.DELEGATEE_EMAIL).text();
}
function parseConfig() {
  var _window, _window$gbar_;
  // array with two emails
  const emailsFromConfigString = JSON.stringify((_window = window) === null || _window === void 0 ? void 0 : (_window$gbar_ = _window.gbar_) === null || _window$gbar_ === void 0 ? void 0 : _window$gbar_.CONFIG).match(/([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/g);

  // delegatee email is different from the current user email
  const delegateeEmail = emailsFromConfigString.find(email => email !== this.settings.gmailGlobals.user);
  return delegateeEmail;
}

/***/ }),

/***/ 62769:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Ay: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   fK: () => (/* binding */ createSectionTooltip),
/* harmony export */   se: () => (/* binding */ getAttachmentTooltipContent)
/* harmony export */ });
const {
  RenderAttachmentTooltip,
  RenderSectionTooltip,
  RenderRevokedTooltip
} = __webpack_require__(26847);
const globalStore = __webpack_require__(71139);
const commonUtils = __webpack_require__(55675);
const i18n = __webpack_require__(2622);
const {
  AUTHORIZATION_PERSISTENT_PROTECTION,
  AUTHORIZATION_WATERMARK
} = (__webpack_require__(42769).PolicyModel);
const mimeTypeMap = {
  pdf: 'application/pdf',
  doc: 'application/msword',
  docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  xls: 'application/vnd.ms-excel',
  xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  ppt: 'application/vnd.ms-powerpoint',
  pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  gif: 'image/gif',
  png: 'image/png',
  jpeg: 'image/jpeg',
  jpg: 'image/jpeg',
  bmp: 'image/bmp',
  txt: 'text/plain',
  csv: 'text/csv',
  md: 'text/markdown',
  wav: 'audio/wav',
  mp3: 'audio/mpeg',
  mp4: 'video/mp4'
};
Object.freeze(mimeTypeMap);
const fileTypes = {
  png: 'png',
  pdf: 'pdf',
  xlsx: 'xlsx',
  docx: 'docx',
  pptx: 'pptx',
  jpg: 'jpg',
  jpeg: 'jpeg'
};
Object.freeze(fileTypes);
const PDFTronMimeTypes = [mimeTypeMap.pdf, mimeTypeMap.docx, mimeTypeMap.xlsx, mimeTypeMap.pptx, mimeTypeMap.jpeg, mimeTypeMap.jpg, mimeTypeMap.png];
Object.freeze(PDFTronMimeTypes);
function getAttachmentTooltipContent(authorizations, isSender, isSupportedFile, isStepChild, isManaged = false) {
  const isPP = authorizations && authorizations.includes(AUTHORIZATION_PERSISTENT_PROTECTION);
  const isEW = authorizations && authorizations.includes(AUTHORIZATION_WATERMARK);
  const isEP = authorizations && authorizations.includes(AUTHORIZATION_WATERMARK) && authorizations.includes(AUTHORIZATION_PERSISTENT_PROTECTION);
  const isMN = isManaged;
  const isEMN = isManaged && authorizations.includes(AUTHORIZATION_PERSISTENT_PROTECTION);
  const i18nKeysArray = ['ATTACHMENTS_TOOLTIP_CONTENT'];
  if (isSender) {
    i18nKeysArray.push('SENDER');
  } else {
    i18nKeysArray.push('RECIPIENT');
  }
  if (isStepChild) {
    i18nKeysArray.push('STEPCHILD');
  } else {
    if (isSupportedFile) {
      i18nKeysArray.push('SUPPORTED_FILE');
    } else {
      i18nKeysArray.push('UNSUPPORTED_FILE');
    }
    // First of all we need to check for EW and PP turn on, then only PP, then only EW, then turn off both security option
    // order is important here
    switch (true) {
      case isEP:
        i18nKeysArray.push('EXPANDED_PROTECTION');
        break;
      case isEMN:
        i18nKeysArray.push('EXPANDED_IS_MANAGED');
        break;
      case isPP:
        i18nKeysArray.push('PERSISTENT_PROTECTION');
        break;
      case isEW:
        i18nKeysArray.push('EXPANDED_WATERMARKING');
        break;
      case isMN:
        i18nKeysArray.push('IS_MANAGED');
        break;
      default:
        i18nKeysArray.push('NONE_SECURE');
        break;
    }
  }
  const i18nKey = i18nKeysArray.join('.');
  return i18n.t(i18nKey);
}
function isSupportPDFTronByFileName(fileName) {
  const extension = fileName.split('.')[fileName.split('.').length - 1];
  const supportedFileExtensions = [fileTypes.png, fileTypes.pdf, fileTypes.xlsx, fileTypes.docx, fileTypes.pptx, fileTypes.jpg, fileTypes.jpeg];
  if (supportedFileExtensions.includes(extension.toLowerCase())) {
    return extension;
  }
}
function isPdf(fileName) {
  const extension = fileName.split('.')[fileName.split('.').length - 1];
  return extension.toLowerCase() === fileTypes.pdf && extension;
}
function createChipTooltip({
  $anchor,
  fileName,
  authorizations,
  isReattachedPFPFile,
  isSender,
  attachmentId,
  isManaged = false,
  isTdf3Html
}) {
  const isSupportedFile = isManaged ? isPdf(fileName) : isSupportPDFTronByFileName(fileName);
  const title = fileName;
  authorizations = authorizations || null;
  const attachmentWrapperClassName = 'virtru-attachment-wrapper';
  const attachmentWrapperAsParent = $anchor.parents(`.${attachmentWrapperClassName}`);
  if (attachmentWrapperAsParent && attachmentWrapperAsParent.length > 0) {
    attachmentWrapperAsParent.after($anchor).remove();
  }
  const tooltipAttachmentWrapper = document.createElement('div');
  tooltipAttachmentWrapper.className = attachmentWrapperClassName;
  $anchor.after(tooltipAttachmentWrapper);
  const anchor = $anchor[0];
  const attachmentData = {
    fileName,
    authorizations,
    isSender,
    isReattachedPFPFile,
    attachmentId,
    isSupportedFile,
    isManaged
  };
  globalStore.dispatch({
    type: 'ADD_ATTACHMENT_DATA',
    id: attachmentId,
    data: attachmentData
  });
  const renderData = {
    anchor,
    title,
    attachmentId,
    isTdf3Html
  };
  RenderAttachmentTooltip(tooltipAttachmentWrapper, renderData);
}
function createRevokedTooltip($anchor, attachmentId) {
  const tooltipAttachmentWrapper = document.createElement('div');
  tooltipAttachmentWrapper.className = 'virtru-attachment-wrapper';
  $anchor.after(tooltipAttachmentWrapper);
  const anchor = $anchor[0];
  const renderData = {
    anchor,
    title: i18n.t('ATTACHMENT_REVOKED_HEADER'),
    content: i18n.t('ATTACHMENT_REVOKED_TEXT'),
    attachmentId
  };
  RenderRevokedTooltip(tooltipAttachmentWrapper, renderData);
}
function createSectionTooltip(editor) {
  const uniqueSectionID = window.crypto.randomUUID();
  const $attachmentSectionInfo = editor.find('.virtru-attachment-section-info');
  $attachmentSectionInfo.removeAttr('id');
  const sectionTooltipWrapper = editor.find('.virtru-section-tooltip-wrapper');
  if (sectionTooltipWrapper && sectionTooltipWrapper.length > 0) {
    sectionTooltipWrapper.after($attachmentSectionInfo).remove();
  }
  $attachmentSectionInfo.attr('id', `virtru-attachemnt-section_${uniqueSectionID}`).after(`<div id="${uniqueSectionID}" class="virtru-section-tooltip-wrapper"></div>`);
  const anchor = $attachmentSectionInfo[0];
  const sectionTooltipTitle = i18n.t('ATTACHMENT_SECTION_TOOLTIP_TITLE');
  const sectionTooltipContent = i18n.t('ATTACHMENT_SECTION_TOOLTIP_CONTENT');
  const renderData = {
    anchor,
    title: sectionTooltipTitle,
    content: sectionTooltipContent
  };
  RenderSectionTooltip(uniqueSectionID, renderData);
}

/**
 * Function for get CSS class names by the specified params
 * @param fileName - name ex. file.ext
 * @param isReattachedFile - if true we use different method to get extension and apply warning icon in UI
 * @param pfpEnabled - if true we apply PFP specific styles for supported files
 * @param isComposeMod - warning icon should be displayed only for sender
 * @return {String} class name(s)
 */
function attachmentExtensionClassName(fileName, isReattachedFile, pfpEnabled, isComposeMod, isTdf3Html) {
  const isTdfHtmlFile = commonUtils.supportsExpandedWatermarking(fileName) || isTdf3Html;
  const extension = commonUtils.getFileExtension(fileName);
  const supportedFileExtensions = ['md', 'png', 'pdf', 'xlsx', 'docx', 'pptx', 'jpg', 'jpeg', 'txt', 'svg', 'gif', 'bmp', 'tif'];
  const classNames = [];
  if (supportedFileExtensions.includes(extension)) {
    classNames.push(extension);
  } else {
    classNames.push('file-icon-default');
  }
  if (isTdfHtmlFile) {
    classNames.push('tdf-html-file');
  }
  if (isTdfHtmlFile && isReattachedFile) {
    classNames.push('reattached');
  }
  if (pfpEnabled) {
    classNames.push('pfp-enabled');
  }
  if (isComposeMod && (isReattachedFile || !isTdfHtmlFile)) {
    classNames.push('pfp-warning');
  }
  return classNames.join(' ');
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getAttachmentTooltipContent,
  isSupportPDFTronByFileName,
  createChipTooltip,
  createRevokedTooltip,
  attachmentExtensionClassName,
  createSectionTooltip
});

/***/ }),

/***/ 64115:
/***/ ((module) => {

module.exports = '<div class="virtru-popover-wrapper">\n  <span class="virtru-popover-title"></span>\n  <div class="virtru-popover-content"></div>\n</div>';

/***/ }),

/***/ 64474:
/***/ ((module, exports, __webpack_require__) => {

const en_US = __webpack_require__(25026);
const fr_FR = __webpack_require__(24361);
const sv_SE = __webpack_require__(85392);
const ja_JP = __webpack_require__(49706);
const dev = __webpack_require__(56119);

/**
 * When adding a new locale, add it also for moment.js in momentLocale property
 * Also check which locale is what in gmail and add to gmailLocale property
 * List of available locales:
 * https://github.com/moment/moment/tree/develop/locale
 */

const locales = {
  'en-US': {
    translation: en_US,
    label: 'English (USA)',
    mobileLabel: 'EN',
    momentLocale: 'en',
    published: true,
    enabled: true
  },
  'fr-FR': {
    translation: fr_FR,
    label: 'Franais (France)',
    mobileLabel: 'Fr',
    momentLocale: 'fr',
    published: true,
    enabled: true
  },
  'sv-SE': {
    translation: sv_SE,
    label: 'Swedish',
    mobileLabel: 'Sv',
    momentLocale: 'sv',
    published: true,
    enabled: true
  },
  'ja-JP': {
    translation: ja_JP,
    label: 'Japanese ()',
    mobileLabel: 'Ja',
    momentLocale: 'ja',
    published: true
  },
  dev: {
    translation: dev,
    label: 'Development',
    mobileLabel: 'Dev',
    momentLocale: 'fr',
    published: false
  }
};
module.exports = exports = locales;

/***/ }),

/***/ 64688:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 64791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const $ = __webpack_require__(91089);
const generateUniqueString = (input, seed) => {
  seed += Math.round(Math.random() * 10);
  var reg = new RegExp(seed, 'g');
  return reg.test(input) ? generateUniqueString(input, seed) : seed;
};
const longestWord = wordArray => wordArray.reduce((maxLen, word) => word.length > maxLen ? word.length : maxLen, 0);
// Here's what's happening.
// 1. In the generateUniqueString function I'm generating a unique string. That is, a string that doesn't exist
//    anywhere in the body of the email.
// 2. Then, after every 30 characters I add the unique string that we generated above.
// 3. Next, I replace all greater-than, and less-than characters, with their equivalant encoded version (&gt, &lt;)
// 4. Last, I replace the unique strings that we initially inserted every 30 characters, with the HTML
//    tag <wbr>.
//
// The reason for this craziness is because if, like before, we add <wbr> first, THEN replace the greater-than, and less-thans,
// the wbrs will look like &gt;WBR&lt;
//
//  - Tyler (15 Jul 2014)
const formatBody = message => {
  const elHtml = `<div>${message}</div>`;
  const el = $(elHtml);
  const allChildren = el.find('*:not(span.virtru-attachment-file-name)');
  const uniqueString = generateUniqueString(elHtml, 'virtru_unique');
  const reg = new RegExp(uniqueString, 'g');
  allChildren.each(function (ind, ele) {
    const {
      childNodes
    } = ele;
    childNodes.forEach(child => {
      // Only want text nodes that have words longer than 30 characters.
      if (child.nodeType === 3 && longestWord(child.nodeValue.match(/\S+/g) || []) > 30) {
        const text = child.nodeValue.replace(/(\S{30})/g, `$1${uniqueString}`).replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(reg, '<wbr>');
        $(child).replaceWith(text);
      }
    });
  });
  return el.html();
};
module.exports = {
  formatBody
};

/***/ }),

/***/ 65001:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   warningPopoverModal: () => (/* binding */ warningPopoverModal)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const warningPopoverModal = () => `
  <div class="popup-overlay warning-popover-overlay" >
    <div class="warning-popup">
      <div class="popup-header">
        <div class="popup-icon"></div>
        <div class="popup-header-text"></div>
      </div>
      <div class="popup-description"></div>
      <div class="popup-list-border-box">
        <div class="popup-files-list">
          <ul></ul>
        </div>
      </div>
      <div class="popup-additional-description"></div>
      <div class="popup-additional-bold-description"></div>
      <div class="popup-footer">
        <div class="popup-button popup-button-blue" tabIndex="3" role="button"></div>
        <div class="popup-button popup-button-white" tabIndex="2" role="button"></div>
        <div class="popup-button popup-button-borderless popup-button-cancel" tabIndex="1" aria-label="${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('COMMON_CANCEL')}" role="button">
          ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('COMMON_CANCEL')}
        </div>
      </div>
    </div>
  </div>
`;

/***/ }),

/***/ 65413:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var $ = __webpack_require__(91089);
var {
  WaiterMap
} = __webpack_require__(89965);
var CompatMutationObserver = __webpack_require__(72083);
var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver;
exports.isNative = true;
if (!MutationObserver) {
  exports.isNative = false;
  MutationObserver = CompatMutationObserver;
}
var defaultWaiterOnOptions = {
  includeChildren: true,
  timeout: 0,
  timedOut() {},
  includeAdded: true,
  includeRemoved: false,
  continuous: false
};
function waitOn(selector) {
  var callback = arguments[1];
  var timeoutID = null;
  var observer = null;
  var waits = null;
  var userOptions = {};
  if (arguments.length >= 3) {
    userOptions = arguments[1];
    callback = arguments[2];
  }
  var options = $.extend({}, defaultWaiterOnOptions, userOptions);
  var stopWaiting = function () {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
    if (observer) {
      observer.disconnect();
    }
    waits.remove(selector, callback);
  };
  var parentElement = this;
  var filter = function (nodes) {
    return nodes;
  };
  var preliminaryMatch = function () {
    return false;
  };
  if (selector !== null) {
    preliminaryMatch = function () {
      var matches = parentElement.find(selector);
      if (matches.length > 0) {
        callback.apply(null, [matches]);
        return true;
      }
      return false;
    };
    if (typeof selector === 'function' || options.includeRemoved) {
      // Skip the preliminary match if the selector is a function
      preliminaryMatch = function () {
        return false;
      };
    }
    var inclusiveSelector = `${selector}, :has(${selector})`;
    filter = function (nodes) {
      return $(nodes).filter(inclusiveSelector);
    };
  }
  observer = new MutationObserver(function (records) {
    var addedMatches = [];
    var removedMatches = [];
    records.forEach(function (record) {
      if (record.addedNodes) {
        addedMatches.push.apply(addedMatches, filter(record.addedNodes));
      }
      if (record.removedNodes) {
        removedMatches.push.apply(removedMatches, filter(record.removedNodes));
      }
    });
    var hasRemoved = removedMatches.length > 0 && options.includeRemoved;
    var hasAdded = addedMatches.length > 0 && options.includeAdded;
    if (hasAdded || hasRemoved) {
      callback.apply(null, [addedMatches, removedMatches]);
      if (!options.continuous) {
        stopWaiting();
      }
    }
  });
  if (preliminaryMatch()) {
    if (!options.continuous) {
      return;
    }
  }
  this.each(function () {
    observer.observe(this, {
      subtree: true,
      childList: true
    });
  });
  waits = this.data('stopWaiters') || new WaiterMap();
  waits.add(selector, callback, stopWaiting);
  this.data('stopWaiters', waits);
  // If there is a timeout
  if (options.timeout > 0) {
    timeoutID = setTimeout(function () {
      stopWaiting();
      options.timedOut.apply(null);
    }, options.timeout);
  }
  return this;
}
function waitOff(selector, callback) {
  var waits = this.data('stopWaiters');
  if (waits) {
    if (callback) {
      waits.remove(selector, callback, function (stopWaiting) {
        stopWaiting.apply(null);
      });
    } else {
      waits.removeAll(selector, function (stopWaiting) {
        stopWaiting.apply(null);
      });
    }
  }
}
var methods = {
  on: waitOn,
  off: waitOff
};
$.fn.wait = function (methodName) {
  var method = methods[methodName];
  if (!method) {
    throw new Error(`wait method "${methodName}" does not exist`);
  }
  var methodArgs = [].splice.apply(arguments, [1]);
  return method.apply(this, methodArgs);
};

/***/ }),

/***/ 66089:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 66527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var contexts = __webpack_require__(47446);
var $ = __webpack_require__(55401);
var printUtils = __webpack_require__(91090);
module.exports = Print;

/**
 * Sets up printing an individual message
 *
 * @param {GmailSettings} settings
 * @param {HTMLElement} element - DOM element
 */
function Print(settings, element) {
  this.settings = settings;
  this.element = element;
  this._clone = null;
  this.setup(settings, element);
}
Print.mainDomKey = 'PRINT_DROPDOWN';
function replaceEle($message, element, clone, selectors) {
  if (!printUtils.hasEncryptedContent($message, selectors)) {
    clone.parentNode && clone.parentNode.replaceChild(element, clone);
  } else {
    element.parentNode && element.parentNode.replaceChild(clone, element);
  }
}
function getMessage($dropdown, settings) {
  return $dropdown.closest(settings.dom.MESSAGES);
}

/**
 * Sets up the print button from the dropdown. The print button is not unique per message.
 * There is only one print button for all messages.
 *
 * @param {GmailSettings} settings
 * @param {HTMLElement} element
 */
Print.prototype.setup = function (settings, element) {
  // Must add processedClass to prevent infinite setup attempts
  element.classList.add(settings.processedClass);
  var clone = element.cloneNode(true);
  clone.id = 'virtru-print'; // It appears the id is used to trigger printing (event delegation), so we change it

  var $message;
  clone.onclick = function () {
    printUtils.print(settings, $message);
  };

  // Allows us to replicate the hover effects gmail adds via JS
  printUtils.addHover(clone, settings.dom.PRINT_ONE_HOVER_CLASS);
  var $dropdown = $(settings.dom.MORE_DROPDOWN).filter('[aria-expanded="true"]');
  var $readContainer = $(settings.dom.READ_CONTAINER);
  $readContainer.on('mousedown', settings.dom.MORE_DROPDOWN, function switchElement() {
    $message = getMessage($(this), settings);
    replaceEle($message, element, clone, settings.dom);
  });
  $dropdown.click();
};

// There is nothing to teardown, since once you go back to the inbox these elements disappear
Print.prototype.teardownAll = function () {};

// Required for the mod system, but we setup in constructor
Print.prototype.setupAll = function () {};

// Alive while dropdown is expanded
Print.prototype.isAlive = function () {
  return $(this.settings.dom.READ_CONTAINER).length;
};
contexts.addOpen(Print);

/***/ }),

/***/ 67262:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const emitter = __webpack_require__(16502);
const {
  BaseModalPage
} = __webpack_require__(86345);
const {
  _bindAllMethods
} = __webpack_require__(4424);
function OnboardingV2Modal(element, settings, options) {
  this._settings = settings;
  if (options && options.confirm) {
    this._confirm = options.confirm;
  }
  if (options && options.callback) {
    this._callback = options.callback;
  }
  _bindAllMethods(this);
  BaseModalPage.call(this, element);
}

// Setup object inheritance tree
OnboardingV2Modal.prototype = new BaseModalPage();
OnboardingV2Modal.prototype.constructor = OnboardingV2Modal;
emitter(OnboardingV2Modal.prototype);
OnboardingV2Modal.prototype.closeModal = function () {
  /**
   * Do not remove the if check here. Somehow the this.modal.close function can become undefined
   * or not a function and will throw a "TypeError: this.modal.close is not a function" error when called.
   * This was causing an "Activation Failed" modal to be shown to the user even when activation
   * was successful, and typically happened when a compose window stays open while activating.
   */
  if (this.modal.close !== undefined && typeof this.modal.close === 'function') {
    this.modal.close();
  }
};
exports.OnboardingV2Modal = OnboardingV2Modal;

/***/ }),

/***/ 67563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  escHtml,
  escJavaScript
} = __webpack_require__(39283);
module.exports = ({
  manifest,
  payload,
  transferUrl,
  transferBaseUrl
}) => `<html>
<head>
    <meta charset="UTF-8">
  </head>
  <body style="font-family: Arial; color: #2D323B; overflow: hidden; margin: 0; height: 100%; background-color: white;">
    <input id="data-input" type="hidden" value="${escHtml(payload)}">
    <input id="data-manifest" type="hidden" value="${escHtml(manifest)}">
    <iframe style="width:0;height:0;border:0; border:none;" src="${escHtml(transferUrl)}"></iframe>
    <div role="banner" style="background-color: #092356; color: white; height: 55px;">
      <img src="https://cdn.virtru.com/assets/virtru-logo-white-rgb.png"
           style="display: inline-block; padding: 18px 0 0 24px;"
           width="62px" height="19px" alt="Virtru logo" title="Virtru"/>
    </div>
   <div role="main" class="wrapper" style="padding-top: 107px; display: flex; flex-direction: row; max-width: 1200px;
          min-width: 800px; margin: 0 auto; min-height: calc(100vh - 230px); border-bottom: 1px solid #F3F5F7;">
      <div role="region">
        <img src="https://cdn.virtru.com/assets/request-access.png" style="display: inline-block;"
             width="387px" height="310px" alt="Request access image" title="Request access"/>
      </div>
      <div role="complementary" style="word-break: break-all; padding-right: 12px;">
        <h1 style="font-size: 1.5em;">Virtru Secure File</h1>
        <noscript style="font-weight: 100;">
          <span>
            To view this file, download and access it from your computer:
            <br />
            <br />
          </span>
          <div>
            1. <b>Go Back</b> to the file directory and <b>Right-click</b> on the file
          </div>
          <div>
            2. Select <b>Download</b>
          </div>
          <div>
            3. Once download is complete, <b>double-click</b> on the local file to open
          </div>
        </noscript>
        <div id="js-enabled-message" style="display: none;">
          <span>We are trying to send you to Secure Reader. If this does not work, please click the button below</span>
          <br />
          <button
            id="viewbutton"
            style="
              color: #fff!important; 
              background: gray; padding: 10px 40px; 
              border-radius: 25px; 
              display: inline-block; 
              border: none; font-size: 15px; width: 300px;
              margin-block-start: 1.1em;
              margin-block-end: 1.1em;"
            class="viewbutton"
            type="button"
          >
            View File in Secure Reader
          </button>
        </div>
      </div>
    </div>
    <div role="contentinfo" style="color: grey; text-align: center; padding-top: 25px; font-family: Arial;">
        <span style="padding: 25px; font-size: 13px;"> Copyright 2019 Virtru Corporation</span>
        <span style="padding: 25px; font-size: 13px;">Learn more at www.virtru.com</span>
    </div>
    <script type="text/javascript">
      var transferComplete = false;
      var data = document.getElementById('data-input').value;
      var manifest = JSON.parse(atob(document.getElementById('data-manifest').value));
      var redirectButton = document.getElementById('viewbutton');
      var ifr = document.querySelector('iframe');
      var otherWindow = ifr.contentWindow;

      document.getElementById('js-enabled-message').style.display = 'block';
      ifr.addEventListener("load", iframeLoaded, false);

      function iframeLoaded() {
        var channel = new MessageChannel();
        otherWindow.postMessage({
          type: 'tdf.html',
          data: data,
          policy: manifest.encryptionInformation.policy
        }, '${escJavaScript(transferBaseUrl)}', [channel.port2]);

        channel.port1.onmessage = handleMessage;

        function handleMessage(e) {
          let msg = e.data;
          if (msg.status === 'success') {
            transferComplete = true;
            redirectButton.style.background = '#004987';
            window.location.href = "${escJavaScript(transferUrl)}";
          }
        }
      }
      redirectButton.onclick = function(){
        if (transferComplete) {
          window.location.href = "${escJavaScript(transferUrl)}";
        }
      };
    </script>
  </body>
</html>`;

/***/ }),

/***/ 67650:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   invitationEmailReplace: () => (/* binding */ invitationEmailReplace)
/* harmony export */ });
/* eslint-disable max-len */
const invitationEmailReplace = () => `
  <div 
    class="virtru-nested-secure-message-static" 
    contenteditable="false" 
    style="-webkit-user-select: none; pointer-events: none; background-color: #F1F1F1; color: #A7A9AC; display: inline-block; font-size: 10pt; padding: 10px; margin-top: 5px;"
  >
    <div class="virtru-nested-secure-message-icon" style="display: inline-block; margin-right: 5px; vertical-align: middle; background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyFpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNS1jMDE0IDc5LjE1MTQ4MSwgMjAxMy8wMy8xMy0xMjowOToxNSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChXaW5kb3dzKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDpERjNBREUxRDMwNTcxMUUzQkQ5N0I5Q0I2RDJBRDlBMCIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDpERjNBREUxRTMwNTcxMUUzQkQ5N0I5Q0I2RDJBRDlBMCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkRGM0FERTFCMzA1NzExRTNCRDk3QjlDQjZEMkFEOUEwIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOkRGM0FERTFDMzA1NzExRTNCRDk3QjlDQjZEMkFEOUEwIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+y+QNegAAASpJREFUeNqk0zFLw1AUhuEmtIt20A4OKlWwk1AoLoLURRcXFwfRJTi6mV9Q9BcIbp06qpOLQ1CcdHMSwaGgTsWgIlVxqLWN74ETuJQmFnPgaXqTni+39yZWEASpJJX2PO+bY+YfvQ+YSRvNMpUmPiIaLOSQ1fGwfNg6kMYORnGPMqYNm2hrc1N7fDPgHQuoYwm32JC/iD1cynRxhhVzWrbx/RpzqGIEh3hEBT/Y0WY/KkDqC9tYxQsmcaPBB7pODRyj1i8grFPMYg3zuIOLJ7QwgfO4AKlXnGiDg32M6XqVNSBrD7jnjh7XNeQC41gOA/K6Pb1kAYcwFT54evc3HZfkxBWKfe4qC9bFFgp67qjnN7sSsPjH9N24i3YqYQ0S8Bxz7dNK+jr/CjAAMx5CZ9tPhdAAAAAASUVORK5CYII=); width: 16px; height: 16px; background-repeat: no-repeat;background-position: center;"></div>
    <div class="virtru-nested-secure-message-text-default" style="display:inline-block;">
    </div>
  </div>
`;

/***/ }),

/***/ 67688:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OnboardingMod: () => (/* binding */ OnboardingMod)
/* harmony export */ });
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4424);
/* provided dependency */ var console = __webpack_require__(31799);

const mods = __webpack_require__(25939);
const contexts = __webpack_require__(47446);
const $ = __webpack_require__(55401);
const i18n = __webpack_require__(2622);
const {
  OnboardingV2Modal
} = __webpack_require__(38282);
const onboardingTourPopover = (__webpack_require__(44883).OnboardingTourMod);
const {
  NewComposeActivationMod
} = __webpack_require__(21771);
const {
  transports
} = __webpack_require__(29182);
const AnalyticsService = (__webpack_require__(1246).instance)();
const Templates = __webpack_require__(5749);
const TUTORIAL_MODAL_HTML = Templates.virtruOnboardingV2();
const VirtruOfflineMode = (__webpack_require__(2883)/* ["default"] */ .A);

/**
 * The onboarding mod
 *
 */
class OnboardingMod extends mods.Mod {
  static mainDomKey = 'COMPOSE_BUTTON';
  constructor(settings, newComposerMod) {
    super(settings, newComposerMod);
    this._settings = settings;
    this._newComposerMod = newComposerMod;
    this._current;
    this._isAlive = true;
    this._virtruOfflineMode = new VirtruOfflineMode(this._settings.user._profile);
    (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__._bindAllMethods)(this);
  }
  setup() {
    const {
      user
    } = this._settings;
    const {
      pathname
    } = window.location;
    this.isDelegate = pathname.includes('/b/') || pathname.includes('/d/');
    // listeners for activation via the popup and an email verification
    this._settings.on('load:user', this.checkForActivation);
    this._settings.on('load:user:profile', this.checkForActivation);
    this._settings.on('delegateActivationCompleted', this.delegateActivationCompleted);
    this._settings.user.on('update', this._callback);
    this._settings.user.on('restartTourNoAuth', this.showOnboardOne);
    this._onboardingTourMod = onboardingTourPopover.open(this._settings);
    const onboarding = user.setting('onboarding');
    const showOnboarding = onboarding.isActive;
    // escape if Onboarding is not active
    if (!showOnboarding) {
      return;
    }
    if (this._virtruOfflineMode.isOffline()) {
      return;
    }

    // flags for onboarding progress
    const seenActivationModal = user.setting('onboarding.activation') || false;

    // If the user is new show the activate poopover
    if (user.auth('status') === 'new') {
      // get the install type
      transports.call('content', 'getExtensionInfo', {}).then(res => {
        this.isAdminInstall = res.installType === 'admin';
        if (!seenActivationModal) {
          this.showOnboardOne();
        }
      }).catch(error => console.error(error));
    }

    // reset flag for displaying LimitedEncryptionWarning modal window
    // when users tries to encrypt unsupported PFP formats
    localStorage.setItem('skipLimitedEncryptionWarning', 'false');
  }
  showOnboardOne() {
    AnalyticsService.onboardingTourInitiated({});
    const el = document.createElement('div');
    el.innerHTML = TUTORIAL_MODAL_HTML;
    const imageClass = this.isAdminInstall ? 'activation-admin' : 'activation';
    const bodyText = this.isAdminInstall ? 'ONBOARDING_POPOVER_1_ENTERPRISE_BODY' : 'ONBOARDING_POPOVER_1_INDIVIDUAL_BODY';
    const sendActivation = this.isDelegate ? 'ONBOARDING_SEND_VERIFICATION' : 'ONBOARDING_POPOVER_1_CONFIRM';
    $('.onboardv2__heading', el).text(i18n.t('ONBOARDING_POPOVER_1_HEADER'));
    $('.onboardv2__body', el).text(i18n.t(bodyText));
    $('.onboardv2__confirm', el).text(i18n.t(sendActivation));
    $(el).find('.onboardv2__hero').addClass(imageClass);
    this._current = new OnboardingV2Modal($(el), {});
    const activateButton = $(el).find('.onboardv2__confirm');
    activateButton.on('click', () => {
      this._settings.user.setting('onboarding.activation', true);
      this.close();
      this.requestActivation();
      this._isAlive = false;
    });
    const closeButton = $(el).find('.tour-x-button');
    closeButton.on('click', () => {
      this._settings.user.setting('onboarding.activation', true);
      AnalyticsService.onboardingTourCanceled({
        atModal: 'Welcome to Virtru - Activation'
      });
      this.close();
      this._isAlive = false;
    });
    this._current.openModal();
  }
  showOnboardTwo() {
    const el = document.createElement('div');
    el.innerHTML = TUTORIAL_MODAL_HTML;
    const shouldOnboardingBeShown = this._settings.user.setting('preferences.showOnboardingTour') !== undefined ? this._settings.user.setting('preferences.showOnboardingTour') : false;

    // if the user has the permissions to turn virtru on and has not seen the onboarding tour yet, show the tour
    const doShowOnboardingTour = this._settings.user.setting('permissions.canCreatePolicies') && shouldOnboardingBeShown;

    // If they haven't seen the tour the button should say next otherwise say done
    const buttonText = doShowOnboardingTour ? 'ONBOARDING_POPOVER_2_CONFIRM' : 'ONBOARDING_POPOVER_3_CONFIRM';
    $('.onboardv2__heading', el).text(i18n.t('ONBOARDING_POPOVER_2_HEADER'));
    $('.onboardv2__body', el).text(i18n.t('ONBOARDING_POPOVER_2_BODY', {
      currentUser: this._settings.gmailGlobals.user
    }));
    $('.onboardv2__confirm', el).text(i18n.t(buttonText));
    $('.onboardv2__checkbox-label', el).text(i18n.t('ONBOARDING_POPOVER_2_SKIP_CHECKBOX_LABEL'));
    $(el).find('.onboardv2__hero').addClass('activated');
    $(el).find('.onboardv2__checkbox').css('display', 'flex');
    this._current = new OnboardingV2Modal($(el), {});
    const confirmButton = $(el).find('.onboardv2__confirm');
    confirmButton.one('click', () => {
      this.close();
      this._isAlive = false;
      const checkbox = $(el).find('.onboardv2__checkbox input');
      if (checkbox.is(':checked')) {
        localStorage.setItem('skipActivationCompletedModal', true);
      }
      if (doShowOnboardingTour) {
        // check if any compose window is open, if not show the compose popover.
        const newComposeWindow = $(this._settings.dom.NEW_COMPOSE_BODY);
        if (newComposeWindow.length === 0) {
          this._onboardingTourMod.openTourStepOne();
        } else {
          this._onboardingTourMod.openTourStepTwo();
        }
      }
    });
    const closeButton = $(el).find('.tour-x-button');
    closeButton.hide();
    this._current.openModal();
  }
  activationCompleted() {
    var _this$_newComposerMod, _this$_newComposerMod2;
    this._onboardingTourMod.hideRestartBanner();
    const showModal = !localStorage.getItem('skipActivationCompletedModal');
    if (showModal) {
      this.showOnboardTwo();
    }
    (_this$_newComposerMod = this._newComposerMod) === null || _this$_newComposerMod === void 0 ? void 0 : (_this$_newComposerMod2 = _this$_newComposerMod.updateLabel) === null || _this$_newComposerMod2 === void 0 ? void 0 : _this$_newComposerMod2.call(_this$_newComposerMod);
  }
  delegateActivationCompleted() {
    var _this$_newComposerMod3, _this$_newComposerMod4;
    const statusNotIsActive = this._settings.user.auth('status') !== 'active';

    // If the user is a delegated account and activating from the compose window,
    // show email sent notification
    if (statusNotIsActive && $('.virtru_new_compose').length && !$('.virtru-receiver-inactive').length) {
      this._newComposeActivationMod = NewComposeActivationMod.open($('.virtru_new_compose'), this._settings.currentUser(), this._settings.user.auth('status'), this._settings.dom);
    }
    (_this$_newComposerMod3 = this._newComposerMod) === null || _this$_newComposerMod3 === void 0 ? void 0 : (_this$_newComposerMod4 = _this$_newComposerMod3.updateLabel) === null || _this$_newComposerMod4 === void 0 ? void 0 : _this$_newComposerMod4.call(_this$_newComposerMod3);
  }
  close() {
    if (this._callback) {
      this._settings.user.off('update', this._callback);
    }
    if (this._current) {
      this._current.closeModal.call(this._current);
    }
  }
  requestActivation() {
    this._settings.requestActivation({
      requestedFrom: 'onboarding',
      isReactivation: false
    });
  }
  isAlive() {
    return this._isAlive;
  }
  teardown() {
    this.close();
    this._virtruOfflineMode.teardown();
  }
  showOnboardingModalFinal() {
    // use old flag to populate the new flag.
    if (this._settings.user.setting('onboarding.sentFirstMessage')) {
      this._settings.user.setting('preferences.seenSentFirstMessage', true);
    }
    if (!this._settings.user.setting('preferences.seenSentFirstMessage')) {
      const el = document.createElement('div');
      el.innerHTML = TUTORIAL_MODAL_HTML;
      $('.onboardv2__heading', el).text(i18n.t('ONBOARDING_POPOVER_3_HEADER'));
      $('.onboardv2__body', el).html(i18n.t('ONBOARDING_POPOVER_3_BODY'));
      $('.onboardv2__confirm', el).text(i18n.t('ONBOARDING_POPOVER_3_CONFIRM'));
      $(el).find('.onboardv2__hero').addClass('sent');
      const modal = new OnboardingV2Modal($(el), {});
      const doneButton = $(el).find('.onboardv2__confirm');
      doneButton.one('click', () => {
        modal.closeModal.call(modal);
        this._settings.user.setting('onboarding.isActive', false);
        // Save to server that the user has seen this modal.
        const params = {
          userId: this._settings.currentUser()
        };
        transports.call('content', 'saveUserSettingsToServer', params).catch(err => {
          console.error('Error on saving the user-settings', err);
        });
      });
      const closeButton = $(el).find('.tour-x-button');
      closeButton.hide();
      modal.openModal();
      this._settings.user.setting('preferences.seenSentFirstMessage', true);
      AnalyticsService.onboardingTourFirstEmail({});
    }
  }
  checkForActivation() {
    // if the user is activated and in onboarding.
    const onboarding = this._settings.user.setting('onboarding');
    if (this._settings.user.auth('status') === 'active' && onboarding.isActive) {
      this._settings.off('load:user', this.checkForActivation);
      this.close();
      this.activationCompleted();
    }
  }
}
Object.assign(OnboardingMod.prototype, mods.ModWaiterPromises);
contexts.addOpen(OnboardingMod);

/***/ }),

/***/ 68014:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var mods = __webpack_require__(25939);
var Templates = __webpack_require__(5749);
var emailUtils = __webpack_require__(25119);
const TDF_SELECTOR = 'div pre:contains("--- START PROTECTED MESSAGE TDF")';
const INVITATION_EMAIL_REPLACEMENT = Templates.invitationEmailReplace();
class ComposeBase extends mods.Mod {
  constructor(element) {
    super(element);
    this._element = $(element);
  }
  hideSecureMessageContainer() {
    const tdf = this._editor.find(TDF_SELECTOR);
    if (tdf.length <= 0) {
      return;
    }
    const secureMessage = $(tdf[0]);
    this._secureMessageContainer = emailUtils.getMessageContainer(secureMessage);
    this._secureMessageContainerHtml = this._secureMessageContainer.html();
    this._secureMessageContainer.empty();
    this._secureMessageContainer.html(INVITATION_EMAIL_REPLACEMENT);
  }
  showSecureMessageContainer() {
    if (this._secureMessageContainer) {
      this._secureMessageContainer.empty();
      this._secureMessageContainer.html(this._secureMessageContainerHtml);
    }
  }
}
module.exports = ComposeBase;

/***/ }),

/***/ 68207:
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
function ComposeManager() {
  this.composeMods = {};

  // Used for specific use case of popping out a reply/forward
  this.fauxComposeForPopout = undefined;
}
ComposeManager.prototype.register = function (composeMod) {
  if (composeMod === undefined || composeMod === null) {
    throw new Error('');
  }
  console.debug(`Registering compose : ${composeMod.composeId()}`);
  this.composeMods[composeMod.composeId()] = composeMod;
};
ComposeManager.prototype.registerFaux = function (fauxComposeMod) {
  console.debug('Registering faux compose for pop-out...');
  this.fauxComposeForPopout = fauxComposeMod;
};
ComposeManager.prototype.unregister = function (composeMod) {
  const composeId = composeMod.composeId();
  console.debug(`Unregistering compose : ${composeId}`);
  delete this.composeMods[composeId];
};
ComposeManager.prototype.getComposeMod = function (composeId) {
  console.debug(`Retrieving compose mod: ${composeId}`);
  if (!this.composeMods[composeId]) {
    console.debug('Compose mod does not exist!');
  }
  return this.composeMods[composeId];
};
// Ensure we are a singleton. Use the existing compose manager if it's already defined on the parent window.
// If Virtru is in a popout, we want to grab the compose manager already instantiated on the parent window.
// IMPORTANT NOTE: this can throw an error if we don't have the permission to access the parent (i.e. different domain)
try {
  window.VIRTRU_COMPOSE_MANAGER = window.VIRTRU_COMPOSE_MANAGER || window.opener && window.opener.VIRTRU_COMPOSE_MANAGER;
} catch (e) {
  console.debug('Unable to access information on parent frame.');
}
// Only one instance of compose manager should be on the window.
if (!window.VIRTRU_COMPOSE_MANAGER) {
  window.VIRTRU_COMPOSE_MANAGER = new ComposeManager();
}
module.exports = exports = window.VIRTRU_COMPOSE_MANAGER;

/***/ }),

/***/ 68819:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
const $ = __webpack_require__(91089);
const XhrCoup = (__webpack_require__(98383)["default"]);
const {
  EmailMetadata,
  EmailMetadataEnum
} = __webpack_require__(38282);
const CksUtil = __webpack_require__(15641);
const AnalyticsService = (__webpack_require__(1246).instance)();
const sanitizeAnalyticsError = (__webpack_require__(81442)/* ["default"] */ .A);
const {
  isSender,
  formatDraft,
  getAllWindows
} = __webpack_require__(60355);
const {
  transports
} = __webpack_require__(29182);
const {
  SecureServiceProxy
} = __webpack_require__(6336);
const {
  get
} = __webpack_require__(52635);
const {
  set
} = __webpack_require__(45055);
const {
  TemporaryDraftContent
} = __webpack_require__(60355);
const secureService = SecureServiceProxy.create(transports);
const messageObjArrPath = ['[2][1]', '[1]'];
const messagePaths = ['[2][2][14][1][9][2][0][2]', '[2][2][3][1][5][0][9][2][0][2]', '[0][1][1][13][0][8][1][0][1]', '[0][1][1][2][0][4][0][8][1][0][1]', '[0][1][1][1][0][8][1][0][1]'];
const subjectPaths = ['[2][2][14][1][8]', '[2][2][3][1][5][0][8]', '[0][1][1][13][0][7]', '[0][1][1][2][0][4][0][7]', '[0][1][1][1][0][7]'];
const flagPaths = ['[2][2][14][1][11]', '[2][2][3][1][5][0][11]', '[0][1][1][13][0][10]', '[0][1][1][2][0][4][0][10]', '[0][1][1][1][0][10]'];
const draftFlags = ['^r', '^r_bt'];
module.exports = settings => {
  const isPopoutWindow = document.body.matches(settings.dom.POPOUT_WINDOW);
  if (isPopoutWindow) {
    return;
  }
  const allWindows = getAllWindows();
  const draftIntercept = new XhrCoup(allWindows);
  draftIntercept.urlContains('/sync').hasQueryParam('c').customFilter(req => {
    var _settings$user, _settings$user$permis, _settings$user2, _settings$user2$_prof, _settings$user2$_prof2;
    return isSender(settings) && (settings === null || settings === void 0 ? void 0 : (_settings$user = settings.user) === null || _settings$user === void 0 ? void 0 : (_settings$user$permis = _settings$user.permissions) === null || _settings$user$permis === void 0 ? void 0 : _settings$user$permis.canCreatePolicies) && (settings === null || settings === void 0 ? void 0 : (_settings$user2 = settings.user) === null || _settings$user2 === void 0 ? void 0 : (_settings$user2$_prof = _settings$user2._profile) === null || _settings$user2$_prof === void 0 ? void 0 : (_settings$user2$_prof2 = _settings$user2$_prof.auth) === null || _settings$user2$_prof2 === void 0 ? void 0 : _settings$user2$_prof2.status) === 'active' && req.requestMetadata.headers['Content-Type'] === 'application/json';
  }).on('send', (req, body) => {
    if (typeof body !== 'undefined' && body !== null) {
      const promises = [];

      // The request may hold multiple messages that are waiting to be synced
      // Iterate through them, infer which need to be encrypted, and update them with encrypted TDF html
      const parsedBody = JSON.parse(body);
      let messageObjArr;
      messageObjArrPath.forEach(item => {
        const intermediateResult = get(parsedBody, item);
        if (Array.isArray(intermediateResult)) {
          messageObjArr = intermediateResult;
        }
      });
      if (Array.isArray(messageObjArr)) {
        messageObjArr.forEach(messageObj => {
          try {
            const {
              flags,
              message,
              subject,
              pathIndex
            } = parseMessageObj(messageObj);
            const isSending = $('.virtru-send-animation-widget').length > 0;
            if (!isDraft(flags) && isSending && message) {
              // Clear the temporary draft content on send message
              set(messageObj, messagePaths[pathIndex], TemporaryDraftContent.clear(message));
              promises.push(Promise.resolve(messageObj));
            }

            // We can't single out draft saves from the request headers alone.
            // We need to do filtering on the body of the request to know for sure.
            if (isDraft(flags) && message) {
              const isPlainTextMessage = !message.startsWith('<div') || message.endsWith('div>');
              const htmlMessage = isPlainTextMessage ? `<div>${message}</div>` : message;
              const emailMetadata = EmailMetadata.load($(htmlMessage));
              const isSecure = emailMetadata && (emailMetadata.get(EmailMetadataEnum.COMPOSE_METADATA) || {}).secure;
              const draftId = emailMetadata && emailMetadata.get(EmailMetadataEnum.COMPOSE_ID) || 1;
              if (isSecure && draftId || isSending) {
                // Passed all validation checks so now generate the draft

                console.debug(`Generating secure draft for compose : ${draftId} `);
                promises.push(generateDraft({
                  message,
                  subject,
                  draftId
                }, settings).then(getSendDraftFn(req, messageObj, pathIndex)));
              }
              console.debug('Form body does not contain expected fields for parsing.');
            }
          } catch (e) {
            console.error('failed to parse messageObj', e);
          }
        });
      }
      if (promises.length > 0) {
        return Promise.all(promises).then(() => JSON.stringify(parsedBody)).catch(error => {
          AnalyticsService.clientError({
            context: 'secure_draft',
            name: 'Error making secure draft or sending the message',
            error_obj: sanitizeAnalyticsError(error)
          });
        });
      }
    }
    return false;
  });
};
function generateDraft(parsedQuery, settings) {
  var policyOptions = {
    owner: settings.currentUser(),
    emailUsers: [settings.currentUser()],
    displayName: parsedQuery.subject,
    type: 'draft',
    composeId: parsedQuery.draftId
  };
  var userSettings = settings.user.settings();
  var processorOptions = {
    orgPublicKey: CksUtil.getOrgPublicKey(userSettings)
  };
  return secureService.makeSecureDraft(parsedQuery.message, policyOptions, processorOptions);
}

/**
 * Returns a function that processes the secured draft.
 *
 * @param xhr
 * @param args
 * @returns {Function}
 */
function getSendDraftFn(_, messageObj, pathIndex) {
  return function (response) {
    const formattedDraft = formatDraft(response.tdfXml, false);
    set(messageObj, messagePaths[pathIndex], formattedDraft.message);
  };
}

// TODO: iterate deeply through object and automatically detect which are drafts
function parseMessageObj(messageObj) {
  let pathIndex;
  messagePaths.forEach((path, index) => {
    if (get(messageObj, path)) {
      pathIndex = index;
    }
  });
  return {
    message: get(messageObj, messagePaths[pathIndex]),
    subject: get(messageObj, subjectPaths[pathIndex]),
    flags: get(messageObj, flagPaths[pathIndex]),
    pathIndex
  };
}
function isDraft(flags) {
  return Array.isArray(flags) && flags.indexOf(draftFlags[0]) >= 0 && flags.indexOf(draftFlags[1]) >= 0;
}

/***/ }),

/***/ 70815:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  MessageMod: () => (/* binding */ MessageMod)
});

// EXTERNAL MODULE: ./node_modules/superagent/lib/client.js
var client = __webpack_require__(75522);
var client_default = /*#__PURE__*/__webpack_require__.n(client);
// EXTERNAL MODULE: ./node_modules/suspenders/ElementRegistry/index.js + 1 modules
var ElementRegistry = __webpack_require__(98932);
// EXTERNAL MODULE: ./lib/widgets/read-receipt/index.js
var read_receipt = __webpack_require__(90029);
// EXTERNAL MODULE: ./lib/mods/index.js
var mods = __webpack_require__(25939);
var mods_default = /*#__PURE__*/__webpack_require__.n(mods);
// EXTERNAL MODULE: ./lib/constants/errors.js
var errors = __webpack_require__(22592);
var errors_default = /*#__PURE__*/__webpack_require__.n(errors);
// EXTERNAL MODULE: ./lib/contexts/index.js
var contexts = __webpack_require__(47446);
var contexts_default = /*#__PURE__*/__webpack_require__.n(contexts);
// EXTERNAL MODULE: ./compatibility/jquery-pack/index.js
var jquery_pack = __webpack_require__(55401);
var jquery_pack_default = /*#__PURE__*/__webpack_require__.n(jquery_pack);
// EXTERNAL MODULE: ./lib/sdk/index.js
var sdk = __webpack_require__(29182);
// EXTERNAL MODULE: ./lib/email/index.js
var email = __webpack_require__(58922);
var email_default = /*#__PURE__*/__webpack_require__.n(email);
// EXTERNAL MODULE: ./compatibility/helpers/index.js
var helpers = __webpack_require__(4424);
;// ./sites/gmail/page/mods/download-attachment-net.js
/* provided dependency */ var console = __webpack_require__(31799);

var download_attachment_net_mods = __webpack_require__(25939);
var download_attachment_net_contexts = __webpack_require__(47446);
var $ = __webpack_require__(55401);
var {
  AttachmentService
} = __webpack_require__(38282);
var {
  transports
} = __webpack_require__(29182);
var i18n = __webpack_require__(2622);

/**
 * Creates a new DownloadAttachmentModNet around the download attachment
 * container element.
 *
 * @param settings Current users settings
 * @param element The download attachment container element
 * @constructor
 */
class DownloadAttachmentModNet extends download_attachment_net_mods.Mod {
  constructor(settings, element, attachmentInfo) {
    super(settings, element);
    this._settings = settings;
    this._element = $(element);
    this._downloadOriginalIcon = null;
    this._attachmentInfo = attachmentInfo ? attachmentInfo : null;
    (0,helpers._bindAllMethods)(this);
  }

  // Reference for what's in the attachment array from the parsed email_data
  //  0: "0.1"
  //  1: "config.rb.tdf"
  //  2: "application/tdf"
  //  3: 2257
  //  4: 0
  //  5: "f_hp68v0e90"
  //  6: "/mail/u/0/images/generic.gif"
  //  7: "application/tdf"
  //  9: "?ui=2&ik=a154f92cf8&view=att&th=142eeee2e58434ad&attid=0.1&disp=safe&realattid=f_hp68v0e90&zw"
  //  20: 0
  //  23: 0
  //  28: 1
  /**
   * Initializes the Mod.  This processes the file name then sets up
   * the shield icon and download original link.
   */
  setup() {
    var self = this;
    var $downloadContainer = $(this._element);

    // Process the file name
    var filename = this._attachmentInfo ? this._attachmentInfo[1] : $(this._settings.dom.READ_ATTACHMENT_FILENAME_NOV2013, $downloadContainer).text();
    var splitFilename = filename.toLowerCase().split('.');
    var extension = splitFilename.slice(-1)[0];
    // remove any .tdf extensions from the end of the filename
    for (var i = splitFilename.length - 1; i >= 0; i--) {
      if (splitFilename[i].toLowerCase() !== 'tdf') {
        break;
      }
    }
    var originalFilename = splitFilename.slice(0, i + 1).join('.');
    //  var originalExtension = splitFilename.slice(-2)[0]; // For when we add managed support
    // Skip if not tdf
    if (extension.toLowerCase() !== 'tdf') {
      return;
    }
    this._downloadFilename = originalFilename;
    self.reskinAttachmentElement($downloadContainer, originalFilename);
  }

  /**
   * Changes the UI for the secure attachment
   */
  reskinAttachmentElement(element, originalFilename) {
    var {
      dom
    } = this._settings;

    // add our custom CSS
    element.addClass('gmail-secure-attachment-ui');
    var buttons = $(dom.READ_ATTACHMENT_BUTTONS, element);
    var downloadButton = $(buttons[0]);
    var driveButton = $(buttons[1]);
    this.attachToDownloadButton(downloadButton);
    this.attachToDriveButton(driveButton);
    this.attachToBackgroundElement(element);

    // style the .tdf extension
    var filenameParent = $(dom.READ_ATTACHMENT_FILENAME_PARENT, element);
    var filenameElement = $(`<span>${originalFilename}</span>`);
    $(dom.ATTACHMENT_STYLE_TO_HIDE, element).hide();
    filenameParent.append(filenameElement);
    filenameParent.append('<span class="tdf-extension">.tdf</span>');
  }
  attachToBackgroundElement(element) {
    var self = this;
    var {
      dom
    } = this._settings;

    // add text to the background
    var backgroundLogo = $(dom.READ_ATTACHMENT_BACKGROUND_LOGO, element);
    var backgroundTdfLogo = '<div class="tdf-background"></div>';
    backgroundLogo.append(backgroundTdfLogo);

    // add the Virtru logo and create the decrypting screen
    var decryptionElement = `${'<div class="decryption-element">' + '<div class="virtru-logo">' + '<div class="logo-circle"></div>' + '<div class="logo-v"></div>' + '</div>' + '<div class="decryption-text"><b>'}${i18n.t('DOWNLOAD_ATTACHMENT_DECRYPTING')}</b></div>` + '</div>';
    var interceptBackgroundClick = function (event) {
      console.debug('Background element click.');
      event.stopPropagation();
      event.preventDefault();
      self.downloadOriginal(event);
      return false;
    };

    // intercept background element clicks and allow them to decrypt the TDF and download the original file
    var backgroundElement = $(dom.READ_ATTACHMENT_BACKGROUND, element);
    backgroundElement.append(decryptionElement);
    backgroundElement[0].addEventListener('click', interceptBackgroundClick);

    // do the same for the triangular corner element
    var cornerElement = $(dom.READ_ATTACHMENT_CORNER, element);
    cornerElement[0].addEventListener('click', interceptBackgroundClick);
  }
  attachToDownloadButton(downloadButton) {
    var self = this;
    downloadButton.addClass('download-button');
    downloadButton.attr('data-tooltip', i18n.t('TOOLTIP_SECURE_ATTACHMENT_DOWNLOAD'));
    var buttonTooltipConfig = {
      attributes: true
    };
    this.downloadTooltipObserver = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.attributeName === 'data-tooltip') {
          self.downloadTooltipObserver.disconnect();
          downloadButton.attr('data-tooltip', i18n.t('TOOLTIP_SECURE_ATTACHMENT_DOWNLOAD'));
          self.downloadTooltipObserver.observe(downloadButton[0], buttonTooltipConfig);
        }
      });
    });
    this.downloadTooltipObserver.observe(downloadButton[0], buttonTooltipConfig);

    // Setup events for the cloned element
    downloadButton[0].addEventListener('mousedown', self.downloadOriginal, true);
    downloadButton[0].addEventListener('mouseup', function (event) {
      console.debug('downloadButton : mouseup');
      event.stopPropagation();
      event.preventDefault();
    }, true);
    downloadButton[0].addEventListener('click', function (event) {
      console.debug('downloadButton : click');
      event.stopPropagation();
      event.preventDefault();
    }, true);
  }
  attachToDriveButton(driveButton) {
    var self = this;

    // add our CSS classes to the buttons
    driveButton.addClass('drive-button');

    // disable clicks on the Save to Drive button and replace tooltips
    driveButton[0].addEventListener('click', function (event) {
      console.debug('Drive button click... ignore this');
      event.stopPropagation();
      event.preventDefault();
      return false;
    }, true);
    driveButton.attr('data-tooltip', i18n.t('TOOLTIP_SECURE_ATTACHMENT_DRIVE'));

    // mutation observers for the drivetooltips
    var buttonTooltipConfig = {
      attributes: true
    };
    this.driveTooltipObserver = new MutationObserver(function (mutations) {
      mutations.forEach(function (mutation) {
        if (mutation.attributeName === 'data-tooltip') {
          self.driveTooltipObserver.disconnect();
          driveButton.attr('data-tooltip', i18n.t('TOOLTIP_SECURE_ATTACHMENT_DRIVE'));
          self.driveTooltipObserver.observe(driveButton[0], buttonTooltipConfig);
        }
      });
    });
    this.driveTooltipObserver.observe(driveButton[0], buttonTooltipConfig);
  }
  teardown() {
    if (this.downloadTooltipObserver) {
      this.downloadTooltipObserver.disconnect();
    }
    if (this.driveTooltipObserver) {
      this.driveTooltipObserver.disconnect();
    }
  }

  /**
   * Handles the click event from Download Original
   *
   * @param event
   */
  downloadOriginal(event) {
    console.debug('Download original...');
    // Prevent propagation of this event to google's link
    event.stopPropagation();
    event.preventDefault();
    var url = location.origin + location.pathname + (this._attachmentInfo ? this._attachmentInfo[9] : this._element.attr('download_url'));
    var filename = this._downloadFilename;
    var self = this;
    this._element.addClass('gmail-secure-attachment-ui-decrypting');
    var attachmentService = new AttachmentService(transports, undefined, this._settings);
    attachmentService.readSecureStandaloneFile(url).then(function (response) {
      var $a = $('<a>', {
        download: filename,
        href: response.file,
        style: 'display: none;'
      });
      self._element.removeClass('gmail-secure-attachment-ui-decrypting');
      $(document.body).before($a);
      $a.triggerNative('click');
    }, function () {
      self._element.removeClass('gmail-secure-attachment-ui-decrypting');
    });
  }
}
Object.assign(DownloadAttachmentModNet.prototype, download_attachment_net_mods.ModWaiterPromises);
Object.assign(DownloadAttachmentModNet.prototype, download_attachment_net_mods.ModElementShortcut);
Object.assign(DownloadAttachmentModNet.prototype, download_attachment_net_mods.ModEventListenerShortcut);
download_attachment_net_contexts.addOpen(DownloadAttachmentModNet);
// EXTERNAL MODULE: ./lib/email/lib/animation-widget.js
var animation_widget = __webpack_require__(53749);
// EXTERNAL MODULE: ./lib/email/lib/attachment-utils.js
var attachment_utils = __webpack_require__(62769);
// EXTERNAL MODULE: ./lib/i18n/index.js
var lib_i18n = __webpack_require__(2622);
var i18n_default = /*#__PURE__*/__webpack_require__.n(lib_i18n);
// EXTERNAL MODULE: ./compatibility/virtru-popover/index.js
var virtru_popover = __webpack_require__(55929);
var virtru_popover_default = /*#__PURE__*/__webpack_require__.n(virtru_popover);
// EXTERNAL MODULE: ./lib/utils/index.js
var utils = __webpack_require__(55675);
// EXTERNAL MODULE: ./lib/templates/index.js
var templates = __webpack_require__(5749);
var templates_default = /*#__PURE__*/__webpack_require__.n(templates);
// EXTERNAL MODULE: ./lib/analytics/index.js
var analytics = __webpack_require__(1246);
// EXTERNAL MODULE: ./lib/email/lib/constants.js
var constants = __webpack_require__(76223);
// EXTERNAL MODULE: ./lib/utils/virtru-offline-mode.js
var virtru_offline_mode = __webpack_require__(2883);
// EXTERNAL MODULE: ./sites/gmail/page/mods/gmail-utility.js
var gmail_utility = __webpack_require__(2090);
;// ./sites/gmail/page/mods/message.js
/* provided dependency */ var message_console = __webpack_require__(31799);






















// This doesn't work, READ_RECEIPT_CLASS isn't exported from the package. Replaced with a const below.
// const READ_RECEIPT_CLASS = require('read-receipt').READ_RECEIPT_CLASS;
const READ_RECEIPT_CLASS = 'read-receipt';
const AnalyticsService = (0,analytics.instance)();
const MAX_NUM_DECRYPT_ATTEMPTS = 10;

/**
 * The message mod
 *
 * This mod is responsible for decrypting email messages.
 */
class MessageMod extends mods.Mod {
  constructor(settings, element) {
    super(settings, element);
    this._settings = settings;
    this._element = jquery_pack_default()(element);
    this.decryptionError = null;
    this.numTimesDecrypted = 0;
    this._isMessageClipped = false;
    this._TDF_SELECTOR = [settings.dom.TDF_SELECTOR, 'div pre:contains("Virtru Secure Email:") + pre:contains("Message ID:")'];
    this.decryptedMessage = null;
    this.rejectLoadFn = null;
    this._virtruOfflineMode = new virtru_offline_mode/* default */.A(this._settings.user._profile);
    (0,helpers._bindAllMethods)(this);
  }
}
Object.assign(MessageMod.prototype, (mods_default()).ModWaiterPromises);
contexts_default().addOpen(MessageMod);
MessageMod.prototype.setup = async function () {
  var {
    dom
  } = this._settings;
  var settings = this._settings;
  var self = this;
  self._messageId = self.getMessageId();
  if (!self._messageId) {
    return;
  }

  // make sure multiple mods not hooking the same message
  const otherMods = self.getOtherMods();
  if (otherMods.some(mod => mod._element.get(0) === self._element.get(0))) {
    return;
  }

  // make sure we actually have a secure message
  const isSecure = !!self._findSecureMessageContainer(self._element);

  // hold on to messages to prevent decrypting multiple times
  window._virtruEncryptedMessageCache = window._virtruEncryptedMessageCache || {};
  window._virtruMessageLoadPromises = window._virtruMessageLoadPromises || {};

  // wait until other messages have loaded to prevent flickering
  try {
    await (window._virtruMessageLoadPromises[self._messageId] || Promise.resolve());
  } catch (e) {
    message_console.warn(e);
  }
  if (self.isAlive()) {
    window._virtruMessageLoadPromises[self._messageId] = new Promise((resolve, reject) => {
      self.rejectLoadFn = reject;
    }).catch(message_console.debug);

    // Decrypt the message continuously in case gmail renders content into this DOM element
    self.checkIfMessageNeedsToBeDecryptedEveryInterval(250);
    if (isSecure) {
      self.animationWidget = animation_widget.AnimationWidget.create(self._element, self._settings);
      await self.animationWidget.beginAnimation({
        isMessageClipped: this._isMessageClipped
      });
    }
    if (isSecure) {
      var _perf, _self$getPolicy;
      if (settings.user.auth('status') !== 'active') {
        settings.on('load:user', self.settingsLoaded);
      } else {
        try {
          const decryptedElement = await (0,ElementRegistry.waitUntilElementHasDescendant)(self._element.parents(dom.MESSAGES).get(0), '.virtru-email-decrypted', 32);
          self.decryptedMessage = jquery_pack_default()(decryptedElement);
          self.scrubMessage(decryptedElement);
        } catch (e) {
          message_console.warn(e);
        }
      }
      await self.animationWidget.endAnimation();
      let perf = null;
      try {
        perf = performance.measure('animation_time', constants.DECRYPTION_ANIMATION_START, constants.DECRYPTION_ANIMATION_END);
      } catch (e) {
        message_console.warn(e.message);
      }
      const animationDuration = Math.trunc((_perf = perf) === null || _perf === void 0 ? void 0 : _perf.duration);
      AnalyticsService.decryptionAnimation({
        'policy.Id': (_self$getPolicy = self.getPolicy()) === null || _self$getPolicy === void 0 ? void 0 : _self$getPolicy.policyId,
        'duration': animationDuration
      });
    }
    window._virtruMessageLoadPromises[self._messageId] = null;
  }
};
MessageMod.prototype.reskinDecryptedMessage = function (decryptedMessage) {
  const settings = this._settings;
  const userProfile = settings.user._profile;
  if ((0,utils.isFeatureEnabled)(userProfile, 'useAttachmentChipsV2')) {
    // Allow native or jquery element to be passed
    const $decryptedMessage = jquery_pack_default()(decryptedMessage);
    // If we have attachment chips in the message, move it to the attachment section.
    const attachmentChips = $decryptedMessage.find('.virtru-attachment');
    // Fix attachments if id is not exist
    attachmentChips.each((index, element) => {
      const tdoID = jquery_pack_default()(element).attr('data-tdo-id');
      jquery_pack_default()(element).attr('id', tdoID);
    });
    // Recreate the attachment section
    $decryptedMessage.find('.virtru-attachment-section').remove();
    if (attachmentChips.length > 0) {
      const attachmentSection = jquery_pack_default()(templates_default().attachmentSection());
      // Move all the attachments down into the attachment section
      attachmentSection.append(attachmentChips);
      $decryptedMessage.append(attachmentSection);
      (0,attachment_utils/* createSectionTooltip */.fK)($decryptedMessage);
    }
    // Update the header to reflect how many attachments we have
    $decryptedMessage.find('.virtru-attachment-section-header-text').text(i18n_default().t('SECURED_ATTACHMENTS_HEADER', {
      count: attachmentChips.length
    }));
    // Make sure the attachment section is always at the bottom, in the event that it is already in the message
    $decryptedMessage.append($decryptedMessage.find('.virtru-attachment-section'));
  }
};
MessageMod.prototype.addVirtruStylesAndDelegationLink = function () {
  const self = this;
  const element = this._element;
  const settings = this._settings;
  const {
    processedClass
  } = settings;
  element.addClass(processedClass);
  element.addClass('virtru-message');
  jquery_pack_default()(element).toggleClass('virtru-offline', this._virtruOfflineMode.isOffline());

  // For delegation, if it is an activation email, in BP, the linkId link should be visible
  const {
    pathname
  } = window.location;
  const isDelegated = pathname.includes('/b/') || pathname.includes('/d/');
  const isPopout = document.body.matches(settings.dom.POPOUT_WINDOW) || pathname.includes('/popout');
  if (isDelegated) {
    let linkIdLink = jquery_pack_default()('[name]', element);
    let linkIdName = linkIdLink.attr('name');
    if (!linkIdLink.length) {
      linkIdLink = jquery_pack_default()('a[href*="email-activation"]', element);
      linkIdName = linkIdLink.attr('href');
    }

    // Ensure the link is 'virtru-activation' and not 'virtru-activation-code'
    if (linkIdLink.length && /(virtru|email)-activation(?!-code)/.test(linkIdName) && !linkIdLink.hasClass('verify-me')) {
      linkIdLink.addClass('verify-me').text(i18n_default().t('ACTIVATION_MESSAGE_DELEGATION_LINK'));
      linkIdLink.on('click', function (ev) {
        ev.preventDefault();
        if (isPopout) {
          // Send a message to PopoutListenerFeature (see ./feature/popout-listener-feature.js)
          window.opener.postMessage({
            action: 'activationFromPopoutWindow',
            url: ev.target.href
          }, '*');
          window.close();
        } else {
          // wait for verification tab to open, then reload user profile
          sdk.transports.call('content', 'waitForEmailActivation', {
            url: ev.target.href
          }).then(function () {
            self._settings.emit('load:user:profile');
          });
        }
      });
    }
  }

  // sets the container to show overflow so that the polic config menu displays correctly
  element.find('div[style="overflow: hidden;"]').css({
    'overflow': 'visible'
  });
};
MessageMod.prototype.getOtherMods = function () {
  return window.VIRTRU_MONITOR._collection._mods.filter(mod => mod._element && mod !== this && mod.getMessageId && mod.getMessageId() === this.getMessageId());
};
MessageMod.prototype.messageLooksEncrypted = function () {
  const embeddedMessages = this._element.parent().find('.virtru-embedded-message');
  const isTopLevelMessage = embeddedMessages.length === 0;
  const secureMessageContainer = this._findSecureMessageContainer(this._element);
  // Make sure we are actually a secure message!
  return !!secureMessageContainer
  // When a message is decrypted, the original message is hidden, and the new message is placed right next to it.
  // If the original message are no longer hidden, chances are gmail has re-rendered this portion of the DOM.
  && (isTopLevelMessage && this._element.is(':visible') || !isTopLevelMessage && secureMessageContainer.is(':visible'))
  // It's also possible that we present an an error
  && this._element.parent().find('.virtru-error-template').length <= 0
  // Ensure we're not already in the middle of decrypting
  && !this.isDecrypting && !this.decryptionError;
};
MessageMod.prototype.checkIfMessageNeedsToBeDecryptedEveryInterval = function (interval) {
  const self = this;
  this.isDecrypting = false;
  this.needsDecrypt = false;
  this.decryptionError = null;
  // Check frequently to see if we need to decrypt again
  _decryptMessageIfNecessary();
  function _decryptMessageIfNecessary() {
    self.addVirtruStylesAndDelegationLink();
    // If a user is already activated, make sure the message stays decrypted.
    if (self._settings.user.auth('status') === 'active') {
      // Make sure we don't get stuck in an endless decrypt loop
      if ((self.needsDecrypt || self.messageLooksEncrypted()) && self.numTimesDecrypted < MAX_NUM_DECRYPT_ATTEMPTS) {
        self.needsDecrypt = false;
        // check if we already have the decrypted message on hand
        if (self.decryptedMessage) {
          // we can just swap out the message if we already went through decryption
          const secureMessageContainer = self._findSecureMessageContainer(self._element);
          if (secureMessageContainer) {
            self._hideOriginalMessage();
            self.decryptedMessage.insertAfter(secureMessageContainer.parent());
            self.decryptedMessage = null;
          }
        } else {
          // We need to decrypt this message from scratch
          self.isDecrypting = true;
          self.numTimesDecrypted++;
          self.processMessage();
          self.setupDownloadAttachments();
        }
      }
      // Show activation UI if it doesn't already exist
    } else if (self._element.find('.virtru-receiver-inactive').length <= 0) {
      self.showActivationUI();
      self.hideMicroTdf();
    }

    // Show decryption errors if they exist
    if (self.decryptionError) {
      self.showDecryptionError();
    }
    if (!self.isAlive()) {
      self.teardown();
    } else {
      self._refreshTimeout = setTimeout(_decryptMessageIfNecessary, interval);
    }
  }
};

/**
 * Return the message id of the current message
 *
 * @returns {*} The message id of this message
 */
MessageMod.prototype.getMessageId = function () {
  var {
    dom
  } = this._settings;
  var $messageContainer = this._element.parents(dom.MESSAGES);
  var messageId = $messageContainer.data('message-id');
  return messageId ? String(messageId).replace('#', '') : '';
};
MessageMod.prototype.getPolicy = function () {
  if (!this.readWidget) {
    message_console.error('Cannot find readWidget');
    return undefined;
  }
  return this.readWidget.getPolicy();
};
MessageMod.prototype.showActivationUI = function (status) {
  var activationInterface = email_default().showActivationInterface(this._element, this._settings.currentUser(), status ? status : this._settings.user.auth('status'), this._settings.dom);
  activationInterface.on('activationRequested', this.requestActivation);
};

// Implement scenarios for Decryption Errors
MessageMod.prototype.showDecryptionError = function () {
  const showError = {
    [(errors_default()).TWO_FACTOR_REQUIRED]: () => this.show2FAError()
  };
  if (Object.hasOwn(showError, this.decryptionError.name)) {
    showError[this.decryptionError.name]();
  }
};

// Check if 2FA error message exist on the page
MessageMod.prototype.is2FAErrorEmbedded = function () {
  return document.querySelector('.virtru-2fa-error');
};
MessageMod.prototype.show2FAError = function () {
  if (this.is2FAErrorEmbedded()) {
    return;
  }
  const errorMessage = document.createElement('td');
  errorMessage.className = 'virtru-2fa-error';
  errorMessage.innerText = i18n_default().t('TWO_FACTOR_AUTH_ERROR');
  const closestMessage = document.querySelector('.virtru-message');
  const messageLinks = closestMessage.querySelectorAll('a');
  const closestButton = [...messageLinks].filter(l => l.innerText === i18n_default().t('UNLOCK_MESSAGE_BUTTON'))[0];
  const closestTableRow = closestButton.parentNode;
  closestTableRow.after(errorMessage);
};
MessageMod.prototype.requestActivation = function (isReactivation) {
  this._settings.requestActivation({
    requestedFrom: 'email_read',
    isReactivation
  });
};
MessageMod.prototype.settingsLoaded = function () {
  var settings = this._settings;
  if (settings.user.auth('status') === 'active') {
    if (!this.isDecrypting) {
      this.needsDecrypt = true;
    }
    settings.off('load:user', this.settingsLoaded);
    this._element.attr('data-virtru-needs-decrypt', 'true');
    this.decryptionError = null;
  }
};
MessageMod.prototype.processMessage = function () {
  var element = this._element;

  // See if the message is clipped by checking for any links with the message id in the URL.
  // If it's clipped we xhr the full message.
  var clippedMessageHref = '';
  var $links = element.find('a');
  for (var i = 0; i < $links.length; i++) {
    var messageHref = decodeURIComponent(String(jquery_pack_default()($links[i]).attr('href')));
    if (messageHref.indexOf(this._messageId) >= 0) {
      clippedMessageHref = messageHref;
      break;
    }
  }
  if (clippedMessageHref) {
    this._isMessageClipped = true;
    this.handleClippedMessage(clippedMessageHref);
  } else {
    this._createWidget(element);
  }
};
MessageMod.prototype.handleClippedMessage = function (href) {
  const element = this._element;
  message_console.warn(`Detected clipped message (msg id: ${this._messageId}), attempting to retrieve pristine message from GMail...`);
  client_default().post(href).end((error, res) => {
    if (error) {
      // This should set up the error widget...
      message_console.error('Retrieving the full message failed, attempting to display message as is...');
      this._createWidget(element);
      return;
    }
    message_console.info(`Retrieved clipped message (msg id: ${this._messageId})`);
    const responseHtml = res.text;
    const appended = jquery_pack_default()('<div></div>').append(responseHtml);

    // Find the secure message container inside of the 'clipped' message as well as the
    // 'pristine' message downloaded from GMail so we can swap them.
    const clippedMessageContainer = this._findSecureMessageContainer(element);
    const pristineMessageContainer = this._findSecureMessageContainer(appended);

    // We aren't dealing with secure content
    if (!pristineMessageContainer) {
      message_console.warn(`False positive clipped message (msg id: ${this._messageId}), not an encrypted message`);
      return;
    }

    // Make sure to replace the partial chain with the full chain
    // that was just grabbed from GMail
    if (clippedMessageContainer) {
      message_console.info(`Loading clipped message into DOM (msg id: ${this._messageId})`);
      clippedMessageContainer.empty();
      clippedMessageContainer.append(pristineMessageContainer.children());
    } else {
      // It was so clipped that we cannot find any secure container
      message_console.info(`Loading pristine secure container into bottom of DOM, no clipped secure container found (msg id: ${this._messageId})`);
      element.append(pristineMessageContainer);
    }
    this._createWidget(element);
  });
};
MessageMod.prototype.getMessageSender = function () {
  var {
    dom
  } = this._settings;
  var messageContainer = this._element.parents(dom.MESSAGES);
  var emailSpan = messageContainer.find('span.gD');
  var emailAddress = emailSpan.attr('email');
  return emailAddress;
};
MessageMod.prototype.getSubject = function () {
  var {
    dom
  } = this._settings;
  return this._element.parents(dom.GMAIL_THREAD_CONTAINER).find(dom.MESSAGE_THREAD_SUBJECT).text();
};
MessageMod.prototype._createWidget = function (element) {
  const {
    dom
  } = this._settings;
  const options = {
    transports: sdk.transports,
    sender: this.getMessageSender(),
    subject: this.getSubject(),
    doAnimation: false
  };
  this.didAnimation = true;

  // Hold onto the pristine payload in case we need it elsewhere (e.g. replying).
  // This is used to workaround gmail material design's behavior of clipping long messages.
  // We only want to do this if the message is secure so that we don't muck with unsecure content.
  const secureMessageContainer = this._findSecureMessageContainer(element);
  if (secureMessageContainer && (0,gmail_utility.isSecureParentMessage)(secureMessageContainer.parent())) {
    const messageId = this._messageId;
    const ltr = element.find(dom.LTR_BLOCK);
    if (ltr.length > 0 && !window._virtruEncryptedMessageCache[messageId]) {
      window._virtruEncryptedMessageCache[messageId] = ltr.html();
    }
  }
  email_default().createWidget(element, this._settings, options).then(emailWidget => {
    this.emailWidget = emailWidget;
    this.registerMessage(emailWidget);
    var {
      canViewReadReceipt
    } = this._settings.user.permissions;
    // this is currently INTENTIONALLY enabled for everyone..
    canViewReadReceipt = true; // DEBUG

    if (canViewReadReceipt) {
      var $msg = element.closest(dom.MESSAGES);
      var $target = $msg.find('.virtru-sender-header-message');

      // Remove any previously drawn read receipts
      $target.find(`.${READ_RECEIPT_CLASS}`).remove();

      // readWidget SEEMS to correlate to the one msg being decrypted..
      // TODO what are readwidgets? can you have more than one?
      emailWidget._readWidgets.forEach(function (readWidget) {
        try {
          const callbacks = {
            forward: count => i18n_default().t('READ_RECEIPT_FORWARD_COUNT', {
              count
            }),
            recipients: ({
              accessors,
              recipients
            }) => i18n_default().t('READ_RECEIPT_READBY_COUNT', {
              accessors,
              count: recipients
            })
          };
          var readReceipt = new read_receipt/* ReadReceipt */.h(readWidget._contract, $msg, (virtru_popover_default()), callbacks);
          readReceipt.addIndicatorTo($target);
        } catch (e) {
          message_console.error(e);
        }
      });
    }
    emailWidget.on('loaded-message-in-chain', this.scrubMessage);
  }).catch(async err => {
    message_console.error(err);
    if (err.name === (errors_default()).INVALID_APP_ID) {
      this.showActivationUI('expired');
      this.hideMicroTdf();
      this._settings.on('load:user', this.settingsLoaded);
    } else if (err.name === (errors_default()).NO_APP_ID_FOR_DOMAIN) {
      this.showActivationUI('new');
      this.hideMicroTdf();
      this._settings.on('load:user', self.settingsLoaded);
    } else {
      // continue as normal
    }
    await this.animationWidget.endAnimation();
    this.decryptionError = err;
  }).finally(() => {
    this.isDecrypting = false;
  });
};

/**
 * Registers this widget and its policy with the MessageManager
 *
 * @param emailWidget
 */
MessageMod.prototype.registerMessage = function (emailWidget) {
  // Only register if we know we have a readWidget
  if (emailWidget._readWidgets != null && emailWidget._readWidgets.length != 0) {
    this.readWidget = emailWidget._readWidgets[0];
    mods_default().MessageManager.register(this);
  }
};

/**
 * This function removes and 'h5' classes on elements... These are being
 * hidden for some reason in GMail because the class has display: none;
 * on it.
 */
MessageMod.prototype.scrubMessage = function (loadedMessage) {
  var {
    dom
  } = this._settings;
  var element = this._element;
  var hiddenElements = element.find(dom.GMAIL_HIDDEN_ELEMENTS);
  hiddenElements.removeClass('h5');

  // Remove extra Virtru template message if it exists (mostly related to Outlook 365 plugin)
  jquery_pack_default()(loadedMessage).find('.virtru-invitation').closest(dom.LTR_BLOCK).remove();
  this.reskinDecryptedMessage(jquery_pack_default()(loadedMessage).parent().find('.virtru-email-decrypted'));
};
MessageMod.prototype.isAlive = function () {
  return jquery_pack_default().contains(document.documentElement, this._element[0]) && !!this._messageId;
};
MessageMod.prototype.teardown = function () {
  mods_default().MessageManager.unregister(this);
  if (this._refreshTimeout) {
    clearTimeout(this._refreshTimeout);
  }
  const $cksElement = this._element.parent().parent().find('.virtru-cks-indicator');
  if ($cksElement.length) {
    $cksElement.remove();
  }
  if (this.rejectLoadFn) {
    window._virtruMessageLoadPromises[this._messageId] = null;
    this.rejectLoadFn(new Error('Manually rejected load promise'));
  }
  if (this.emailWidget) {
    this.emailWidget.teardown();
    this.emailWidget.off('loaded-message-in-chain', this.scrubMessage);
  }
  if (this.downloadAttachmentModNet) {
    this.downloadAttachmentModNet.teardown();
  }
  // remove messages from cache, only if no other mods are using it
  const otherMods = this.getOtherMods();
  if (otherMods.length <= 0) {
    delete window._virtruEncryptedMessageCache[this._messageId];
  }
  this._virtruOfflineMode.teardown();
};
MessageMod.prototype.hideMicroTdf = function () {
  for (var i = 0, len = this._TDF_SELECTOR.length; i < len; ++i) {
    jquery_pack_default()(this._TDF_SELECTOR[i]).css('font-size', '0em');
  }
};

/**
 * This function finds the secure message container div inside of an element. It does
 * this by iterating through a few different selectors until it identifies some part
 * of the secure message format, then navigates up the dom to the container element.
 * @param {$} element - A jQuery like element
 * @private
 * @returns {$} - The jQuery element containing the secure message or undefined if no
 * secure message container can be found.
 */
MessageMod.prototype._findSecureMessageContainer = function _findSecureMessageContainer(element) {
  for (var i = 0, len = this._TDF_SELECTOR.length; i < len; ++i) {
    const selector = this._TDF_SELECTOR[i];
    const result = element.find(selector);
    if (result.length !== 0) {
      return result.parent();
    }
  }
  return null;
};

/**
 * Locate attachments on the page
 */
MessageMod.prototype.setupDownloadAttachments = function () {
  var self = this;
  var {
    dom
  } = this._settings;
  var messageContainer = this._element.parent().parent();
  var attachmentContainer = jquery_pack_default()(dom.GMAIL_ATTACHMENT_DATA, messageContainer);

  // FIXME separate into a different mod
  var processMatches = function (matches, attachmentData) {
    matches.each(function (index, el) {
      el = jquery_pack_default()(el);
      // If it's the nov 2013 style of attachment container use that mod
      var mod = DownloadAttachmentModNet.open(self._settings, el, attachmentData ? attachmentData[index] : null);
      self.register(mod);
    });
  };

  // Use a very inclusive selector to support the old and the nov-2013
  // attachment container
  var downloadAttachmentsSelector = `${dom.READ_ATTACHMENT_CONTAINER}, ${dom.READ_ATTACHMENT_CONTAINER_NOV2013}`;
  var matches = jquery_pack_default()(downloadAttachmentsSelector, messageContainer);
  if (matches.length > 0) {
    processMatches(matches);
  } else if (attachmentContainer.length > 0) {
    var attachmentData = [];
    attachmentContainer.each(function (index, el) {
      el = jquery_pack_default()(el);
      el.addClass('N5jrZb');
      var arr = [];
      arr[1] = jquery_pack_default()(self._settings.dom.READ_ATTACHMENT_FILENAME_NOV2013, el).text();
      arr[9] = `?ui=2&view=att&th=${self._messageId.slice(1)}&attid=0.${index + 1}`;
      attachmentData.push(arr);
    });
    processMatches(attachmentContainer, attachmentData);
  }
};
MessageMod.prototype._hideOriginalMessage = function () {
  // We should hide all parts of original message
  // These 3 divs contain metadata, payload and <table> markup
  // that users sees when he opens an email without extension
  const secureMessageContainer = this._findSecureMessageContainer(this._element);
  secureMessageContainer.prev().prev().hide();
  secureMessageContainer.prev().hide();
  secureMessageContainer.hide();
};
MessageMod.mainDomKey = 'READ_EMAIL_ELEMENT';
MessageMod.skipAutoTeardown = true;

/***/ }),

/***/ 71139:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  createStore
} = __webpack_require__(42804);
const reducers = (__webpack_require__(82878)/* ["default"] */ .A);
const globalStore = createStore(reducers);
module.exports = globalStore;

/***/ }),

/***/ 71652:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const contexts = __webpack_require__(47446);
const {
  renderEncryptedSearchReminder
} = __webpack_require__(59345);
module.exports = EncryptedSearchReminder;

/**
 * Sets up printing an individual message
 *
 * @param {GmailSettings} settings
 * @param {HTMLElement} element - DOM element
 */
function EncryptedSearchReminder(settings, element) {
  this.settings = settings;
  this.element = element;
  this.user = settings.user;
  this.setup(settings, element);
  this.unmountReminder = () => {};
}
EncryptedSearchReminder.mainDomKey = 'SEARCH_BAR_DROPDOWN_TBODY';

/**
 * Sets up the print button from the dropdown. The print button is not unique per message.
 * There is only one print button for all messages.
 *
 * @param {GmailSettings} settings
 * @param {HTMLElement} element
 */
EncryptedSearchReminder.prototype.setup = function (settings, element) {
  if (this.user.settings().hasSearchKey) {
    return;
  }
  this.unmountReminder = renderEncryptedSearchReminder(element);
};
EncryptedSearchReminder.prototype.teardownAll = function () {
  this.unmountReminder();
};

// Required for the mod system, but we setup in constructor
EncryptedSearchReminder.prototype.setupAll = function () {};
contexts.addOpen(EncryptedSearchReminder);

/***/ }),

/***/ 72083:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * A mutation observer shim for finding new elements. Only works on new
 * elements.
 */
var $ = __webpack_require__(91089);
var processedClass = `mopc-${Math.floor(Math.random() * 100000)}`;
var TIMEOUT = 100; // Check for new every 100 ms

function CompatMutationObserver(callback) {
  this._callback = callback;
  this._observerTimeout = null;
}
CompatMutationObserver.prototype.observe = function (el) {
  var callback = this._callback;
  var self = this;
  function findMatches() {
    var matches = $(el).find(`:not(.${processedClass})`);
    matches.addClass(processedClass);
    var rawMatches = matches.get();
    callback(new Records(rawMatches));
    self._observerTimeout = setTimeout(findMatches, TIMEOUT);
  }
  // Do an initial match
  findMatches();
};
CompatMutationObserver.prototype.disconnect = function () {
  clearTimeout(this._observerTimeout);
};

/**
 * A shim for the records
 */
function Records(matches) {
  this._matches = matches;
}
Records.prototype.forEach = function (callback) {
  callback({
    addedNodes: this._matches
  });
};
module.exports = CompatMutationObserver;

/***/ }),

/***/ 72213:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ createReactRoot)
/* harmony export */ });
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(64078);

function createReactRoot({
  element,
  rootId,
  tagName = 'div'
}) {
  let rootEl = document.querySelector(`#${rootId}`);
  if (!rootEl) {
    rootEl = document.createElement(tagName);
    rootEl.id = rootId;
    (element || document.body).appendChild(rootEl);
  }
  return (0,react_dom_client__WEBPACK_IMPORTED_MODULE_0__/* .createRoot */ .H)(rootEl);
}

/***/ }),

/***/ 72665:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SecureEmailWidget: () => (/* binding */ SecureEmailWidget)
/* harmony export */ });
/* harmony import */ var _utils_sanitizeAnalyticsError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(81442);
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4424);
/* provided dependency */ var console = __webpack_require__(31799);


var $ = __webpack_require__(55401);
var widgets = __webpack_require__(31795);
var i18n = __webpack_require__(2622);
var AnalyticsService = (__webpack_require__(1246).instance)();
var emitter = __webpack_require__(16502);
var {
  SecureEmailReader
} = __webpack_require__(96638);
var SecureReadWidget = __webpack_require__(73871);
var {
  AnimationWidget
} = __webpack_require__(53749);
var Guard = __webpack_require__(57128);
var errors = __webpack_require__(22592);
var {
  cksErrors
} = (__webpack_require__(82672).modules);
var defaultOptions = {
  SecureEmailReader,
  SecureReadWidget,
  AnimationWidget,
  secureService: null,
  connectOptions: null,
  renderer: info => info.message.body
};

/**
 * A widget for reading emails
 *
 * @param {*} element - The UI message element
 * @param {Settings} settings - The settings object
 * @param {*} options - Other options
 * @property {String} options.sender - The reported sender in the UI
 * @property {String} options.subject - The reported subject in the UI
 * @property {*} options.secureService - The {SecureService} object to use
 *
 * @constructor
 */
function SecureEmailWidget(element, settings, options) {
  this._element = element;
  this._options = options;
  this._settings = settings;
  this._reader = null;
  this._secureService = options.secureService;
  // Set properties
  this._isOwner = false;
  this._readWidgets = [];
  (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_0__._bindAllMethods)(this);
}

/**
 * Events:
 *   loaded-message-in-chain - This event is fired when the 'Load more messages' button
 *      is clicked.  This event has no parameters.
 *
 *
 */
emitter(SecureEmailWidget.prototype);

/**
 * Create the widget to replace the given email element
 *
 * @param {DOMElement/jQueryElement} emailElement The element that contains
 *                                                the email html
 * @param {Settings} settings - Settings object
 * @param {Object} options options object
 * @param {Object} options.transports - The script transports object
 * @param {String} options.sender - The sender email address reported in the UI
 *
 * @returns {Promise} A promise that returns the widget
 */
SecureEmailWidget.create = function (emailElement, settings, options) {
  Guard.checkIsDefAndNotNull(emailElement, 'SecureEmailWidget.emailElement');
  Guard.checkIsDefAndNotNull(settings, 'SecureEmailWidget.settings');
  Guard.checkIsDefAndNotNull(options, 'SecureEmailWidget.options');
  emailElement = $(emailElement);
  options = {
    ...defaultOptions,
    ...options
  };
  var widget = new SecureEmailWidget(emailElement, settings, options);
  return widget.readEmail().then(() => widget);
};

/**
 * Loads the first email element using the SecureEmailReader
 *
 * @returns {Promise<*>} - Returns a promise to completion of reading the email
 */
SecureEmailWidget.prototype.readEmail = function () {
  var options = this._options;
  var element = this._element;
  this._reader = this._reader = options.SecureEmailReader.create({
    element,
    settings: options.settings || this._settings,
    secureService: this._secureService
  });
  this._animationWidget = null;
  this._secureReaderLink = this.getSecureReaderLink(element);
  return Promise.resolve().then(this._readMessage.bind(this)).then(this._processMessage.bind(this)).catch(this._handleError.bind(this));
};
SecureEmailWidget.prototype._readMessage = function () {
  return this._reader.startReading(this._element, this._options.connectOptions, this._animationWidget).then(readerResponse => {
    this._readerResponse = readerResponse;
  });
};
SecureEmailWidget.prototype._processMessage = function () {
  if (this._readerResponse.messageWasClipped) {
    return this._handleClippedMessages();
  }
  if (!this._readerResponse.isSecureMessage) {
    return undefined;
  }
  return this._renderMessage();
};
SecureEmailWidget.prototype._handleClippedMessages = function () {
  if (!this._readerResponse.messageWasClipped) {
    return;
  }
  var element = this._readerResponse.containerElement;
  element.empty();

  // Remove all classes
  element.removeClass();
  element.addClass('virtru-open');
  const messageClippedError = new Error('Message was clipped');
  // _handleError method that does logging is bypassed with this flow
  // do the logging here
  console.error(messageClippedError);
  this.setupReadEmailError(element, false, messageClippedError);
};
SecureEmailWidget.prototype._renderMessage = function (readerResponse) {
  readerResponse = readerResponse || this._readerResponse;
  var messageState = readerResponse.messageInfo.contract.state;
  var {
    isOwner
  } = readerResponse.messageInfo.contract;
  var options = this._options;

  // If we can only render if active then do nothing if it is not active
  if (messageState === 'deactivated' && !isOwner && options.renderOnlyIfActive) {
    return;
  }
  var readWidgets = this._readWidgets;
  // Disable cascading footers
  if (readWidgets.length) {
    readWidgets[readWidgets.length - 1].emailWidget.hideFooter();
  }
  var secureReadWidget = SecureReadWidget.create(readerResponse, this._settings, this._options, this._reader._metadata);
  readWidgets.push(secureReadWidget);
  this._setupReplyChainRendering(secureReadWidget);

  // This call is kicked off asynchronously rather than being returned.  The reason is that
  // this call pulls the RemoteManifest from S3 and decrypts it.  Blocking on this on slow connections
  // forces the user to wait for 3 network requests prior to viewing the content of the message.  On
  // latent or slow connections this perceived latency is compounded and in some cases can take up
  // to 10-12 seconds.
  secureReadWidget.setupVirtruAttachments();
};
SecureEmailWidget.prototype._setupReplyChainRendering = function (secureReadWidget) {
  var showNextMessage = secureReadWidget.emailWidget._element.find('div[data-message-id]:not(.virtru-open)');
  showNextMessage.click(e => {
    showNextMessage.off('click');
    var target = $(e.target);
    var placeholder = target.closest('div[data-message-id]');
    var messageId = placeholder.data('message-id');
    this._readChainedMessage(placeholder, messageId);

    // Display the placeholder's loading text while the message loads
    placeholder.removeClass('virtru-nested-secure-message-default');
    placeholder.addClass('virtru-nested-secure-message-loading');
  });
};

/**
 * Reads one of the chained messages
 *
 * @param {jQueryElement} placeholder The placeholder for the chained message
 * @param {String} messageId The id of the message to be read
 *
 * @returns {Promise} A promise that resolves no data when complete.
 */
SecureEmailWidget.prototype._readChainedMessage = function (placeholder, messageId) {
  return this._reader.read(messageId).then(readerResponse => {
    readerResponse.containerElement = placeholder;
    placeholder.addClass('virtru-open');
    this._renderMessage(readerResponse);
    this.emit('loaded-message-in-chain', placeholder);
  }).catch(err => {
    // TODO : Update the UI to reflect the error
    console.error(err);
  });
};
SecureEmailWidget.prototype.setupIntegrityError = function (error) {
  this._emailError = widgets.MessageIntegrityError.create({
    sender: this._options.sender
  });
  this._element.before(this._emailError.htmlElement());
  this._element.hide();
  this._element.empty();
  this._emailError.initEvents();

  // Emit metric for this event
  var event = {
    type: 'payload',
    'policy.Id': this._getPolicyId(),
    'alert.variant': 'none'
  };
  if (error.currentMessageId) {
    event.context = {
      'message.id': error.currentMessageId
    };
  }
  AnalyticsService.integrityCompromised(event);
};
SecureEmailWidget.prototype.setupCksError = function (error) {
  widgets.CksError.render(this._element[0], {
    error
  });
  this._element.hide();
  this._element.empty();
  AnimationWidget.removeFromDOM(this._element);
  this._trackError(error);
};
SecureEmailWidget.prototype.setupReadEmailError = function (element, canRetry, error) {
  if (canRetry === undefined) {
    canRetry = true;
  }
  const props = {
    customClassName: 'virtru-error-template-read',
    errorMessage: i18n.t('EMAIL_ERROR_READ'),
    canRetry,
    onRetryClick: () => window.location.reload(),
    SRLink: this._secureReaderLink,
    SRLabel: i18n.t('EMAIL_ERROR_READ_SECURE_READER_LABEL')
  };
  if (error) {
    let header;
    let message;
    if (error.name === errors.NETWORK_CONNECTION_ERROR) {
      header = i18n.t('EMAIL_ERROR_NETWORK_LOST_HEADER');
      message = i18n.t('EMAIL_ERROR_NETWORK_LOST');
    } else if (error.name === errors.INTERNAL_SERVER_ERROR) {
      header = i18n.t('EMAIL_ERROR_INTERNAL_SERVER_ERROR_HEADER');
      message = i18n.t('EMAIL_ERROR_INTERNAL_SERVER_ERROR');
    } else if (error.name === errors.CORRUPT_TDF_PACKAGE) {
      header = i18n.t('EMAIL_ERROR_EMAIL_CORRUPT_HEADER');
      message = i18n.t('EMAIL_ERROR_EMAIL_CORRUPT');

      // Only show this in debug mode for QA
    } else if (error.name === errors.NO_APP_ID_FOR_DOMAIN) {
      header = i18n.t('EMAIL_ERROR_YOURE_ON_STAGING_HEADER');
      message = i18n.t('EMAIL_ERROR_YOURE_ON_STAGING');

      // Generic error
    } else {
      header = i18n.t('EMAIL_ERROR_UNKNOWN_HEADER');
      message = i18n.t('EMAIL_ERROR_UNKNOWN');
    }
    props.errorHeader = header;
    props.errorMessage = message;
    this._trackError(error);
  } else {
    AnalyticsService.clientError({
      context: 'email_read',
      'policy.Id': this._getPolicyId(),
      name: 'unknown'
    });
  }
  element.siblings('.virtru-error-template').remove();
  const container = widgets.EmailError.create(props);
  element.before(container);
  element.hide();
  AnimationWidget.removeFromDOM(element);
};
SecureEmailWidget.prototype._trackError = function (error) {
  if (error.name !== errors.NETWORK_CONNECTION_ERROR) {
    AnalyticsService.clientError({
      context: 'email_read',
      'policy.Id': this._getPolicyId(),
      name: typeof error.name !== 'undefined' ? error.name : 'unknown',
      error_obj: (0,_utils_sanitizeAnalyticsError__WEBPACK_IMPORTED_MODULE_1__/* .sanitizeAnalyticsError */ .h)(error)
    });
  }
};
SecureEmailWidget.prototype._handleError = function (error) {
  console.error('Widget error', error);
  this._handledError = error;

  // Early out errors, just show the unlock template as-is
  if ([errors.NO_APP_ID_FOR_DOMAIN, errors.INVALID_APP_ID, errors.TWO_FACTOR_REQUIRED].includes(error.name)) {
    throw error;
  }
  if (error.name === errors.INTEGRITY_COMPROMISED_ERROR) {
    this.setupIntegrityError(error);
  } else if (cksErrors.isCksError(error) || error.name === errors.COMPROMISED_KEY_ERROR) {
    this.setupCksError(error);
  } else if (error.type !== errors.NOT_A_SECURE_EMAIL) {
    this.setupReadEmailError(this._element, true, error);
  } else {
    // no special handling
  }
};

/**
 * Teardown all of the connected read widgets
 */
SecureEmailWidget.prototype.teardown = function () {
  this._readWidgets.forEach(readWidget => {
    readWidget.teardown();
  });
};

/**
 * Gets policy id if one can be found.
 * @returns {String} - The policy id or 'unknown' if not available
 */
SecureEmailWidget.prototype._getPolicyId = function () {
  var _this$_readerResponse, _this$_readerResponse2, _this$_readerResponse3;
  return ((_this$_readerResponse = this._readerResponse) === null || _this$_readerResponse === void 0 ? void 0 : (_this$_readerResponse2 = _this$_readerResponse.messageInfo) === null || _this$_readerResponse2 === void 0 ? void 0 : (_this$_readerResponse3 = _this$_readerResponse2.contract) === null || _this$_readerResponse3 === void 0 ? void 0 : _this$_readerResponse3.policyId) || 'unknown';
};

/**
 * Receive the secure reader link from the original message.
 */
SecureEmailWidget.prototype.getSecureReaderLink = function (element) {
  const link = element.parent().find('a[href*="virtru.com/start/"]');
  return link.attr('href');
};

/***/ }),

/***/ 73377:
/***/ ((module) => {

module.exports = {
  gray: '#A7A9AC',
  green: '#60AE04',
  black: '#2C2C2C',
  white: '#F6F6F6',
  blue: '#4585FF'
};

/***/ }),

/***/ 73405:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  PolicyConfigMenuFunctions: () => (/* binding */ PolicyConfigMenuFunctions),
  attachPolicyMenu: () => (/* binding */ attachPolicyMenu),
  updateModel: () => (/* binding */ updateModel)
});

// EXTERNAL MODULE: ./node_modules/react/index.js
var react = __webpack_require__(87568);
// EXTERNAL MODULE: ./node_modules/react-dom/client.js
var client = __webpack_require__(64078);
// EXTERNAL MODULE: ./lib/widgets/policy-model.js
var policy_model = __webpack_require__(74029);
// EXTERNAL MODULE: ./lib/i18n/index.js
var i18n = __webpack_require__(2622);
var i18n_default = /*#__PURE__*/__webpack_require__.n(i18n);
// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(33632);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);
;// ./lib/widgets/policy-config-menu/policy-config-const.js

const DAYS = 'days';
const CLOSED = 'closed';
const OPEN = 'open';
const ERROR = 'error';
const OPPOSITE_MENU_STATE = {
  [CLOSED]: OPEN,
  [OPEN]: CLOSED,
  [ERROR]: ERROR
};
const SWITCHERS = {
  NOAUTH: 'noauth',
  FORWARDING: 'forwarding',
  EXPIRES: 'expires',
  SMS: 'sms',
  MANAGED_PDF: 'managed-pdf',
  WATERMARK: 'watermark',
  PFP: 'pfp'
};
const EMIT_FLAGS = {
  [SWITCHERS.NOAUTH]: 'enable-noauth-changed',
  [SWITCHERS.FORWARDING]: 'disable-forwarding-changed',
  [SWITCHERS.EXPIRES]: 'expiration-date-changed',
  [SWITCHERS.SMS]: 'enable-sms-changed',
  [SWITCHERS.MANAGED_PDF]: 'is-managed-changed',
  [SWITCHERS.WATERMARK]: 'enable-watermark-changed',
  [SWITCHERS.PFP]: 'pfp-changed'
};
const SECURITY_OPTION_TOGGLED = {
  [SWITCHERS.NOAUTH]: 'enableNoauth',
  [SWITCHERS.FORWARDING]: 'disableForwarding',
  [SWITCHERS.EXPIRES]: 'expires',
  [SWITCHERS.SMS]: 'sms',
  [SWITCHERS.MANAGED_PDF]: 'isManaged',
  [SWITCHERS.WATERMARK]: 'expandedWatermarking',
  [SWITCHERS.PFP]: 'persistentProtection'
};
const SCREENREADER = {
  [SWITCHERS.NOAUTH]: {
    on: i18n_default().t('SCREENREADER_ENABLED_ONECLICK'),
    off: i18n_default().t('SCREENREADER_DISABLED_ONECLICK')
  },
  [SWITCHERS.FORWARDING]: {
    on: i18n_default().t('SCREENREADER_DISABLED_FORWARDING'),
    off: i18n_default().t('SCREENREADER_ENABLED_FORWARDING')
  },
  [SWITCHERS.EXPIRES]: {
    on: i18n_default().t('SCREENREADER_ENABLED_EXPIRATION'),
    off: i18n_default().t('SCREENREADER_DISABLED_EXPIRATION')
  },
  [SWITCHERS.SMS]: {
    on: i18n_default().t('SCREENREADER_SMS', {
      context: 'ENABLED'
    }),
    off: i18n_default().t('SCREENREADER_SMS', {
      context: 'DISABLED'
    })
  },
  [SWITCHERS.MANAGED_PDF]: {
    on: i18n_default().t('SCREENREADER_ENABLED_WATERMARK_PDF'),
    off: i18n_default().t('SCREENREADER_DISABLED_WATERMARK_PDF')
  },
  [SWITCHERS.WATERMARK]: {
    on: i18n_default().t('SCREENREADER_ENABLED_WATERMARK'),
    off: i18n_default().t('SCREENREADER_DISABLED_WATERMARK')
  },
  [SWITCHERS.PFP]: {
    on: i18n_default().t('SCREENREADER_ENABLED_PFP'),
    off: i18n_default().t('SCREENREADER_DISABLED_PFP')
  }
};
// EXTERNAL MODULE: ./compatibility/virtru-popover/index.js
var virtru_popover = __webpack_require__(55929);
var virtru_popover_default = /*#__PURE__*/__webpack_require__.n(virtru_popover);
// EXTERNAL MODULE: ./node_modules/moment/moment.js
var moment = __webpack_require__(13985);
var moment_default = /*#__PURE__*/__webpack_require__.n(moment);
;// ./lib/widgets/policy-config-menu/policy-config-utils.js



const StateToModelMapper = {
  [SWITCHERS.FORWARDING]: state => ({
    disableForwarding: state[SWITCHERS.FORWARDING].stateObject.switched
  }),
  [SWITCHERS.NOAUTH]: state => ({
    enableNoauth: !state[SWITCHERS.NOAUTH].stateObject.switched
  }),
  [SWITCHERS.MANAGED_PDF]: state => ({
    isManaged: state[SWITCHERS.MANAGED_PDF].stateObject.switched
  }),
  [SWITCHERS.WATERMARK]: state => ({
    expandedWatermarking: state[SWITCHERS.WATERMARK].stateObject.switched
  }),
  [SWITCHERS.PFP]: state => ({
    persistentProtection: state[SWITCHERS.PFP].stateObject.switched
  }),
  [SWITCHERS.EXPIRES]: state => ({
    expires: state[SWITCHERS.EXPIRES].stateObject.switched,
    expirationNum: state[SWITCHERS.EXPIRES].stateObject.num,
    expirationUnit: state[SWITCHERS.EXPIRES].stateObject.select,
    expirationDate: state[SWITCHERS.EXPIRES].stateObject.date
  }),
  [SWITCHERS.SMS]: state => ({
    sms: state[SWITCHERS.SMS].stateObject.switched,
    sms2faMap: state[SWITCHERS.SMS].stateObject.sms2faMap
  })
};
const units = ['minutes', 'hours', 'days', 'weeks', 'months', 'years'].reverse();
const calculateExpirationNum = (today, endDay) => {
  const diffs = units.map(item => endDay.diff(today, item, true));
  const diff = diffs.find(diff => Math.round(diff) > 0 && Math.round(diff) === +Number(diff + 0.2).toFixed(0));
  if (diff) {
    return {
      num: Math.round(diff),
      select: units[diffs.indexOf(diff)]
    };
  }
  return {
    num: Math.round(diffs[0]),
    select: units[0]
  };
};
const checkDiff = (newItem, oldItem) => {
  if (newItem && typeof newItem === 'object' && oldItem && typeof oldItem === 'object') {
    return Object.keys(newItem).some(key => oldItem[key] !== newItem[key]);
  }
  return newItem !== oldItem;
};
const getRecipients = (recipientsFn, sms2faMap = {}) => {
  var _recipientsFn$emails;
  const recipients = (_recipientsFn$emails = recipientsFn().emails) === null || _recipientsFn$emails === void 0 ? void 0 : _recipientsFn$emails.map(email => ({
    email,
    phone: sms2faMap[email] || ''
  }));
  return {
    recipients
  };
};
const createPopover = function (anchor, text, title, position, showTimer, withOffset = true) {
  var popover = new (virtru_popover_default())(text, title);
  popover.classname += ' virtru-popover-dark ';
  if (withOffset) {
    popover.classname += ' virtru-popover-policy-config-offset ';
  }
  popover.position(position);
  popover.setShowTimer(showTimer);
  popover.attach(anchor);
  return popover;
};
const getValue = (object, key, def) => {
  const value = object[key];
  return typeof value === 'undefined' ? def : value;
};
const modifyWithPermissions = (options = {}, permissions = {}) => {
  const {
    requireAuthOffByDefault,
    canCreateNoAuthPolicies,
    isCksOrg
  } = permissions;
  if (requireAuthOffByDefault && canCreateNoAuthPolicies && !isCksOrg) {
    return {
      ...options,
      enableNoauth: getValue(options, 'enableNoauth', requireAuthOffByDefault),
      expirationDate: getValue(options, 'expirationDate', moment_default()().add(30, 'days').toDate()),
      expires: getValue(options, 'expires', true)
    };
  }
  return options;
};
;// ./lib/widgets/policy-config-menu/options-toggle.js




const OptionsToggle = props => {
  const {
    id,
    flag,
    emitAction,
    className,
    label,
    optionsSection,
    stateObject: {
      disabled,
      visible,
      switched
    },
    tooltip: {
      text = '',
      title = '',
      position = 'east'
    },
    setOn,
    setOff
  } = props;
  const thisRef = (0,react.useRef)();
  const openCloseListener = function (flag) {
    const listener = event => {
      if (event.key === 'Enter' || event.key === ' ') {
        !disabled && flag ? setOff() : setOn({
          switched: true
        });
        thisRef.current.removeEventListener('keydown', listener);
      }
    };
    return listener;
  };
  const onClick = () => {
    if (!disabled) {
      if (switched) {
        setOff();
      } else {
        setOn({
          switched: true
        });
      }
      emitAction(EMIT_FLAGS[flag], !switched && visible);
      emitAction('security-option-toggled', SECURITY_OPTION_TOGGLED[flag], !switched);
    }
  };
  (0,react.useEffect)(() => {
    let keysListener = null;
    if (thisRef.current) {
      keysListener = openCloseListener(switched);
      thisRef.current.addEventListener('keydown', keysListener);
    }
    return () => {
      thisRef.current && thisRef.current.removeEventListener('keydown', keysListener);
    };
  }, [switched]);
  (0,react.useEffect)(() => {
    if (thisRef.current) {
      createPopover(thisRef.current, text, title, position, 500);
      const listener = openCloseListener(switched);
      thisRef.current.addEventListener('keydown', listener);
    }
  }, [thisRef, visible]);
  if (!visible) {
    return null;
  }
  return /*#__PURE__*/react.createElement("div", {
    id: id,
    ref: thisRef,
    className: `virtru-pcm-option no-outline ${className}${disabled ? '-upsell' : ''} ${switched ? 'open' : ''}`,
    role: "button"
  }, /*#__PURE__*/react.createElement("span", {
    className: "virtru-pcm-option-label"
  }, label), /*#__PURE__*/react.createElement("div", {
    className: `virtru-pcm-option-toggle ${switched ? 'toggle-on' : ''}`,
    onClick: onClick,
    tabIndex: "1"
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-option-handle"
  })), optionsSection);
};
OptionsToggle.propTypes = {
  id: (prop_types_default()).string,
  flag: (prop_types_default()).string,
  emitAction: (prop_types_default()).func,
  className: (prop_types_default()).string,
  label: (prop_types_default()).string,
  optionsSection: (prop_types_default()).element,
  stateObject: prop_types_default().shape({
    disabled: (prop_types_default()).bool,
    visible: (prop_types_default()).bool,
    switched: (prop_types_default()).bool
  }),
  tooltip: prop_types_default().shape({
    text: (prop_types_default()).string,
    title: (prop_types_default()).string,
    position: (prop_types_default()).string
  }),
  setOn: (prop_types_default()).func,
  setOff: (prop_types_default()).func
};
OptionsToggle.defaultProps = {
  stateObject: {
    disabled: false,
    visible: true,
    switched: false
  },
  tooltip: {
    text: '',
    title: '',
    position: 'east'
  }
};
const stateObjectEq = (obj1, obj2) => Object.keys(obj1).every(key => obj1[key] === obj2[key]);
const OptionsToggleMemo = /*#__PURE__*/react.memo(OptionsToggle, (prevProps, nextProps) => prevProps.id === nextProps.id && prevProps.optionsSection === nextProps.optionsSection && stateObjectEq(prevProps.stateObject, nextProps.stateObject));
OptionsToggleMemo.displayName = 'OptionsToggleMemo';
// EXTERNAL MODULE: ./node_modules/react-phone-number-input/min/index.js + 21 modules
var min = __webpack_require__(84389);
;// ./lib/email/lib/RenderSms.js




function SmsRecipient({
  email,
  phone = '',
  setRecipientPhone
}) {
  const [value, setValue] = (0,react.useState)(phone);
  const [canShowError, setCanShowError] = (0,react.useState)(!!phone);
  const isValid = () => !!value && (0,min/* isPossiblePhoneNumber */.h1)(value);
  (0,react.useEffect)(() => {
    if (value !== phone) {
      setRecipientPhone(email, value, isValid());
    }
    setCanShowError(!!value);
  }, [value]);
  return /*#__PURE__*/react.createElement("div", {
    className: "sms-2fa-recipient"
  }, /*#__PURE__*/react.createElement("span", {
    className: "recipient-email-label",
    "data-test-id": "sms-recipient-email-label"
  }, email), /*#__PURE__*/react.createElement(min/* default */.Ay, {
    placeholder: i18n_default().t('SMS_PHONE_INPUT_LABEL'),
    value: phone,
    onChange: val => setValue(val),
    onBlur: () => setCanShowError(true)
  }), canShowError && !isValid() && /*#__PURE__*/react.createElement("span", {
    className: "recipient-phone-input-error",
    "data-test-id": "sms-input-error-text"
  }, "\u26A0\xA0", i18n_default().t('SMS_ERROR_WRONG_NUMBER')));
}
SmsRecipient.propTypes = {
  email: (prop_types_default()).string.isRequired,
  phone: (prop_types_default()).string,
  setRecipientPhone: (prop_types_default()).func.isRequired
};

// TODO not updated in case of empty phone - not used now
const SmsRecipientMemo = /*#__PURE__*/react.memo(SmsRecipient, (prevProps, nextProps) => prevProps.email === nextProps.email && prevProps.phone === nextProps.phone && prevProps.setRecipientPhone === nextProps.setRecipientPhone);
SmsRecipientMemo.displayName = 'SmsRecipientMemo';

// TODO think about memo
function SmsRenderList({
  renderData,
  setRecipientPhone
}) {
  const {
    recipients = []
  } = renderData;
  if (!recipients.length) {
    return /*#__PURE__*/react.createElement("div", {
      className: 'sms-2fa-no-recipients'
    }, i18n_default().t('SMS_NO_RECIPIENTS'));
  }
  return recipients.map(({
    email,
    phone
  }) => /*#__PURE__*/react.createElement(SmsRecipient, {
    key: `recipient-${email}`,
    email: email,
    phone: phone,
    setRecipientPhone: setRecipientPhone
  }));
}
SmsRenderList.propTypes = {
  renderData: prop_types_default().shape({
    recipients: (prop_types_default()).array
  }),
  setRecipientPhone: (prop_types_default()).func.isRequired
};
const SmsRenderListMemo = /*#__PURE__*/react.memo(SmsRenderList, (prevProps, nextProps) => prevProps.renderData.recipients.length === nextProps.renderData.recipients.length && prevProps.renderData.recipients.every((item, index) => nextProps.renderData.recipients[index] === item));
SmsRenderListMemo.displayName = 'SmsRenderListMemo';
// EXTERNAL MODULE: ./lib/email/lib/react-render.js + 4 modules
var react_render = __webpack_require__(26847);
// EXTERNAL MODULE: ./lib/utils/index.js
var utils = __webpack_require__(55675);
;// ./lib/widgets/policy-config-menu/policy-config-state.js




const defaultStateObject = {
  disabled: false,
  visible: true,
  switched: false
};
const switchersModel = {
  [SWITCHERS.NOAUTH]: {
    id: 'virtru-pcm-option-noauth',
    label: i18n.t('ONE_CLICK_OPTION'),
    stateObject: {
      ...defaultStateObject
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_ONE_CLICK_CONTENT')
    },
    getDefault: (_state, permissions, options) => ({
      ...defaultStateObject,
      visible: permissions ? permissions.canCreateNoAuthPolicies && !permissions.isCksOrg && permissions.canExpireOwnedPolicies : defaultStateObject.visible,
      switched: options && 'enableNoauth' in options ? !options.enableNoauth : true
    }),
    isVisible: permissions => permissions.canCreateNoAuthPolicies && !permissions.isCksOrg && permissions.canExpireOwnedPolicies,
    checkVisibilityWithDep: () => true,
    setOptions: options => ({
      switched: 'enableNoauth' in options ? !options.enableNoauth : true
    })
  },
  [SWITCHERS.FORWARDING]: {
    id: 'virtru-pcm-option-forwarding',
    label: i18n.t('POLICY_MENU_DISABLE_FORWARDING'),
    stateObject: {
      ...defaultStateObject
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_DISABLE_FORWARDING_CONTENT')
    },
    isVisible: () => true,
    checkVisibilityWithDep: state => state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true,
    setOptions: options => ({
      switched: !!options.disableForwarding
    })
  },
  [SWITCHERS.EXPIRES]: {
    id: 'virtru-pcm-option-expires',
    label: i18n.t('EMAIL_EXPIRATION'),
    stateObject: {
      ...defaultStateObject,
      num: 1,
      select: 'days',
      date: new Date()
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_EXPIRATION_CONTENT')
    },
    getDefault: () => ({
      ...defaultStateObject,
      num: 1,
      select: 'days',
      date: new Date()
    }),
    isVisible: () => true,
    checkVisibilityWithDep: () => true,
    setOptions: options => {
      const commonOptions = {
        switched: !!options.expires,
        date: options.expirationDate
      };
      if (options.expirationDate) {
        const end = moment_default()(options.expirationDate);
        const today = moment_default()();
        return {
          ...commonOptions,
          ...calculateExpirationNum(today, end)
        };
      }
      return commonOptions;
    }
  },
  [SWITCHERS.SMS]: {
    id: 'virtru-pcm-option-sms',
    label: i18n.t('SMS_REQUIRE'),
    stateObject: {
      ...defaultStateObject,
      sms2faMap: undefined
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_ENABLE_SMS2FA')
    },
    getDefault: state => ({
      ...defaultStateObject,
      sms2faMap: undefined,
      visible: state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true
    }),
    isVisible: permissions => permissions.canUseSms2Fa,
    checkVisibilityWithDep: state => state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true,
    setOptions: options => ({
      switched: !!options.sms2faMap,
      sms2faMap: options.sms2faMap
    })
  },
  [SWITCHERS.MANAGED_PDF]: {
    id: 'virtru-pcm-option-managed-pdf',
    label: i18n.t('POLICY_MENU_WATERMARKING'),
    stateObject: {
      ...defaultStateObject
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_WATERMARK_CONTENT')
    },
    isVisible: () => false,
    checkVisibilityWithDep: () => true,
    setOptions: options => ({
      switched: !!options.isManaged
    })
  },
  [SWITCHERS.WATERMARK]: {
    id: 'virtru-pcm-option-watermark',
    label: i18n.t('POLICY_MENU_EXPANDED_WATERMARKING'),
    stateObject: {
      ...defaultStateObject
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_WATERMARK_CONTENT')
    },
    getDefault: state => ({
      ...defaultStateObject,
      visible: state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true
    }),
    isVisible: permissions => permissions.canUseExpandedWatermarking && !permissions.isManaged,
    checkVisibilityWithDep: state => state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true,
    setOptions: options => ({
      switched: !!options.expandedWatermarking
    })
  },
  [SWITCHERS.PFP]: {
    id: 'virtru-pcm-option-pfp',
    label: i18n.t('POLICY_MENU_PERSISTENT_PROTECTION'),
    stateObject: {
      ...defaultStateObject
    },
    tooltip: {
      text: i18n.t('TOOLTIP_SENDER_PFP_CONTENT')
    },
    getDefault: state => ({
      ...defaultStateObject,
      visible: state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true
    }),
    isVisible: permissions => permissions.canTogglePfp,
    checkVisibilityWithDep: state => state[SWITCHERS.NOAUTH].stateObject.visible ? state[SWITCHERS.NOAUTH].stateObject.switched : true,
    setOptions: options => ({
      switched: !!options.persistentProtection
    })
  }
};
function setStates(permissions, state, options) {
  const result = {};
  for (const i in state) {
    const item = state[i];
    result[i] = {
      ...item,
      stateObject: {
        ...item.stateObject,
        visible: item.isVisible(permissions),
        ...item.setOptions(options || {})
      }
    };
  }
  return result;
}
const changeVisibilityWithDep = state => {
  for (const i in state) {
    const item = state[i];
    const visibility = item.checkVisibilityWithDep(state);
    item.stateObject.visible = item.stateObject.visible && visibility;
    if (!visibility) {
      const {
        switched
      } = item.getDefault ? item.getDefault(state) : {
        switched: false
      };
      item.stateObject.switched = switched;
    }
  }
};
const checkVisibility = (state, permissions) => {
  const result = state;
  for (const i in state) {
    const item = state[i];
    result[i] = {
      ...item,
      stateObject: {
        ...item.stateObject,
        visible: item.isVisible(permissions)
      }
    };
  }
  changeVisibilityWithDep(result);
  return result;
};
function reducer(state, action) {
  if (action.type === 'init') {
    const result = {};
    for (const i in state) {
      const item = state[i];
      result[i] = {
        ...item,
        stateObject: item.getDefault ? item.getDefault(state, action.permissions, action.options) : {
          ...item.stateObject,
          switched: false,
          disabled: false
        }
      };
    }
    return result;
  }
  if (action.type === 'checkVisibility') {
    return checkVisibility(state, action.payload);
  }
  const item = state[action.type];
  if (item) {
    const {
      permissions,
      payload
    } = action;
    const newStateObject = {
      ...item.stateObject,
      ...payload
    };
    const newObject = {
      ...item,
      stateObject: newStateObject
    };
    const newState = {
      ...state,
      [action.type]: newObject
    };
    if (permissions) {
      return checkVisibility(newState, permissions);
    }
    return newState;
  }
  throw new Error('Wrong action type');
}
;// ./lib/widgets/policy-config-menu/expiration-component.js





const clearExpirationNumber = value => value.replaceAll(/[^0-9]/g, '');
const updateModelDate = (expirationNum, expirationUnit, dispatch) => {
  var date = new Date();
  if (expirationNum) {
    // eslint-disable-next-line default-case
    switch (expirationUnit) {
      case 'minutes':
        date.setMinutes(date.getMinutes() + expirationNum);
        break;
      case 'hours':
        date.setHours(date.getHours() + expirationNum);
        break;
      case DAYS:
        date.setDate(date.getDate() + expirationNum);
        break;
      case 'weeks':
        date.setDate(date.getDate() + expirationNum * 7);
        break;
      case 'months':
        date.setMonth(date.getMonth() + expirationNum);
        break;
      case 'years':
        date.setFullYear(date.getFullYear() + expirationNum);
        break;
    }
    dispatch({
      type: SWITCHERS.EXPIRES,
      payload: {
        date: date.toISOString()
      }
    });
  }
  return date;
};
const getDateString = date => {
  const end = moment_default()(date);
  const isoDate = end.format('YYYY-MM-DD[T]HH:mm:ss');
  moment_default().updateLocale(moment_default().locale(), {
    calendar: i18n.t('MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE', {
      returnObjects: true
    })
  });
  return moment_default()(isoDate).calendar();
};

// @TODO devide this function into two - one function to check time and set expiration text, other - set popup
const onExpirationDateUpdated = function ({
  keepExistingExpirationDate,
  expirationNum,
  expirationUnit,
  expirationDate,
  dispatch
}) {
  const date = !keepExistingExpirationDate ? updateModelDate(expirationNum, expirationUnit, dispatch) : expirationDate;
  const end = moment_default()(date);
  const isoDate = end.format('YYYY-MM-DD[T]HH:mm:ss');
  moment_default().updateLocale(moment_default().locale(), {
    calendar: i18n.t('MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE', {
      returnObjects: true
    })
  });
  return moment_default()(isoDate).calendar();
};
const ExpirationComponent = props => {
  const {
    emitAction,
    dispatch,
    num,
    select,
    date,
    switched
  } = props;
  const [timeText, setTimeText] = (0,react.useState)('');
  const textRef = (0,react.useRef)();
  const formattedTimeText = timeText && moment_default()(timeText).format('dddd, MMM Do, YYYY [@] h:mm a');
  const updateDate = (keepExistingExpirationDate = false, num, select) => {
    const time = onExpirationDateUpdated({
      expirationNum: num,
      expirationUnit: select,
      expirationDate: date,
      keepExistingExpirationDate,
      dispatch
    });
    setTimeText(time);
  };
  const onChangeNum = elem => {
    const value = clearExpirationNumber(elem.currentTarget.value);
    const newNum = Number.isNaN(value) ? '' : parseInt(value, 10);
    updateDate(false, newNum, select);
    dispatch({
      type: SWITCHERS.EXPIRES,
      payload: {
        num: newNum
      }
    });
  };
  const onChangeSelect = elem => {
    const newSelect = elem.currentTarget.value;
    const newNum = !num ? 1 : num;
    updateDate(false, num, newSelect);
    dispatch({
      type: SWITCHERS.EXPIRES,
      payload: {
        select: newSelect,
        num: newNum
      }
    });
  };
  (0,react.useEffect)(() => {
    updateDate(true, num, select);
    // TODO move to one function
    const date = updateModelDate(num, select, dispatch);
    const start = moment_default()();
    const end = moment_default()(date);
    emitAction(EMIT_FLAGS[SWITCHERS.EXPIRES], switched, date, end.from(start), end.calendar());
  }, []);
  (0,react.useEffect)(() => {
    // TODO move to one function
    const date = updateModelDate(num, select, dispatch);
    const start = moment_default()();
    const end = moment_default()(date);
    setTimeText(getDateString(date));
    emitAction(EMIT_FLAGS[SWITCHERS.EXPIRES], switched, date, end.from(start), end.calendar());
  }, [num, select]);
  return /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-exp-options"
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-exp-date"
  }, /*#__PURE__*/react.createElement("input", {
    onChange: onChangeNum,
    className: "virtru-pcm-exp-number no-outline",
    tabIndex: switched ? '1' : '-1',
    type: "text",
    maxLength: "4",
    value: Number.isNaN(num) ? '' : parseInt(num, 10)
  }), /*#__PURE__*/react.createElement("select", {
    onChange: onChangeSelect,
    className: "virtru-pcm-exp-unit-select no-outline",
    tabIndex: switched ? 1 : -1,
    dir: "rtl",
    value: select
  }, /*#__PURE__*/react.createElement("option", {
    id: "virtru-pcm-exp-unit-mins",
    value: "minutes"
  }, i18n.t('EXPIRATION_UNIT_MINS', {
    count: num
  })), /*#__PURE__*/react.createElement("option", {
    id: "virtru-pcm-exp-unit-hours",
    value: "hours"
  }, i18n.t('EXPIRATION_UNIT_HOURS', {
    count: num
  })), /*#__PURE__*/react.createElement("option", {
    id: "virtru-pcm-exp-unit-days",
    value: "days"
  }, i18n.t('EXPIRATION_UNIT_DAYS', {
    count: num
  })), /*#__PURE__*/react.createElement("option", {
    id: "virtru-pcm-exp-unit-weeks",
    value: "weeks"
  }, i18n.t('EXPIRATION_UNIT_WEEKS', {
    count: num
  })), /*#__PURE__*/react.createElement("option", {
    id: "virtru-pcm-exp-unit-months",
    value: "months"
  }, i18n.t('EXPIRATION_UNIT_MONTHS', {
    count: num
  })), /*#__PURE__*/react.createElement("option", {
    id: "virtru-pcm-exp-unit-years",
    value: "years"
  }, i18n.t('EXPIRATION_UNIT_YEARS', {
    count: num
  })))), /*#__PURE__*/react.createElement("div", {
    ref: textRef,
    className: "virtru-pcm-exp-full-date"
  }, formattedTimeText));
};
ExpirationComponent.propTypes = {
  emitAction: (prop_types_default()).func,
  dispatch: (prop_types_default()).func,
  state: (prop_types_default()).object,
  num: (prop_types_default()).number,
  select: (prop_types_default()).string,
  date: (prop_types_default()).string,
  switched: (prop_types_default()).bool
};
;// ./lib/widgets/policy-config-menu/policy-config-menu-component.js
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }












const PopupComponent = props => {
  const {
    initialPermissions,
    options,
    toggleOff,
    close,
    disable,
    enable,
    recipientsFn,
    limitedEncryptionCheck,
    updatePolicy,
    emitAction,
    updateStatusForScreenReader,
    refreshUserPermissions,
    dom
  } = props;
  const [open, setOpen] = (0,react.useState)(false);
  const [disabled, setDisabled] = (0,react.useState)(false);
  const [previouslySent] = (0,react.useState)(!!(options !== null && options !== void 0 && options.isPreviouslySentMessage));
  const [permissions, setPermissions] = (0,react.useState)(initialPermissions);
  const [recipientsPhones, setRecipientsPhones] = (0,react.useState)(getRecipients(recipientsFn, options === null || options === void 0 ? void 0 : options.sms2faMap));
  const [state, dispatch] = (0,react.useReducer)(reducer, setStates(permissions, switchersModel, options));
  const infoRef = (0,react.useRef)();
  const pcmButtonRef = (0,react.useRef)();
  const listener = event => {
    const isPopup = event.target.classList.contains('popup-button');
    const validTarget = event.target.closest('.virtru-pcm-container') === null;
    if (validTarget && open && !isPopup) {
      setOpen(!open);
      document.removeEventListener('mousedown', listener);
    }
  };
  const getState = flag => ({
    ...state[flag],
    flag,
    emitAction,
    setOn: payload => {
      dispatch({
        type: flag,
        payload,
        permissions
      });
      updateStatusForScreenReader(SCREENREADER[flag].on);
    },
    setOff: () => {
      const defaultState = switchersModel[flag].getDefault ? switchersModel[flag].getDefault(state, permissions, options) : defaultStateObject;
      const payload = {
        ...defaultState,
        switched: false,
        visible: switchersModel[flag].isVisible(permissions, state)
      };
      dispatch({
        type: flag,
        payload,
        permissions
      });
      updateStatusForScreenReader(SCREENREADER[flag].off);
    }
  });
  const openCloseListener = function (flag) {
    const listener = event => {
      if (event.key === 'Enter' || event.key === ' ') {
        setOpen(flag);
        pcmButtonRef.current.removeEventListener('keydown', listener);
      }
    };
    return listener;
  };
  (0,react.useEffect)(() => {
    toggleOff(() => dispatch({
      type: 'init',
      permissions: initialPermissions,
      options
    }));
    close(() => setOpen(false));
    disable(() => setDisabled(true));
    enable(() => setDisabled(false));
  }, []);
  (0,react.useEffect)(() => {
    const keysListener = openCloseListener(!open);
    if (open) {
      document.addEventListener('mousedown', listener);
      pcmButtonRef.current.addEventListener('keydown', keysListener);
      const perms = refreshUserPermissions();
      setPermissions(perms);
      dispatch({
        type: 'checkVisibility',
        payload: perms
      });
      setRecipientsPhones(getRecipients(recipientsFn, options === null || options === void 0 ? void 0 : options.sms2faMap));
      updateStatusForScreenReader(i18n.t('SCREENREADER_OPENED_POLICY_MENU'));

      // add z-index to message element to prevent virtru-pcm from being hidden by other elements
      if (pcmButtonRef.current) {
        const messageElement = pcmButtonRef.current.closest(dom.ORIGINAL_AND_LATEST_MESSAGES);
        if (messageElement) {
          const indexInParent = Array.from(messageElement.parentElement.children).indexOf(messageElement);
          messageElement.style.zIndex = 1000 - indexInParent;
          messageElement.style.position = 'relative';
        }
      }
    } else {
      // update policy model
      updatePolicy(state);
      pcmButtonRef.current.addEventListener('keydown', keysListener);
      updateStatusForScreenReader(i18n.t('SCREENREADER_CLOSED_POLICY_MENU'));

      // reset message element
      if (pcmButtonRef.current) {
        const messageElement = pcmButtonRef.current.closest(dom.ORIGINAL_AND_LATEST_MESSAGES);
        if (messageElement) {
          messageElement.style.zIndex = 1;
          messageElement.style.position = '';
        }
      }
    }
    return () => {
      pcmButtonRef.current && pcmButtonRef.current.removeEventListener('keydown', keysListener);
    };
  }, [open]);
  (0,react.useEffect)(() => {
    createPopover(pcmButtonRef.current, i18n.t('TOOLTIP_VIRTRU_OPTIONS'), undefined, 'south', 1000, false);
    const openListener = openCloseListener(true);
    pcmButtonRef.current.addEventListener('keydown', openListener);
    return () => {
      pcmButtonRef.current.removeEventListener('keydown', openListener);
    };
  }, [pcmButtonRef]);
  const noauthState = getState(SWITCHERS.NOAUTH);
  const forwardingState = getState(SWITCHERS.FORWARDING);
  const expirationState = getState(SWITCHERS.EXPIRES);
  const smsState = getState(SWITCHERS.SMS);
  const managedPDFState = getState(SWITCHERS.MANAGED_PDF);
  const whatermarkState = getState(SWITCHERS.WATERMARK);
  const pfpState = getState(SWITCHERS.PFP);
  // TODO add callbacks for OptionsToggles
  return /*#__PURE__*/react.createElement("div", {
    className: `virtru-pcm-container ${open ? 'virtru-pcm-container-open' : ''}`,
    onBlur: listener
  }, /*#__PURE__*/react.createElement("div", {
    className: `${disabled ? 'virtru-pcm-button-sent-disabled' : 'virtru-pcm-button'} no-outline ${previouslySent ? 'virtru-pcm-button-sent' : ''}`,
    ref: pcmButtonRef,
    onClick: () => setOpen(!open),
    tabIndex: '1',
    "aria-label": i18n.t('SCREENREADER_VIRTRU_POLICY_MENU'),
    role: "button",
    "aria-haspopup": "menu"
  }), /*#__PURE__*/react.createElement("div", {
    className: `virtru-pcm ${previouslySent ? 'virtru-pcm-sent' : ''}`,
    "aria-expanded": open
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-content-outer"
  }, /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-content"
  }, /*#__PURE__*/react.createElement("h6", null, i18n.t('MESSAGE_OPTIONS')), /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, noauthState, {
    className: "virtru-pcm-noauth",
    setOn: payload => {
      noauthState.setOn(payload);
    },
    setOff: () => {
      noauthState.setOff();
      if (!expirationState.stateObject.switched) {
        dispatch({
          type: SWITCHERS.EXPIRES,
          payload: {
            switched: true,
            num: 30,
            select: DAYS
          }
        });
      }
    }
  })), /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, forwardingState, {
    className: "virtru-pcm-forwarding"
  })), /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, expirationState, {
    className: "virtru-pcm-expires",
    optionsSection: /*#__PURE__*/react.createElement(ExpirationComponent, {
      emitAction: emitAction,
      dispatch: dispatch,
      num: expirationState.stateObject.num,
      select: expirationState.stateObject.select,
      date: expirationState.stateObject.date,
      switched: expirationState.stateObject.switched
    })
  })), /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, smsState, {
    className: "virtru-pcm-sms",
    setOn: payload => {
      smsState.setOn(payload);
      emitAction(EMIT_FLAGS[SWITCHERS.FORWARDING], true);
      dispatch({
        type: SWITCHERS.FORWARDING,
        payload: {
          disabled: true,
          switched: true
        }
      });
    },
    setOff: () => {
      smsState.setOff();
      dispatch({
        type: SWITCHERS.FORWARDING,
        payload: {
          disabled: false
        }
      });
    },
    optionsSection: /*#__PURE__*/react.createElement("div", {
      className: "virtru-pcm-sms-options"
    }, smsState.stateObject.switched && /*#__PURE__*/react.createElement(SmsRenderList, {
      renderData: recipientsPhones,
      setRecipientPhone: (email, value, isValid) => {
        const sms2faMap = {
          ...(smsState.stateObject.sms2faMap || {}),
          [email]: isValid ? value : ''
        };
        dispatch({
          type: SWITCHERS.SMS,
          payload: {
            sms2faMap
          }
        });
      }
    }))
  })), /*#__PURE__*/react.createElement("hr", null), /*#__PURE__*/react.createElement("h6", null, i18n.t('ATTACHMENT_OPTIONS'), /*#__PURE__*/react.createElement("span", {
    ref: infoRef,
    className: "virtru-pcm-info"
  }), /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-info-wrapper"
  }, open && /*#__PURE__*/react.createElement(react_render.RenderPCMInfoTooltip, {
    anchor: infoRef.current,
    title: `${i18n.t('POLICY_MENU_SUPPORTED_FILES_INFO_TITLE')}`,
    content: utils.pdftronFileTypes.join(', ').toUpperCase()
  }))), !noauthState.stateObject.switched && noauthState.stateObject.visible && /*#__PURE__*/react.createElement("div", {
    className: "virtru-pcm-more-options"
  }, i18n.t('REQUIRE_AUTH_FOR_MORE_OPTIONS')), /*#__PURE__*/react.createElement(react.Fragment, null, /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, managedPDFState, {
    className: "virtru-pcm-option-managed-pdf"
  })), /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, whatermarkState, {
    setOn: payload => {
      whatermarkState.setOn(payload);
      limitedEncryptionCheck(payload === null || payload === void 0 ? void 0 : payload.switched).then(allowed => {
        if (!allowed) {
          whatermarkState.setOff();
        }
      });
    },
    className: "virtru-pcm-option-watermark"
  })), /*#__PURE__*/react.createElement(OptionsToggleMemo, _extends({}, pfpState, {
    setOn: payload => {
      pfpState.setOn(payload);
      limitedEncryptionCheck(payload === null || payload === void 0 ? void 0 : payload.switched).then(allowed => {
        if (!allowed) {
          pfpState.setOff();
        }
      });
    },
    className: "virtru-pcm-option-pfp"
  })))))));
};
PopupComponent.propTypes = {
  initialPermissions: (prop_types_default()).object,
  options: (prop_types_default()).object,
  toggleOff: (prop_types_default()).func,
  close: (prop_types_default()).func,
  disable: (prop_types_default()).func,
  enable: (prop_types_default()).func,
  recipientsFn: (prop_types_default()).func,
  limitedEncryptionCheck: (prop_types_default()).func,
  updatePolicy: (prop_types_default()).func,
  emitAction: (prop_types_default()).func,
  updateStatusForScreenReader: (prop_types_default()).func,
  refreshUserPermissions: (prop_types_default()).func,
  dom: (prop_types_default()).object
};
;// ./lib/widgets/policy-config-menu/index.js
/* provided dependency */ var console = __webpack_require__(31799);





const PolicyFacade = {
  _policyModel: policy_model.PolicyModel.create(),
  _permissions: {},
  _settings: {},
  _trial: {},
  _actions: {},
  setOptions(options) {
    this._policyModel = policy_model.PolicyModel.create(options);
  },
  getModel() {
    return this._policyModel;
  },
  hasSms2faError(emailsCount) {
    if (!this._permissions.canUseSms2Fa) {
      return false;
    }
    if (this._policyModel.sms) {
      const emailsLength = Object.values(this._policyModel.sms2faMap || {}).filter(itm => itm).length;
      return !this._policyModel.sms2faMap || !emailsLength || emailsLength !== emailsCount;
    }
    return this._policyModel.sms2faMap !== null && this._policyModel.sms2faMap !== undefined;
  },
  getIsCksOrg() {
    var _this$_settings, _this$_settings$user;
    return !!((_this$_settings = this._settings) !== null && _this$_settings !== void 0 && (_this$_settings$user = _this$_settings.user) !== null && _this$_settings$user !== void 0 && _this$_settings$user._profile.settings.orgPublicKey);
  },
  updateStatus(txt) {
    const banner = document.querySelector('.virtru-new-compose-editor-banner .virtru-announce-status');
    if (banner) {
      banner.innerHTML = txt;
    }
  },
  isExpandedProtectionEnabled() {
    return this._policyModel.expandedWatermarking || this._policyModel.persistentProtection;
  },
  refreshUserPermissions() {
    return {
      ...this._settings.user.setting('permissions'),
      isCksOrg: this.getIsCksOrg(),
      isManaged: this._policyModel.isManaged
    };
  },
  callAction(action, ...args) {
    if (this._actions[action]) {
      this._actions[action](...args);
    } else {
      console.warn(`Wrong action name - ${action}`);
    }
  },
  on(action, callback) {
    this._actions[action] = callback;
  },
  off(action) {
    delete this._actions[action];
  },
  close: () => {
    // TODO: Empty dummy-function for back-compatibility. Is rebind during PopupComponent creation with 'bindToPolicyFacade' function
  },
  enable: () => {
    // TODO: Empty dummy-function for back-compatibility. Is rebind during PopupComponent creation with 'bindToPolicyFacade' function
  },
  disable: () => {
    // TODO: Empty dummy-function for back-compatibility. Is rebind during PopupComponent creation with 'bindToPolicyFacade' function
  }
};
const updateModel = (stateToModel, policy) => {
  const newPolicy = Object.keys(policy).map(key => {
    if (stateToModel[key]) {
      return stateToModel[key](policy);
    }
    return {};
  }).reduce((acc, item) => ({
    ...acc,
    ...item
  }), {});
  return newPolicy;
};
const bindToPolicyFacade = key => callback => {
  PolicyFacade[key] = callback.bind(null);
};

// TODO change to object argument
const attachPolicyMenu = (wrapper, settings, recipientsFn, limitedEncryptionCheck, updatePolicy, options, toggleOff = () => {}) => {
  const permissions = settings.user.setting('permissions');
  PolicyFacade._settings = settings;
  PolicyFacade._permissions = {
    ...permissions,
    isCksOrg: PolicyFacade.getIsCksOrg(),
    isManaged: PolicyFacade._policyModel.isManaged
  };
  const optionsModWithPerm = modifyWithPermissions(options, PolicyFacade._permissions);
  PolicyFacade.setOptions(optionsModWithPerm);
  const update = function (stateToModel, policy) {
    const newPolicy = updateModel(stateToModel, policy);
    const exception = ['expirationNum', 'expirationUnit', 'sms'];
    const isChanged = Object.keys(newPolicy).filter(key => !exception.includes(key)).some(key => checkDiff(newPolicy[key], PolicyFacade._policyModel[key]));
    if (isChanged && updatePolicy) {
      updatePolicy({
        ...PolicyFacade._policyModel,
        ...newPolicy
      });
    }
    PolicyFacade.setOptions(newPolicy);
  };
  const root = (0,client/* createRoot */.H)(wrapper);
  root.render(/*#__PURE__*/react.createElement(PopupComponent, {
    initialPermissions: PolicyFacade._permissions,
    emitAction: PolicyFacade.callAction.bind(PolicyFacade),
    options: optionsModWithPerm,
    recipientsFn: recipientsFn,
    toggleOff: toggleOff,
    enable: bindToPolicyFacade('enable'),
    close: bindToPolicyFacade('close'),
    disable: bindToPolicyFacade('disable'),
    limitedEncryptionCheck: limitedEncryptionCheck,
    updatePolicy: update.bind(undefined, StateToModelMapper),
    updateStatusForScreenReader: PolicyFacade.updateStatus.bind(PolicyFacade),
    refreshUserPermissions: PolicyFacade.refreshUserPermissions.bind(PolicyFacade),
    dom: settings.dom
  }));
};
const PolicyConfigMenuFunctions = PolicyFacade;

/***/ }),

/***/ 73667:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   newComposeActivation: () => (/* binding */ newComposeActivation)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const newComposeActivation = () => `
  <div class="virtru-receiver-inactive">
    <div class="virtru-receiver-inactive-body">
      <div>
        <span class="virtru-receiver-body-inactive-text">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('WEBMAIL_PLUGIN_ACTIVATION_TEXT')}</span>
      </div>
      <div class="virtru-receiver-links">
        <a class="virtru-receiver-link" href="https://www.virtru.com/client-side-encryption/" target="_blank">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_LINK')}</a>
      </div>
    </div>
  </div>
`;

/***/ }),

/***/ 73668:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmailError: () => (/* binding */ EmailError)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87568);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64078);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33632);
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_2__);
/**
 * Virtru Email Template for Receiver
 */





/**
 * @remarks Use this only for maintaining backwards compatibility with `this._emailError` usage in consumers
 */
function EmailError({
  errorHeader,
  errorMessage,
  SRLink,
  SRLabel,
  onRetryClick,
  onCancelRetryClick,
  canRetry = false,
  canCancel = false,
  retry = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('COMMON_REFRESH_PAGE'),
  cancel = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('COMMON_CANCEL'),
  link = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('EMAIL_ERROR_TEMPLATE_SUPPORT_LINK'),
  linkHref = 'https://virtru.zendesk.com/hc'
}) {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-warning-icon"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-error-header"
  }, errorHeader), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-error-message"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", null, errorMessage)))), canRetry && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-error-retry-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("button", {
    className: "virtru-error-retry-button",
    onClick: onRetryClick
  }, retry)), canRetry && canCancel && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-error-retry-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "virtru-error-cancel-retry-link",
    onClick: e => {
      e.preventDefault();
      onCancelRetryClick();
    }
  }, cancel)), SRLink && /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-error-link-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "virtru-error-support-link",
    href: SRLink
  }, SRLabel)), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-error-link-container"
  }, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("a", {
    className: "virtru-error-support-link",
    href: linkHref
  }, link)));
}
EmailError.propTypes = {
  errorHeader: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  errorMessage: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  canRetry: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  canCancel: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().bool),
  retry: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  cancel: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  SRLink: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  SRLabel: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  linkHref: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  link: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().string),
  onRetryClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func),
  onCancelRetryClick: (prop_types__WEBPACK_IMPORTED_MODULE_3___default().func)
};
const containerClassName = 'virtru-error-template';

/**
 * Create the EmailError component
 *
 * @param {{
 *  customClassName: string,
 *  errorHeader: string,
 *  errorMessage: string,
 *  canRetry: boolean,
 *  canCancel: boolean,
 *  retry: string,
 *  cancel: string,
 *  SRLink: string,
 *  SRLabel: string,
 *  linkHref: string,
 *  link: string,
 *  onRetryClick: Function,
 *  onCancelRetryClick: Function,
 * }} props
 * @param props.customClassName - Custom class name to add to the container
 * @param props.errorHeader - Error header text
 * @param props.errorMessage - Error message text
 * @param props.canRetry - Allow retry button to be shown
 * @param props.canCancel - Allow cancel retry button to be shown
 * @param props.retry - Retry button text
 * @param props.cancel - Cancel retry button text
 * @param props.SRLink - Secure Reader link
 * @param props.SRLabel - Secure Reader link text
 * @param props.linkHref - Support link
 * @param props.link - Support link text
 * @param props.onRetryClick - Retry button click handler
 * @param props.onCancelRetryClick - Cancel retry button click handler
 *
 * @returns {EmailError} EmailError component
 *
 * @todo Remove this method once jQuery and React are no longer used together
 */
EmailError.create = function ({
  customClassName,
  ...props
}) {
  const container = document.createElement('div');
  container.className = `${containerClassName} ${customClassName || ''}`;
  const root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__/* .createRoot */ .H)(container);
  root.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(EmailError, props));
  return {
    container,
    teardown: () => root.unmount()
  };
};

/***/ }),

/***/ 73776:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 73871:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var {
  EmailTemplateSender
} = __webpack_require__(31795);
var {
  EmailTemplateReceiver
} = __webpack_require__(31795);
var {
  PolicyUpdater
} = __webpack_require__(3558);
var {
  PolicyAttributes
} = __webpack_require__(38282);
var {
  Autolinker
} = __webpack_require__(15042);
var Guard = __webpack_require__(57128);
var AnalyticsService = (__webpack_require__(1246).instance)();
var {
  DownloadVirtruAttachmentMod
} = __webpack_require__(38282);
var gmailUtil = __webpack_require__(2090);
var {
  formatBody
} = __webpack_require__(64791);
const {
  _bindAllMethods
} = __webpack_require__(4424);
const {
  renderCKSIndicator
} = __webpack_require__(53054);
const AUTOLINKER_MAX_LEN = 300000;

/**
 * Widget that handles a reading element
 */
function SecureReadWidget(readerResponse, element, settings, options) {
  var {
    messageInfo
  } = readerResponse;
  this._readerResponse = readerResponse;
  if (this._readerResponse && this._readerResponse.metadata) {
    this._metadata = this._readerResponse.metadata;
  }
  this._element = element;
  this._addedElement = null;
  this._attachments = [];
  this._settings = settings;
  this._messageInfo = messageInfo;
  this._contract = messageInfo.contract;
  this._isOwner = this._contract.isOwner;
  this._secureService = options.secureService;
  this._messageContainer = null;
  this._options = options;
  this._connectionEventRouter = options.connectionEventRouter;
  this._transports = options.transports;
  _bindAllMethods(this);
}
Emitter(SecureReadWidget.prototype);
SecureReadWidget.create = function (readerResponse, settings, options) {
  Guard.checkIsDefAndNotNull(readerResponse, 'SecureReadWidget.readerResponse');
  Guard.checkIsDefAndNotNull(readerResponse.containerElement, 'SecureReadWidget.readerResponse.containerElement');
  Guard.checkIsDefAndNotNull(readerResponse.messageInfo, 'SecureReadWidget.readerResponse.messageInfo');
  Guard.checkIsDefAndNotNull(settings, 'SecureReadWidget.settings');
  Guard.checkIsDefAndNotNull(options, 'SecureReadWidget.options');
  var element = readerResponse.containerElement;
  var {
    messageInfo
  } = readerResponse;

  // Added so that the text will wrap naturally even in the case of long unbroken strings (like a URL)
  var {
    message
  } = messageInfo;
  if (readerResponse && readerResponse.metadata) {
    this._metadata = readerResponse.metadata;
  }
  if (message) {
    message = this.treatHtml(message);
    message = formatBody(message);
    messageInfo.message = message;
  }
  var widget = new SecureReadWidget(readerResponse, element, settings, options);
  widget.setup();
  return widget;
};

/**
 * Just parses the the html string and gets it ready for being rendered.
 * for instance it takes urls and turns them into links
 */
SecureReadWidget.treatHtml = function (html) {
  // The auto linker is not very performant for extremely long emails, so
  // we skip it for emails longer than AUTOLINKER_MAX_LEN so it doesn't freeze
  // the browser.
  if (html.length > AUTOLINKER_MAX_LEN) {
    return html;
  }
  try {
    return Autolinker.link(html, {
      stripPrefix: false
    });
  } catch (e) {
    console.error('Error treating HTML');
    return html;
  }
};

// TODO : make sure this is converted to contract
SecureReadWidget.prototype.getPolicy = function () {
  return this._contract;
};
SecureReadWidget.prototype.setup = function () {
  var element = this._element;
  var {
    dom
  } = this._settings;
  var messageInfo = this._messageInfo;
  const contract = this._contract;
  var {
    authorizations
  } = contract;
  if (!authorizations) {
    authorizations = [];
  }
  var policyUpdater = PolicyUpdater.create(this._secureService, contract, this._connectionEventRouter);
  var emailWidget;
  if (this._isOwner) {
    emailWidget = EmailTemplateSender.create({
      id: contract.policyId || this._metadata.messageId,
      bodyHtml: messageInfo.message,
      status: contract.state,
      disableCopyPaste: !authorizations.includes(PolicyAttributes.COPY_PASTE),
      disablePrint: !authorizations.includes(PolicyAttributes.PRINT),
      disableForwarding: !authorizations.includes(PolicyAttributes.ALLOW_FORWARDING),
      enableNoauth: authorizations.includes(PolicyAttributes.NOAUTH),
      expandedWatermarking: authorizations.includes(PolicyAttributes.WATERMARK),
      persistentProtection: authorizations.includes(PolicyAttributes.PERSISTENT_PROTECTION),
      expires: contract.activeEnd !== undefined,
      expirationDate: contract.activeEnd,
      analyticsService: AnalyticsService,
      isManaged: contract.isManaged,
      remoteContentLink: this._readerResponse.remoteContentLink,
      sms2faMap: contract.sms2faMap
    }, this._settings);
  } else {
    emailWidget = EmailTemplateReceiver.create({
      id: contract.policyId || this._metadata.messageId,
      bodyHtml: messageInfo.message,
      status: contract.state,
      disableCopyPaste: !authorizations.includes(PolicyAttributes.COPY_PASTE),
      disablePrint: !authorizations.includes(PolicyAttributes.PRINT),
      disableForwarding: !authorizations.includes(PolicyAttributes.ALLOW_FORWARDING),
      enableNoauth: authorizations.includes(PolicyAttributes.NOAUTH),
      expandedWatermarking: authorizations.includes(PolicyAttributes.WATERMARK),
      persistentProtection: authorizations.includes(PolicyAttributes.PERSISTENT_PROTECTION),
      expires: contract.activeEnd !== undefined,
      expirationDate: contract.activeEnd,
      analyticsService: AnalyticsService,
      isManaged: contract.isManaged,
      remoteContentLink: this._readerResponse.remoteContentLink,
      sms2faMap: contract.sms2faMap
    }, this._settings);
    policyUpdater.on('offline', emailWidget.onOffline);
    policyUpdater.on('offline-lease-started', emailWidget.onOfflineLeaseStarted);
    policyUpdater.on('offline-lease-expired', emailWidget.onOfflineLeaseExpired);
    policyUpdater.on('online', emailWidget.onOnline);
  }
  element.removeClass();
  element.addClass('virtru-open');

  // Previously we were simply replacing the contents of this element, but ran into issues fighting shadow DOM re-rendering.
  // Now we insert the decrypted message into a nearby optimal place depending on whether we are a parent or nested read widget.
  var $parentElement = $(element).closest('.virtru-email-decrypted');
  var closestMessage = $(element).closest('.virtru-message');
  var isSecureParentMessage = gmailUtil.isSecureParentMessage(element);
  var isOutlookSecureMessage = this._metadata && this._metadata['user.platform'] ? this._metadata['user.platform'] === 'office365_browser' : false;

  // Hide the original message content and insert our decrypted message nearby
  // This is a workaround to avoid multiple decryptions from being triggered if the top-level parent is re-rendered
  // We also have to do this for messages from O365 or it will misidentify parents and render duplicates
  if ($parentElement.length === 0 && (isSecureParentMessage || isOutlookSecureMessage)) {
    /*
      We're hiding gmail's default message element, and creating our own to be rendered directly below it.
      Because we're creating our own element for decrypted content, some class names that google uses
      aren't present, so we're simply copying their classnames over to our new element.
       The class names we copy are important because they apply default google styles for font-size.
    */
    var classes = $(element).closest('.virtru-message').attr('class');
    var childClasses = $(element).closest('.virtru-message').firstChild().attr('class');
    emailWidget._element.addClass(classes).addClass(childClasses);
    closestMessage.find('[class*=virtru-invitation]').hide();
    closestMessage.find('.virtru-receiver-inactive').hide();
    closestMessage.css('display', 'none');

    // Get rid of previous messages to avoid duplicates
    $(element).closest('.virtru-message').siblings('.virtru-email-decrypted').remove();
    $(element).closest('.virtru-message').after(emailWidget._element);
    if (this._options && this._options.doAnimation) {
      // Hide the decrypted content until the animation widget is finished
      $(emailWidget._element).addClass('virtru-started-decrypt');
    }
  } else {
    $(emailWidget._element).addClass('virtru-embedded-message');
    $(element).after(emailWidget._element);
    $(element).hide();
  }
  var readMessageContainer = element.closest(dom.READ_MESSAGE_CONTAINER);
  $(readMessageContainer).closest(dom.NEW_COMPOSE_TRIMMED_CONTENT).addClass('gmail_extra-borders-removed');
  policyUpdater.on('revocation', emailWidget.handleRevocation);
  policyUpdater.on('revoke-succeeded', emailWidget.handleRevokeSucceeded);
  policyUpdater.on('revoke-failed', emailWidget.handleRevokeFailed);
  policyUpdater.on('enable-succeeded', emailWidget.handleEnableSucceeded);
  policyUpdater.on('enable-failed', emailWidget.handleEnableFailed);
  policyUpdater.on('policy-update-succeeded', emailWidget.handlePolicyUpdateSucceeded);
  policyUpdater.on('policy-update-failed', emailWidget.handlePolicyUpdateFailed);
  policyUpdater.on('is-managed-update', this.updateAttachmentIsManaged);
  emailWidget.on('revoke', policyUpdater.handleRevoke);
  emailWidget.on('enable', policyUpdater.handleEnable);
  emailWidget.on('policy-updated', policyUpdater.handlePolicyChanged);
  this.emailWidget = emailWidget;
  this.policyUpdater = policyUpdater;

  // Check if we need to add a CKS indicator, depending on the type of encryption used
  if (contract.isInternalCksMessage) {
    const $cksContainer = emailWidget._element.find('.virtru-cks-indicator-container');
    if ($cksContainer.length) {
      // remove any existing cks indicators on this message
      $cksContainer.children().each(function () {
        $(this).remove();
      });
      $cksContainer.empty();
      const $cksElement = $('<div class="virtru-cks-indicator"></div>');
      $cksContainer.append($cksElement);
      renderCKSIndicator($cksElement[0]);
    }
  }
};

/**
 * figure out if it's active/revoked/expired.  Right now we ony do
 * active or revoked
 */
SecureReadWidget.prototype.status = function (policy) {
  if (policy.contract.state === 'active') {
    return 'active';
  }
  return 'revoked';
};

/**
 * Teardown the widget
 */
SecureReadWidget.prototype.teardown = function () {
  var {
    emailWidget
  } = this;
  var {
    policyUpdater
  } = this;
  policyUpdater.off('revocation');
  policyUpdater.off('revoke-succeeded');
  policyUpdater.off('revoke-failed');
  policyUpdater.off('enable-succeeded');
  policyUpdater.off('enable-failed');
  policyUpdater.off('policy-update-succeeded');
  policyUpdater.off('policy-update-failed');
  policyUpdater.off('offline');
  policyUpdater.off('offline-lease-started');
  policyUpdater.off('offline-lease-expired');
  policyUpdater.off('online');
  emailWidget.off('revoke');
  emailWidget.off('enable');
  emailWidget.off('policy-updated');
  this.emailWidget.teardown();
  this.policyUpdater.teardown();
  if (this.DownloadVirtruAttachmentMod) {
    this.DownloadVirtruAttachmentMod.teardown();
  }
};
SecureReadWidget.prototype.updateAttachmentIsManaged = function (isManaged) {
  if (this._isOwner) {
    this._attachments.forEach(function (mod) {
      mod.setIsManaged(isManaged);
    });
  }
};

/**
 * Search through decrypted message and pull out inline Drive attachments
 */
SecureReadWidget.prototype.setupVirtruAttachments = function () {
  var promises = [];
  try {
    var attachmentChips = $('.virtru-attachment', this.emailWidget._element);
    var brokenAttachmentSection = this.emailWidget._element.find('[class$=gmail-virtru-attachment-section]');
    if (brokenAttachmentSection.length > 0) {
      brokenAttachmentSection.remove();
    }
    for (var i = 0, len = attachmentChips.length; i < len; i++) {
      var mod = new DownloadVirtruAttachmentMod(this._settings, attachmentChips[i], this._transports);
      promises.push(mod.setup());
      this._attachments.push(mod);
      this.DownloadVirtruAttachmentMod = mod;
    }
    return Promise.allSettled(promises);
  } catch (err) {
    AnalyticsService.clientError({
      context: 'read_virtru_attachment',
      'policy.Id': this._metadata.messageId,
      name: Object.hasOwn(err, 'name') ? err.name : 'Could not hook Virtru attachments'
    });
    return Promise.reject('Could not hook Virtru Attachments');
  }
};
module.exports = SecureReadWidget;

/***/ }),

/***/ 74029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * Virtru Policy Model
 */
const {
  _bindAllMethods
} = __webpack_require__(4424);
var DEFAULT_OPTIONS = {
  state: 'closed',
  expirationUnit: 'days',
  disableCopyPaste: false,
  disablePrint: false,
  disableForwarding: false,
  enableNoauth: false,
  persistentProtection: false,
  expandedWatermarking: false,
  expires: false,
  isManaged: false,
  sms: false
};
function PolicyModel() {
  this.disableCopyPaste = null;
  this.disablePrint = null;
  this.disableForwarding = null;
  this.enableNoauth = null;
  this.expandedWatermarking = null;
  this.expires = null;
  this.sms = null;
  this.sms2faMap = null;
  this.expirationNum = null;
  this.expirationUnit = null;
  this.expirationDate = null;
  this.revokedDate = null;
  this.isManaged = null;
  this.persistentProtection = null;
  _bindAllMethods(this);
}
PolicyModel.create = function (options) {
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  var policyModel = new PolicyModel();
  policyModel.setOptions(options);
  return policyModel;
};
PolicyModel.prototype.setOptions = function (options) {
  this.disableCopyPaste = options.disableCopyPaste;
  this.disablePrint = options.disablePrint;
  this.disableForwarding = options.disableForwarding;
  this.enableNoauth = options.enableNoauth;
  this.persistentProtection = options.persistentProtection;
  this.expandedWatermarking = options.expandedWatermarking;
  this.expires = options.expires;
  this.sms = options.sms;
  this.sms2faMap = options.sms2faMap;
  this.expirationNum = options.expirationNum;
  this.expirationUnit = options.expirationUnit;
  this.expirationDate = options.expirationDate;
  this.revokedDate = options.revokedDate;
  this.isManaged = options.isManaged;
};
PolicyModel.DEFAULT_OPTIONS = DEFAULT_OPTIONS;
exports.PolicyModel = PolicyModel;

/***/ }),

/***/ 74838:
/***/ ((__unused_webpack_module, exports) => {

exports.validateEmails = function (emails) {
  for (var i = 0; i < emails.length; i++) {
    var email = emails[i];
    if (email.length == 0) {
      //eslint-disable-line
      return {
        valid: false,
        email: undefined
      };
    }
    if (!exports.validateEmail(email)) {
      return {
        valid: false,
        email
      };
    }
  }
  return {
    valid: true
  };
};
exports.validateEmail = function (email) {
  // eslint-disable-next-line
  var re = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
  return re.test(email);
};

/***/ }),

/***/ 75451:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PopoutListenerFeature: () => (/* binding */ PopoutListenerFeature)
/* harmony export */ });
/* harmony import */ var _lib_mods__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(25939);
/* harmony import */ var _lib_mods__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_mods__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_contexts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47446);
/* harmony import */ var _lib_contexts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lib_contexts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lib_sdk__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(29182);
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4424);






/**
 * The popout listener feature
 *
 * This mod is responsible for registering a pop out listener.
 */
class PopoutListenerFeature extends _lib_mods__WEBPACK_IMPORTED_MODULE_0__.Mod {
  constructor(settings, element) {
    super(settings, element);
    this._settings = settings;
    this._element = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_2___default()(element);
    (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_4__._bindAllMethods)(this);
  }
  setup() {
    this.setupPopoutDelegatedActivation();
  }

  /**
   * Add the listener for activate delegated accounts from a pop out window
   */
  setupPopoutDelegatedActivation() {
    const self = this;
    window.addEventListener('message', function handler(event) {
      var _event$data;
      if (((_event$data = event.data) === null || _event$data === void 0 ? void 0 : _event$data.action) === 'activationFromPopoutWindow') {
        const {
          url
        } = event.data;
        // wait for verification tab to open, then reload user profile
        _lib_sdk__WEBPACK_IMPORTED_MODULE_3__.transports.call('content', 'waitForEmailActivation', {
          url
        }).then(() => {
          self._settings.emit('load:user:profile');
          window.removeEventListener('message', handler);
        });
      }
    });
  }
}
PopoutListenerFeature.mainDomKey = 'GMAIL_MAIN_CONTAINER';
Object.assign(PopoutListenerFeature.prototype, (_lib_mods__WEBPACK_IMPORTED_MODULE_0___default().ModWaiterPromises));
_lib_contexts__WEBPACK_IMPORTED_MODULE_1___default().addOpen(PopoutListenerFeature);

/***/ }),

/***/ 75769:
/***/ ((__unused_webpack_module, exports) => {

function ModFactory(settings, modClass) {
  this._settings = settings;
  this._modClass = modClass;
}
ModFactory.create = function (settings, modClass) {
  var {
    dom
  } = settings;
  var factory = new ModFactory(settings, modClass);
  var domKey = modClass.mainDomKey;
  factory.mainSelector = dom[domKey];
  return factory;
};
ModFactory.prototype.process = function (matches) {
  var modClass = this._modClass;
  var self = this;
  var newMods = [];
  matches.forEach(function (element) {
    var mod = modClass.open(self._settings, element);
    if (mod) {
      mod._addedElement = element;
      newMods.push(mod);
    }
  });
  return newMods;
};
exports.ModFactory = ModFactory;

/***/ }),

/***/ 75794:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

const globalStore = __webpack_require__(71139);
const {
  AUTHORIZATION_PERSISTENT_PROTECTION,
  AUTHORIZATION_WATERMARK
} = (__webpack_require__(42769).PolicyModel);

/**
 * Virtru Email Template for Sender
 */
var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var Popover = __webpack_require__(55929);
var i18n = __webpack_require__(2622);
var moment = __webpack_require__(13985);
var Templates = __webpack_require__(5749);
var emailUtils = __webpack_require__(25119);
var {
  NestedMessagePlaceholder
} = __webpack_require__(82890);
const {
  _bindAllMethods
} = __webpack_require__(4424);
var defaultOptions = {};
var STATUSES = {
  active: 'active',
  revoked: 'deactivated',
  expired: 'expired'
};
function EmailTemplateSender(element, settings, options) {
  this._element = element;
  this._settings = settings;
  this._status = options.status;
  this._expirationDate = options.expirationDate;
  this._revokedDate = options.revokedDate;
  this._analyticsService = options.analyticsService;
  _bindAllMethods(this);
}

// Add events to this class
Emitter(EmailTemplateSender.prototype);

/**
 *
 * @param options
 *
 *  status: 'active'
 *  bodyHtml: <div>
 *  disableCopyPaste: true
 *  disableForwarding: false
 *  enableNoauth: false
 *  persistentProtection: false
 *  disablePrint: false
 *  expirationDate: Fri Sep 06 2013 14:08:40 GMT-0400 (EDT)
 *  revokedDate: Fri Sep 06 2013 14:08:40 GMT-0400 (EDT)
 *  id: "4115b21d-9e08-4c04-b981-2ceb3cff37bc"
 *  @param settings The settings object for the current user
 *
 * @returns {EmailTemplateSender}
 */
EmailTemplateSender.create = function (options, settings) {
  options = Object.assign({}, defaultOptions, options);
  var element = $(Templates.emailTemplateSender());
  var sender = new EmailTemplateSender(element, settings, options);
  options.isPreviouslySentMessage = true;
  const {
    attachPolicyMenu,
    PolicyConfigMenuFunctions
  } = (__webpack_require__(31795).PolicyConfig);
  const recipientsFn = () => {
    const emails = sender.getEmails();
    return {
      emails: Array.from(new Set(emails))
    };
  };
  const limitedEncryptionCheck = () => Promise.resolve(true);
  sender._policyConfig = PolicyConfigMenuFunctions;
  attachPolicyMenu(element.find('.virtru-sender-menu-container')[0], settings, () => recipientsFn(), limitedEncryptionCheck, model => {
    sender.policyConfigMenuClosed(model, true);
  }, options);
  sender.setBodyHtml(options.bodyHtml);

  // Replace the chained messages with our own html
  var nestedMessages = element.find('div[data-message-id]');
  nestedMessages.each(function (_, nestedMessage) {
    nestedMessage = $(nestedMessage);
    var messageId = nestedMessage.data('message-id');
    NestedMessagePlaceholder.render(nestedMessage[0], {
      messageId
    });
  });
  element.find('.virtru-attachment[data-size]').each(function () {
    const fileSize = $(this).data('size');
    const correctFileSize = emailUtils.formatFileSize(fileSize);
    $(this).find('.virtru-attachment-file-size').text(correctFileSize);
  });
  sender.initEvents();
  sender.updateExpirationDate(options.expirationDate, options.expirationDate !== undefined);
  sender.setRevokedDate(options.revokedDate);
  sender.setStatus(options.status);
  return sender;
};
EmailTemplateSender.prototype.getEmails = function () {
  const {
    dom
  } = this._settings;
  $(dom.EMAIL_POPUP_BUTTON).click(); // Should emit render of email popup (to get emails)
  const emailNodes = $(dom.EMAIL_POPUP_AREA).find(dom.EMAIL_POPUP_SPAN);
  const emails = Array.from(emailNodes).slice(1).map(itm => itm.getAttribute(dom.EMAIL_ATTRIBUTE).toLocaleLowerCase());
  $(dom.EMAIL_POPUP_BUTTON).click();
  return emails;
};
EmailTemplateSender.prototype.initEvents = function () {
  var element = this._element;

  // Only enable if the user can revoke
  if (this._settings.user.permissions.canRevokeOwnedPolicies) {
    element.find('.virtru-sender-button').on('click', this.toggleActive);
  }
  this._policyConfig.on('expiration-date-changed', this.updateExpirationDate);
  this._policyConfig.on('opened', this.disableActionButton);
  this._policyConfig.on('closed', this.policyConfigMenuClosed);
  this._policyConfig.on('disable-forwarding-changed', this.onDisableForwardingChanged);
  this._policyConfig.on('enable-sms-changed', this.onEnableSMSChanged);
  this._policyConfig.on('enable-noauth-changed', this.onEnableNoauthChanged);
  this._policyConfig.on('pfp-changed', this.onPfpChanged);
  this._policyConfig.on('enable-watermark-changed', this.onWatermarkStateChanged);
  var model = this._policyConfig.getModel();
  this.onDisableForwardingChanged(model.disableForwarding);
  this.onEnableSMSChanged(model.sms);
  this.onEnableNoauthChanged(model.enableNoauth);
  this.onPfpChanged(model.persistentProtection);
  if (this._status === STATUSES.active && this._policyConfig.getModel().expires) {
    this.refreshExpirationTimer();
  }
  this._expirationInterval = setInterval(this.updateExpirationText, 30000);
};

// sets up the expiration timer and forces a refresh if the value is too far in the future
EmailTemplateSender.prototype.refreshExpirationTimer = function () {
  var now = moment();
  var expiration = moment(this._expirationDate);
  var differenceMs = Math.max(expiration.diff(now), 0);
  if (this._expirationTimer) {
    clearTimeout(this._expirationTimer);
  }
  if (differenceMs >= 0x7FFFFFFF) {
    // setTimeout limit is MAX_INT32=(2^31-1)
    var self = this;
    this._expirationTimer = setTimeout(function () {
      self.refreshExpirationTimer();
    }, 0x7FFFFFFF);
  } else {
    this._expirationTimer = setTimeout(this.handleExpiration, differenceMs);
  }
};
EmailTemplateSender.prototype.onDisableForwardingChanged = function (value) {
  $(this._element.find('.virtru-forwarding-icon')[0]).css('display', value ? 'inline' : 'none');
};
EmailTemplateSender.prototype.onEnableSMSChanged = function (value) {
  this._element.find('.virtru-sms-icon')[value ? 'show' : 'hide']();
};
EmailTemplateSender.prototype.onEnableNoauthChanged = function (value) {
  $(this._element.find('.virtru-noauth-icon')[0]).css('display', value ? 'inline' : 'none');
};
EmailTemplateSender.prototype.onPfpChanged = function (value) {
  $(this._element.find('.virtru-pfp-icon')[0]).css('display', value ? 'inline' : 'none');
  this.togglePfpStyle(value);
  this.updateAttachmentsSecurityOptions(value, AUTHORIZATION_PERSISTENT_PROTECTION);
};
EmailTemplateSender.prototype.onWatermarkStateChanged = function (value) {
  $(this._element.find('.virtru-watermark-icon')[0]).css('display', value ? 'inline' : 'none');
  this.updateAttachmentsSecurityOptions(value, AUTHORIZATION_WATERMARK);
};
EmailTemplateSender.prototype.updateAttachmentsSecurityOptions = function (value, securityOption) {
  $(this._element).find('.virtru-attachment[data-size]').each(function () {
    const id = $(this).attr('id');
    const securityOptionData = {
      securityOption,
      value
    };
    globalStore.dispatch({
      type: 'UPDATE_ATTACHMENT_SECURITY_OPTION',
      id,
      data: securityOptionData
    });
  });
};
EmailTemplateSender.prototype.togglePfpStyle = function (value) {
  const attachments = this._element.find('.virtru-attachment-v2', this._settings.dom.VIRTRU_TDF_ATTACHMENT);
  $(attachments).toggleClass('pfp-enabled', value);
};
EmailTemplateSender.prototype.setStatus = function (value) {
  var element = this._element;
  var revokeButton = $(element.find('.virtru-sender-button')[0]);
  var gmailExtra = $(element.find(this._settings.dom.NEW_COMPOSE_TRIMMED_CONTENT)[0]);
  var popoverTitle = '';
  var popoverContent = '';
  element.addClass('virtru-email-decrypted');
  this._status = value;
  switch (value) {
    // eslint-disable-line
    case STATUSES.active:
      element.removeClass('virtru-sender-revoked');
      element.addClass('virtru-sender-enabled');
      revokeButton.removeClass('virtru-sender-reauthorize-button');
      revokeButton.addClass('virtru-sender-revoke-button');
      this._policyConfig.enable();
      gmailExtra.show();
      popoverTitle = i18n.t('TOOLTIP_REVOKE_BUTTON_TITLE');
      popoverContent = i18n.t('TOOLTIP_REVOKE_BUTTON_CONTENT');
      this.updateExpirationText();
      break;
    case STATUSES.revoked:
      element.removeClass('virtru-sender-enabled');
      element.addClass('virtru-sender-revoked');
      revokeButton.removeClass('virtru-sender-revoke-button');
      revokeButton.addClass('virtru-sender-reauthorize-button');
      this._policyConfig.disable();
      gmailExtra.hide();
      popoverTitle = i18n.t('TOOLTIP_REAUTHORIZE_BUTTON_TITLE');
      popoverContent = i18n.t('TOOLTIP_REAUTHORIZE_BUTTON_CONTENT');
      break;
    case STATUSES.expired:
      break;
  }

  // Only enable if the user can revoke
  if (!this._settings.user.permissions.canRevokeOwnedPolicies) {
    var actionButton = this._element.find('.virtru-sender-button');
    actionButton.removeClass('virtru-sender-disabled-reauthorize-button');
    actionButton.removeClass('virtru-sender-disabled-revoke-button');
    actionButton.removeClass('virtru-sender-reauthorize-button');
    actionButton.removeClass('virtru-sender-revoke-button');
    actionButton.addClass('virtru-sender-upsell-revoke-button');
    popoverContent += i18n.t('TOOLTIP_UPSELL_POSTFIX');
  }
  if (this._revokeButtonPopover) {
    this._revokeButtonPopover.title(popoverTitle);
    this._revokeButtonPopover.content(popoverContent);
    if (this._revokeButtonPopover.el.parent().length) {
      this._revokeButtonPopover.reposition();
    }
  } else {
    this._revokeButtonPopover = new Popover(popoverContent, popoverTitle);
    this._revokeButtonPopover.classname += ' virtru-popover-dark';
    this._revokeButtonPopover.position('north');
    this._revokeButtonPopover.setShowTimer();
    this._revokeButtonPopover.attach(revokeButton);
  }
};

/**
 * Sets the body html
 * @param bodyHtml
 */
EmailTemplateSender.prototype.setBodyHtml = function (bodyHtml) {
  var body = $(this._element.find('.virtru-sender-body')[0]);
  body.empty();
  body.append(bodyHtml);
};
EmailTemplateSender.prototype.setRevokedDate = function (date) {
  this._revokedDate = date;
  this.updateRevokedDateText();
};

/**
 *
 */
EmailTemplateSender.prototype.policyConfigMenuClosed = function (policyModel, changesDetected) {
  if (!this._policyConfig) {
    return;
  }
  var self = this;
  if (changesDetected) {
    this.emit('policy-updated', policyModel);
    setTimeout(function () {
      self.disableButtons();
    }, 0);
  } else {
    self.enableButtons();
  }
};
EmailTemplateSender.prototype.updateExpirationDate = function (expires, date) {
  // @TODO check all places where this function is used
  if (date !== null && date !== void 0 && date.toISOString) {
    this._expirationDate = date;
    this.updateExpirationText();
  }
};
EmailTemplateSender.prototype.updateExpirationText = function () {
  var element = this._element;
  var {
    expires
  } = this._policyConfig.getModel();
  var result = i18n.t('SENDER_WIDGET_NO_EXPIRATION');
  var date = this._expirationDate;
  var start = moment();
  var end = moment(date);
  if (expires) {
    if (start > end) {
      result = i18n.t('SENDER_WIDGET_EXPIRED_DATE', {
        datetime: end.from(start)
      });
    } else {
      result = i18n.t('SENDER_WIDGET_EXPIRES_DATE', {
        datetime: end.from(start)
      });
    }
  }
  var expirationElement = $(element.find('.virtru-sender-header-expiration-date')[0]);
  if (expires) {
    expirationElement.removeClass('virtru-sender-header-no-expiration-date');
  } else {
    expirationElement.addClass('virtru-sender-header-no-expiration-date');
  }
  expirationElement.text(result);
};
EmailTemplateSender.prototype.updateRevokedDateText = function () {
  var revokedText = i18n.t('SENDER_WIDGET_MESSAGE_REVOKED');
  if (this._revokedDate !== undefined) {
    var start = moment();
    var end = moment(this._revokedDate);
    revokedText = i18n.t('SENDER_WIDGET_REVOKED_DATE', {
      datetime: end.from(start)
    });
  }
  $(this._element.find('.virtru-sender-header-expiration-date')[0]).text(revokedText);
};
EmailTemplateSender.prototype.toggleActive = function () {
  if (this._status === STATUSES.active) {
    this.emit('revoke');
  } else {
    this.emit('enable');
  }
  this.disableButtons();
};
EmailTemplateSender.prototype.hideFooter = function () {
  $(this._element.find('.virtru-sender-footer')[0]).hide();
  this._element.css('padding-bottom', '0');
};

/**
 * Cleanup function
 */
EmailTemplateSender.prototype.teardown = function () {
  if (this._expirationTimer) {
    clearTimeout(this._expirationTimer);
  }
  if (this._expirationInterval) {
    clearInterval(this._expirationInterval);
  }
  this._policyConfig.off('expiration-date-changed', this.updateExpirationDate);
  this._policyConfig.off('closed', this.policyConfigMenuClosed);
  this._policyConfig = null;
};
EmailTemplateSender.prototype.appendTo = function (el) {
  $(el).append(this._element);
  $(el).closest('.gmail_extra').addClass('gmail_extra-borders-removed');
};

/*
 * Disables the policyConfig and revoke/reauthorize buttons;
 */
EmailTemplateSender.prototype.disableButtons = function () {
  this._policyConfig.disable();
  this.disableActionButton();
};

/*
 * Enables the policyConfig and revoke/reauthorize buttons;
 */
EmailTemplateSender.prototype.enableButtons = function () {
  if (this._status === STATUSES.active) {
    this._policyConfig.enable();
  }
  this.enableActionButton();
};

/**
 * Disables the revoke/reauthorize button
 */
EmailTemplateSender.prototype.disableActionButton = function () {
  var actionButton = $(this._element.find('.virtru-sender-button')[0]);
  if (this._status === STATUSES.active) {
    actionButton.addClass('virtru-sender-disabled-revoke-button');
  } else {
    actionButton.addClass('virtru-sender-disabled-reauthorize-button');
  }
};

/**
 * Enables the revoke/reauthorize button
 */
EmailTemplateSender.prototype.enableActionButton = function () {
  var actionButton = $(this._element.find('.virtru-sender-button')[0]);
  actionButton.removeClass('virtru-sender-disabled-reauthorize-button');
  actionButton.removeClass('virtru-sender-disabled-revoke-button');
};

/**
 * Handles a revocation event
 */
EmailTemplateSender.prototype.handleRevocation = function () {
  this.setStatus(STATUSES.revoked);
  this.setRevokedDate(new Date());
};

/**
 * Handles revocation succeeded after the user triggers a revoke
 */
EmailTemplateSender.prototype.handleRevokeSucceeded = function () {
  this.setStatus(STATUSES.revoked);
  this.setRevokedDate(new Date());
  this.enableButtons();
};

/**
 * Handles revocation failed after the user triggers a revoke
 */
EmailTemplateSender.prototype.handleRevokeFailed = function () {
  // TODO : Handle this appropriately
  alert(i18n.t('SENDER_WIDGET_ERROR_REVOCATION'));
  this.enableButtons();
};

/**
 * Handles enabled succeeded after the user enables an email
 */
EmailTemplateSender.prototype.handleEnableSucceeded = function () {
  this.setStatus(STATUSES.active);
  this.enableButtons();
};

/**
 * Handles revocation succeeded after the user triggers a revoke
 */
EmailTemplateSender.prototype.handleEnableFailed = function () {
  // TODO : Handle this appropriately
  alert(i18n.t('SENDER_WIDGET_ERROR_ENABLE_MESSAGE'));
  this.enableButtons();
};
EmailTemplateSender.prototype.handleExpiration = function () {
  clearTimeout(this._expirationTimer);
  this.expire();
};

/* Forces the message to expire, with an optional expiration date. Removes body text completely */
EmailTemplateSender.prototype.expire = function (expirationDate) {
  if (expirationDate) {
    this.updateExpirationDate(undefined, expirationDate); // TODO refactor this function and its usage
  }
  this.setStatus(STATUSES.expired);
};

/**
 * Handles success when the user updates the policy
 */
EmailTemplateSender.prototype.handlePolicyUpdateSucceeded = function () {
  this.enableButtons();
};

/**
 * Handles failure when the user updates the policy
 */
EmailTemplateSender.prototype.handlePolicyUpdateFailed = function () {
  // TODO : Handle this appropriately
  alert(i18n.t('SENDER_WIDGET_ERROR_UPDATE_POLICY'));
  this.enableButtons();
  this.updateExpirationText();
};
exports.EmailTemplateSender = EmailTemplateSender;

/***/ }),

/***/ 76223:
/***/ ((module) => {

module.exports = {
  // The selector that finds the TDF within something we believe to be a
  // secure email
  TDF_SELECTOR: 'div pre:contains("--- START PROTECTED MESSAGE TDF")',
  TDF_METADATA_SELECTOR: 'div pre:contains("Virtru Metadata:")',
  SECURE_MESSAGE: '.virtru-open',
  ANIMATION: '.virtru-animation-widget',
  NESTED_SECURE_MESSAGE: '.virtru-nested-secure-message-default',
  DRAFT_SELECTOR: 'input[name*="virtru-secure-draft"]',
  SENDER_HEADER: 'h3.iw span[email]',
  SENDER_EMAIL_HEADER: 'h3.iw .go',
  TIMESTAMP_HEADER: '.gK .g3',
  METADATA_SELECTOR: 'input[name="virtru-metadata"]',
  // Maximum number of attached files
  ATTACHMENTS_LIMIT: 150,
  MAX_RETRY_COUNT: 5,
  UPLOAD_RETRY_DELAY: 2500,
  START_DECRYPTION: 'starting_decryption',
  DONE_DECRYPTION: 'decryption_done',
  DECRYPTION_ANIMATION_START: 'begin_decryption_animation',
  DECRYPTION_ANIMATION_END: 'end_decryption_animation',
  EXTENSION_KEY: 'BP'
};

/***/ }),

/***/ 77957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
module.exports = function () {
  var monitor = {};
  Emitter(monitor);
  var dragEnter = function (event) {
    monitor.emit('dragenter', event);
  };
  var dragStop = function (event) {
    if (event.type === 'drop') {
      monitor.emit('drop', event);
    }
  };
  var monitorElem = function (elem) {
    elem.addEventListener('dragenter', dragEnter, true);
    elem.addEventListener('dragleave', dragStop, true);
    elem.addEventListener('drop', dragStop, true);
  };
  monitor.refresh = function () {
    var iframes = $('iframe');
    for (var i = 0, len = iframes.length; i < len; ++i) {
      try {
        monitorElem(iframes[i].contentWindow);
        // eslint-disable-next-line
      } catch (e) {} // Preventing errors for access control issues
    }
  };
  monitorElem(window);
  return monitor;
}();

/***/ }),

/***/ 77965:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 78376:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

// Default policy for Trusted Types support
// TODO: temporary solution, remove this once we properly resolve existing violations
if (!window.trustedTypes.defaultPolicy) {
  window.trustedTypes.createPolicy('default', {
    // fixes violations from jQuery and other DOM manipulation code
    createHTML: string => string,
    // fixes violations from HTML template engines
    createScript: string => string
  });
}
const $ = __webpack_require__(55401);
const {
  Router
} = __webpack_require__(61526);
const {
  routers
} = __webpack_require__(29182);
const {
  transports
} = __webpack_require__(29182);
const {
  ScriptTransport
} = transports;
const {
  EXTENSION_KEY
} = __webpack_require__(76223);
const contentRouter = routers.router('content');

/**
 * Adapt requests to the content script
 */
function requestAdapter(command, params, responseCallback, progressCallback) {
  // Setup a unique id for the request
  const callId = window.crypto.randomUUID();
  const envelope = {
    uniqueExtensionKey: EXTENSION_KEY,
    type: 'command',
    action: command,
    target: 'content',
    data: params,
    callId
  };

  // Listen for a response
  const responseEvent = `response-${callId}`;
  const progressEvent = `progress-${callId}`;
  const progressListener = function (event) {
    const progressData = event.data.data;
    const {
      error
    } = event.data;
    progressCallback.apply(null, [error, progressData]);
    if (error) {
      // It shouldn't get here but if it does cancel the event listeners
      window.removeEventListener(responseEvent, responseListener);
      window.removeEventListener(progressEvent, progressListener);
    }
  };
  const responseListener = function (event) {
    const responseData = event.data.data;
    const {
      error
    } = event.data;
    responseCallback.apply(null, [error, responseData]);
    window.removeEventListener(responseEvent, responseListener);
    window.removeEventListener(progressEvent, progressListener);
  };
  window.addEventListener(responseEvent, responseListener, false);
  window.addEventListener(progressEvent, progressListener, false);
  window.postMessage(envelope, window.location.origin);
}

// Intialize transport
const chromePageToContentTransport = ScriptTransport.setup({
  requestAdapter
});

// Configure the transport into virtru.transports
transports.registerTransport('content', chromePageToContentTransport);

/**
 * A shortcut for triggering a window event.
 *
 * This is used for calling the response and progress events. Eventually we
 * may create a better way to handle these
 */
function windowDataEvent(eventName, data) {
  $(window).triggerNative(eventName, {
    extra: {
      data
    }
  });
}

// Create a router to route the 'message' events
const messageRouter = new Router();

/**
 * Handle responses from the content script
 */
messageRouter.register('response', function (data) {
  const id = data.callId;
  windowDataEvent(`response-${id}`, data);
});

/**
 * Handle progress responses from the content script
 */
messageRouter.register('progress', function (data) {
  const id = data.callId;
  windowDataEvent(`progress-${id}`, data);
});

/**
 * Handle commands from the content script
 */
messageRouter.register('command', function (commandData) {
  const actionName = commandData.action;
  const requestParams = commandData.data;
  const responseCallback = function (error, responseData) {
    window.postMessage({
      uniqueExtensionKey: EXTENSION_KEY,
      type: 'response',
      action: null,
      target: 'content',
      callId: commandData.callId,
      data: responseData,
      error
    }, window.location.origin);
  };
  contentRouter.route(actionName, requestParams, responseCallback);
});

/**
 * Start the message routing
 */
window.addEventListener('message', function (event) {
  if (event.origin !== window.location.origin) {
    // Ignore messages not from the origin
    return;
  }
  if (event.data.target !== 'page' || event.source !== window) {
    return;
  }
  if (!event.data.uniqueExtensionKey || event.data.uniqueExtensionKey && event.data.uniqueExtensionKey !== EXTENSION_KEY) {
    return;
  }
  const messageData = event.data;
  messageRouter.route(messageData.type, messageData);
});
const runExtensionScript = function () {
  // Run the script
  (__webpack_require__(1459).main)();
};

// Run the extension's adapter and main script
runExtensionScript();

/***/ }),

/***/ 78982:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 79145:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 79368:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 80539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var Popover = __webpack_require__(55929);
var i18n = __webpack_require__(2622);
const {
  _bindAllMethods
} = __webpack_require__(4424);
const defaultOptions = {
  dismissClass: 'virtru-dismiss',
  dismissText: i18n.t('DISMISS_POPOVER_DEFAULT_OPTIONS_TEXT')
};

/**
 * Creates a popover that has a dismiss button
 */
class DismissPopover extends Popover {
  constructor(content, title, options) {
    super(content, title);
    this._options = options;
    _bindAllMethods(this);
  }
  static create(content, options) {
    options = Object.assign({}, defaultOptions, options);
    const dismissContent = $('<div></div>');
    dismissContent.append(content);
    const dismissButton = $(`<a href="javascript:void(0)">${options.dismissText}</a>`);
    dismissButton.addClass(options.dismissClass);
    dismissContent.append(dismissButton);
    return new DismissPopover(dismissContent, options.title, options);
  }
  show(...args) {
    // Call the superclass
    super.show(...args);
    const dismissButton = this.el.find(`.${this._options.dismissClass}`);
    const self = this;

    // Hide when dismissed
    const hidePopover = () => {
      self.hide();
      dismissButton.off('click', hidePopover);
    };
    dismissButton.on('click', hidePopover);
  }
}
exports.DismissPopover = DismissPopover;

/***/ }),

/***/ 80790:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var colors = __webpack_require__(73377);
module.exports = {
  open: '<svg width="12px" height="12px" viewBox="0 0 12 12" ' + '><path d="M11,5V2H8V1H7V0H5V1H4V2H1V5H0v6H1v1H11V11h1V5H11ZM10,' + '6H9V7H8V8H7V9H5V8H4V7H3V6H2V3h8V6Z"/></svg>',
  closed: '<svg width="12px" height="12px" viewBox="0 0 12 12" ' + '><polygon points="2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 7 6 7 5 8 5 8 4 9 4 9' + ' 3 10 3 10 2 2 2"/><polygon points="11 3 11 4 10 4 10 5 9 5 9 6 8' + ' 6 8 7 7 7 7 8 5 8 5 7 4 7 4 6 3 6 3 5 2 5 2 4 1 4 1 3 0 3 0 9 1 9 1 10 ' + '11 10 11 9 12 9 12 3 11 3"/></svg>',
  fwd: `${'<svg width="12px" height="12px" viewBox="0 0 24 24"><defs>' + '<style>.cls-1{fill:none;stroke:'}${colors.blue};stroke-linecap:round;` + 'stroke-linejoin:round;stroke-width:2px;}</style></defs><circle ' + 'class="cls-1" cx="12" cy="12" r="11"/><line class="cls-1" x1="7.7" ' + 'y1="12" x2="14.8" y2="12"/><polyline class="cls-1" points="11.1 6.9 ' + '16.1 12 11.1 17.1"/></svg>'
};

/***/ }),

/***/ 80952:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   promoFooter: () => (/* binding */ promoFooter)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const promoFooter = () => `
  <br>
  <br>
  <div lang="klingon" spellcheck="false" class="virtru-message-footer" style="color: #929292 !important;">
    ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('FOOTER_PROMO')} <a 
        lang="klingon" 
        contenteditable="false" 
        spellcheck="false" 
        style="color: #929292 !important;" 
        href="https://www.virtru.com/how-it-works/?utm_medium=Email&utm_source=Plugin%20Users&utm_campaign=Footer" 
        target="_blank"
      >
        ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('FOOTER_PROMO_USE')}
      </a>.
      <div contenteditable="false" class="virtru-footer-cog"></div>
  </div>
`;

/***/ }),

/***/ 81143:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   virtruNewFeatureTipPopover: () => (/* binding */ virtruNewFeatureTipPopover)
/* harmony export */ });
const virtruNewFeatureTipPopover = ({
  label,
  body,
  button
}) => `
  <div class="virtru-new-feature-tip-popover-container">
    <div class="virtru-new-feature-tip-icon"></div>
    <div class="virtru-new-feature-tip-label">${label}</div>
  </div>
  <div class="virtru-new-feature-tip-main-container">${body}</div>
  <div class="virtru-new-feature-tip-buttons">
    <button class="virtru-new-feature-tip-main-button">${button}</button>
  </div>
`;

/***/ }),

/***/ 81147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var contexts = __webpack_require__(47446);

/**
 * A type of context that is meant to be bound to an element
 */
function Mod(settings, element) {
  this._settings = settings;
  this._element = element;
}
Object.assign(Mod.prototype, contexts.ContextManager);
Mod.prototype.setupAll = function () {
  this.setup();
};
Mod.prototype.teardown = function () {};
Mod.prototype.setup = function () {};
Mod.prototype.isAlive = function () {
  return false;
};
exports.Mod = Mod;
class WaiterTimedOut extends Error {
  constructor(message) {
    super(message);
    this.name = 'WaiterTimedOut';
  }
}
var defaultOnceAppearsOptions = {
  listenOn: null,
  timeout: 30000
};

/**
 * ModWaiters Mixin
 *
 * Allows for a promise interface to waiters that automatically manages the
 * registration of a waiter context
 */
var ModWaiterPromises = {
  /**
   * Return a deferred once the selector appears
   */
  onceFinds(selector, options) {
    options = Object.assign({}, defaultOnceAppearsOptions, options);
    var listenOn = options.listenOn || this._element;
    return new Promise((resolve, reject) => {
      options.timedOut = function () {
        reject(new WaiterTimedOut(`Timed out waiting for ${selector} on ${listenOn}`));
      };
      var contextOptions = {
        options,
        callback(matches) {
          resolve(matches);
        }
      };
      var context = contexts.WaiterContext.open(listenOn, selector, contextOptions);
      this.register(context);
    });
  }
};
exports.ModWaiterPromises = ModWaiterPromises;
var ModElementShortcut = {
  /**
   * Return a deferred once the selector appears
   */
  attachElement(options) {
    var context = contexts.ElementContext.open(options);
    this.register(context);
  }
};
exports.ModElementShortcut = ModElementShortcut;
var ModEventListenerShortcut = {
  attachElementEvents() {
    var context = contexts.EventListenerContext.open.apply(null, arguments);
    this.register(context);
  },
  attachObjectEvents() {
    var context = contexts.ObjectEventListenerContext.open.apply(null, arguments);
    this.register(context);
  }
};
exports.ModEventListenerShortcut = ModEventListenerShortcut;
var ModCSSClassShortcut = {
  addClassesToElement(element, options) {
    var context = contexts.CSSClassContext.open(element, options);
    this.register(context);
  }
};
exports.ModCSSClassShortcut = ModCSSClassShortcut;

/***/ }),

/***/ 81177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @file Provides the main settings utility.
 */

var Emitter = __webpack_require__(16502);

/**
 * Stores application settings. Implements events: can be listened to when it changes
 * @constructor
 * @param {Object} window - the 'window' object
 * @param {String} site - the 'mail-site' (i.e.: 'yahoo', 'gmail', 'outlook', ...
 * @param {String} provider - one of: 'yahoo', 'google', 'windowslive', ...
 */
function BaseSettings(window, site, provider) {
  this.dom = {};
  this.window = window;
  this._site = site;
  this._provider = provider;
  // Bind some methods here
  this.userProfileUpdate = this.userProfileUpdate.bind(this);
}

/**
 * Implement events for the BaseSettings object.
 */
Emitter(BaseSettings.prototype);

/**
 * Set the DOM-dictionary
 * @method
 * @param {Object} dom - the DOM object
 */
BaseSettings.prototype.setDomDictionary = function (dom) {
  this.dom = dom;
};

/**
 * Set the user-profile
 * @method
 * @param {Object} userProfile - the Object based on UserProfileProxy
 */
BaseSettings.prototype.setUserProfile = function (userProfile) {
  this.refreshUserProfile(userProfile);

  // Setup listeners
  userProfile.on('update', this.userProfileUpdate);
  this.emit('load:user');
};

/**
 * Refresh the user-profile
 * @method
 * @param {Object} userProfile - the Object based on UserProfileProxy
 */
BaseSettings.prototype.refreshUserProfile = function (userProfile) {
  this.user = userProfile;
};

/**
 * Update the user-profile
 * @method
 * @param {Object} property - the 'property' to be updated
 * @param {String} key - the 'key' to assign to
 * @param {*} value - the 'value' of the key
 */
BaseSettings.prototype.userProfileUpdate = function (property, key, value) {
  this.emit('update', 'user', property, key, value);
  this.emit('update:user', property, key, value);
  this.emit(`update:user:${property}`, key, value);
  this.emit(`update:user:${property}:${key}`, value);
};

/**
 * Request activation for the current user
 *
 * The requestedFrom argument is for analytics purposes, it allows us to see from where
 * the user requested to activate.
 *    i.e.
 *       Dropdown (browser action)
 *       Compose window
 *       Read window
 *       Popup modal
 *
 */
BaseSettings.prototype.requestActivation = function (requstedFrom) {
  this.emit('activationRequested', requstedFrom);
};

/**
 * Get the current user.
 * @abstract
 * @returns {String} - the email address of the current user
 */
BaseSettings.prototype.currentUser = function () {};

/**
 * Get the webmail site
 * @abstract
 * @returns {String} - the webmail site
 */
BaseSettings.prototype.site = function () {
  return this._site;
};

/**
 * Get the current user's display name.  Falls back to the e-mail address if
 * the display name cannot be located
 * @method
 * @returns {String} - the display name of the current user or the e-mail address
 */
BaseSettings.prototype.currentUserDisplayName = function () {};

/**
 * Get the current version
 * @abstract
 * @returns {String} - the 'string-ified' version ID
 */
BaseSettings.prototype.currentVersion = function () {};

/**
 * Get the sdk-transports object (sub-class MUST return the sdk/transports object)
 * @abstract
 * @returns {Object} - the 'sdk/transports' object
 */
BaseSettings.prototype.getTransports = function () {};
exports.BaseSettings = BaseSettings;

/***/ }),

/***/ 81442:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   h: () => (/* binding */ sanitizeAnalyticsError)
/* harmony export */ });
const sanitizeAnalyticsError = error => {
  if (typeof error === 'string') {
    return error;
  }
  const sanitizedError = {
    ...error
  };
  if (sanitizedError.containerElement) {
    delete sanitizedError.containerElement;
  }
  if (sanitizedError.metadata && sanitizedError.metadata.remoteContentLink) {
    delete sanitizedError.metadata.remoteContentLink;
  }
  return sanitizedError;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sanitizeAnalyticsError);

/***/ }),

/***/ 81722:
/***/ ((__unused_webpack_module, exports) => {

const ALLOW_FORWARDING = 'forward';
const NOAUTH = 'no-auth';
const COPY_PASTE = 'copy';
const PRINT = 'print';
const READ_ONCE = 'read_once';
const WATERMARK = 'watermark';
const PREVENT_DOWNLOAD = 'prevent-download';
const PERSISTENT_PROTECTION = 'persistent-protection';

/**
 * Returns an array of the authorizations for a policy.
 *
 * @param {Object} The policy returned from the policy config
 * menu component.
 */
function getAuthorizations(policy) {
  var authorizations = [];
  // opt-in
  if (policy.enableNoauth && !policy.disableForwarding) {
    authorizations.push(NOAUTH);
  }
  if (policy.persistentProtection) {
    authorizations.push(PERSISTENT_PROTECTION);
  }
  // opt-out
  if (!policy.disableForwarding) {
    authorizations.push(ALLOW_FORWARDING);
  }
  if (!policy.disableCopyPaste) {
    authorizations.push(COPY_PASTE);
  }
  if (!policy.disablePrint) {
    authorizations.push(PRINT);
  }
  if (policy.readOnce) {
    authorizations.push(READ_ONCE);
  }
  if (policy.expandedWatermarking) {
    authorizations.push(WATERMARK);
  }
  if (policy.preventDownload) {
    authorizations.push(PREVENT_DOWNLOAD);
  }
  return authorizations;
}
exports.PolicyAttributes = {
  ALLOW_FORWARDING,
  NOAUTH,
  PERSISTENT_PROTECTION,
  READ_ONCE,
  COPY_PASTE,
  PRINT,
  WATERMARK,
  getAuthorizations
};

/***/ }),

/***/ 82519:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
const $ = __webpack_require__(91089);
const XhrCoup = (__webpack_require__(98383)["default"]);
const {
  encryptedSearch
} = __webpack_require__(82672);
const AnalyticsService = (__webpack_require__(1246).instance)();
const {
  transports
} = __webpack_require__(29182);
const {
  SecureServiceProxy
} = __webpack_require__(6336);
const {
  getAllWindows
} = __webpack_require__(60355);
const {
  get
} = __webpack_require__(52635);
const {
  set
} = __webpack_require__(45055);
const sanitizeAnalyticsError = (__webpack_require__(81442)/* ["default"] */ .A);
const SEARCH_PATH = '/bv';
const oldAttributes = {
  IS_SEARCH_ATTR: '1.1',
  SIMPLE_QUERY_ATTR: '1.4',
  ADV_SEARCH_ATTR: '1.16.4',
  ADV_QUERY_ATTR: '1.16.4.4',
  ADV_EXCL_ATTR: '1.16.4.5'
};
const newAttributes = {
  IS_SEARCH_ATTR: '0.0',
  SIMPLE_QUERY_ATTR: '0.3',
  ADV_SEARCH_ATTR: '0.15.3',
  ADV_QUERY_ATTR: '0.15.3.3',
  ADV_EXCL_ATTR: '0.15.3.4'
};
const knownSearchAttributes = [79, 123];
function getAttributes(body) {
  const searchAttr = get(body, newAttributes.IS_SEARCH_ATTR, false);
  const current = knownSearchAttributes.includes(searchAttr) ? newAttributes : oldAttributes;
  return key => current[key];
}
const ENCRYPTED_SEARCH_TIMEOUT_MS = 5000;
const SEARCH_OPTS = {
  jquery: $,
  preserveSyntax: true
};
const MATERIAL_SEARCH_BAR = 'input[aria-label="Search mail"]';

/**
 * Gracefully handle if encrypted search goes too long. This typically happens when search
 * hangs due to the content script detaching from background script
 *
 * Default: 5000ms
 * @param {Number} timeout - time to wait
 * @returns {Promise} timeout promise
 */
const encryptedSearchTimeout = (timeout = ENCRYPTED_SEARCH_TIMEOUT_MS) => new Promise((resolve, reject) => {
  const timeoutId = setTimeout(() => {
    clearTimeout(timeoutId);
    reject(new Error('Encrypted Search Timeout'));
  }, timeout);
});

/**
 * Initializes encrypted search XHR interception
 *
 * @param {Object} settings - settings object
 */
function initSearchXhr(settings) {
  var _settings$user;
  const isPopoutWindow = document.body.matches(settings.dom.POPOUT_WINDOW);
  if (isPopoutWindow) {
    return;
  }
  const windows = getAllWindows();
  const secureService = SecureServiceProxy.create(transports);
  const searchIntercept = new XhrCoup(windows);
  const searchBar = $(MATERIAL_SEARCH_BAR);
  if (!(settings !== null && settings !== void 0 && (_settings$user = settings.user) !== null && _settings$user !== void 0 && _settings$user.setting)) {
    _onSearchError({}, 'initSearchXhr - no profile');
  }

  // We always want this filter, regardless of whether or not it's material
  searchIntercept.customFilter(() => {
    var _settings$user2, _settings$user2$permi;
    return (settings === null || settings === void 0 ? void 0 : (_settings$user2 = settings.user) === null || _settings$user2 === void 0 ? void 0 : (_settings$user2$permi = _settings$user2.permissions) === null || _settings$user2$permi === void 0 ? void 0 : _settings$user2$permi.canSearchEncryptedEmails) && !!settings.user.setting('searchKey');
  }).urlContains(SEARCH_PATH).methodEquals('POST').on('send', handleSearch.bind(this, secureService, searchBar, settings));
}
function _isSearch(body) {
  const attr = getAttributes(body);
  const searchAttr = get(body, attr('IS_SEARCH_ATTR'), false);
  return knownSearchAttributes.includes(searchAttr);
}
function _onSearchError(err, context = 'Encrypted Search') {
  AnalyticsService.clientError({
    name: Object.hasOwn(err, 'name') ? err.name : 'Search Error',
    context,
    error_obj: sanitizeAnalyticsError(err)
  });
}
function handleSearch(secureService, searchBar, settings, req, body) {
  // If we are truly a search XHR, let's fail hard from here on out
  try {
    var _settings$user3, _settings$user3$permi;
    const searchKey = (settings === null || settings === void 0 ? void 0 : (_settings$user3 = settings.user) === null || _settings$user3 === void 0 ? void 0 : (_settings$user3$permi = _settings$user3.permissions) === null || _settings$user3$permi === void 0 ? void 0 : _settings$user3$permi.canSearchEncryptedEmails) && settings.user.setting('searchKey');

    // In material design, search queries live in the POST body
    let postBody;
    try {
      postBody = JSON.parse(body);
    } catch (e) {
      postBody = null;
    }

    // XHR for search is very simlar to the request fired if the user clicks on "drafts", or "starred", etc...
    if (!postBody || !_isSearch(postBody)) {
      return Promise.resolve(body);
    }
    const attr = getAttributes(postBody);
    const simpleSearchQuery = get(postBody, attr('SIMPLE_QUERY_ATTR'), false);
    const advSearchParams = get(postBody, attr('ADV_SEARCH_ATTR'), false);

    // Simple Search
    if (simpleSearchQuery && !advSearchParams) {
      const queryArray = encryptedSearch.createWordArray(simpleSearchQuery, SEARCH_OPTS);
      const simpleSearchPromise = secureService.buildSearchTokenQuery(queryArray, searchKey).then(encryptedSearchQuery => {
        set(postBody, attr('SIMPLE_QUERY_ATTR'), encryptedSearchQuery);
        return [JSON.stringify(postBody)];
      });
      return Promise.race([simpleSearchPromise, encryptedSearchTimeout()]).catch(err => {
        console.error(err);
        _onSearchError(err, 'Encrypted search timeout');

        // Check chrome.storage to indicate problems with the extension
        // If we are disconnected from background script, store this error in localStorage
        // and emit the error the next time extension runs
        if (chrome.storage === undefined) {
          localStorage.setItem('previousVirtruError', JSON.stringify(err));
        }
        return [JSON.stringify(postBody)];
      });
    }

    // Advanced Search
    if (advSearchParams) {
      const searchQuery = get(postBody, attr('ADV_QUERY_ATTR'), '');
      const exclusionQuery = get(postBody, attr('ADV_EXCL_ATTR'), '');
      const queryArray = encryptedSearch.createWordArray(searchQuery, SEARCH_OPTS);
      const exclArray = encryptedSearch.createWordArray(exclusionQuery, SEARCH_OPTS);

      // Gmail takes the contents of the encrypted search request and places in into the
      // search bar so we need to set the search bar contents immediately after the
      // request completes to prevent the user from seeing search tokens.
      var proxiedOnready = req.onreadystatechange;
      req.onreadystatechange = function () {
        // Allow the gmail function to continue as expected
        proxiedOnready();
        setTimeout(() => {
          // And then undo the change the previous function made to the search query input
          let originalQuery = searchQuery.slice();
          if (exclusionQuery.length) {
            originalQuery += ` -{${exclusionQuery}}`;
          }

          // Reset the search bar
          searchBar.val(originalQuery);
        }, 1);
      };
      const generateTokens = [secureService.buildSearchTokenQuery(queryArray, searchKey), secureService.buildSearchTokenQuery(exclArray, searchKey)];
      const advancedSearchPromise = Promise.all(generateTokens).then(queries => {
        set(postBody, attr('ADV_QUERY_ATTR'), queries[0]);
        set(postBody, attr('ADV_EXCL_ATTR'), queries[1]);
        console.log('advanced search done');
        return [JSON.stringify(postBody)];
      });
      return Promise.race([advancedSearchPromise, encryptedSearchTimeout()]).catch(err => {
        console.error(err);
        _onSearchError(err, 'Encrypted Search advanced');
        return [JSON.stringify(postBody)];
      });
    }
  } catch (err) {
    console.error(err);
    _onSearchError(err, 'Encrypted Search general');
    return Promise.reject(err);
  }
}
module.exports = {
  initSearchXhr,
  handleSearch
};

/***/ }),

/***/ 82603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dict = __webpack_require__(96663);
module.exports = dict;

/***/ }),

/***/ 82878:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(42804);
/* harmony import */ var _attachments_reducer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51041);
/* harmony import */ var _attachments_reducer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_attachments_reducer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _messages_reducer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(22885);



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,redux__WEBPACK_IMPORTED_MODULE_2__.combineReducers)({
  attachments: (_attachments_reducer__WEBPACK_IMPORTED_MODULE_0___default()),
  secureMessages: _messages_reducer__WEBPACK_IMPORTED_MODULE_1__/* .reducer */ .Ff
}));

/***/ }),

/***/ 82890:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NestedMessagePlaceholder: () => (/* binding */ NestedMessagePlaceholder)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(87568);
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(64078);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_2__);




/**
 * @deprecated Use the `NestedMessagePlaceholder.render` method to render the component
 * @remarks Exported for testing purposes only
 */
function NestedMessagePlaceholder() {
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-nested-secure-message-icon"
  }), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-nested-secure-message-text-default"
  }, _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('NESTED_MESSAGE_PLACEHOLDER_TEXT_DEFAULT')), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-nested-secure-message-text-loading"
  }, _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('NESTED_MESSAGE_PLACEHOLDER_TEXT_LOADING')), /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement("div", {
    className: "virtru-nested-secure-message-arrow"
  }));
}

/**
 *
 * @param {HTMLElement} elementToReplace HTML DOM element to replace with React component
 * @param {{ messageId: string }} props - props used to render the component
 * @param props.messageId - string id of the message
 *
 * @todo Remove this method once jQuery and React are no longer used together
 */
NestedMessagePlaceholder.render = function (elementToReplace, props) {
  // create component container
  const container = document.createElement('div');
  container.className = 'virtru-nested-secure-message-default';
  container.setAttribute('data-message-id', props.messageId);

  // replace the existing DOM element with the container
  elementToReplace.replaceWith(container);

  // render component
  const root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_1__/* .createRoot */ .H)(container);
  root.render(/*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(NestedMessagePlaceholder, null));
};

/***/ }),

/***/ 83681:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(57128);
/* harmony import */ var _base_modal_page__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(86345);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5749);
/* harmony import */ var _templates__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_templates__WEBPACK_IMPORTED_MODULE_3__);
/**
 * @module lib/sites/limited-encryption-warning
 * Provides limited encryption warning modal object (extended watermarking).
 */




class LimitedEncryptionWarning extends _base_modal_page__WEBPACK_IMPORTED_MODULE_2__.BaseModalPage {
  /**
   * Constructor
   *
   * @param {Object} options - Modal options
   * @param {Array} options.filesList
   * @param {Object} options.onContinueClick
   */
  constructor(options) {
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsObject(options, 'Must provide options.');
    super(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(_templates__WEBPACK_IMPORTED_MODULE_3___default().limitedEncryptionPopover()), options);
  }
  closeDialog() {
    this.modal.close();
  }
  updateDialog(options) {
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsObject(options, 'Must provide options.');
    _virtru_private_node_precond__WEBPACK_IMPORTED_MODULE_1__.checkIsArray(options.filesList, 'Must provide files list.');

    // Get elements
    const backdrop = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()('#virtru-modal-backdrop');
    const listContainer = this.element.find('.popup-files-list');
    const list = this.element.find('.popup-files-list ul');
    const checkbox = this.element.find('.popup-checkbox');
    const checkboxInput = this.element.find('.popup-checkbox input');
    const ok = this.element.find('.popup-button.ok');
    const cancel = this.element.find('.popup-button.cancel');

    // Set up files list
    list.html(options.filesList.map(file => `<li>${file.name}</li>`));

    // Override styles
    backdrop.attr('class', 'modal-overlay-light');
    if (listContainer.height() < list.height()) {
      listContainer.addClass('scrollable-block');
    }

    // Set up events
    ok.on('click', () => {
      options.emitResult(true);
      this.closeDialog();
    });
    cancel.on('click', () => {
      options.emitResult(false);
      this.closeDialog();
    });
    checkbox.on('change', () => {
      localStorage.setItem('skipLimitedEncryptionWarning', checkboxInput.prop('checked'));
    });
  }

  /**
   * Defines the base action for the modal page
   * @param {Object} dialog - the 'simplemodal.js' dialog object
   * @param {Object} modal - the modal-window, as in: 'const modal = element.modal();'
   */
  defineActions(dialog, modal) {
    this.modal = modal;
    this.element.addClass('fade-in');
    this.updateDialog(this.options);
  }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LimitedEncryptionWarning);

/***/ }),

/***/ 83804:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emailTemplateReceiver: () => (/* binding */ emailTemplateReceiver)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const emailTemplateReceiver = () => `
  <div>
    <div class="virtru-email-template-receiver-notification-bar"></div>

    <div class="virtru-email-template-receiver-header">
      <div class="virtru-email-template-receiver-header-message">&nbsp;</div>
      <div class="virtru-email-template-receiver-icon virtru-forwarding-icon">&nbsp;</div>
      <div class="virtru-email-template-receiver-icon virtru-sms-icon">&nbsp;</div>
      <div class="virtru-email-template-receiver-icon virtru-expiration-icon">&nbsp;</div>
      <div class="virtru-cks-indicator-container"></div>
      <div>
        <div class="virtru-email-template-receiver-header-expiration-date"></div>
        <div class="virtru-email-template-receiver-info-icon">&nbsp;</div>
      </div>
    </div>

    <div class="virtru-email-template-receiver-body-enabled"></div>
    <div class="virtru-email-template-receiver-body-revoked">
      <div class="virtru-email-template-receiver-body-revoked-icon">
        <div class="virtru-email-template-receiver-body-revoked-text">&nbsp;</div>
      </div>
    </div>

    <a class="virtru-email-template-receiver-footer" href="http://www.virtru.com" target="_blank">
      <div class="virtru-email-template-receiver-footer-inner-div">
        <span class="virtru-email-template-receiver-footer-span">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('EMAIL_TEMPLATE_FOOTER')}</span>
      </div>
    </a>
  </div>
`;

/***/ }),

/***/ 83956:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   emailTemplateSender: () => (/* binding */ emailTemplateSender)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const emailTemplateSender = () => `
  <div>
    <button class="virtru-sender-button"></button>
    <div class="virtru-sender-menu-container"></div>

    <div class="virtru-sender-header">
      <div class="virtru-sender-header-message">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('EMAIL_TEMPLATE_SENDER_HEADER')}</div>
      <div class="virtru-cks-indicator-container"></div>
      <div class="virtru-sender-header-expiration-date">&nbsp;</div>
    </div>

    <div class="virtru-sender-body"></div>

    <a class="virtru-sender-footer" href="http://www.virtru.com" target="_blank">
      <div class="virtru-sender-footer-inner-div">
        <span class="virtru-sender-footer-span">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('EMAIL_TEMPLATE_FOOTER')}</span>
      </div>
    </a>
  </div>
`;

/***/ }),

/***/ 84712:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ConnectivityState)
/* harmony export */ });
class ConnectivityState {
  constructor(window) {
    this._window = window;
    this._isOnline = this._window.navigator.onLine;
    this._onlineCallbacks = new Set();
    this._offlineCallbacks = new Set();
    this._boundOnlineListener = this._onlineListener.bind(this);
    this._boundOfflineListener = this._offlineListener.bind(this);
    this._init();
  }
  isOnline() {
    return this._isOnline;
  }
  isOffline() {
    return !this._isOnline;
  }
  _init() {
    this._window.addEventListener('online', this._boundOnlineListener);
    this._window.addEventListener('offline', this._boundOfflineListener);
  }
  teardown() {
    this._window.removeEventListener('online', this._boundOnlineListener);
    this._window.removeEventListener('offline', this._boundOfflineListener);
    this._onlineCallbacks.clear();
    this._offlineCallbacks.clear();
  }
  _onlineListener(event) {
    this._isOnline = true;
    this._onlineCallbacks.forEach(callback => callback(event));
  }
  _offlineListener(event) {
    this._isOnline = false;
    this._offlineCallbacks.forEach(callback => callback(event));
  }
  whenOnline(callback) {
    this._onlineCallbacks.add(callback);
  }
  whenOffline(callback) {
    this._offlineCallbacks.add(callback);
  }
  onChange(callback) {
    this.whenOnline(callback);
    this.whenOffline(callback);
  }
  dropOnlineListener(callback) {
    this._onlineCallbacks.delete(callback);
  }
  dropOfflineListener(callback) {
    this._offlineCallbacks.delete(callback);
  }
  dropChangeListener(callback) {
    this.dropOnlineListener(callback);
    this.dropOfflineListener(callback);
  }
}

/***/ }),

/***/ 85149:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ TooltipHelper)
/* harmony export */ });
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(55401);
/* harmony import */ var _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13985);
/* harmony import */ var moment__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _compatibility_virtru_popover__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55929);
/* harmony import */ var _compatibility_virtru_popover__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_compatibility_virtru_popover__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lib_utils_virtru_offline_mode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(2883);
/* harmony import */ var _compatibility_helpers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(4424);






class TooltipHelper {
  static createPopover({
    $icon,
    content,
    title,
    position = 'north',
    delay = 1000,
    classname = 'virtru-popover-dark'
  }) {
    const popover = new (_compatibility_virtru_popover__WEBPACK_IMPORTED_MODULE_3___default())(content, title, {
      pad: 0
    });
    popover.classname += ` ${classname}`;
    popover.position(position);
    popover.setShowTimer(delay);
    popover.attach($icon);
    return popover;
  }
  constructor({
    $element,
    settings,
    stateManager
  }) {
    this._element = $element;
    /* TODO: should moved somewhere */
    this._settings = settings;
    this._getUserSetting = this._settings.user.setting.bind(this._settings.user);
    this._expirationPopover = null;
    this._togglePopover = null;
    this._activatePopover = null;
    this._sendButtonPopover = null;
    this._toggle = null;
    this._stateManager = stateManager;
    this.unsubscribeCreatePopover = this._stateManager.createPopover().requestSub(TooltipHelper.createPopover);
    this._virtruOfflineMode = new _lib_utils_virtru_offline_mode__WEBPACK_IMPORTED_MODULE_4__/* ["default"] */ .A(this._settings.user._profile);
    (0,_compatibility_helpers__WEBPACK_IMPORTED_MODULE_5__._bindAllMethods)(this);
  }
  isSecureMode() {
    return this._stateManager.isSecureMode().requestOnce();
  }
  setToggleElement(toggle) {
    this._toggle = toggle;
  }
  onExpirationDateChanged(expirationDate, expires) {
    const element = this._element;
    const $icon = _compatibility_jquery_pack__WEBPACK_IMPORTED_MODULE_0___default()(element.find('.virtru-expiration-icon')[0]);
    if (expires) {
      const position = 'southwest';
      const popoverTitle = '';
      const popoverContent = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_EXPIRES', {
        date: moment__WEBPACK_IMPORTED_MODULE_1___default()(expirationDate).calendar()
      });
      if (this._expirationPopover) {
        this._expirationPopover.title(popoverTitle);
        this._expirationPopover.content(popoverContent);
        if (this._expirationPopover.el.parent().length) {
          this._expirationPopover.reposition();
        }
      } else {
        this._expirationPopover = TooltipHelper.createPopover({
          $icon,
          content: popoverContent,
          title: popoverTitle,
          position
        });
      }
    }
    $icon.css('display', expires ? 'inline-block' : 'none');
    this._stateManager.toggleIconPadding().request();
  }
  updateActivateTooltip() {
    if (!this._activatePopover) {
      this._activatePopover = TooltipHelper.createPopover({
        $icon: this._element.find('.virtru-auth-link'),
        content: _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_TOGGLE_OFF_OFFLINE'),
        position: 'northeast',
        delay: null
      });
    }
    if (this._virtruOfflineMode.isOffline()) {
      this._activatePopover.enable();
    } else {
      this._activatePopover.disable().hide();
    }
  }
  updateToggleTooltip() {
    const isSecureMode = this.isSecureMode();
    const isOffline = this._virtruOfflineMode.isOffline();
    const isOrgOverridden = !this._getUserSetting('orgSettings.defaultVirtruStateOverride') && this._getUserSetting('orgSettings.defaultVirtruState') === 'on' && this._toggle && !this._toggle.isTouched();
    const canToggle = this._getUserSetting('permissions.canCreatePolicies');
    let tooltipContent = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_TOGGLE_DISABLED');
    if (isSecureMode) {
      tooltipContent = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_TOGGLE_ON', {
        context: isOrgOverridden ? 'ORG' : ''
      });
    } else if (canToggle) {
      tooltipContent = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_TOGGLE_OFF', {
        context: isOffline ? 'OFFLINE' : ''
      });
    }
    let tooltipPosition = 'south';
    if (isOrgOverridden) {
      tooltipPosition = 'southeast';
    } else if (isOffline) {
      tooltipPosition = 'north';
    }
    if (this._togglePopover) {
      this._togglePopover.content(tooltipContent);
    } else {
      this._togglePopover = TooltipHelper.createPopover({
        $icon: this._element.find('.virtru-toggle').first(),
        content: tooltipContent,
        position: tooltipPosition,
        delay: null
      });
    }
    if (this._togglePopover.el.parent().length) {
      this._togglePopover.reposition();
    }
  }
  generateForwardingTooltip() {
    const $icon = this._element.find('.virtru-forwarding-icon');
    const content = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_DISABLE_FORWARDING');
    const title = '';
    const position = 'southwest';
    TooltipHelper.createPopover({
      $icon,
      content,
      title,
      position
    });
  }
  generateNoAuthTooltip() {
    const $icon = this._element.find('.virtru-noauth-icon');
    const content = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_ONE_CLICK');
    const title = '';
    const position = 'southwest';
    TooltipHelper.createPopover({
      $icon,
      content,
      title,
      position
    });
  }
  generateForwardWarningTooltip() {
    const $icon = this._element.find('.virtru-forward-warning-icon');
    const content = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_FORWARDING_RESTRICTED_CONTENT');
    const title = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_FORWARDING_RESTRICTED');
    TooltipHelper.createPopover({
      $icon,
      content,
      title
    });
  }
  generateWatermarkingTooltip() {
    const $icon = this._element.find('.virtru-watermark-icon');
    const content = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_SENDER_WATERMARK');
    const title = '';
    const position = 'southwest';
    TooltipHelper.createPopover({
      $icon,
      content,
      title,
      position
    });
  }
  generatePersistentProtectionTooltip() {
    const $icon = this._element.find('.virtru-pfp-icon');
    const content = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('TOOLTIP_SENDER_PFP');
    const title = '';
    const position = 'southwest';
    TooltipHelper.createPopover({
      $icon,
      content,
      title,
      position
    });
  }
  generateMailMergeTooltip() {
    const $icon = this._element.find('.virtru-mail-merge-disabled');
    const content = _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('MAIL_MERGE_CONFLICT_TOOLTIP');
    const title = '';
    const position = 'south';
    TooltipHelper.createPopover({
      $icon,
      content,
      title,
      position
    });
  }
  teardown() {
    this.unsubscribeCreatePopover();
    this._virtruOfflineMode.teardown();
    this._toggle = null;
  }
}

/***/ }),

/***/ 85392:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"ACTIVATION_BUTTON_ACTIVATE":"Aktivera {{currentUser}}","ACTIVATION_BUTTON_REACTIVATE":"teraktivera {{currentUser}}","ACTIVATION_FAILED":"Aktivering misslyckades","ACTIVATION_FAILED_GENERAL_BODY":"Vi kunde inte aktivera Virtru-skydd. Vnta ett gonblick och frsk igen eller kontakta din administratr.","ACTIVATION_HEADER_USER_NOT_ACTIVATED":"{{currentUser}} r inte aktiverad fr att anvnda Virtru","ACTIVATION_LINK":"S hr fungerar det","ACTIVATION_MESSAGE_DELEGATION_LINK":"Aktivera","ACTIVATION_SUBTEXT":"Fr att skydda din integritet behver vi regelbundet verifiera din identitet. Det tar endast en minut och du behver bara klicka fr att teraktivera.","ACTIVATION_TEXT_ACTIVATE":"AKTIVERA VIRTRU FR ATT<br>SKRIVA SKRA E-POST","ACTIVATION_TEXT_REACTIVATE":"TERAKTIVERA VIRTRU FR ATT FORTSTTA","ACTIVATION_WAIT_CANCELED":"Virtru kunde inte autentisera ditt e-postkonto eftersom autentiseringsfliken var stngd.<br/><br/>Klicka p lnken \\"Frsk igen\\" nedan fr att starta om processen","ACTIVATION_WAIT_ERROR":"Virtru  Kunde inte autentisera","ACTIVATION_WAIT_FAILED":"Virtru kunde inte autentisera ditt e-postkonto eftersom dina aktuella webblsarinstllningar inte tillter att cookies skapas eller fr att du nekade Virtru till att verifiera din e-postadress.</br><br/>Autentiseringsprocessen krver cookies. Om du har ndrat din webblsares standardinstllningar fr cookies, konfigurera din webblsare s att den tillter alla cookies och klicka sedan p knappen \\"Frsk igen\\". Nr ditt konto har autentiserats kan du teraktivera begrnsningarna fr cookies och fortstta anvnda Virtru.</br><br/>Virtru begr behrigheten \\"Se din e-postadress\\" frn din webbpostleverantr fr att verifiera att du ger det konto som du aktiverar. Fr mer information om hur vi anvnder din e-postadress, se vra <a href=\\"https://www.virtru.com/terms-of-service\\" target=\\"_blank\\">Anvndningsvillkor<a/> och <a href=\\"https://www.virtru.com/privacy-policy\\" target=\\"_blank\\">Integritetspolicy</a>. Klicka p knappen \\"Frsk igen\\" fr att bevilja denna behrighet.","ACTIVATION_WAIT_HEADER":"Virtru  Autentiserar...","ACTIVATION_WAIT_IN_PRIVATE":"Virtru kunde inte autentisera ditt e-postkonto eftersom din webblsare r i privat lge, som ven kallas \\"inkognito\\"- eller \\"InPrivate\\"-lge. Autentiseringsprocessen krver cookies, vilka r begrnsade i privat lge.</br><br/>Om du vill fortstta ska du inaktivera det privata lget och terg till ditt fnster eller din flik till webbposten fr att starta om autentiseringsprocessen.</br><br/>Nr ditt konto har autentiserats kan du teraktivera privat lge och fortstta anvnda Virtru.","ACTIVATION_WAIT_MESSAGE":"Virtru autentiserar fortfarande ditt e-postkonto i denna webblsare. Du kan inte skicka eller lsa skra meddelanden innan du har slutfrt autentiseringen.","ANIMATION_WIDGET_LOADING_TEXT":"Dekrypterar e-post...","ATTACHMENTS_UPLOADING_NO_SEND":"Uppladdningen av bilagor mste slutfras innan du kan skicka.","ATTACHMENT_APPID_ERROR_HEADER":"Aktivering har gtt ut","ATTACHMENT_APPID_ERROR_TEXT":"Dina bilagor kan inte laddas upp eftersom din aktivering har gtt ut. Vnligen teraktivera och frsk igen.","ATTACHMENT_CONNECTION_ERROR_HEADER":"Ntverksfel","ATTACHMENT_CONNECTION_ERROR_TEXT":"Det uppstod ett problem nr dina bilagor laddades upp. Kontrollera din anslutning och frsk igen.","ATTACHMENT_CONTENT":"Innehll i bilaga","ATTACHMENT_ERROR_CORRUPT":"Bilagan r korrupt och kan inte dekrypteras. Be avsndaren att skicka bilagan p nytt.","ATTACHMENT_ERROR_UNAUTHORIZED":"Du r inte auktoriserad till att ha tkomst till denna fil.","ATTACHMENT_ERROR_UNKNOWN":"Ett fel har intrffat och Virtru kan inte ladda ner eller dekryptera denna fil. Frsk igen senare.","ATTACHMENT_GENERIC_ERROR_BUTTON":"Avvisa","ATTACHMENT_GENERIC_ERROR_HEADER":"Fel i bilagor","ATTACHMENT_GENERIC_ERROR_TEXT":"Det uppstod ett problem nr dina bilagor laddades upp. Kontrollera dina filer, din webblsare och ditt insticksprogram innan du frsker igen.","ATTACHMENT_INTEGRITY_COMPROMISED":"Virtru kan inte dekryptera denna bilaga. Denna situation uppstr vanligtvis nr chiffertexten i ett meddelande har ndrats, vilket gr krypteringen olsbar.","ATTACHMENT_ERROR_CLOSE_BUTTON":"Stng","ATTACHMENT_NOT_READY_ERROR":"Bilaga r inte redo","ATTACHMENT_OPTIONS":"Alternativ fr bilaga","ATTACHMENT_PFP_ERROR_HEADER":"Fel i bilagor","ATTACHMENT_REVOKED_HEADER":"tkomst terkallades","ATTACHMENT_REVOKED_TEXT":"Du har inte lngre behrighet att se denna fil","ATTACHMENT_TOO_LARGE_HEADER":"Bilaga r fr stor","ATTACHMENT_TOO_LARGE_TEXT":"En eller flera av dina bilagor var fr stora fr att kunna krypteras. Bifoga filer som r mindre n {{maxSizeMb}} MB.","ATTACHMENT_TOO_LARGE_SUGGEST_SECURE_SHARE_TEXT":"En eller flera av dina bilagor verskrider storleksgrnsen fr e-postkryptering. Bifoga filer under {{maxSizeMb}} MB eller anvnd Virtru Secure Share fr att skicka filer upp till {{secureShareMaxSize}} GB till dina mottagare p ett skert stt.","CANNOT_DECRYPT_GET_HELP":"Ls mer om detta i Virtrus FoS.","CANNOT_DECRYPT_HEADER":"Mjligen ndrat meddelande","CANNOT_DECRYPT_MESSAGE_CKS":"Krypteringsservern {{ownerName}} gr inte att n.<br/>Fr hjlp, <a href=\\"{{ownerSupportUrl}}\\">kontakta<br/>{{ownerName}} supportdesk</a>.","CANNOT_DECRYPT_MESSAGE_CKS_TROUBLE_READING_EMAIL":"Vi har problem med att lsa ditt e-postmeddelande. Frsk igen senare!","CANNOT_DECRYPT_MESSAGE_INTEGRITY_COMPROMISED":"Virtru har upptckt att detta meddelande kan ha manipulerats. Frsk att be <span class=\\"vic-message-bold\\">{{sender}}</span> skicka meddelandet p nytt.","CHROME_POPUP_ABOUT_VIRTRU_BUTTON":"Om Virtru","CHROME_POPUP_ACTIVATION_BUTTON":"Aktivera Virtru fr {{userId}}","CHROME_POPUP_ACTIVATION_LABEL":"Virtru e-postskydd","CHROME_POPUP_SIGN_OUT_BUTTON":"Logga ut","CHROME_POPUP_VIRTRU_CONTROL_CENTER_BUTTON":"Kontrollcenter","CHROME_POPUP_SUPPORT_BUTTON":"Support","CHROME_POPUP_UNINSTALL_BUTTON":"Avinstallera","CHROME_POPUP_DRIVE_CROSS_SELL":"Skaffa Virtru fr Drive","CHROME_POPUP_SECURE_SHARE_CROSS_SELL":"Skaffa Virtru Secure Share fr Drive","COMMON_RETRY_SECURE_SEND":"Prova sker sndning p nytt","COMMON_CANCEL":"Avbryt","COMMON_CLOSE":"Stng","COMMON_OK":"OK","COMMON_SEND":"Skicka","COMMON_SEND_SECURE":"Sker sndning","COMMON_SEND_SECURE_TOOLTIP_OFFLINE":"Skyddat meddelande kan inte skickas eftersom Virtru r offline","COMMON_TRY_AGAIN":"Frsk igen","COMMON_REFRESH":"Uppdatera","COMMON_REFRESH_PAGE":"Uppdatera sida","COMPOSE_ACTIVATION_REQUIRED":"Virtru krver aktivering","COMPOSE_ATTACHMENTS_UPLOADING_WARN":"Skert lge kan inte ndras nr bilagor laddas upp. Vnta tills uppladdningen av bilagorna r klar och vxla sedan till skert lge.","COMPOSE_DRIVE_ATTACHMENTS_UNSUPPORTED":"Virtru har fr nrvarande inte std fr bilagor i Drive. Vill du ta bort dem?","COMPOSE_EXPIRES":"Gr ut {{timeRemaining}}","COMPOSE_INSERT_DRIVE_INSERT_FILE":"Infogning av filer frn Google Drive stds inte i skert lge.","COMPOSE_INSERT_PHOTOS_INLINE_IMAGES":"Fr nrvarande stder inte Virtru infogade bilder.","COMPOSE_OFF_CONFIRM_REMOVE":"Alla skra bilagor tas bort om skert lge stngs av. r du sker p att du vill gra detta?","CONTENT_IS_MANAGED":"Avsndaren har inaktiverat nedladdning av denna fil.","CONTEXTUAL_ACTIVATE_INFO":"Kontot {{currentUser}} har inte aktiverats med Virtru. Din identitet verifieras nr den har aktiverats och Virtru skickar nycklarna till dig s att du kan dekryptera dina skra meddelanden. Virtru har aldrig tkomst till ngot av ditt innehll.","DISMISS_POPOVER_DEFAULT_OPTIONS_TEXT":"Ok, jag frstr.","DOWNLOAD_ATTACHMENT_DECRYPTING":"Dekrypterar","EMAIL_BODY_CONTENT":"Innehll i e-postens brdtext","EMAIL_ERROR_EMAIL_CORRUPT":"Meddelandet r korrupt och kan inte dekrypteras. Be avsndaren att skicka meddelandet p nytt.","EMAIL_ERROR_EMAIL_CORRUPT_HEADER":"Korrupt e-post","EMAIL_ERROR_INTERNAL_SERVER_ERROR":"Virtrus servrar svarade inte. Vnta ngra minuter och frsk igen.","EMAIL_ERROR_INTERNAL_SERVER_ERROR_HEADER":"Serverfel","EMAIL_ERROR_NETWORK_LOST":"Virtru kunde inte ansluta till internet. Kontrollera din internetanslutning och frsk igen.","EMAIL_ERROR_NETWORK_LOST_HEADER":"Fel p ntverksanslutning","EMAIL_ERROR_READ":"Meddelandet kunde inte dekrypteras. Kontrollera din internetanslutning och frsk igen.","EMAIL_ERROR_SEND":"Ett fel intrffade och meddelandet kunde inte skickas. Kontrollera din internetanslutning och frsk igen.","EMAIL_ERROR_SMART_SEND_SECURE":"Ett fel intrffade nr du frskte skicka ditt meddelande. Kontakta Virtru om problemet kvarstr.","EMAIL_ERROR_SMART_SEND_SECURE_HEADER":"Fel vid sndning","EMAIL_ERROR_TEMPLATE_SUPPORT_LINK":"Virtru Support","EMAIL_ERROR_UNKNOWN":"Virtru har sttt p ett fel och kan inte skicka detta meddelande. Uppdatera denna sida och frsk igen.","EMAIL_ERROR_UNKNOWN_HEADER":"Oknt fel","EMAIL_ERROR_YOURE_ON_STAGING":"Hll dina hstar  Det ser ut som om du frsker gra en luring och lsa ett e-postmeddelande frn fel server (iscensttning/produktion). Kontrollera alternativsidan fr att se vilken server du lnkar till  du kanske bara lnkar till fel server.","EMAIL_ERROR_YOURE_ON_STAGING_HEADER":"Hll dina hstar Det ser ut som om du frsker gra en luring och lsa ett e-postmeddelande frn ","EMAIL_ERROR_SEND_UNKNOWN":"Virtru har sttt p ett fel och kan inte skicka detta meddelande. Klicka p knappen nedan fr att skicka igen.","EMAIL_ERROR_SEND_UNKNOWN_HEADER":"Oknt fel","EMAIL_ERROR_SEND_REACTIVATION":"Aktiveringen har lpt ut, vnligen aktivera om fr att skicka ditt meddelande.","EMAIL_ERROR_SEND_REACTIVATION_HEADER":"Fel vid sndning","EMAIL_ERROR_SEND_REACTIVATION_RETRY_BUTTON":"teraktivera och skicka","EMAIL_ERROR_READ_SECURE_READER_LABEL":"Klicka hr fr att se meddelandet i Virtrus Secure Reader","EMAIL_EXPIRATION":"Utgngsdatum","EMAIL_INVALID_ADDRESS":"Adressen \\"{{invalidAddress}}\\" kndes inte igen. Se till att alla adresser r korrekt utformade.","EMAIL_INVALID_ADDRESS_GENERIC":"En eller flera e-postadresser kndes inte igen. Se till att alla adresser r korrekt utformade.","EMAIL_TEMPLATE_FOOTER":"Skrad av Virtru","EMAIL_TEMPLATE_SENDER_HEADER":"Ditt meddelande som skyddas av Virtru","ENCRYPTED_SEARCH_REMINDER_HEADER":"Krypterad skning visas inte i dina skresultat.","ENCRYPTED_SEARCH_REMINDER_SUBTEXT":"Skning av Virtru-krypterade meddelandekroppar r fr nrvarande inte aktiverad. Klicka hr fr att lra dig hur du aktiverar krypterad skning.","ENHANCEDPDF_DL_DISABLED_TOOLTIP":"Avsndaren har inaktiverat nedladdning av denna fil. Klicka nedan fr att se den i Virtrus Secure Reader.","ENHANCEDPDF_DL_DISABLED_TOOLTIP_TITLE":"Frbttrat PDF-skydd","EXPANDED_WATERMARKING_DL_DISABLED_TOOLTIP_TITLE":"Frbttrat skydd","FAQ":"FoS","FEATURE_CHIP_TEXT":"By funktion","FEATURE_ENCRYPTED_SEARCH_FAQ":"Ls mer i vra FoS","FEATURE_ENCRYPTED_SEARCH_POPUP_DESCRIPTION":"Fr att aktivera skning av dina Virtru-krypterade e-postmeddelanden klickar du nedan fr att g till fliken \\"Funktioner\\" i Virtru kontrollcenter.","FEATURE_ENCRYPTED_SEARCH_BUTTON":"G till kontrollcenter","FEATURE_ENCRYPTED_SEARCH_CANCEL":"Senare","FEATURE_ENCRYPTED_SEARCH_DESCRIPTION":["I Kontrollcenter, g till fliken Funktioner och aktivera skning.","Eller g till vr FoS fr att lra dig mer."],"FEATURE_ENCRYPTED_SEARCH_TITLE_TEXT":"Sk efter dina krypterade e-postmeddelanden","FEATURE_ENCRYPTED_SEARCH_SUB_TITLE_TEXT":"Aktivera skning efter dina Virtru-krypterade e-postmeddelanden","FEATURE_VAULT_BUTTON":"Kom igng","FEATURE_VAULT_CANCEL":"Nej tack","FEATURE_VAULT_DESCRIPTION":["Sk, krypterade e-postmeddelanden och dekryptera dem direkt","Upprtthll knslighet med Virtru-kryptering","Ltt att upptcka av auktoriserade parter","Integrerad i ditt befintliga Google-grnssnitt","Kontakta en Virtru-representant fr mer information."],"FEATURE_VAULT_TITLE_TEXT":"Sk efter Virtru-e-post i Google Vault","FEATURE_VAULT_SUB_TITLE_TEXT":"Lgg till Google Vault-paketet till din Virtru end-to-end-kryptering","FILE_SIZES":{"BYTES":"b","UNITS":["Kb","Mb","Gb","Tb","Pb","Eb","Zb","Yb"]},"DELIMITERS":{"DECIMAL":"."},"FIRST_TIME_ONBOARD_LINK_ACTIVATE":"Aktivera","FOOTER_POPOVER_BODY":"Bertta fr dina vnner och kollegor att de kan skicka e-post till dig p ett skert stt med Virtru.","FOOTER_POPOVER_HEADER":"Kommunicera privat","FOOTER_POPOVER_REMOVE_SIGNATURE":" Ta bort frn min e-postsignatur ","FOOTER_PROMO":"Behver du skicka privat e-postmeddelande till mig? Jag anvnder","FOOTER_PROMO_USE":"Virtru","FORWARDING_RESTRICTED":" Begrnsad vidarebefordring","GMAIL_BASIC_MODE_UNSUPPORTED_MAIN":"Gmails grundlggande HTML-visning stds inte","GMAIL_BASIC_MODE_UNSUPPORTED_SUB":"Vxla till standardvisningen fr att anvnda Virtru.","GO_TO_SECURE_SHARE":"g till Secure Share","INTRO_MESSAGE_FOOTER_TEXT":"Text ovanfr denna rad krypteras inte.","INVITATION_EMAIL_REPLACE_TEXT_DEFAULT":"Detta r en sker meddelandekedja som skyddas av Virtru.","LEARN_MORE":"Ls mer","LIMITED_ENCRYPTION_BUTTON_CANCEL":"Avbryt","LIMITED_ENCRYPTION_BUTTON_OK":"Fortstt","LIMITED_ENCRYPTION_CHECKBOX":"Visa inte igen","LIMITED_ENCRYPTION_HEADER":"Begrnsat skydd","LIMITED_ENCRYPTION_TEXT":"Ytterligare skerhetsfunktioner som bestndigt skydd och vattenmrkning tillmpas inte p fljande bilagor eftersom filtyperna antingen inte stds eller har skerhetsinstllningar som hanteras separat frn detta meddelande:","MESSAGE_OPTIONS":"Meddelandealternativ","MOMENT_CALENDAR_POLICY_CONFIG_FULL_DATE":{"lastDay":"[igr kl.] LT","lastWeek":"[senast] dddd [kl.] LT","nextDay":"[imorgon kl.] LT","nextWeek":"dddd [kl.] LT","sameDay":"[idag kl.] LT","sameElse":"dddd[,] MMM Do[,] YYYY [kl.] LT"},"MOMENT_CALENDAR_RECIPIENT_EXPIRATION":{"lastDay":"[kl.] LT [igr]","lastWeek":"[kl.] LT [senast] dddd","nextDay":"[kl.] LT [imorgon]","nextWeek":"[kl.] LT [p] dddd","sameDay":"[kl.] LT [idag]","sameElse":"[kl.] LT [den] dddd[,] MMM Do[,] YYYY"},"MOMENT_CALENDAR_SENDER_EXPIRED":{"lastDay":"[igr kl.] LT","lastWeek":"[senast] dddd [kl.] LT","nextDay":"[imorgon kl.] LT","nextWeek":"[p] dddd [kl.] LT","sameDay":"[idag kl.] LT","sameElse":"[den] dddd[,] MMM Do[,] YYYY [kl.] LT"},"MOMENT_CALENDAR_SENDER_EXPIRING_SOON":{"lastDay":"LT [igr]","lastWeek":"LT [senast] dddd","nextDay":"LT [imorgon]","nextWeek":"LT [p] dddd","sameDay":"LT [idag]","sameElse":"LT [den] dddd[,] MMM Do[,] YYYY"},"NESTED_MESSAGE_PLACEHOLDER_TEXT_DEFAULT":"Visa senaste skra meddelande","NESTED_MESSAGE_PLACEHOLDER_TEXT_LOADING":"Laddar skert meddelande...","NEW_COMPOSE_ARCHIVE_SEND":"Skicka +","NEW_COMPOSE_ARCHIVE_SEND_SECURE":"Sker sndning +","NEW_COMPOSE_DISABLED_WHILE_SECURING":"Inaktiverad nr meddelandet (och bilagor) skras","NEW_MESSAGE_NOT_SECURE":"Nytt meddelande","NEW_FEATURE_POPOVER_PP_BODY":"Virtru kan nu hlla dina filbilagor skyddade nr de har delats och laddats ner.<br><br><a href=\'https://support.virtru.com/hc/en-us/articles/360022693153\'>Ls mer</a> om denna funktion, inklusive hur mottagaren upplever den.","NEW_FEATURE_POPOVER_PP_BUTTON":"Avvisa","NEW_FEATURE_POPOVER_PP_LABEL":"Nyhet! Bestndigt skydd","NEW_MESSAGE_SECURE":"Nytt skert meddelande","OFFLINE_MODE_MODAL":{"PROTECTION_OFF":{"ACTION":"Stng","BODY":"Virtru-skyddet r fr nrvarande inaktiverat eftersom ntverksanslutningen r offline.","TITLE":"Inget ntverk upptcktes"},"PROTECTION_ON":{"ACTION":"Stng","BODY":"Virtru-skyddet r fr nrvarande inaktiverat eftersom ntverksanslutningen r offline. Eventuella ndringar nr du r offline sparas inte.","TITLE":"Inget ntverk upptcktes"}},"OKGOTIT":"OK, JAG FRSTR!","ONBOARDING_POPOVER_1_CONFIRM":"Aktivera","ONBOARDING_POPOVER_1_ENTERPRISE_BODY":"Ditt fretag anvnder Virtru fr att skydda e-post och hlla sina data privata. Aktivera ditt e-postkonto fr att brja skicka skra meddelanden.","ONBOARDING_POPOVER_1_HEADER":"Vlkommen till Virtru","ONBOARDING_POPOVER_1_INDIVIDUAL_BODY":"Med Virtru r det enkelt att skydda e-post och hlla dina data privata. Aktivera ditt e-postkonto fr att brja skicka skra meddelanden.","ONBOARDING_POPOVER_2_BODY":"Du r nu redo att skicka skra meddelanden frn {{currentUser}} med Virtru.","ONBOARDING_POPOVER_2_CONFIRM":"Nsta","ONBOARDING_POPOVER_2_HEADER":"Din e-postadress r aktiverad","ONBOARDING_POPOVER_2_SKIP_CHECKBOX_LABEL":"Visa inte igen","ONBOARDING_POPOVER_3_BODY":"ndrade du dig? terkalla tkomst eller uppdatera kontroller frn mappen Skickad mapp i Gmail eller ditt <a href=\'https://secure.virtru.com/control-center\'>Virtru kontrollcenter</a>.","ONBOARDING_POPOVER_3_CONFIRM":"Klar","ONBOARDING_POPOVER_3_HEADER":"Du har skickat ditt frsta skra meddelande!","ONBOARDING_RESTART_4_BODY":"Virtru skyddar dina meddelanden och bilagor. Fr att lsa mer om hur Virtru skyddar dig ska du g till <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>.","ONBOARDING_RESTART_4_ORG_BODY":"Virtru-skyddet har stllts in till \\"P\\" av din administratr och skyddar dina meddelanden och bilagor.<br><br>Fr att lsa mer om hur Virtru skyddar dig ska du g till <a href=\'https://www.virtru.com/intro/\'>virtru.com/intro</a>.","ONBOARDING_RESTART_4_ORG_HEADING":"Virtru-skydd","ONBOARDING_RESTART_CONFIRM":"Ta en rundtur","ONBOARDING_SEND_VERIFICATION":"Skicka aktivering via e-post","ONBOARDING_TOUR_1_BODY":"Nr du r redo att skicka ett skert meddelande ska du vlja <span class=\\"bold\\">Skriv</span> fr att brja.","ONBOARDING_TOUR_1_HEADER":"Brja skriva ett meddelande","ONBOARDING_TOUR_2_BODY":"Nr du behver skicka ett skert meddelande aktiverar du Virtru lngst upp till hger i skrivfnstret. Utkast r ocks skyddade, ven innan du skickar.","ONBOARDING_TOUR_2_HEADER":"Sl p Virtru-skyddet","ONBOARDING_TOUR_3_BODY":"Kontrollera tkomsten till ditt skra meddelande: ange ett utgngsdatum, inaktivera vidarebefordring eller vattenstmpla bilagor.","ONBOARDING_TOUR_3_HEADER":"Lgg till skerhetsalternativ","ONBOARDING_TOUR_4_BODY":"Skra meddelanden kan innehlla introduktionstext som mottagaren kan se utan att dekryptera hela meddelandet. Du kan anpassa denna introduktion genom att vlja <span class=\\"bold\\">Personlig introduktion</span>.","ONBOARDING_TOUR_4_HEADER":"Personlig introduktion","ONBOARDING_TOUR_CONFIRM":"OK","ONE_CLICK_OPTION":"tkomst med ett klick","PAGE_ACTIONS_FORMAT_NON_PROD_MESSAGE":"Detta meddelande skickades med {{acmUrl}}","PERSONAL_INTRO_ADD":"Personlig introduktion","ARIA_PERSONAL_INTRO":"Personlig introduktion","PERSONAL_INTRO_ONBOARD":"Lgg till en okrypterad personlig introduktion till ditt privata e-postmeddelande. P s stt vet mottagarna att ditt meddelande r kta och inte skrppost.","PERSONAL_INTRO_PLACEHOLDER_TEXT":"[Skriv ditt introduktionsmeddelande hr. Inkludera information som endast mottagaren knner till, eller skriv det p ett sdant stt att de vet att det verkligen r du.]","PLAINTEXT_NOT_SUPPORTED_HEADER":"Klartextlget stds inte","PLAINTEXT_NOT_SUPPORTED_TEXT":"Stng av klartextlget innan du fortstter.","PLAINTEXT_NOT_SUPPORTED_TITLE":"Det gick inte att skicka","POLICY_MENU_DISABLE_FORWARDING":"Inaktivera vidarebefordring","POLICY_MENU_EXPANDED_WATERMARKING":"Vattenmrkning","POLICY_MENU_PERSISTENT_PROTECTION":"Bestndigt skydd","POLICY_MENU_WATERMARKING":"PDF-vattenmrkning","POLICY_MENU_SUPPORTED_FILES_INFO_TITLE":"Format med std","PROTECTION_REQUIRED":"Skydd krvs","PROTECT_AND_SEND":"Skydda och skicka","READ_RECEIPT_FORWARD_COUNT_DETAILS":"(klicka fr mer detaljer)","RECIPIENT":"Mottagarflt","RECIPIENT_WIDGET_EXPIRATION_DATE":"Gr ut {{datetime}}","RECIPIENT_WIDGET_EXPIRED":"Detta meddelande har gtt ut","RECIPIENT_WIDGET_EXPIRED_BODY":"TKOMST HAR GTT UT","RECIPIENT_WIDGET_EXPIRED_DATE":"Detta meddelande har gtt ut den {{datetime}}","RECIPIENT_WIDGET_HEADER":"Du lser ett skert meddelande som skyddas av Virtru","RECIPIENT_WIDGET_NO_EXPIRATION":"Inget utgngsdatum","RECIPIENT_WIDGET_OFFLINE_BODY":"FRLORAD INTERNETANSLUTNING","RECIPIENT_WIDGET_OFFLINE_HEADER":"tkomst till skra meddelanden tillts inte utan en internetanslutning.","RECIPIENT_WIDGET_REVOKED_BODY":"TKOMST TERKALLADES","RECIPIENT_WIDGET_REVOKED_HEADER":"Skaparen har tagit bort din tkomst","RECIPIENT_WIDGET_UNAUTHORIZED_BODY":"DENNA E-POSTADRESS R INTE AUKTORISERAD TILL ATT VISA DETTA E-POSTMEDDELANDE","RECIPIENT_WIDGET_UNAUTHORIZED_HEADER":"Denna e-postadress r inte auktoriserad till att lsa detta e-postmeddelande","RESTORE_DRAFT_FAILED":"Det frekom ett problem nr detta utkast terstlldes. Kontrollera din ntverksanslutning och frsk igen.","SCREENREADER_CLOSED_POLICY_MENU":"Stngd policymeny","SCREENREADER_DISABLED_EXPIRATION":"Inaktiverade utgngsdatum","SCREENREADER_DISABLED_FORWARDING":"Inaktiverade vidarebefordring","SCREENREADER_DISABLED_ONECLICK":"Inaktiverade tkomst med ett klick","SCREENREADER_DISABLED_WATERMARK":"Inaktiverade vattenmrke","SCREENREADER_DISABLED_WATERMARK_PDF":"Inaktiverade PDF-vattenmrke","SCREENREADER_DISABLED_PFP":"Inaktiverade bestndigt skydd","SCREENREADER_DISABLE_FORWARDING":"Inaktivera vidarebefordring","SCREENREADER_ENABLED_EXPIRATION":"Aktiverade utgngsdatum","SCREENREADER_ENABLED_FORWARDING":"Aktiverade vidarebefordring","SCREENREADER_ENABLED_ONECLICK":"Aktiverade tkomst med ett klick","SCREENREADER_ENABLED_WATERMARK":"Aktiverade vattenmrke","SCREENREADER_ENABLED_WATERMARK_PDF":"Aktiverade PDF-vattenmrke","SCREENREADER_ENABLED_PFP":"Aktiverade bestndigt skydd","SCREENREADER_EXPIRATION":"Utgngsdatum angavs","SCREENREADER_ONECLICK":"Aktivera tkomst med ett klick","SCREENREADER_OPENED_POLICY_MENU":"ppnad policymeny","SCREENREADER_VIRTRU_POLICY_MENU":"Skerhetsalternativ fr Virtru","SCREENREADER_VIRTRU_SECURE_TOGGLE":"Sker vxling i Virtru","SCREENREADER_WATERMARK_PDF":"PDF-vattenmrke","SCREENREADER_WATERMARK":"Vattenmrke","SCREENREADER_PFP":"Bestndigt skydd","SECURE_EMAIL_COMPOSER_PLACEHOLDER_HTML":"Denna e-postkedja har skrats av Virtru.","SECURE_EMAIL_COMPOSER_POLICY_OPTIONS_DEFAULT":"(Inget mne)","SECURE_MESSAGE_CONTROL_ENABLE":"Aktivera","SECURE_MESSAGE_CONTROL_REVOKE":"terkalla","SECURE_MESSAGE_LABEL":"Du lser ett skrat meddelande","SECURE_MESSAGE_SENT_NOTIFICATION":"Skert meddelande har skickats.","SECURED_ATTACHMENTS_HEADER":"{{count}} SKRADE BILAGA","SECURED_ATTACHMENTS_HEADER_plural":"{{count}} SKRADE BILAGOR","SENDER_WIDGET_ERROR_ENABLE_MESSAGE":"Det uppstod ett fel nr du aktiverade detta meddelande.","SENDER_WIDGET_ERROR_REVOCATION":"Det uppstod ett fel nr du behandlade terkallelsen.","SENDER_WIDGET_ERROR_UPDATE_POLICY":"Det uppstod ett fel nr policyn uppdaterades.","SENDER_WIDGET_EXPIRED_DATE":"Har gtt ut den {{datetime}}","SENDER_WIDGET_EXPIRES_DATE":"Gr ut {{datetime}}","SENDER_WIDGET_MESSAGE_REVOKED":"Detta meddelande har terkallats","SENDER_WIDGET_NO_EXPIRATION":"Inget utgngsdatum","SENDER_WIDGET_REVOKED_DATE":"terkallade {{datetime}}","SEND_ANIMATION_LOADING_TEXT":"Krypterar e-post...","SEND_ANYWAY":"Skicka nd","SEND_ANYWAY_OFFLINE":"Placera i k nd","SCHEDULE_SEND":"Schemalgg sndning","GO_BACK":"G tillbaka","SEND_BLOCK_HEADER":"vertrdelse upptcktes","SEND_BLOCK_SUBTEXT":"Enligt din organisations skerhetspolicy fr innehll innehller detta e-postmeddelandet knslig information och kan inte skickas utan Virtru-skydd.","SEND_WARNING_BUTTON_SEND":"SKICKA","SEND_WARNING_BUTTON_SEND_SECURE":"SKICKA SKERT","SEND_WARNING_BUTTON_SEND_SECURE_IMMEDIATELY":"Skicka skert nu","SEND_WARNING_WARNING_SEND_SCHEDULED_LABEL":"Schemalagd sndning stds dock inte fr nrvarande med Virtru-skyddet. Ta antingen bort skicka skert eller knslig information fr att schemalgga sndning.","SEND_WARNING_SCHEDULE_SEND_NOT_SUPPORTED":"Schemalgg sndning stds fr tillfllet inte. Skicka skert nu eller schemalgg sndning utan Virtru-skydd.","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE":"Schemalagd sndning finns inte","SEND_WARNING_WARNING_SCHEDULED_SEND_UNAVAILABLE_TOOLTIP":"Schemalagd sndning stds inte fr nrvarande med Virtru-skyddet","SENSITIVE_DATA_FOUND":"Knsliga data hittades","WARN_SENSITIVE_DATA_FOUND_BODY":"Meddelandet du skickar innehller knslig information. Din organisation rekommenderar att du aktiverar Virtru-skyddet innan du skickar denna e-post.","WARN_SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE":"Du kan skydda och skicka detta utkast nr du ter igen har ntverksanslutning eller stlla e-postmeddelandet i k i utkorgen utan Virtru-skydd.","WARN_SENSITIVE_DATA_FOUND_BODY_OFFLINE":"Meddelandet du skickar innehller knslig information.","WARN_SENSITIVE_DATA_FOUND_BODY_MAIL_MERGE":"Virtru-skyddet r dock inte kompatibelt med Mail Merge i Gmail. Vnligen vlj {{button}} p denna skrm och stng av Mail Merge fr att fortstta.","SENSITIVE_DATA_FOUND_BODY":"Meddelandet du skickar innehller knslig information och din organisation har automatiskt tillmpat Virtru-skyddet.","SENSITIVE_DATA_FOUND_BODY_OFFLINE":"Meddelandet du skickar innehller knslig information.","SENSITIVE_DATA_FOUND_BODY_ADDITIONAL_OFFLINE":"Du kan skydda och skicka utkastet nr du ter igen har ntverksanslutning eller ta bort den knsliga informationen fr att stlla e-postmeddelandet i k i utkorgen utan Virtru-skydd.","WARN_ATTACHMENTS_LIMIT_REACHED":"Grnsen fr bilagor har ntts","ATTACHMENTS_LIMIT_REACHED_BODY":"Du har bifogat [ATTACHMENTS_COUNT] filer till detta meddelande. Virtru-skyddet stder upp till [ATTACHMENTS_LIMIT] bilagor per skert meddelande. Ta bort [ATTACHMENTS_REMOVE_COUNT] filer frn det skra meddelandet och frsk igen.","SMART_SEND_SECURE_STACK_ERROR_HEADER":"Meddelandet kan inte skickas","SMART_SEND_SECURE_STACK_ERROR_BODY":"Detta meddelande verskrider den maximala storleken fr kryptering, vanligtvis p grund av antalet svar, vidarebefordringar eller mngden innehll. Minska storleken p ditt meddelande eller starta en ny konversation. G till <a href=\\"https://support.virtru.com/hc/en-us\\" target=\\"blank\\">Virtru Support</a> fr mer information.","TOOLTIP_DISABLE_FORWARDING":"Inaktivera vidarebefordring","TOOLTIP_EXPIRATION":"Utgngsdatum","TOOLTIP_EXPIRES":"Gr ut: {{date}}","TOOLTIP_FORWARDING_RESTRICTED":"Begrnsad vidarebefordring","TOOLTIP_FORWARDING_RESTRICTED_CONTENT":"Vidarebefordring har begrnsats fr ett skert meddelande i kedjan. Mottagare som lagts till i ditt meddelande kanske inte kan f tkomst till det vidarebefordrade meddelandet. garen av det skra meddelandet mste ge nya mottagare tkomst till det.","TOOLTIP_ONE_CLICK":"tkomst med ett klick","TOOLTIP_REAUTHORIZE_BUTTON_CONTENT":"Detta meddelande har tidigare terkallats. Auktorisera det p nytt fr att lta personer se det igen.","TOOLTIP_REAUTHORIZE_BUTTON_TITLE":"Auktorisera meddelande p nytt","TOOLTIP_RECIPIENT_DISABLE_FORWARDING":"Detta Virtru-skrade meddelande har begrnsats frn vidarebefordran av dess avsndare.","TOOLTIP_RECIPIENT_EXPIRATION":"Detta Virtru-skrade meddelande gr ut {{date}}. Kontakta avsndaren om du vill se detta meddelande nr det gtt ut.","TOOLTIP_RECIPIENT_ONE_CLICK":"Detta Virtru-skrade meddelande krver inte auktorisering fr att lsas.","TOOLTIP_RECIPIENT_UNAUTHORIZED_INFO":"Den ursprungliga frfattaren av denna e-post har begrnsad tkomst till detta meddelande. Om du inte har ftt detta meddelande direkt frn den ursprungliga frfattaren kan du drfr inte se dess innehll.<br><br>Kontakta den ursprungliga frfattaren fr att f tkomst.","TOOLTIP_REVOKE_BUTTON_CONTENT":"Inaktiverar tkomst till ditt meddelande. Ingen annan n du kommer att kunna se detta meddelande.","TOOLTIP_REVOKE_BUTTON_TITLE":"terkalla meddelande","TOOLTIP_SECURE_ATTACHMENT_CONTENT":"{{filename}} har skrats av Virtru","TOOLTIP_SECURE_ATTACHMENT_DOWNLOAD":"Dekryptera och ladda ner","TOOLTIP_SECURE_ATTACHMENT_DRIVE":"Spara till Google Drive d det inte stds av Virtru","TOOLTIP_SECURE_ATTACHMENT_TITLE":"Virtru sker bilaga","TOOLTIP_SENDER_DISABLE_FORWARDING_CONTENT":"Denna instllning gr ditt meddelande olsbart om det har vidarebefordrats","TOOLTIP_SENDER_ENABLE_SMS2FA":"tkomst till detta meddelande krver SMS-verifiering","TOOLTIP_SENDER_EXPIRATION_CONTENT":"Efter den angivna tiden har dina mottagare inte lngre tkomst till detta meddelande","TOOLTIP_SENDER_ONE_CLICK_CONTENT":"Om du slr p denna funktion krvs ingen autentisering fr att visa ditt krypterade meddelande","TOOLTIP_TOGGLE_DISABLED":"Du r inte auktoriserad att skicka skert. Kontakta din administratr om du har ngra frgor.","TOOLTIP_TOGGLE_ON":"Virtru-skyddet r aktiverat","TOOLTIP_TOGGLE_ON_ORG":"Virtru-skyddet r aktiverat som standard. Du kan inaktivera om det inte krvs.","TOOLTIP_SENDER_WATERMARK":"Vattenmrkning","TOOLTIP_SENDER_WATERMARK_CONTENT":"Bilagor med std vattenmrks i Secure Reader","TOOLTIP_SENDER_PFP":"Bestndigt skydd","TOOLTIP_SENDER_PFP_CONTENT":"Denna instllning skyddar filer genom att krva autentisering ven om de delas eller laddas ner till en dator","TOOLTIP_TOGGLE_OFF":"Skydda ditt meddelande med Virtru","TOOLTIP_TOGGLE_OFF_OFFLINE":"Virtru-skyddet kan inte aktiveras nr du r offline","TOOLTIP_UPSELL_POSTFIX":"<br/><br/>Denna funktion finns i Pro-versionen till Virtru.","TOOLTIP_VIRTRU_OPTIONS":"Skerhetsalternativ","UNSECURE_ATTACHMENTS_EXIST_HEADER":"Oskra bilagor finns","UNSECURE_ATTACHMENTS_EXIST_TEXT":"Det gr inte att skicka skert nr bilagor upptcks.","UNSECURE_ATTACHMENTS_EXIST_TITLE":"Det gick inte att skicka","UPDATE_MODAL_HEADER":"Virtru har uppdaterats.","UPDATE_MODAL_REFRESH_BUTTON":"Klicka hr fr att uppdatera","UPDATE_MODAL_SUBHEADER":"Uppdatera denna sida fr att se till att <br>du anvnder den senaste versionen.","VIRTRU_ATTACHMENT_DECRYPTING":"Dekrypterar","VIRTRU_ATTACHMENT_DOWNLOAD":"Ladda ner","VIRTRU_ATTACHMENT_VIEW":"Visa","VIRTRU_ATTACHMENT_REMOVE":"Ta bort","VIRTRU_AUTH_LINK":"Aktivera Virtru","VIRTRU_AUTH_LINK_REACTIVATE":"teraktivera Virtru","VIRTRU_CONTACT_US":"Kontakta din IT-administratr","VIRTRU_DISABLED_ON_DOMAIN":"Virtru har inaktiverats fr din domn","VIRTRU_PROTECTION_NOT_AUTH":"Virtru mste vara aktiverat fr att aktivera skydd.","VIRTRU_PROTECTION_NOT_AUTH_OFFLINE":"Ntverksanslutning krvs fr Virtru-aktivering.","VIRTRU_PROTECTION_NOT_AUTH_SHORT":"Aktivera Virtru.","VIRTRU_PROTECTION_ON":"Virtru-skyddet r P","VIRTRU_PROTECTION_OFF":"Virtru-skyddet r AV","VIRTRU_PROTECTION_OFFLINE":"Virtru-skyddet r offline","VIRTRU_SECURE_DRAFT_PREFIX":"Detta r ett utkast som skrats av Virtru","WEBMAIL_PLUGIN_ACTIVATION_LINK_RETRY":"Skicka igen","WEBMAIL_PLUGIN_ACTIVATION_TEXT":"E-post fr verifiering har skickats.<br>Kontrollera denna inkorg inom kort.","WEBMAIL_PLUGIN_INIT_ERROR":"Virtru kunde inte initieras. Detta kan bero p fel i ntverksanslutningen eller en trasig anvndarkonfiguration. Frsk att uppdatera igen om ett tag, eller kontakta Virtru kundsupport p <a href=\\"https://support.virtru.com/hc/en-us/\\">https://support.virtru.com/hc/en-us/</a>","WEBMAIL_PLUGIN_INIT_ERROR_HEADER":"Virtru-insticksprogram kunde inte initieras","WIDGET_BASE_BODY_REVOKED":"TKOMST NEKADES","WIDGET_BASE_EXPIRATION_OPTIONS_CUSTOM":"Lgg till anpassat datum/anppasad tid","WIDGET_BASE_FOOTER":"Skrad med Virtru-teknik","WIDGET_BASE_HEADER_MESSAGE_RECIPIENT":"Du lser ett skert meddelande som skyddas av Virtru","WIDGET_BASE_HEADER_MESSAGE_SENDER":"Ditt meddelande som skyddas av Virtru","WIDGET_BASE_MENU_OPTION_EXPIRES":"Lgg till utgngsdatum","WIDGET_BASE_MENU_OPTION_FORWARDING":"Inaktivera vidarebefordring","EXPIRATION_UNIT_DAYS":"dag","EXPIRATION_UNIT_DAYS_plural":"dagar","EXPIRATION_UNIT_HOURS":"timme","EXPIRATION_UNIT_HOURS_plural":"timmar","EXPIRATION_UNIT_MINS":"minut","EXPIRATION_UNIT_MINS_plural":"minuter","EXPIRATION_UNIT_MONTHS":"mnad","EXPIRATION_UNIT_MONTHS_plural":"mnader","EXPIRATION_UNIT_WEEKS":"vecka","EXPIRATION_UNIT_WEEKS_plural":"veckor","EXPIRATION_UNIT_YEARS":"r","EXPIRATION_UNIT_YEARS_plural":"r","READ_RECEIPT_READBY_COUNT":"Lst av {{accessors}} av {{count}} mottagare","READ_RECEIPT_FORWARD_COUNT":"<div style=\\"text-align:center;\\">Vidarebefordrad {{count}} gng<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","READ_RECEIPT_FORWARD_COUNT_plural":"<div style=\\"text-align:center;\\">Vidarebefordrad {{count}} gnger<br /><span style=\\"font-size:8pt;\\">$t(READ_RECEIPT_FORWARD_COUNT_DETAILS)</span></div>","ATTACHMENTS_TOOLTIP_CONTENT":{"RECIPIENT":{"SUPPORTED_FILE":{"NONE_SECURE":"Denna fil r krypterad och inga ytterligare skerhetsalternativ r aktiverade.","EXPANDED_WATERMARKING":"Denna fil vattenmrks nr den visas i Virtru Secure Reader.","IS_MANAGED":"Denna fil vattenmrks nr den visas i Virtru Secure Reader.","EXPANDED_IS_MANAGED":"Denna fil har ytterligare skerhetsalternativ aktiverade och vattenmrks och skyddas nr den laddas ner eller delas.","PERSISTENT_PROTECTION":"Denna fil har bestndigt skydd aktiverat och frblir sker nr den laddas ner eller delas.","EXPANDED_PROTECTION":"Denna fil har ytterligare skerhetsalternativ aktiverade och vattenmrks och skyddas nr den laddas ner eller delas."},"UNSUPPORTED_FILE":{"NONE_SECURE":"Denna fil r krypterad och inga ytterligare skerhetsalternativ r aktiverade.","EXPANDED_WATERMARKING":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","IS_MANAGED":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","EXPANDED_IS_MANAGED":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","PERSISTENT_PROTECTION":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","EXPANDED_PROTECTION":"Inget ytterligare skydd aktiverades p grund av filformat utan std."},"STEPCHILD":"Denna bilaga har skerhetsinstllningar som hanteras separat frn detta meddelande."},"SENDER":{"SUPPORTED_FILE":{"NONE_SECURE":"Denna fil r krypterad och inga ytterligare skerhetsalternativ r aktiverade.","EXPANDED_WATERMARKING":"<p>Ytterligare skerhetsalternativ:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Vattenmrkning</p>","IS_MANAGED":"<p>Ytterligare skerhetsalternativ:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>PDF-vattenmrkning</p>","EXPANDED_IS_MANAGED":"<p>Ytterligare skerhetsalternativ:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>PDF-vattenmrkning</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Bestndigt skydd</p>","PERSISTENT_PROTECTION":"<p>Ytterligare skerhetsalternativ:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Bestndigt skydd</p>","EXPANDED_PROTECTION":"<p>Ytterligare skerhetsalternativ:</p><p><span class=\\"virtru-attachment-tooltip-icon icon-watermarking\\"></span>Vattenmrkning</p><p><span class=\\"virtru-attachment-tooltip-icon icon-persistent-protection\\"></span>Bestndigt skydd</p>"},"UNSUPPORTED_FILE":{"NONE_SECURE":"Denna fil r krypterad och inga ytterligare skerhetsalternativ r aktiverade.","EXPANDED_WATERMARKING":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","IS_MANAGED":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","EXPANDED_IS_MANAGED":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","PERSISTENT_PROTECTION":"Inget ytterligare skydd aktiverades p grund av filformat utan std.","EXPANDED_PROTECTION":"Inget ytterligare skydd aktiverades p grund av filformat utan std."},"STEPCHILD":"Denna bilaga har skerhetsinstllningar som hanteras separat frn detta meddelande."}},"ATTACHMENT_SECTION_TOOLTIP_TITLE":"Skrade bilagor","ATTACHMENT_SECTION_TOOLTIP_CONTENT":"Bilagorna nedan r krypterade av Virtru. Filer med lsikonen har aktiverat bestndigt skydd och kommer fortfarande att vara skyddade nr de har delats eller laddats ner.","ERROR_REFRESH_TOAST_MESSAGE":"Virtru har sttt p ett fel och kanske inte fungerar korrekt. Uppdatera denna sida och frsk igen.","REATTACH_FILE_WARNING_MESSAGE_POP_IN":"Du behver bifoga din fil igen. G in nd?","REATTACH_FILE_WARNING_MESSAGE_POP_OUT":"Du behver bifoga din fil igen. Riva av nd?","CKS_INDICATOR_TITLE":"Identitet verifierad","CKS_INDICATOR_BODY":"Avsndarens identitet r verifierad av Virtru fr att frhindra bedrgerier.","CKS_INDICATOR_LINK":"Ls mer hr","MAIL_MERGE_CONFLICT_MODAL_TITLE":"Sammanfogningskonflikt","MAIL_MERGE_CONFLICT_MODAL_BODY":"Virtru-skyddet r inte kompatibelt med sammanslagning av e-post i Gmail. Vnligen stng av sammanslagningen av e-post fr att fortstta.","MAIL_MERGE_CONFLICT_TOOLTIP":"Sammanslagning av e-post stds inte med Virtru-skydd"}');

/***/ }),

/***/ 86278:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const XhrCoup = (__webpack_require__(98383)["default"]);
const Utils = __webpack_require__(55675);
const {
  getWindowOpener
} = __webpack_require__(37060);
class PredictiveInterceptor {
  constructor(user) {
    this._user = user;
    this._isWorking = false;
    this._windowErrorHandler = null;
    this._interceptors = ['taskassist:compose', 'jserror'];
    this._interceptorStopCallbacks = [];
  }
  start() {
    const canStart = Utils.isFeatureEnabled(this._user._profile, 'canDisablePredictiveServices');
    if (canStart && !this._isWorking) {
      try {
        this._isWorking = true;
        this._hideErrors();
        this._interceptors.forEach(this._setupInterceptor, this);
      } catch (error) {
        this.stop();
        throw error;
      }
    }
  }
  stop() {
    if (this._isWorking) {
      getWindowOpener().onerror = this._windowErrorHandler;
      this._windowErrorHandler = null;
      this._interceptorStopCallbacks.forEach(interceptorStopCallback => {
        interceptorStopCallback();
      });
      this._interceptorStopCallbacks = [];
      this._isWorking = false;
    }
  }
  _hideErrors() {
    this._windowErrorHandler = getWindowOpener().onerror;
    getWindowOpener().onerror = message => {
      // Hide errors which was throw by GMail after aborting requests related to Predictive Services
      if (message.includes('Unsupported HTTP status: null')) {
        return true;
      }
    };
  }
  _setupInterceptor(criteria) {
    const handleOpen = request => {
      request.onloadstart = () => {
        request.abort();
      };
    };
    const handleSent = () => {
      // TODO: notify user
    };
    const interceptor = new XhrCoup([getWindowOpener()]);
    [].concat(criteria).forEach(condition => {
      interceptor.urlContains(condition);
    });
    interceptor.on('open', handleOpen);
    interceptor.on('sent', handleSent);
    this._interceptorStopCallbacks.push(() => {
      interceptor.off('open', handleOpen);
      interceptor.off('sent', handleSent);
      interceptor.stop();
    });
  }
}
module.exports = {
  PredictiveInterceptor
};

/***/ }),

/***/ 86294:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var Emitter = __webpack_require__(16502);
var DragMonitor = __webpack_require__(77957);
var AttachmentService = __webpack_require__(95727);
var AttachmentUtil = __webpack_require__(31027);
const {
  PolicyAttributes
} = __webpack_require__(81722);
const {
  showAttachmentsLimitModal
} = __webpack_require__(52561);
const {
  ATTACHMENTS_LIMIT
} = __webpack_require__(76223);
function AttachmentDropZone(elements, transports, composeMod) {
  this._elements = [];
  this.addElements(elements);
  this._composeMod = composeMod;
  this._settings = composeMod._settings;
  this._transports = transports;
  this._shields = [];
}
Emitter(AttachmentDropZone.prototype);
AttachmentDropZone.prototype.setup = function () {
  if (!this._attachmentService) {
    this._attachmentService = new AttachmentService(this._transports, this._composeMod, this._settings);
  }
  if (!this._drop) {
    this._drop = this.drop.bind(this);
  }
  DragMonitor.refresh(); // This makes the DragMonitor watch iframes as well
  DragMonitor.on('drop', this._drop);
  for (var i = 0, len = this._elements.length; i < len; ++i) {
    $(this._elements[i]).addClass('virtru-processed');
  }
};

/**
 * Drop handler
 * @param  {object} event the event object
 * @return {[type]}       [description]
 */
AttachmentDropZone.prototype.drop = async function (event) {
  if (this._composeMod._toggle.getState() === 'off' || event.dataTransfer.effectAllowed === 'move') {
    return false;
  }
  var {
    dom
  } = this._settings;
  this.emit('drop', event);
  var triggerDrop = false;
  event.preventDefault();
  event.stopPropagation();
  for (var i = 0, len = this._elements.length; i < len; ++i) {
    var ele = $(this._elements[i]);
    if (ele.length > 0 && ($.contains(ele[0], event.target) || ele[0] === event.target)) {
      triggerDrop = true;
    }
    $(window).triggerNative('dragleave');
    $(document.body).triggerNative('dragleave');

    // Sigh. If it's gmail we need to hide the attachment dropzone manually.
    // The slice is to remove the period at the start of the class name
    if (typeof dom.NEW_COMPOSE_ATTACHMENT_DROP_ZONE !== 'undefined' && ele.hasClass(dom.NEW_COMPOSE_ATTACHMENT_DROP_ZONE.slice(1))) {
      ele.css('display', 'none');
    }
  }
  if (triggerDrop === true || this._elements[0] === document.body) {
    var _this$_composeMod, _this$_composeMod$att;
    const processedFiles = AttachmentUtil.processFilesMimeType(event.dataTransfer.files);
    const securedAttacments = (_this$_composeMod = this._composeMod) === null || _this$_composeMod === void 0 ? void 0 : (_this$_composeMod$att = _this$_composeMod.attachmentsHelper) === null || _this$_composeMod$att === void 0 ? void 0 : _this$_composeMod$att._tdfAttachmentMods.length;
    const filesAmmount = securedAttacments + processedFiles.length;
    if (filesAmmount > ATTACHMENTS_LIMIT) {
      showAttachmentsLimitModal(filesAmmount);
    }
    const files = await AttachmentUtil.validateFileSize(processedFiles, this._settings.user, this._transports);
    if (files.length === 0) {
      return;
    }
    const policyConfigMenu = this._composeMod._policyConfigMenu;
    const isExpandedProtection = policyConfigMenu.isExpandedProtectionEnabled();
    const authorizations = PolicyAttributes.getAuthorizations(this._composeMod.getPolicyConfig());
    if (isExpandedProtection) {
      const canProceedFileUpload = await AttachmentUtil.canProceedLimitedEncryption(files, authorizations);
      if (!canProceedFileUpload) {
        return;
      }
    }

    // Apply the same way as for attached attachments
    // mark the file for insertion at last known cursor position
    files.forEach(function (file) {
      file.doInsertAtCursorPosition = true;
    });
    this.emit('attachment-attached', files);
    const {
      isManaged
    } = this._composeMod._policyConfigMenu._policyModel;
    this._attachmentService.encryptAndUploadFiles(files, {
      isManaged,
      authorizations
    }, 'button').then(attachments => {
      this.emit('attach-secure', attachments.successful);
      this.emit('fail-attach-secure', attachments.failed.length);
    });
  }
};
AttachmentDropZone.prototype.addElements = function (elements) {
  if (typeof elements !== 'undefined') {
    if (elements instanceof Array) {
      this._elements = this._elements.concat(elements);
    } else {
      this._elements.push(elements);
    }
  }
  return this._elements;
};
AttachmentDropZone.prototype.teardown = function () {
  if (this._drop) {
    DragMonitor.off('drop', this._drop);
  }
};
module.exports = AttachmentDropZone;

/***/ }),

/***/ 86345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/**
 * @file Provides the base-class for modal-page objects.
 */
var Emitter = __webpack_require__(16502);
var $ = __webpack_require__(55401);

// Constants
const OPACITY_DEFAULT = 85;
const BACKGROUND_DEFAULT = 'rgb(0,0,0)';

/**
 * @constructor
 * @param {Object} element - the jQuery element to attach a modal-page to
 *
 *
 * events:
 *  modal-closed
 *
 */
function BaseModalPage(element, options) {
  this.element = element;
  this.options = options;
  this.overlayId = 'virtru-modal-backdrop';
  this.closeClass = 'virtru-close';
  this.opacity = OPACITY_DEFAULT;
  this.background = BACKGROUND_DEFAULT;
  this.isWatcherEnabled = false;
  this.close = false;
  this.clicked = false;
  this.modal = false;
}
Emitter(BaseModalPage.prototype);

/**
 * Opens the modal-page
 * @method
 */
BaseModalPage.prototype.openModal = function () {
  var self = this;
  var {
    element
  } = this;
  // Display the modal window
  this.modal = element.modal($.extend({
    opacity: self.opacity,
    background: self.background,
    overlayId: self.overlayId,
    closeClass: self.closeClass,
    onShow(dialog) {
      self.onShow(dialog, this);
    },
    onClose(dialog) {
      self.onClose(dialog, this);
    },
    close: false
  }, this.options));
  return this;
};

/**
 * Define the actions for the modal page
 * @method defineActions
 * @abstract
*/
BaseModalPage.prototype.defineActions = function () {
  // do nothing.
};

/**
 * Define the actions to do before the modal page closes
 * @abstract
 */
BaseModalPage.prototype.closeModal = function () {
  // do nothing.
};

/**
 * On-show event: fires as the modal window is shown
 * @method
 * @param {Object} dialog - the 'simplemodal.js' dialog object
 * @param {Object} modal - the modal-window, as in: 'var modal = element.modal();'
 */
BaseModalPage.prototype.onShow = function (dialog, modal) {
  this.defineActions(dialog, modal);
  if (this.isWatcherEnabled) {
    this.startWatcher(100);
  }
  // Put the modal window in-focus
  $.modal.focus();
};

/**
 * On-close event: fires as the modal-window is closing
 * @method
 * @param {Object} dialog - the 'simplemodal.js' dialog object
 * @param {Object} modal - the modal-window, as in: 'var modal = element.modal();'
 */
BaseModalPage.prototype.onClose = function (dialog, modal) {
  this.close = true;
  if (this.isWatcherEnabled) {
    this.stopWatcher();
  }
  this.closeModal(dialog, modal);
  // modal.close() can work too -- but the next line is more fool-proof
  $.modal.close();

  // Fire this after the modal is closed so that we can open a new one
  this.emit('modal-closed');
};

/**
 * Start a watcher object (optional: if 'this.isWatcherEnabled' == true'
 * @method
 */
BaseModalPage.prototype.startWatcher = function (wait) {
  wait = wait || 200;
  wait = wait <= 0 ? 200 : wait;
  var self = this;
  this.watcher = setInterval(function () {
    self.forceDisplay();
  }, wait);
};

/**
 * Force the modal-window to be re-displayed (by the watcher)
 * @method
 */
BaseModalPage.prototype.forceDisplay = function () {
  // If the window has already been clicked, then stop watching
  if (this.clicked) {
    this.stopWatcher();
    return;
  }
  // If the simplemodal-container is no longer around, then stop the watcher too.
  var modalContainer = $('#simplemodal-container');
  if (!modalContainer.length) {
    this.stopWatcher();
    return;
  }
  var {
    element
  } = this;
  // If the element is displayed, do nothing
  if (element.is(':visible')) {
    return;
  }
  element.css({
    visibility: 'visible',
    display: 'block',
    'z-index': '5000'
  });
};

/**
 * Stops the watcher (if enabled)
 * @method
 */
BaseModalPage.prototype.stopWatcher = function () {
  // If watcher is not active, do nothing.
  if (this.watcher === undefined) {
    return;
  }
  clearInterval(this.watcher);
  this.watcher = undefined;
};
exports.BaseModalPage = BaseModalPage;

/***/ }),

/***/ 87224:
/***/ ((module) => {

module.exports = '<div class="tip tip-hide" role="dialog" aria-modal="true" tabindex="-1">\n  <div class="tip-arrow"></div>\n  <div class="tip-inner"></div>\n</div>';

/***/ }),

/***/ 87618:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
/**
 * @file Provides the user-profile-proxy (UserProfileProxy) object.
 */
var Emitter = __webpack_require__(16502);
var Guard = __webpack_require__(57128);
var {
  Keys
} = __webpack_require__(42769);

/**
 * UserProfileProxy
 * @constructor
 * @param {profile}
 */
function UserProfileProxy(profile) {
  this._profile = profile;
  this.permissions = this._profile.settings.permissions;
}

/**
 * Implement events for the UserProfileProxy object
 */
Emitter(UserProfileProxy.prototype);

/**
 * Static method initializer
 * @constructs
 */
UserProfileProxy.create = function (profile) {
  return new UserProfileProxy(profile);
};

/**
 * Get the auth settings/permissions
 * @method
 * @param {String} key - The key for the auth setting
 * @returns {Any} [value] - The value for the key
 */
UserProfileProxy.prototype.auth = function (key) {
  Guard.checkIsString(key, 'The argument key must be a string.');
  return this._profile.auth[key];
};

/**
 * Get or set the setting
 * @method
 * @param {String} key - The key for the setting. Separate properties by periods.
 * @returns {Any} [value] - The value for the key
 */
UserProfileProxy.prototype.setting = function (key, value) {
  var _this$_profile;
  var origKey = key;
  var settings = (_this$_profile = this._profile) === null || _this$_profile === void 0 ? void 0 : _this$_profile.settings;
  var self = this;
  var setterGetter = function (obj, keyLoc, valueLoc) {
    if (typeof keyLoc === 'string') {
      return setterGetter(obj, keyLoc.split('.'), valueLoc);
    } else if (keyLoc.length === 1 && valueLoc !== undefined) {
      var spl = origKey.split('.');
      obj[keyLoc[0]] = valueLoc;
      self.emit('update', 'settings', spl[0], self._profile.settings[spl[0]]);
      obj[keyLoc[0]] = valueLoc;
      return undefined;
    } else if (keyLoc.length === 0) {
      return obj;
    }
    // Create the path to the key if needed
    if (typeof obj[keyLoc[0]] === 'undefined' && valueLoc) {
      obj[keyLoc[0]] = {};
    }
    return setterGetter(obj[keyLoc[0]], keyLoc.slice(1), valueLoc);
  };
  try {
    return setterGetter(settings, key, value);
  } catch (err) {
    return undefined;
  }
};
UserProfileProxy.prototype.memberships = function () {
  // Creates an array of OU and group values from attributes
  return this._profile.settings.attributes.reduce((memberships, attr) => {
    if (Keys.isOrganizationalUnit(attr.key) || Keys.isGroup(attr.key)) {
      memberships.push(attr.value);
    }
    return memberships;
  }, []);
};

/**
 * Creates an array of user aliases
 */
UserProfileProxy.prototype.aliases = function () {
  return this._profile.settings.attributes.reduce((aliases, attr) => {
    if (Keys.isAlias(attr.key)) {
      aliases.push(attr.value);
    }
    return aliases;
  }, []);
};

/**
 * Returns array of customer domains associated with their org
 */
UserProfileProxy.prototype.domains = function () {
  console.log(this._profile.settings);
  return this._profile.settings.domains || [];
};
UserProfileProxy.prototype.refreshProfile = function (profile, silent) {
  this._profile = profile;
  if (!silent) {
    this.emit('profile-refreshed', profile);
  }
};

/**
 * Read only access to settings
 * @method
 * @returns {String} JSON-string
 */
UserProfileProxy.prototype.settings = function () {
  // Make a deep copy
  return JSON.parse(JSON.stringify(this._profile.settings));
};
exports.UserProfileProxy = UserProfileProxy;

/***/ }),

/***/ 89650:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readActivation: () => (/* binding */ readActivation)
/* harmony export */ });
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_0__);

const readActivation = ({
  currentUser,
  expired
}) => `
  <div class="virtru-receiver-inactive virtru-receiver-inactive-gray-background">
    <div class="virtru-receiver-header">
      <span class="virtru-receiver-inactive-header-message">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_HEADER_USER_NOT_ACTIVATED', {
  currentUser
})}</span>
      <div class="virtru-receiver-inactive-header-info-link" />
    </div>

    <div class="virtru-receiver-inactive-body">
      ${_renderBody({
  expired,
  currentUser
})}
      <div class="virtru-receiver-links">
        <a class="virtru-receiver-link" href="https://www.virtru.com/client-side-encryption/" target="_blank">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_LINK')}</a>
      </div>
    </div>

    <a class="virtru-receiver-footer" href="http://www.virtru.com">
      <div class="virtru-receiver-footer-image" />
    </a>
  </div>
`;
function _renderBody({
  expired,
  currentUser
}) {
  if (expired) {
    return `
      <div>
        <span class="virtru-receiver-body-inactive-text">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_TEXT_REACTIVATE')}</span>
      </div>
      <div>
        <span>
          <a class="virtru-reactivation-button virtru-activation-button virtru-activation-button" href="javascript:void(0)">
            ${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_BUTTON_REACTIVATE', {
      currentUser
    })}
          </a>
        </span>
      </div>
      <div class="virtru-activation-subtext">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_SUBTEXT')}</div>
    `;
  }
  return `
    <div>
      <span class="virtru-receiver-body-inactive-text">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_TEXT_ACTIVATE')}</span>
    </div>
    <div>
      <span>
        <a class="virtru-firsttime-activation-button virtru-activation-button" href="javascript:void(0)">${_lib_i18n__WEBPACK_IMPORTED_MODULE_0___default().t('ACTIVATION_BUTTON_ACTIVATE', {
    currentUser
  })}</a>
      </span>
    </div>
  `;
}

/***/ }),

/***/ 89965:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var {
  Dict
} = __webpack_require__(82603);
var WaiterMap = function () {
  this.map = {};
};

/**
 * Get all callbacks for a selector
 */
WaiterMap.prototype.all = function (selector) {
  return this.map[selector];
};
WaiterMap.prototype.get = function (selector, callback) {
  var selectorDict = this.map[selector];
  if (selectorDict) {
    return selectorDict.get(callback);
  }
};
WaiterMap.prototype.add = function (selector, callback, stopWaiting) {
  var selectorDict = this.map[selector] || new Dict();
  selectorDict.set(callback, stopWaiting);
  this.map[selector] = selectorDict;
};
WaiterMap.prototype.remove = function (selector, callback, handler) {
  handler = handler || function () {};
  var selectorDict = this.map[selector];
  if (selectorDict) {
    var stopWaiting = selectorDict.pop(callback);
    if (stopWaiting) {
      handler.apply(null, [stopWaiting]);
    }
  }
};
WaiterMap.prototype.removeAll = function (selector, handler) {
  handler = handler || function () {};
  var selectorDict = this.map[selector];
  if (selectorDict) {
    while (selectorDict.length() > 0) {
      var popped = selectorDict.popitem();
      var stopWaiting = popped[1];
      handler.apply(null, [stopWaiting]);
    }
  }
};
exports.WaiterMap = WaiterMap;

/***/ }),

/***/ 90029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
var $ = __webpack_require__(91089);
var SVG = __webpack_require__(80790);
var colors = __webpack_require__(73377);
var dom = __webpack_require__(33621);

// grunt replace handles this in BP. indexOf checks that it was set properly.
// parameterize www-url, webpack 5 was evaluating the ternary at build time and generating funky output.
var WWW_PARAM = 'https://secure.virtru.com';
var WWW_DEFAULT = 'https://www.virtru.com';
var WWW_URL = WWW_PARAM.indexOf('http') === 0 ? WWW_PARAM : WWW_DEFAULT;
var READ_RECEIPT_CLASS = 'read-receipt';

/*
* Read Receipt constructor - Supplies contract and optional DOM context of gmail
*
* @param contract - contract of policy for which to add an RR indicator
* @param $message - jQuery node of message DOM context
* @param CustomPopover - Popover component custom implementation
* @param contentCallbacks - callback functions (recipients, forward) used to i18n content
*/
function ReadReceipt(contract, $message, CustomPopover, contentCallbacks) {
  this.contract = contract || {};
  this.$message = $message;
  this.Popover = CustomPopover;
  this.contentCallbacks = contentCallbacks;
}

// TODO move this into a proper template
ReadReceipt.prototype.fwdCountHtml = function (fwdCount) {
  return `${'<div style="text-align:center;">' + 'Forwarded '}${fwdCount} times<br />` + '<span style="font-size:8pt;">(click for more details)</span>' + '</div>';
};

/*
* Actual SVG creation and stylizing for the provided email address
*
* @param email - email of the user to check against contract's accessedBy list
*/
ReadReceipt.prototype.createReadReceiptSvg = function (email) {
  var accessed = this.contract.accessedBy.indexOf(email) >= 0;
  var icon = SVG.closed;
  var full;
  if (email && accessed) {
    icon = SVG.open;
    full = true;
  } else if (!email) {
    if (this.contract.accessPercent !== '0.00') {
      icon = SVG.open;
    }
    full = this.contract.accessPercent === '100.00';
  }
  var $icon = $(icon);
  var color = `fill:${full ? colors.green : colors.gray};`;
  $icon.attr('style', color);
  $icon.addClass(READ_RECEIPT_CLASS);
  return $icon;
};

/*
* Handler for gmail email chip DOM nodes
*/
ReadReceipt.prototype.tagEmail = function tagEmail() {
  var self = this;
  return function () {
    var $email = $(this);
    var email = $email.attr('email');
    var html = $email.html();
    if (html.indexOf('<svg') < 0) {
      var $svg = $(self.createReadReceiptSvg(email));
      var style = $svg.attr('style');
      $svg.attr('style', `${style}margin: 0 4px -1px 0;`);
      $email.html($svg.prop('outerHTML') + html);
    }
  };
};

/*
* Handler for gmail [ v ] more info tooltip (in message-header DOM node)
*/
ReadReceipt.prototype.addReadReceipt = function () {
  var self = this;
  function waitATick() {
    var $topLvl = self.$message.parents(dom.TOPLEVEL);
    var date = self.$message.find(dom.DATES).attr('title');
    var $popoverForDate = $topLvl.find(`${dom.POPOVER_FOR_DATE}(${date})`);
    var $weirdGoogleNodeLayout = $popoverForDate.parents(dom.POPOVERS);
    var $popoverEmails = $weirdGoogleNodeLayout.find(dom.EMAILS_IN_POPOVER);
    $popoverEmails.each(self.tagEmail());
  }

  // allow tick for google to populate popover DOM after caller 'click' event
  return function onPopoverClickHandler() {
    setTimeout(waitATick);
  };
};

/*
* Initiation point for indicator attachment into DOM
*
* @param $target       - jQuery DOM selection into which the indicator is placed
* @param customTooltip - return tooltip text for use in custom implementation
* @param email         - email for passthrough to get per recipient indicator
*/
ReadReceipt.prototype.addIndicatorTo = function ($target, customTooltip, email) {
  if (
  // read receipt is not available to no-auth messages
  this.contract.authorizations.indexOf('no-auth') >= 0 ||
  // read receipt is not available to non-owners of a message
  !this.contract.isOwner) {
    return;
  }

  // Add RR svg icon to $target with styles
  var $svg = this.createReadReceiptSvg(email);
  var style = $svg.attr('style');
  $svg.attr('style', `${style}margin: 0 6px;`);
  $target.append($svg.prop('outerHTML'));

  // add popover to svg
  var accessPercent = this.contract.accessPercent / 100;
  var accessors = Math.round(accessPercent * this.contract.recipientCount);
  var recipients = this.contract.recipientCount;
  var content = `Read by ${accessors} of ${recipients} recipient`;
  content = recipients !== 1 ? `${content}s` : content;
  if (this.contentCallbacks && this.contentCallbacks.recipients) {
    content = this.contentCallbacks.recipients({
      accessors,
      recipients
    });
  }
  if (customTooltip) {
    return content;
  }
  $svg = $target.find(`.${READ_RECEIPT_CLASS}`); // added in last op
  this.createPopover($svg, content);

  // gmail ALSO requires fwd tree link, email chips, and gmail chips tooltip
  if (location.host === 'mail.google.com') {
    // add link to forwarding tree
    this.linkToFwdTreeInDsh($target);

    // tag emails with read receipts now and on message detail tooltips
    var $emails = this.$message.find(dom.MESSAGE_HEADER_EMAILS);
    $emails.each(this.tagEmail());

    // tag emails in gmail native recipient list tooltip
    var $details = this.$message.find(dom.MESSAGE_HEADER_POPOVER);
    $details.on('click', this.addReadReceipt());
  }
};

/*
* A link to the DSH fwd tree panel (AKA policy details panel)
*
* @param $target - jQuery DOM selection into which the indicator is placed
* @param basic   - add icon, but not link or popover
*/
ReadReceipt.prototype.linkToFwdTreeInDsh = function ($target, basic) {
  if (!this.contract.forwardCount) {
    return;
  }
  var encodedPolicyId = btoa(this.contract.policyId);
  var url = `${WWW_URL}/control-center/email&id=${encodedPolicyId}`;
  var icon = `<a class="forward">${SVG.fwd}</a>`;
  var $icon = $(icon);

  // add icon to target node
  $target.append($icon.prop('outerHTML'));
  if (basic) {
    return;
  }
  var $indicator = $target.find('.forward');
  $indicator.attr('href', url); // link to DSH
  var {
    forwardCount
  } = this.contract;
  var forwardCallback = this.contentCallbacks && this.contentCallbacks.forward;
  var fwdCountHtml = forwardCallback ? forwardCallback(forwardCount) : this.fwdCountHtml(forwardCount);
  this.createPopover($indicator, fwdCountHtml);
};

/*
* Creation of a popover via virtru-popover library, attached to $element
*
* @param $element - jQuery DOM selection onto which the popover is attached
* @param content  - HTML or text to place within the popover
*/
ReadReceipt.prototype.createPopover = function ($element, content) {
  let popover;
  try {
    if (!this.Popover) {
      throw new Error('Popover component not available');
    }
    popover = new this.Popover();
  } catch (e) {
    $element.parent().attr('title', content);
    console.warn(e);
    return;
  }
  popover.inner.empty().append(content);
  popover.position('north');

  // add event listeners for hoverstate on RR indicator
  $element.on('mouseenter', popover.show.bind(popover, $element));
  $element.on('mouseleave', popover.hide.bind(popover));

  // stylize tooltip. TODO: move into scss class
  popover.el.find('.tip-arrow').css('border', `5px solid ${colors.black}`);
  popover.el.find('.tip-inner').css('box-shadow', 'none');
  popover.el.find('.tip-inner').css('background', colors.black);
  popover.el.find('.tip-inner').css('color', colors.white);
};
exports.h = ReadReceipt;

/***/ }),

/***/ 91090:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
module.exports = {
  cleanupMessageForPrint: cleanupMessagesForPrint,
  hasEncryptedContent,
  addHover,
  print
};

/**
 * Handles printing currently open messages.
 *
 * @param {GmailSettings} settings - Only the DOM references are used, but entire settings sent over
 * @param {jQueryElement} [$messagesToPrint] - If specificied the message(s) we want to print
 */
function print(settings, $messagesToPrint) {
  var $container = $(createContainer()).empty();
  $messagesToPrint = $messagesToPrint || $(settings.dom.MESSAGES);
  var $clonedMessages = $messagesToPrint.clone();
  cleanupMessagesForPrint($clonedMessages, settings.dom);
  var $frag = $(document.createDocumentFragment());
  var $subjectElement = findCorrectSubjectElement(settings, $messagesToPrint);
  $frag.append($subjectElement.clone());
  $frag.append($clonedMessages);
  $container.append($frag);
  window.print();
}
var printContainer;
/**
 * Creates and stores the created print container
 *
 * @return {HTMLElement} The newly created or stored print container;
 */
function createContainer() {
  if (printContainer) {
    return printContainer;
  }
  printContainer = document.createElement('div');
  printContainer.id = 'virtru-print-container';
  document.body.appendChild(printContainer);
  return printContainer;
}

/**
 * Determines whether the current element has encrypted content. Would be a specific message or thread.
 *
 * @param {jQueryElement} $element - The element to search through
 * @param {Object} selectors - Object of globally set selectors
 *
 * @return {Boolean} Has encrypted content
 */
function hasEncryptedContent($element, selectors) {
  if ($element.find(selectors.SECURE_MESSAGE).length || $element.find(selectors.ANIMATION).length || $element.find(selectors.TDF_SELECTOR).length) {
    return true;
  }
  return false;
}

/**
 * This function will search through the DOM for the correct element to pull
 * the subject from the email print container. It will first try to use the global message
 * class. If this item exists and has a length of 1, it will return.
 *
 * For split pane view, it will traverse to the top of the message container and then search
 * down for the correct subject element.
 *
** @param  {GmailSettings}   settings - Only the DOM references are used, but entire settings sent over
 * @param  {jQueryElement}   $messagesToPrint - If specificied the message(s) we want to print
 * @return {jQueryElement}   The jQuery element that contains the correct subject
 */
function findCorrectSubjectElement(settings, $messagesToPrint) {
  var $defaultSubject = $(settings.dom.MESSAGE_THREAD_SUBJECT);
  if ($defaultSubject && $defaultSubject.length === 1) {
    return $defaultSubject;
  }
  var globalSubjectElement = settings.dom.MESSAGE_THREAD_SUBJECT;
  var topLevelMessageViewElement = settings.dom.MESSAGE_PRINT_CONTAINER;
  var $subject = $messagesToPrint.closest(topLevelMessageViewElement).find(globalSubjectElement);
  return $subject;
}

/**
 * Certain pieces of a message require logic not found in css. This will "style" those cases.
 *
 * @param {jQueryElement} $messages - All messages that are being printed
 * @param {Object} dom - A <GmailSettings> dom property
 */
function cleanupMessagesForPrint($messages, dom) {
  // We want to remove all collapsed secure messages as they provide no value to print
  var $nestedSecure = $messages.find(dom.NESTED_SECURE_MESSAGE);
  $nestedSecure.closest(dom.COLLAPSED_GMAIL_EXTRA).remove();
  $nestedSecure.closest(dom.COLLAPSED_GMAIL_QUOTE).remove();

  // Add missing timestamp and email address if needed
  $messages.each(function addEmailAndTimestamp() {
    var $message = $(this);
    var $senderElem = $message.find(dom.SENDER_HEADER);
    var $senderEmailElem = $message.find(dom.SENDER_EMAIL_HEADER);

    // Create sender email elem if it doesn't exist
    if ($senderEmailElem.length === 0) {
      var senderEmail = $senderElem.attr('email');
      var $headerElem = $senderElem.parent();
      $headerElem.append(`<span class="go"><span aria-hidden="true">&lt;</span>${senderEmail}<span aria-hidden="true">&gt;</span></span>`);
    }

    // Add full timestamp to email
    var $timestampElem = $message.find(dom.TIMESTAMP_HEADER);
    var timestamp = $timestampElem.attr('title');
    $timestampElem.text(timestamp);
  });
}

/**
 * Adds hovering classes needed for styling
 *
 * @param {HTMLElement} ele - DOM Element
 */
function addHover(ele, className) {
  ele.onmouseenter = function () {
    this.classList.add(className);
  };
  ele.onmouseleave = function () {
    this.classList.remove(className);
  };
}

/***/ }),

/***/ 91738:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var Popover = __webpack_require__(55929);
var Templates = __webpack_require__(5749);
function PromoFooter(context) {
  this._footer = false;
  this._popover = false;
  Object.assign(this, {
    _settings: context._settings,
    _editor: context._editor,
    getToggleState: context.getToggleState,
    _fadeAndScaleElementIn: context._fadeAndScaleElementIn
  });
}
PromoFooter.prototype.setFooter = function () {
  if (!this._settings.user.setting('preferences.showPromoFooter')) {
    return;
  }
  var footer = $('.virtru-message-footer', this._editor);
  var isSecure = this.getToggleState() === 'on';
  var {
    isSecureDraft
  } = this;
  var footerExists = footer.length > 0;
  if (isSecure) {
    this.hideFooter();
  } else if (!isSecureDraft && !footerExists && !this._footer) {
    this.addFooter();
  } else {
    footer.css('display', 'block');
  }
};
PromoFooter.prototype.addFooter = function () {
  if (this._footer) {
    return;
  }
  this._editor.append(Templates.promoFooter());
  this._footer = $('.virtru-message-footer', this._editor);
  this._cogIcon = $('.virtru-footer-cog', this._footer);
  this._popover = new Popover();
  this._popover.classname = 'virtru-cog-popover';
  this._popover.inner.empty().append(Templates.footerPopover());

  // show popover and set flag
  this._popover.position('south');
  this._popover.inner.find('.virtru-confirm-button').on('click', function () {
    this._popover.hide();
  }.bind(this));
  this._cogIcon.on('click', function () {
    this._popover.show(this._cogIcon);
    this._fadeAndScaleElementIn(this._popover.el);
  }.bind(this));
};
PromoFooter.prototype.removeCog = function () {
  if (this._cogIcon) {
    this._cogIcon.remove();
  }
};
PromoFooter.prototype.teardown = function () {
  this.removeCog();
  if (this._popover) {
    this._popover.hide();
    this._popover.popover.remove();
  }
};
PromoFooter.prototype.hideFooter = function () {
  if (this._popover) {
    this._popover.hide();
  }
  if (this._footer) {
    this._footer.css('display', 'none');
  }
};
PromoFooter.prototype.showFooter = function () {
  this._popover.position('south');
  this._footer.css('display', 'block');
};
module.exports.PromoFooter = PromoFooter;

/***/ }),

/***/ 92668:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 93139:
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ 93622:
/***/ ((module) => {

"use strict";
module.exports = "<table cellspacing=\"0\" class=\"highlight-overlay\">\n  <tr>\n    <td colspan=\"3\" class=\"highlight-overlay-top\"></td>\n  </tr>\n  <tr class=\"highlight-overlay-middle\">\n    <td class=\"highlight-overlay-left\"></td>\n    <td class=\"highlight-overlay-content\"></td>\n    <td class=\"highlight-overlay-right\"></td>\n  </tr>\n  <tr>\n    <td colspan=\"3\" class=\"highlight-overlay-bottom\"></td>\n  </tr>\n</table>";

/***/ }),

/***/ 93882:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
var $ = __webpack_require__(55401);
var VALUE_ATTR = 'value';
var METADATA_SELECTOR = 'input[name="virtru-metadata"]';

/**
 * An internal class for storing email metadata, i.e. attachments.
 * Since this is being stored as part of the e-mail body it will
 * be saved with any drafts.
 */
function EmailMetadata(emailContainer, metadataElement) {
  this.metadata = {};
  this.metadataElement = metadataElement || null;
  this.emailContainer = emailContainer;
}
const EmailMetadataEnum = {
  COMPOSE_METADATA: 'compose-window',
  EMAIL_POLICY: 'email-policy',
  ATTACHMENTS: 'attachments',
  COMPOSE_ID: 'compose-id',
  PERSONAL_INTRO: 'personal-intro',
  PERSONAL_INTRO_STATUS: 'personal-intro-status'
};
exports.EmailMetadataEnum = EmailMetadataEnum;
EmailMetadata.load = function (emailContainer) {
  let metadataElement = emailContainer.find(METADATA_SELECTOR);
  if (metadataElement.length === 0) {
    metadataElement = null;
  }
  return new EmailMetadata(emailContainer, metadataElement);
};
EmailMetadata.checkMetadataElementAvailability = function (emailContainer) {
  return !!emailContainer.find(METADATA_SELECTOR).length;
};
EmailMetadata.prototype.set = function (key, value) {
  this._ensureMetadataElement();
  var metadata = this._getMetadata();
  metadata[key] = value;
  this._saveMetadata(metadata);
};
EmailMetadata.prototype.update = function (key, callback) {
  this._ensureMetadataElement();
  var metadata = this._getMetadata();
  var currentValue = metadata[key];
  var newValue = callback(currentValue);
  metadata[key] = newValue;
  this._saveMetadata(metadata);
};

/**
 * Removes the metadata with the specified key.
 *
 * @param key
 */
EmailMetadata.prototype.remove = function (key) {
  this._ensureMetadataElement();
  var metadata = this._getMetadata();
  delete metadata[key];
  this._saveMetadata(metadata);
};
EmailMetadata.prototype._ensureMetadataElement = function () {
  var {
    metadataElement
  } = this;

  // Not current known?
  if (metadataElement === null) {
    // Then search for it
    metadataElement = this.emailContainer.find(METADATA_SELECTOR);

    // If you can't find one then create it
    if (metadataElement.length === 0) {
      metadataElement = $('<input name="virtru-metadata" type="hidden" />');
      metadataElement.attr(VALUE_ATTR, '{}');
      this.emailContainer.append(metadataElement);
    }
    this.metadataElement = metadataElement;
  }
};
EmailMetadata.prototype._getMetadata = function () {
  var {
    metadataElement
  } = this;
  if (metadataElement === null) {
    return {};
  }
  try {
    var value = metadataElement.attr(VALUE_ATTR);
    if (value == null) {
      console.error('Could not parse metadata element, attribute doesn\'t exist');
      return {};
    }
    return JSON.parse(value);
  } catch (err) {
    console.error('Could not parse metadata element');
    return {};
  }
};
EmailMetadata.prototype._saveMetadata = function (metadata) {
  var {
    metadataElement
  } = this;
  metadataElement.attr(VALUE_ATTR, JSON.stringify(metadata));
};
EmailMetadata.prototype.get = function (key) {
  var metadata = this._getMetadata();
  return metadata[key];
};
exports.EmailMetadata = EmailMetadata;

/***/ }),

/***/ 94064:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initLogger: () => (/* binding */ initLogger),
/* harmony export */   sendServiceWorkerLog: () => (/* binding */ sendServiceWorkerLog),
/* harmony export */   setLoggerUserContext: () => (/* binding */ setLoggerUserContext)
/* harmony export */ });
/* harmony import */ var _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3780);
/* provided dependency */ var console = __webpack_require__(31799);

let currentContext;
const initLogger = ({
  source,
  version,
  userId
}) => {
  // environment-specific config injected into the bundle by webpack
  const {
    levels,
    handlers
  } = JSON.parse('{"levels":["info","error"],"handlers":["console","http"]}');
  const config = {
    clientToken: 'pubb9e93c6ad9fe8d0dfb61ad98074a1671',
    site: 'datadoghq.com',
    service: 'gmail-extension',
    env: "production",
    version,
    forwardConsoleLogs: [...levels],
    telemetrySampleRate: 0,
    beforeSend: log => {
      const {
        message,
        context
      } = log;
      if (message.includes('XHR error') && message.includes('google.com') && context.source === 'page-script') {
        // discard these logs because they are Google issues and not BP related
        return false;
      }
    }
  };
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.init(config);
  currentContext = {
    source,
    channel: "stable",
    actor:  false ? 0 : 'user'
  };
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.setGlobalContextProperty('context', currentContext);
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.logger.setHandler([...handlers]);
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.setUser({
    id: userId
  });
};
const setLoggerUserContext = userId => {
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.setUser({
    id: userId
  });
};

// special method just for service worker logging
// uses the DD library directly instead of console method forwarding for simplicity
const sendServiceWorkerLog = (args, level) => {
  // temporarily change context.source property to indicate that this is a service worker log
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.setGlobalContextProperty('context', {
    ...currentContext,
    source: 'service-worker'
  });
  console[level](...args);

  // reset context.source property to original value
  _datadog_browser_logs__WEBPACK_IMPORTED_MODULE_0__/* .datadogLogs */ .yf.setGlobalContextProperty('context', currentContext);
};

/***/ }),

/***/ 95727:
/***/ ((module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
const $ = __webpack_require__(55401);
const {
  SecureServiceProxy
} = __webpack_require__(6336);
const {
  Binary
} = __webpack_require__(52938);
const CksUtil = __webpack_require__(15641);
const i18n = __webpack_require__(2622);
const Guard = __webpack_require__(57128);
const AnalyticsService = (__webpack_require__(1246).instance)();
const {
  cksErrors
} = (__webpack_require__(82672).modules);
const Utils = __webpack_require__(55675);
const RemoteContentAttachment = __webpack_require__(45754);
const {
  TDF3_HTML_MANIFEST_SELECTOR,
  TDF3_EMAIL_MANIFEST_SELECTOR
} = __webpack_require__(30893);
const {
  PFP_PARSE_ERROR
} = __webpack_require__(22592);
const renderModal = (__webpack_require__(58665)/* ["default"] */ .A);
const defaultPolicy = {
  type: 'file',
  isManaged: false,
  enforcement: 'strict',
  emailUsers: [],
  children: [],
  activeBegin: new Date().toISOString(),
  authorizations: []
};
function AttachmentService(transports, composeMod, settings) {
  // Only needed on compose
  if (composeMod !== undefined) {
    this._composeMod = composeMod;
    var owner = composeMod._settings.currentUser();
    this._policyOptions = {
      owner,
      emailUsers: [owner],
      type: 'file'
    };
    this._userId = owner;
    this._userSettings = composeMod._settings.user.settings();
    this._orgPublicKey = CksUtil.getOrgPublicKey(this._userSettings);
  }
  if (settings) {
    this._userId = this._userId || settings.currentUser();
  }
  this._settings = settings;
  this._secureService = SecureServiceProxy.create(transports);
  this._transports = transports;
}

/**
 * Wraps a file in a TDF wrapper given the options
 * provided.
 *
 * @param file
 * @param policyOptions The options for securing the file
 * @param policyOptions.owner The owner of the policy for the file
 * @param policyOptions.isManaged A boolean indicating whether or not the
 * file is managed
 * @param policyOptions.enforcement One of strict/permissive/closed; default
 * is strict
 * @param policyOptions.emailUsers An array of authorized users
 * @param policyOptions.children An array of UUIDs managed by this policy
 * @param policyOptions.activeBegin An isoData for the instance the policy
 * becomes active
 * @param policyOptions.activeEnd An isoData for the instant the policy
 * becomes inactive
 * @param policyOptions.authorizations
 */
AttachmentService.prototype.secureFile = function (file, policyOptions) {
  return new Promise((resolve, reject) => {
    policyOptions = Object.assign({}, defaultPolicy, policyOptions);
    var reader = new FileReader();
    reader.onload = async event => {
      if (Utils.isPfpFile(file.name)) {
        // Attempt to parse the file as a TDF.html -- if this fails, throw an error.
        try {
          const result = await this.parseHtmlForPfp(event.target.result);
          resolve(result);
        } catch (err) {
          const error = this._prepareParseError(err);
          reject(error);
        }
        return;
      }
      if (Utils.isTdf3Html(file.name, event.target.result)) {
        try {
          const rewrapPromise = new Promise((innerResolve, innerReject) => {
            this.fileReadCompleteDelegate({
              resolve: innerResolve,
              reject: innerReject
            }, file.name, file.type, policyOptions)(event);
          });
          const originalFilePromise = this.getTDF3originalFileInfo(event.target.result);
          const [rewrapInfo, originalFile] = await Promise.all([rewrapPromise, originalFilePromise]);
          resolve({
            ...rewrapInfo,
            originalFile,
            isTdf3Html: true
          });
          return;
        } catch (err) {
          // if user doesn't have access to file we should handle it as any other html file
          if (err.name !== 'AccessDisabled') {
            const error = this._prepareParseError(err);
            reject(error);
          }
          return;
        }
      }
      this.fileReadCompleteDelegate({
        resolve,
        reject
      }, file.name, file.type, policyOptions)(event);
    };
    reader.readAsBinaryString(file);
  });
};
AttachmentService.prototype._prepareParseError = function (err) {
  console.error('Failed to parse TDF.html file', err);
  emitFailureMetric(err);
  return {
    name: PFP_PARSE_ERROR,
    message: errorToMessage(err)
  };
};

/**
 * Encrypt and upload files
 * @param  {files} files - list of files
 * @param  {files} policyOptions
 * @param  {String} context - method of attachment reported to analytics
 * @return {Q}
 */
AttachmentService.prototype.encryptAndUploadFiles = async function (files, policyOptions, context) {
  policyOptions = Object.assign({}, defaultPolicy, this._policyOptions, policyOptions);
  var promises = [];
  for (var i = 0, len = files.length; i < len; ++i) {
    var file = files[i];
    var promise = this.secureFile(file, policyOptions);
    var attachment = new RemoteContentAttachment({
      name: file.name,
      size: file.size,
      type: file.type,
      inlineImageUuid: file.inlineImageUuid,
      doInsertAtCursorPosition: file.doInsertAtCursorPosition,
      dropPos: file.dropPos,
      imageUrl: file.imageUrl
    }, this._composeMod, promise);
    attachment.addHtml();
    promises.push(attachment.init());
    AnalyticsService.attachmentAdded({
      isManaged: policyOptions.isManaged,
      authorizations: policyOptions.authorizations,
      type: context,
      ...attachment.getAnalyticsObject()
    });
  }
  return Promise.all(promises).then(filesLoc => {
    const successful = filesLoc.filter(fl => typeof fl.error === 'undefined');
    const failed = filesLoc.filter(fl => typeof fl.error !== 'undefined');
    if (failed.length === 0) {
      return {
        successful,
        failed
      };
    }
    return new Promise(resolve => {
      RemoteContentAttachment.showErrorModal(failed, resolve);
    }).then(() => ({
      successful,
      failed
    }));
  });
};

/**
 * Returns a function to handle the response from the
 * file read operation.
 *
 * @param deferred
 * @param filename
 * @param policyOptions
 * @returns {Function}
 */
AttachmentService.prototype.fileReadCompleteDelegate = function (deferred, filename, mimeType, policyOptions) {
  const self = this;
  const func = function fileReadComplete(event) {
    const binary = Binary.fromString(event.target.result);
    policyOptions.displayName = filename;
    policyOptions.type = defaultPolicy.type;
    const tdfName = `${filename}.tdf`;
    const processorOptions = {
      orgPublicKey: self._orgPublicKey
    };
    self._secureService.makeFile(binary, tdfName, mimeType, policyOptions, processorOptions).then(function (success) {
      deferred.resolve(success);
    }).catch(function (error) {
      deferred.reject(error);
    });
  };
  return func.bind(this);
};

/**
 * Sends the file URL to the content script for download
 * @param  {string} fileUrl    The URL to the file.
 * @param  {boolean} standalone True if the file is a zip, otherwise false
 * @return {promise}            A promise to the blob uri for the decrypted file.
 */
AttachmentService.prototype.readSecureFile = function (fileUrl, standalone) {
  if (standalone) {
    Guard.checkIsString(fileUrl, 'The argument fileUrl must be a string.');
  }
  return Promise.resolve().then(() => {
    if (standalone) {
      return this._secureService.readStandaloneFile(fileUrl, this._userId);
    }
    return this._secureService.readFile(fileUrl, this._userId);
  }).catch(err => {
    emitFailureMetric(err);
    renderModal.attachmentGenericError({
      description: errorToMessage(err)
    });
    throw err;
  });
};
function emitFailureMetric(err) {
  if (err.name !== 'IntegrityCompromisedError') {
    AnalyticsService.clientError({
      context: 'Read Secure File',
      name: err.name,
      message: err.message
    });
    return;
  }

  // Emit metric for an Integrity Compromised error
  AnalyticsService.integrityCompromised({
    type: 'payload'
  });
}
function errorToMessage(err) {
  if (cksErrors.isCksError(err)) {
    return i18n.t('CANNOT_DECRYPT_MESSAGE_CKS', err.details || {});
  }
  const stringMap = {
    NetworkConnectionError: 'EMAIL_ERROR_NETWORK_LOST',
    InternalServerError: 'EMAIL_ERROR_INTERNAL_SERVER_ERROR',
    AccessDisabled: 'ATTACHMENT_ERROR_UNAUTHORIZED',
    CorruptTdfPackage: 'ATTACHMENT_ERROR_CORRUPT',
    NoAppIdForDomain: 'EMAIL_ERROR_YOURE_ON_STAGING',
    ContentIsManaged: 'CONTENT_IS_MANAGED',
    IntegrityCompromisedError: 'ATTACHMENT_INTEGRITY_COMPROMISED'
  };
  return i18n.t(stringMap[err.name] || 'ATTACHMENT_ERROR_UNKNOWN');
}

/**
 * Sends the file URL to the content script for download and decryption.
 *
 * @param {String} fileUrl The URL to the file.
 *
 * @returns {Q} A promise to the blob uri for the decrypted file.
 */
AttachmentService.prototype.readSecureStandaloneFile = function (fileUrl) {
  // this function returns nothing. Does it it really work?
  this.readSecureFile(fileUrl, true);
};

/**
 * Downloads a remote attachment (native to gmail/yahoo/outlook) then encrypts and uploads it
 * @param  {fileUrl} file
 * @param  {Object} policyOptions
 * @return {promise}
 */
AttachmentService.prototype.downloadAndEncryptRemoteFile = function (file, policyOptions) {
  const self = this;
  return new Promise(function (resolve, reject) {
    // Make sure the policy options have the default options at the very least
    policyOptions = Object.assign({}, defaultPolicy, self._policyOptions, policyOptions);

    // Download the file, encrypt it locally, than upload it
    // Read the headers to get updated metadata such as file size and file type
    const def = self.readRemoteFile(file, policyOptions);
    const attachment = new RemoteContentAttachment({
      name: file.name,
      // We will fill in this info when we fetch the file's headers
      size: 0,
      type: '',
      inlineImageUuid: file.inlineImageUuid
    }, self._composeMod, def);
    attachment.addHtml();
    attachment.init().then(function (fileLoc) {
      // expecting an array
      resolve([fileLoc]);
    }).catch(function (err) {
      reject(err);
    });
  });
};

/**
 * Downloads a remote attachment (native to gmail/yahoo/outlook) then encrypts and uploads it
 * @param  {fileUrl}
 * @return {promise}
 */
AttachmentService.prototype.readRemoteFile = function (file, policyOptions) {
  const self = this;
  // Make sure the policy options have the default options at the very least
  policyOptions = Object.assign({}, defaultPolicy, self._policyOptions, policyOptions);
  return new Promise((resolve, reject) => {
    try {
      if (!Utils.hasPfpFileExtensions(file.name)) {
        throw new Error('Not a PFP file');
      }
      const req = this._transports.call('content', 'downloadFileAndPlaceInBlob', {
        url: file.url,
        isPFP: true
      });
      req.then(resp => this.parseHtmlForPfp(resp.text)).then(result => {
        resolve(result);
      }).catch(e => {
        reject(e);
      });
    } catch (e) {
      const processorOptions = {
        orgPublicKey: self._orgPublicKey
      };
      // Download the file, encrypt it locally, then upload it
      // Read the headers to get updated metadata such as file size and file type
      self._secureService.secureRemoteFile(file, policyOptions, processorOptions).then(success => {
        resolve(success);
      }).catch(error => {
        reject(error);
      });
    }
  });
};

/**
 * 1) scans a TDF.html string to obtain the preview link
 * 2) parse the preview link to obtain the attachment contract
 * 3) fetch the size and determine the mimetype from the file's extension
 *
 * @param  {String} html - Contents of an HTML file
 * @return {promise} Resolves with RemoteContentAttachment options object
 */
AttachmentService.prototype.parseHtmlForPfp = async function (html) {
  // Create an empty div to hold the result
  const previewLink = $('<div></div>').append(html).find('#previewLink').val();
  const tdfData = await this._secureService.createTdfDataFromPreviewLink(previewLink);
  return tdfData;
};
AttachmentService.prototype.getTDF3originalFileInfo = async function (html) {
  const element = typeof html === 'string' ? $('<div></div>').append(html) : html;
  const manifestSelectors = [TDF3_HTML_MANIFEST_SELECTOR, TDF3_EMAIL_MANIFEST_SELECTOR].join(',');
  const manifestBase64 = element.find(manifestSelectors).val();
  const transferUrl = element.find('iframe').attr('src') || null;
  const manifest = atob(manifestBase64);
  const {
    encryptionInformation
  } = JSON.parse(manifest);
  const policyString = atob(encryptionInformation.policy);
  const {
    uuid: policyId
  } = JSON.parse(policyString);
  const {
    integrityInformation: {
      segments
    }
  } = encryptionInformation;
  const size = segments.reduce((accumulator, segment) => accumulator + segment.encryptedSegmentSize, 0);
  const fileInfo = await this._secureService.getTDF3htmlFileInfo({
    policyId,
    userId: this._userId
  });
  return {
    ...fileInfo,
    size,
    policyId,
    manifestBase64,
    transferUrl
  };
};

/**
 * Update attachment policy
 * @param  {String} policyId      policy id for the attachment
 * @param  {Object} policyUpdates The updated policy object
 * @return {Promise}
 */
AttachmentService.prototype.updateAttachmentPolicy = function (policyId, policyUpdates) {
  return this._secureService.updatePolicy(policyId, policyUpdates);
};
AttachmentService.prototype.getAttachmentContract = function (attachmentId, parsedLink) {
  return this._secureService.getContract(attachmentId, parsedLink);
};
module.exports = exports = AttachmentService;

/***/ }),

/***/ 95961:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var $ = __webpack_require__(55401);
var {
  addOpen
} = __webpack_require__(7709);
var defaultWaiterContextOptions = {
  options: {},
  callback() {}
};
function WaiterContext(element, selector, options) {
  this.element = $(element);
  this.selector = selector;
  this.options = $.extend({}, defaultWaiterContextOptions, options);
  this.waiterOptions = this.options.options;
  this.callback = this.options.callback;
}
addOpen(WaiterContext);
WaiterContext.prototype.setupAll = function () {
  this.element.wait('on', this.selector, this.waiterOptions, this.callback);
};
WaiterContext.prototype.teardownAll = function () {
  this.element.wait('off', this.selector, this.callback);
};
exports.WaiterContext = WaiterContext;
var defaultElementContextOptions = {
  element: undefined,
  create: undefined,
  teardown() {}
};
function ElementContext(options) {
  this.options = $.extend({}, defaultElementContextOptions, options);
}
addOpen(ElementContext);
ElementContext.prototype.setupAll = function () {
  var {
    options
  } = this;
  var {
    create
  } = options;
  var {
    element
  } = options;
  var newElement = undefined;
  if (create) {
    newElement = $(create.apply(null, [this]));
  } else if (element) {
    newElement = $(element);
  } else {
    throw new Error('Incorrectly defined ElementContext');
  }
  this.element = newElement;
};
ElementContext.prototype.teardownAll = function () {
  this.options.teardown.apply(null);
  this.element.remove();
};
exports.ElementContext = ElementContext;
var defaultEventListenerContextOptions = {
  events: {},
  selector: null,
  teardown() {},
  data: {}
};
function EventListenerContext(element, options) {
  this.element = $(element);
  this.options = $.extend({}, defaultEventListenerContextOptions, options);
  this.eventsMap = this.options.events;
  this._id = Math.random();
}
addOpen(EventListenerContext);
EventListenerContext.prototype.setupAll = function () {
  var {
    selector
  } = this.options;
  // Add the context to the data
  var allData = $.extend({}, this.options.data);
  this.element.on(this.eventsMap, selector, allData);
};
EventListenerContext.prototype.teardownAll = function () {
  this.options.teardown.apply(null);
  var {
    selector
  } = this.options;
  this.element.off(this.eventsMap, selector);
};
exports.EventListenerContext = EventListenerContext;
function ObjectEventListenerContext(object, event, callback, context) {
  this._object = object;
  this._event = event;
  this._callback = callback;
  this._context = context;
}
addOpen(ObjectEventListenerContext);
ObjectEventListenerContext.prototype.setupAll = function () {
  var context = this._context;
  if (context) {
    this._object.on(this._event, this._callback, context);
  } else {
    this._object.on(this._event, this._callback);
  }
};
ObjectEventListenerContext.prototype.teardownAll = function () {
  var context = this._context;
  if (context) {
    this._object.off(this._event, this._callback, context);
  } else {
    this._object.off(this._event, this._callback);
  }
};
exports.ObjectEventListenerContext = ObjectEventListenerContext;
var defaultCSSClassContextOptions = {
  classes: []
};

/**
 * Create a context to manage css classes on an element
 *
 * This context allows you to add or remove css classes. To
 * remove a class prefix the name with ^
 */
function CSSClassContext(element, options) {
  this.element = $(element);
  this.options = Object.assign({}, defaultCSSClassContextOptions, options);
  this.classes = this.options.classes;
}
addOpen(CSSClassContext);
CSSClassContext.prototype.setupAll = function () {
  var {
    classes
  } = this;
  var {
    element
  } = this;
  classes.forEach(function (cssClass) {
    var remove = cssClass.startsWith('^');
    if (remove) {
      element.removeClass(cssClass);
    } else {
      element.addClass(cssClass);
    }
  });
};
CSSClassContext.prototype.teardownAll = function () {
  var {
    classes
  } = this;
  var {
    element
  } = this;
  classes.forEach(function (cssClass) {
    var removed = cssClass.startsWith('^');
    if (removed) {
      element.addClass(cssClass);
    } else {
      element.removeClass(cssClass);
    }
  });
};
exports.CSSClassContext = CSSClassContext;

/***/ }),

/***/ 96478:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   process: () => (/* binding */ process)
/* harmony export */ });
const $ = __webpack_require__(55401);
const {
  get
} = __webpack_require__(52635);
const GMAIL_GLOBALS_USER_INDEX = 10;
const GMAIL_GLOBALS_VERSION_INDEX = 2;
const GMAIL_GLOBALS_AUTHURSER_STR_INDEX = 7;

// Keep this guy around after we load it so we can store it to a cookie
var gmailSettings;
function parseGmailGlobals(globals) {
  return {
    user: globals[GMAIL_GLOBALS_USER_INDEX],
    version: globals[GMAIL_GLOBALS_VERSION_INDEX],
    displayName: getDisplayName(globals),
    authUser: getAuthUser(globals)
  };
}

/**
 * Tries to find the users display name
 *
 * @param globals
 * @returns {*}
 */
function getDisplayName(globals) {
  var currentEmailAddress = getCurrentEmailAddress(globals);
  try {
    // This is buried real deep in globals
    return getAvailableDisplayNamesMap(globals[17][23][1])[currentEmailAddress];
  } catch (err) {
    return currentEmailAddress;
  }
}
/**
 * Gets the auth user number, which is the session number. If you have more than one gmail user
 * logged in at once, this number is what's used to keep track of the different
 * xhr requests that go out from each account.
 *
 * @param globals
 * @returns {number} authUser
 */
function getAuthUser(globals) {
  var authUser = globals[GMAIL_GLOBALS_AUTHURSER_STR_INDEX].split('/');
  return authUser[authUser.length - 1];
}

/**
 * Processes the available displayNames in globals into a map. The available
 * displayNames are all of the gmail accounts that are currently logged in by
 * the current end user
 *
 * The map is in the following format:
 *
 *  {
 *    "user1@gmail.com": "User1's Name",
 *    "user2@gmail.com": "User2's Name"
 *  }
 *
 * If there is an error retrieving the user's display name then the email
 * address of the user will be used
 *
 * @param {Array} rawAvailableDisplayNames The raw display names array in gmail
 *                                         globals
 *
 * @returns {Object} A map of emailAddress -> displayName
 */
function getAvailableDisplayNamesMap(rawAvailableDisplayNames) {
  var availableDisplayNamesMap = {};
  rawAvailableDisplayNames.forEach(function (availableDisplayNameArray) {
    var currentDisplayNameEmail = availableDisplayNameArray[0];
    try {
      availableDisplayNamesMap[currentDisplayNameEmail] = availableDisplayNameArray[4];
    } catch (e) {
      availableDisplayNamesMap[currentDisplayNameEmail] = currentDisplayNameEmail;
    }
  });
  return availableDisplayNamesMap;
}

/**
 * Retreives the currently logged in email address in the gmail globals
 *
 * @param globals
 * @returns {String} User's email
 */
function getCurrentEmailAddress(globals) {
  return globals[GMAIL_GLOBALS_USER_INDEX];
}

/**
 * Parses out the necessary configuration we need from the DOM if we're in
 * a popout compose window.  This function looks in the `window.gbar._CONFIG`
 * object
 */
function parsePopOutWindowConfiguration(selectors) {
  // Grab the global config from the `gbar` object (safely, no errors)
  // Pull the email address from the signout link first, then what looks like
  // the 'Google Plus' config next, finally pull it from the global config

  const popoutUserInfoSignout = getPopoutUserInfoFromSignout() || {};
  const popoutUserInfo = getPopoutUserInfo(selectors) || {};
  const popoutConfig = get(window, selectors.POPOUT_COMPOSE_CONFIG, []);
  const popoutUserEmail = popoutUserInfoSignout.email || popoutUserInfo.email || popoutConfig[5];
  const popoutUserDisplayName = popoutUserInfoSignout.displayName || popoutUserInfo.displayName;
  const authUser = popoutConfig[4] || window.location.pathname.split('/').slice(-2)[0];
  return {
    user: popoutUserEmail,
    version: 'popout_unknown',
    // Can't find version in DOM
    displayName: popoutUserDisplayName,
    authUser
  };
}

/**
 * This function will either parse the GLOBALS object and retrieve
 * the gmail settings or attempt to read the required data from the page.
 *
 * @param globals The window.GLOBALS object or undefined.  This
 * parameter is passed in instead of read from window.GLOBALS
 * directly so that it is testable.
 * Schema -> { user, version, displayName, authUser }
 *
 * @returns a promise to parse the globals
 */
function process(globals, selectors) {
  return new Promise((resolve, reject) => {
    if (!globals) {
      $(document).ready(function () {
        var gmailGlobals;
        if (gmailGlobals && gmailGlobals.length > 0) {
          gmailSettings = JSON.parse(gmailGlobals);
          return resolve(gmailSettings);
        }
        var popoutUserInfo = getPopoutUserInfo(selectors);
        if (popoutUserInfo.email.length > 0) {
          return resolve(parsePopOutWindowConfiguration(selectors));
        }
        return reject(new Error('Could not identify user.'));
      });
    } else {
      gmailSettings = parseGmailGlobals(globals);
      resolve(gmailSettings);
    }
  });
}

/**
 * Iterate through a list of user info selectors and return the first instance of a result that makes sense.
 * Otherwise, just return the most results of the most recent set of selectors
 * @param {Object} selectors - selectors to use
 *
 * @returns {Object} user info
 */
function getPopoutUserInfo(selectors) {
  const popoutUserInfo = {
    email: $(selectors.POPOUT_COMPOSE_EMAIL).text(),
    displayName: $(selectors.POPOUT_COMPOSE_DISPLAY_NAME).text()
  };
  return popoutUserInfo;
}

/**
 * Attempts to get the user display name and email from the title of the signout link
 *
 * @returns {Object} user info
 */
function getPopoutUserInfoFromSignout() {
  const popoutUserInfo = {};
  try {
    const popoutUserInfoString = $('a[href^="https://accounts.google.com/SignOutOptions"]').attr('title');

    // popoutUserInfoString is expected to look like this
    // "Google Account: Bob Dylan  \n(bdylan@virtru.com)"
    // Or like this for delegated accounts
    // "Google Account: dcrowley@trusteddataformat.org"
    const nameAndEmail = popoutUserInfoString.split(/\r?\n/);
    if (nameAndEmail.length === 1) {
      popoutUserInfo.email = nameAndEmail[0].match(/Google Account: (.+[^ ])\s*$/)[1];
    } else {
      popoutUserInfo.displayName = nameAndEmail[0].match(/Google Account: (.+[^ ])\s*$/)[1];
      popoutUserInfo.email = nameAndEmail[1].match(/\((.+)\)/)[1];
    }
    return popoutUserInfo;
  } catch (e) {
    // Empty catch
  }
  return popoutUserInfo;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  process
});

/***/ }),

/***/ 96638:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* provided dependency */ var console = __webpack_require__(31799);
/* provided dependency */ var Buffer = __webpack_require__(17995)["Buffer"];
const $ = __webpack_require__(55401);
const AnalyticsService = (__webpack_require__(1246).instance)();
const clientCommonUtils = __webpack_require__(82672);
const emailUtils = __webpack_require__(25119);
const {
  START_DECRYPTION,
  DONE_DECRYPTION
} = __webpack_require__(76223);
const {
  _bindAllMethods
} = __webpack_require__(4424);

/**
 * Service for reading secure emails
 *
 * @param {Object} options Options
 */
function SecureEmailReader(options) {
  this._secureService = options.secureService;
  this._messages = {};
  this._settings = options.settings;
  this._transports = options.transports;
  this._selectors = options.settings.dom;
  _bindAllMethods(this);
}
SecureEmailReader.create = function (options) {
  options = Object.assign({}, options);
  var reader = new SecureEmailReader(options);
  return reader;
};
SecureEmailReader.prototype.startReading = function (emailElement, connectOptions, animationWidget) {
  var messageContainers = emailElement.find(this._selectors.TDF_SELECTOR);
  if (messageContainers.length === 0) {
    return Promise.resolve({
      isSecureMessage: false
    });
  }

  // If it's a secure message, hide the google translate thing
  $(this._selectors.GOOGLE_TRANSLATE_SELECTOR).hide();
  this.connectOptions = connectOptions;
  this.animationWidget = animationWidget;
  this.messageContainers = messageContainers;
  this.emailElement = emailElement;

  // Start animating decryption
  if (this.animationWidget) {
    this.animationWidget.beginAnimation();
  }
  return Promise.resolve().then(this._parseSecureMessages.bind(this));
};
SecureEmailReader.prototype._parseSecureMessages = function () {
  var metadataEle = this.emailElement.find(this._selectors.TDF_METADATA_SELECTOR);
  if (metadataEle !== null && metadataEle.length > 0) {
    this._parseMetadata(metadataEle);
  }
  this.isNonSecureForward = this._checkNonSecureForward();
  var messages = {};
  var messageObjects = Array.from(this.messageContainers).map(messageContainer => {
    messageContainer = $(messageContainer);
    var messageText = messageContainer.text();
    var messageObject = clientCommonUtils.email.parseMessage(messageText);
    // Make a messages map
    messages[messageObject.messageId] = messageObject.base64;
    return messageObject;
  });
  this._messages = messages;
  var topMessage = messageObjects[0];
  var topMessageElem = $(this.messageContainers[0]);
  var topMessageContainer = emailUtils.getMessageContainer(topMessageElem);

  // If the TDF was clipped short
  if (topMessage.messageWasClipped) {
    console.debug('Message is clipped.', topMessage);
    return {
      isSecureMessage: true,
      messageWasClipped: true,
      isNonSecureForward: this.isNonSecureForward,
      containerElement: topMessageContainer,
      metadata: this._metadata
    };
  }
  this.currentMessageId = undefined; // undefined signals first message in chain, for metrics
  this.containerEl = topMessageContainer;
  this.secureMessage = topMessage.base64;
  this.remoteContentLink = this._metadata ? this._metadata.remoteContentLink : undefined;
  return this._readMessage();
};

/**
 * Checks to see if this email is potentially a non-secure reply to
 * a secure message.  It does this *incredibly inefficiently* by
 * cloning the container element, removing the 'secure email' then
 * checking to see if there's any 'text' leftover... This should be
 * safe enough b/c if the check fails and the sender doesn't match
 * the integrity check will fail.
 *
 * @returns {boolean} - True if it is a non-secure forward.
 * @private
 */
SecureEmailReader.prototype._checkNonSecureForward = function () {
  var clone = this.emailElement.clone();
  var secureMessage = clone.find(this._selectors.TDF_SELECTOR);

  // Empty out the Virtru secure email format divs.
  $(secureMessage[0]).parent().parent().empty();
  var text = clone.text();
  if (text.trim().length > 0) {
    return true;
  }
  return false;
};

/**
 * Parses metadata out of the secure container
 *
 * @param {$} metadataEle - The jQuery element containing the metadata
 * @private
 */
SecureEmailReader.prototype._parseMetadata = function (metadataEle) {
  try {
    const text = metadataEle.text().replace(/Virtru\s+Metadata:\s*/g, ' ').trim();
    const metadataObjects = text.split(' ');
    if (metadataObjects && metadataObjects.length > 0) {
      const mostRecentMessage = metadataObjects[0];
      const messageBuffer = Buffer.from(mostRecentMessage, 'base64').toString();
      this._metadata = JSON.parse(messageBuffer);
    }
  } catch (err) {
    console.warn(`Could not parse secure message metadata: ${metadataEle.text()}`);
  }
};
SecureEmailReader.prototype._readMessage = function () {
  return Promise.resolve().then(this._decryptMessage.bind(this)).then(this._getAttachmentData.bind(this)).then(this._emitReadMetric.bind(this)).then(() => ({
    isSecureMessage: true,
    isNonSecureForward: this.isNonSecureForward,
    messageInfo: this.messageInfo,
    containerElement: this.containerEl,
    remoteContentLink: this.remoteContentLink,
    metadata: this._metadata
  })).catch(err => {
    // Handle all other non-revocation errors, attach the container element
    // as well as the metadata if we have it.
    if (err.name !== 'AccessDisabled') {
      err.containerElement = this.containerEl;
      err.metadata = this._metadata;
      err.currentMessageId = this.currentMessageId;
      throw err;
    }

    // Return object for revoked messages
    return {
      isSecureMessage: true,
      isNonSecureForward: this.isNonSecureForward,
      messageInfo: {
        contract: {
          state: err.reason
        }
      },
      containerElement: this.containerEl,
      metadata: this._metadata
    };
  });
};
SecureEmailReader.prototype._decryptMessage = function () {
  performance.mark(START_DECRYPTION);
  return this._secureService.readMessage(this.secureMessage, this.remoteContentLink, {
    sanitizeOpts: {
      doMangleClassNamesAndIds: true
    }
  }).then(function (messageInfo) {
    this.messageInfo = messageInfo;
  }.bind(this));
};
SecureEmailReader.prototype._emitReadMetric = function () {
  var _perf, _this$_settings$user, _this$_settings$user$;
  let perf = null;
  try {
    perf = performance.measure('decryption_time', START_DECRYPTION, DONE_DECRYPTION);
  } catch (e) {
    console.warn(e.message);
  }
  const decryptionDuration = Math.trunc((_perf = perf) === null || _perf === void 0 ? void 0 : _perf.duration);
  AnalyticsService.viewSecureEmail({
    'policy.Id': this.messageInfo.policyUuid,
    'attachment.count': this._attachmentData.count,
    'attachment.origin': 'regular',
    duration: decryptionDuration,
    enforceFips: (_this$_settings$user = this._settings.user) === null || _this$_settings$user === void 0 ? void 0 : (_this$_settings$user$ = _this$_settings$user.permissions) === null || _this$_settings$user$ === void 0 ? void 0 : _this$_settings$user$.enforceFips
  });
};

/**
 * Reads a message with a specific messageId
 *
 * @param {String} messageId The messageId to read
 * @param {jQueryElement} containerEl The placeholder for the message
 */
SecureEmailReader.prototype.read = function (messageId, containerEl) {
  this.containerEl = containerEl;

  // Save the current message id so we can return it in metrics since we won't have the policy id
  // if it fails any checks
  this.currentMessageId = messageId;
  this.secureMessage = this.getMessage(messageId);
  this.remoteContentLink = this._metadata ? this._metadata.remoteContentLink : undefined;
  return this._readMessage();
};
SecureEmailReader.prototype.getMessage = function (messageId) {
  return this._messages[messageId];
};
SecureEmailReader.prototype._getAttachmentData = function () {
  this._attachmentData = {
    count: $(this._selectors.GMAIL_ATTACHMENT_DATA).length,
    origin: 'normal'
  };
  performance.mark(DONE_DECRYPTION);
};
exports.SecureEmailReader = SecureEmailReader;

/***/ }),

/***/ 96663:
/***/ ((__unused_webpack_module, exports) => {

/**
 * dict.js
 *
 * Provides a dictionary that can use any object as a key
 */
function Dict(initial) {
  this._keys = [];
  this._values = [];
  if (initial !== undefined) {
    this._setupInitial(initial);
  }
}
Dict.prototype._setupInitial = function (initial) {
  var keys = this._keys;
  var values = this._values;
  if (initial.length === undefined) {
    for (var key in initial) {
      keys.push(key);
      values.push(initial[key]);
    }
  } else {
    for (var i = 0; i < initial.length; i++) {
      var tuple = initial[i];
      keys.push(tuple[0]);
      values.push(tuple[1]);
    }
  }
};
Dict.prototype.get = function (key) {
  var index = this._keys.indexOf(key);
  if (index === -1) {
    return undefined;
  }
  return this._values[index];
};
Dict.prototype.set = function (key, value) {
  var keys = this._keys;
  var values = this._values;
  var existingIndex = keys.indexOf(key);
  if (existingIndex !== -1) {
    values[existingIndex] = value;
  } else {
    keys.push(key);
    values.push(value);
  }
};
Dict.prototype.has = function (key) {
  return this._keys.indexOf(key) !== -1;
};
Dict.prototype.toArray = function () {
  var keys = this._keys;
  var values = this._values;
  var newArray = [];
  for (var i = 0; i < keys.length; i++) {
    newArray.push([keys[i], values[i]]);
  }
  return newArray;
};
Dict.prototype.del = function (key) {
  var keys = this._keys;
  var values = this._values;
  var index = keys.indexOf(key);
  if (index === -1) {
    return;
  }
  keys.splice(index, 1);
  values.splice(index, 1);
};
Dict.prototype.pop = function (key) {
  var keys = this._keys;
  var values = this._values;
  var index = keys.indexOf(key);
  if (index === -1) {
    return undefined;
  }
  keys.splice(index, 1);
  var valueArray = values.splice(index, 1);
  return valueArray[0];
};
Dict.prototype.length = function () {
  return this._keys.length;
};
Dict.prototype.popitem = function () {
  var key = this._keys.pop();
  var value = this._values.pop();
  if (!key) {
    return undefined;
  }
  return [key, value];
};
exports.Dict = Dict;

/***/ }),

/***/ 97411:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(91089);
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_contexts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(47446);
/* harmony import */ var _lib_contexts__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_lib_contexts__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2622);
/* harmony import */ var _lib_i18n__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_lib_i18n__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _lib_mods__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(25939);
/* harmony import */ var _lib_mods__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_lib_mods__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lib_store_globalStore__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(71139);
/* harmony import */ var _lib_store_globalStore__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_lib_store_globalStore__WEBPACK_IMPORTED_MODULE_4__);





const VIRTRU_ACTION_NOTIFICATION_CLASS = 'virtru-action-notification';
const ACTION_NOTIFICATION_TEXT_CLASS = 'action-notification-text';
const ACTION_NOTIFICATION_LINK_CLASS = 'action-notification-link';
class ActionNotificationMod extends _lib_mods__WEBPACK_IMPORTED_MODULE_3__.Mod {
  constructor(settings, element) {
    super(settings, element);
    this._settings = settings;
    this._$element = jquery__WEBPACK_IMPORTED_MODULE_0___default()(element);

    // the parent element is the block-level element and must be used for background-color
    // however, it has no unique identifier, so we must select the child element, then use its parent
    this._$parent = this._$element.parent();
  }
  getUndoLink() {
    if (!this._$undoLink) {
      const {
        ACTION_NOTIFICATION_UNDO_LINK
      } = this._settings.dom;
      this._$undoLink = this._$element.find(ACTION_NOTIFICATION_UNDO_LINK);
    }
    return this._$undoLink;
  }
  isSecureSend() {
    const {
      MESSAGE_SENDING_UNDO_LINK,
      MESSAGE_SENT_UNDO_LINK
    } = this._settings.dom;
    const {
      secureMessages: {
        draftIds = {},
        threadIds = {}
      } = {}
    } = _lib_store_globalStore__WEBPACK_IMPORTED_MODULE_4___default().getState();
    const $undoLink = this.getUndoLink();
    if ($undoLink.is(MESSAGE_SENDING_UNDO_LINK) || $undoLink.is(MESSAGE_SENT_UNDO_LINK)) {
      const id = $undoLink.attr('param');
      return id && (draftIds[id] || threadIds[id]);
    }
    return false;
  }
  setup() {
    if (this.isSecureSend()) {
      const {
        ACTION_NOTIFICATION_TEXT,
        ACTION_NOTIFICATION_LINK
      } = this._settings.dom;
      this._$parent.addClass(VIRTRU_ACTION_NOTIFICATION_CLASS);
      this._$element.find(ACTION_NOTIFICATION_TEXT).addClass(ACTION_NOTIFICATION_TEXT_CLASS).text(_lib_i18n__WEBPACK_IMPORTED_MODULE_2___default().t('SECURE_MESSAGE_SENT_NOTIFICATION'));
      this._$element.find(ACTION_NOTIFICATION_LINK).addClass(ACTION_NOTIFICATION_LINK_CLASS);
    } else {
      // if any other type of action notification, remove custom styling
      this._$parent.removeClass(VIRTRU_ACTION_NOTIFICATION_CLASS);
    }
  }

  // the action notifications use a singleton DOM element
  // anytime one is created, this teardown of the old one could remove the styling from the new one
  // as such, the styling cannot reliably be removed here; remove it on creation, instead
  // teardown () {
  //   this._$parent.removeClass(VIRTRU_ACTION_NOTIFICATION_CLASS);
  // }
}
_lib_contexts__WEBPACK_IMPORTED_MODULE_1___default().addOpen(ActionNotificationMod);
ActionNotificationMod.mainDomKey = 'ACTION_NOTIFICATION';
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ActionNotificationMod);

/***/ }),

/***/ 99776:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./en-au": 69300,
	"./en-au.js": 69300,
	"./en-ca": 91174,
	"./en-ca.js": 91174,
	"./en-gb": 58199,
	"./en-gb.js": 58199,
	"./en-ie": 7516,
	"./en-ie.js": 7516,
	"./en-il": 39531,
	"./en-il.js": 39531,
	"./en-in": 48493,
	"./en-in.js": 48493,
	"./en-nz": 85070,
	"./en-nz.js": 85070,
	"./en-sg": 58304,
	"./en-sg.js": 58304,
	"./fr": 86078,
	"./fr-ca": 91959,
	"./fr-ca.js": 91959,
	"./fr-ch": 89384,
	"./fr-ch.js": 89384,
	"./fr.js": 86078,
	"./ja": 81375,
	"./ja.js": 81375,
	"./sv": 48279,
	"./sv.js": 48279
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 99776;

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/async module */
/******/ 	(() => {
/******/ 		var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 		var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 		var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 		var resolveQueue = (queue) => {
/******/ 			if(queue && queue.d < 1) {
/******/ 				queue.d = 1;
/******/ 				queue.forEach((fn) => (fn.r--));
/******/ 				queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 			}
/******/ 		}
/******/ 		var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 			if(dep !== null && typeof dep === "object") {
/******/ 				if(dep[webpackQueues]) return dep;
/******/ 				if(dep.then) {
/******/ 					var queue = [];
/******/ 					queue.d = 0;
/******/ 					dep.then((r) => {
/******/ 						obj[webpackExports] = r;
/******/ 						resolveQueue(queue);
/******/ 					}, (e) => {
/******/ 						obj[webpackError] = e;
/******/ 						resolveQueue(queue);
/******/ 					});
/******/ 					var obj = {};
/******/ 					obj[webpackQueues] = (fn) => (fn(queue));
/******/ 					return obj;
/******/ 				}
/******/ 			}
/******/ 			var ret = {};
/******/ 			ret[webpackQueues] = x => {};
/******/ 			ret[webpackExports] = dep;
/******/ 			return ret;
/******/ 		}));
/******/ 		__webpack_require__.a = (module, body, hasAwait) => {
/******/ 			var queue;
/******/ 			hasAwait && ((queue = []).d = -1);
/******/ 			var depQueues = new Set();
/******/ 			var exports = module.exports;
/******/ 			var currentDeps;
/******/ 			var outerResolve;
/******/ 			var reject;
/******/ 			var promise = new Promise((resolve, rej) => {
/******/ 				reject = rej;
/******/ 				outerResolve = resolve;
/******/ 			});
/******/ 			promise[webpackExports] = exports;
/******/ 			promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 			module.exports = promise;
/******/ 			body((deps) => {
/******/ 				currentDeps = wrapDeps(deps);
/******/ 				var fn;
/******/ 				var getResult = () => (currentDeps.map((d) => {
/******/ 					if(d[webpackError]) throw d[webpackError];
/******/ 					return d[webpackExports];
/******/ 				}))
/******/ 				var promise = new Promise((resolve) => {
/******/ 					fn = () => (resolve(getResult));
/******/ 					fn.r = 0;
/******/ 					var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 					currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 				});
/******/ 				return fn.r ? promise : getResult();
/******/ 			}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 			queue && queue.d < 0 && (queue.d = 0);
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		// The chunk loading function for additional chunks
/******/ 		// Since all referenced chunks are already included
/******/ 		// in this file, this function is empty here.
/******/ 		__webpack_require__.e = () => (Promise.resolve());
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/runtimeId */
/******/ 	(() => {
/******/ 		__webpack_require__.j = 729;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			729: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkvirtru_browser_extension"] = self["webpackChunkvirtru_browser_extension"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, [99], () => (__webpack_require__(78376)))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;